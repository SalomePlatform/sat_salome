diff -Naur MEDCOUPLING_old/CMakeLists.txt MEDCOUPLING_new/CMakeLists.txt
--- MEDCOUPLING_old/CMakeLists.txt	2018-04-19 17:04:36.583219652 +0200
+++ MEDCOUPLING_new/CMakeLists.txt	2018-04-19 17:25:17.227787276 +0200
@@ -30,7 +30,7 @@
 STRING(TOUPPER ${PROJECT_NAME} PROJECT_NAME_UC)
 
 SET(${PROJECT_NAME_UC}_MAJOR_VERSION 8)
-SET(${PROJECT_NAME_UC}_MINOR_VERSION 3)
+SET(${PROJECT_NAME_UC}_MINOR_VERSION 4)
 SET(${PROJECT_NAME_UC}_PATCH_VERSION 0)
 SET(${PROJECT_NAME_UC}_VERSION
   ${${PROJECT_NAME_UC}_MAJOR_VERSION}.${${PROJECT_NAME_UC}_MINOR_VERSION}.${${PROJECT_NAME_UC}_PATCH_VERSION})
@@ -52,7 +52,7 @@
 # User options
 # ============
 INCLUDE(CMakeDependentOption)
-OPTION(MEDCOUPLING_MICROMED "Build MED without MED file dependancy." OFF)
+OPTION(MEDCOUPLING_MICROMED "Build MED without MED file dependency." OFF)
 OPTION(MEDCOUPLING_ENABLE_PYTHON "Build PYTHON bindings." ON)
 OPTION(MEDCOUPLING_ENABLE_PARTITIONER "Build MEDPartitioner." ON)
 OPTION(MEDCOUPLING_ENABLE_RENUMBER "Build Renumber." ON)
@@ -69,9 +69,11 @@
 CMAKE_DEPENDENT_OPTION(MEDCOUPLING_PARTITIONER_METIS "Enable metis graph library in MEDPartitioner."  ${USE_METIS_NOT_PARMETIS}
         "MEDCOUPLING_ENABLE_PARTITIONER" OFF)
 CMAKE_DEPENDENT_OPTION(MEDCOUPLING_PARTITIONER_SCOTCH "Enable scotch graph library in MEDPartitioner." ON 
-        "MEDCOUPLING_ENABLE_PARTITIONER;NOT MEDCOUPLING_USE_MPI" OFF)
+        "MEDCOUPLING_ENABLE_PARTITIONER" OFF)
 CMAKE_DEPENDENT_OPTION(MEDCOUPLING_PARTITIONER_PARMETIS "Enable parmetis graph library in MEDPartitioner." ${MEDCOUPLING_USE_MPI} 
         "MEDCOUPLING_ENABLE_PARTITIONER;MEDCOUPLING_USE_MPI" OFF)
+CMAKE_DEPENDENT_OPTION(MEDCOUPLING_PARTITIONER_PTSCOTCH "Enable ptscotch graph library in MEDPartitioner." ${MEDCOUPLING_USE_MPI} 
+        "MEDCOUPLING_ENABLE_PARTITIONER;MEDCOUPLING_USE_MPI" OFF)
 SET(XDR_DEFAULT_OPTION ON)
 IF(WIN32)
     SET(XDR_DEFAULT_OPTION OFF)
@@ -89,6 +91,10 @@
     MESSAGE(FATAL_ERROR "ParMetis and Metis are mutually exclusive! Make a choice (options MEDCOUPLING_PARTITIONER_METIS and MEDCOUPLING_PARTITIONER_PARMETIS).")
 ENDIF()
 
+IF(${MEDCOUPLING_PARTITIONER_PTSCOTCH} AND ${MEDCOUPLING_PARTITIONER_SCOTCH})
+    MESSAGE(FATAL_ERROR "PTScotch and Scotch are mutually exclusive! Make a choice (options MEDCOUPLING_PARTITIONER_SCOTCH and MEDCOUPLING_PARTITIONER_PTSCOTCH).")
+ENDIF()
+
 #
 # Set list of prerequisites
 # =========================
@@ -138,6 +144,13 @@
       ADD_DEFINITIONS("-DMED_ENABLE_PARMETIS")
     ENDIF()
   ENDIF(MEDCOUPLING_PARTITIONER_PARMETIS)
+  IF(MEDCOUPLING_PARTITIONER_PTSCOTCH)
+    FIND_PACKAGE(SalomePTScotch)
+    SALOME_LOG_OPTIONAL_PACKAGE(PTScotch MEDCOUPLING_PARTITIONER_PTSCOTCH)
+    IF(SalomePTScotch_FOUND)
+      ADD_DEFINITIONS("-DMED_ENABLE_PTSCOTCH")
+    ENDIF(SalomePTScotch_FOUND)
+  ENDIF(MEDCOUPLING_PARTITIONER_PTSCOTCH)
 ENDIF(MEDCOUPLING_USE_MPI)
 
 IF(MEDCOUPLING_ENABLE_RENUMBER)
@@ -245,7 +258,7 @@
 # List of targets in this project we want to make visible to the rest of the world.
 # They all have to be INSTALL'd with the option "EXPORT ${PROJECT_NAME}TargetGroup"
 SET(_${PROJECT_NAME}_exposed_targets
-   interpkernel medcoupling medcouplingremapper)
+   interpkernel medcouplingcpp medcouplingremapper)
 
 IF(NOT MEDCOUPLING_MICROMED)
   LIST(APPEND _${PROJECT_NAME}_exposed_targets medloader)
diff -Naur MEDCOUPLING_old/doc/tutorial/atestMEDLoaderAdvancedAPI1.rst MEDCOUPLING_new/doc/tutorial/atestMEDLoaderAdvancedAPI1.rst
--- MEDCOUPLING_old/doc/tutorial/atestMEDLoaderAdvancedAPI1.rst	2018-04-19 17:04:36.585219692 +0200
+++ MEDCOUPLING_new/doc/tutorial/atestMEDLoaderAdvancedAPI1.rst	2018-04-19 17:25:17.221787157 +0200
@@ -89,6 +89,6 @@
 	#
 	fMEDFileRead2 = ml.MEDFileField1TS("TargetMesh2.med",fPart.getName(),7,8)
 	fPartRead, pflRead = fMEDFileRead2.getFieldWithProfile(ml.ON_CELLS,0,meshMEDFileRead)
-	print "Is the partial field correclty read?", fPartRead.isEqualWithoutConsideringStr(fPart.getArray(),1e-12)
+	print "Is the partial field correctly read?", fPartRead.isEqualWithoutConsideringStr(fPart.getArray(),1e-12)
 	print "Is the list of cell identifiers matching?", pflRead.isEqualWithoutConsideringStr(pfl)
 	
diff -Naur MEDCOUPLING_old/doc/tutorial/atestMEDLoaderBasicAPI1.rst MEDCOUPLING_new/doc/tutorial/atestMEDLoaderBasicAPI1.rst
--- MEDCOUPLING_old/doc/tutorial/atestMEDLoaderBasicAPI1.rst	2018-04-19 17:04:36.585219692 +0200
+++ MEDCOUPLING_new/doc/tutorial/atestMEDLoaderBasicAPI1.rst	2018-04-19 17:25:17.170786149 +0200
@@ -32,7 +32,7 @@
 	f.setMesh(targetMesh)
 	f.setName("AFieldName")
 	ml.WriteField("MyFirstField.med",f,True)
-	# Re-read it ans test equality
+	# Re-read it and test equality
 	f2 = ml.ReadFieldCell("MyFirstField.med", f.getMesh().getName(), 0, f.getName(), 7, 8)
 	print "Is the read field identical to 'f' ?", f2.isEqual(f,1e-12,1e-12)
 	# Writing in several steps 
diff -Naur MEDCOUPLING_old/doc/tutorial/medcoupling_2Dpolygon.rst MEDCOUPLING_new/doc/tutorial/medcoupling_2Dpolygon.rst
--- MEDCOUPLING_old/doc/tutorial/medcoupling_2Dpolygon.rst	2018-04-19 17:04:36.627220529 +0200
+++ MEDCOUPLING_new/doc/tutorial/medcoupling_2Dpolygon.rst	2018-04-19 17:25:17.133785418 +0200
@@ -20,7 +20,7 @@
 
 	from math import *
 
-Then we must instanciate a meshing object::
+Then we must instantiate a meshing object::
 
 	mesh=MEDCouplingUMesh.New()
 	mesh.setMeshDimension(2)
diff -Naur MEDCOUPLING_old/doc/tutorial/medcoupling_3Dcube.rst MEDCOUPLING_new/doc/tutorial/medcoupling_3Dcube.rst
--- MEDCOUPLING_old/doc/tutorial/medcoupling_3Dcube.rst	2018-04-19 17:04:36.627220529 +0200
+++ MEDCOUPLING_new/doc/tutorial/medcoupling_3Dcube.rst	2018-04-19 17:25:17.106784884 +0200
@@ -39,7 +39,7 @@
 Classical method
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-First instanciate a meshing object. Therefore, we need to define :
+First instantiate a meshing object. Therefore, we need to define :
 
  * its name
  * its dimension
@@ -248,7 +248,7 @@
  * its values
 
  
-The field will be a sin function dependant of distance of the barycenter of each cell from origin. So we need to create a barycenter field on the 3D mesh::
+The field will be a sin function dependent of distance of the barycenter of each cell from origin. So we need to create a barycenter field on the 3D mesh::
 
 	# Creation of field : with following definition
 	# => Definition of the mesh support
diff -Naur MEDCOUPLING_old/doc/tutorial/medcoupling_dataarray1_fr.rst MEDCOUPLING_new/doc/tutorial/medcoupling_dataarray1_fr.rst
--- MEDCOUPLING_old/doc/tutorial/medcoupling_dataarray1_fr.rst	2018-04-19 17:04:36.627220529 +0200
+++ MEDCOUPLING_new/doc/tutorial/medcoupling_dataarray1_fr.rst	2018-04-19 17:25:17.128785319 +0200
@@ -179,7 +179,7 @@
 La méthode ``findCommonTuples()`` retourne ainsi 2 paramètres: un tableau contenant la liste des tuples communs 
 et un tableau d'index qui permet de naviguer dans le premier tableau.    
 Il s'agit d'une forme de retour très classique dans MEDCoupling, appelée *indirect indexing*. Cela apparaît souvent dans la manipulation des 
-maillages non structurés. Cette représentation est rappelée sur l'image ci-dessous, où le premier tableau et en haut, 
+maillages non structurés. Cette représentation est rappelée sur l'image ci-dessous, où le premier tableau est en haut, 
 et le deuxième tableau permettant de la parcourir en bas:
 
 .. image:: images/IndirectIndex.jpg
@@ -288,7 +288,7 @@
 
 	d3 += [3.3,4.4]
 
-Constuire un maillage non strucuturé
+Constuire un maillage non structuré
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 On chercher maintenant à créer le maillage final montré dans la figure. Nous avons déjà construit le tableau
diff -Naur MEDCOUPLING_old/doc/tutorial/medcouplingloaderex2_en.rst MEDCOUPLING_new/doc/tutorial/medcouplingloaderex2_en.rst
--- MEDCOUPLING_old/doc/tutorial/medcouplingloaderex2_en.rst	2018-04-19 17:04:36.628220549 +0200
+++ MEDCOUPLING_new/doc/tutorial/medcouplingloaderex2_en.rst	2018-04-19 17:25:17.175786248 +0200
@@ -102,7 +102,7 @@
 .. image:: images/zone1Mobm.jpg
 
 From now on we work on "zone1Mobm". We will reduce the working area of "fixm" around "zone1Mobm".
-To achive this: reduce "fixm" taking only "fixm" cells located in the bounding box of "zone1Mobm" (MEDCouplingUMesh.getBoundingBox() and MEDCouplingUMesh.getCellsInBoundingBox()).
+To achieve this: reduce "fixm" taking only "fixm" cells located in the bounding box of "zone1Mobm" (MEDCouplingUMesh.getBoundingBox() and MEDCouplingUMesh.getCellsInBoundingBox()).
 Name this object "partFixm", remove its orphan nodes and display it. ::
 
 	ids2=fixm.getCellsInBoundingBox(zone1Mobm.getBoundingBox(),1e-10)
diff -Naur MEDCOUPLING_old/doc/tutorial/medcouplingmultiproc_fr.rst MEDCOUPLING_new/doc/tutorial/medcouplingmultiproc_fr.rst
--- MEDCOUPLING_old/doc/tutorial/medcouplingmultiproc_fr.rst	2018-04-19 17:04:36.628220549 +0200
+++ MEDCOUPLING_new/doc/tutorial/medcouplingmultiproc_fr.rst	2018-04-19 17:25:17.167786090 +0200
@@ -67,14 +67,13 @@
 L'idée est d'interpoler ``m`` avec ``m2Part``.
 
 On récupèrera ensuite la matrice sparse ``myMat`` issue de ``m`` avec ``m2Part``.
-Ensuite l'idée et de générer une matrice sparse ``mat2`` à partir de ``myMat`` avec les ids globaux de ``m2``. ::
+Ensuite l'idée est de générer une matrice sparse ``mat2`` à partir de ``myMat`` avec les ids globaux de ``m2``. ::
 
 	def work(inp):
             m2Part,partToGlob=inp
 	    myRemap=mr.MEDCouplingRemapper()
 	    assert(myRemap.prepare(m,m2Part,"P0P0")==1)
 	    myMat=myRemap.getCrudeCSRMatrix()
-	    a=mc.DataArrayInt.Range(s.start,s.stop,s.step)
 	    indptrnew=mc.DataArrayInt(m2.getNumberOfCells())
 	    indptrnew.fillWithZero()
 	    d=mc.DataArrayInt(myMat.indptr).deltaShiftIndex()
diff -Naur MEDCOUPLING_old/doc/tutorial/medcoupling_umesh1_en.rst MEDCOUPLING_new/doc/tutorial/medcoupling_umesh1_en.rst
--- MEDCOUPLING_old/doc/tutorial/medcoupling_umesh1_en.rst	2018-04-19 17:04:36.627220529 +0200
+++ MEDCOUPLING_new/doc/tutorial/medcoupling_umesh1_en.rst	2018-04-19 17:25:17.223787197 +0200
@@ -189,7 +189,7 @@
         mesh3DSlice2bis.translate([0.,1000.,0.])
         mesh3DSlice2All=MEDCouplingUMesh.MergeUMeshes([mesh3DSlice2,mesh3DSlice2bis])
 
-.. note:: My apologies for the name of the method MEDCouplingUMesh.MergeUMeshes. In future version it will be called AggregateUMeshes. For information, to merge two (or more) unstructured meshes, one has to invoke MergeUMeshes(), then mergeNodes() on the result, and finally zipConnectivity().
+.. note:: My apologies for the name of the method MEDCouplingUMesh.MergeUMeshes. In future version it will be called AggregateUMeshes. For information, to merge two (or more) unstructured meshes, one has to invoke MergeUMeshes(), then mergeNodes() on the result, and finally zipConnectivityTraducer().
 
 
 Descending connectivity
diff -Naur MEDCOUPLING_old/doc/tutorial/medcoupling_umesh1_fr.rst MEDCOUPLING_new/doc/tutorial/medcoupling_umesh1_fr.rst
--- MEDCOUPLING_old/doc/tutorial/medcoupling_umesh1_fr.rst	2018-04-19 17:04:36.627220529 +0200
+++ MEDCOUPLING_new/doc/tutorial/medcoupling_umesh1_fr.rst	2018-04-19 17:25:17.172786189 +0200
@@ -111,8 +111,6 @@
 	critères géométriques.
 	Il s'agit d'abord de calculer les barycentres des cellules 3D de ``mesh3D`` (méthode 
 	``MEDCouplingUMesh.computeCellCenterOfMass()``).
-	(*Note*: le nom -- un peu trop long -- de cette méthode hérite du passé. Le "AndOwner" indique le fait qu'en C++
-	l'appelant est responsable de la désallocation de l'objet retourné : il prend l'*ownership* du résultat). 
 	
 	Ensuite sélectionner la composante #2 des barycentres des cellules et mettre le résultat dans ``baryZ``.
 	Ensuite il suffit de selectionner dans ``baryZ`` les tuples qui sont dans l'intervalle ``[zLev[1], zLev[2]]``. 
@@ -248,7 +246,7 @@
 	mesh3DSlice2All.writeVTK("mesh3DSlice2All.vtu")
 
 .. note:: Pour information pour merger deux (ou plus) maillages non structurés, il faut invoquer ``MEDCouplingUMesh.MergeUMeshes()``
-	puis ``MEDCouplingUMesh.mergeNodes()`` sur le résultat, et enfin ``MEDCouplingUMesh.zipConnectivity()``.
+	puis ``MEDCouplingUMesh.mergeNodes()`` sur le résultat, et enfin ``MEDCouplingUMesh.zipConnectivityTraducer()``.
 
 .. _exo-umesh-desc-connec:
 
diff -Naur MEDCOUPLING_old/doc/tutorial/medloader_advancedAPI1_fr.rst MEDCOUPLING_new/doc/tutorial/medloader_advancedAPI1_fr.rst
--- MEDCOUPLING_old/doc/tutorial/medloader_advancedAPI1_fr.rst	2018-04-19 17:04:36.628220549 +0200
+++ MEDCOUPLING_new/doc/tutorial/medloader_advancedAPI1_fr.rst	2018-04-19 17:25:17.169786129 +0200
@@ -180,7 +180,7 @@
 
 	fMEDFileRead2 = ml.MEDFileField1TS("TargetMesh2.med",fPart.getName(),7,8)
 	fPartRead, pflRead = fMEDFileRead2.getFieldWithProfile(ml.ON_CELLS,0,meshMEDFileRead)
-	print "Is the partial field correclty read?", fPartRead.isEqualWithoutConsideringStr(fPart.getArray(),1e-12)
+	print "Is the partial field correctly read?", fPartRead.isEqualWithoutConsideringStr(fPart.getArray(),1e-12)
 	print "Is the list of cell identifiers matching?", pflRead.isEqualWithoutConsideringStr(pfl)
 
 Solution
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/appendix/install.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/appendix/install.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/appendix/install.dox	2018-04-19 17:04:36.629220569 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/appendix/install.dox	2018-04-19 17:25:17.099784746 +0200
@@ -22,7 +22,7 @@
 - \a -DMEDCOUPLING_PARTITIONER_METIS=ON enables metis graph library in MEDPartitioner,
 - \a -DMEDCOUPLING_PARTITIONER_PARMETIS=ON enables parmetis graph library in MEDPartitioner,
 - \a -DMEDCOUPLING_PARTITIONER_SCOTCH=ON enables scotch graph library in MEDPartitioner,
-- \a -DMEDCOUPLING_MICROMED=ON build MED with MED file dependancy,
+- \a -DMEDCOUPLING_MICROMED=ON build MED with MED file dependency,
 - \a -DMEDCOUPLING_ENABLE_PYTHON=ON builds PYTHON bindings,
 - \a -DMEDCOUPLING_ENABLE_PARTITIONER builds MEDPartitioner,
 - \a -DMEDCOUPLING_ENABLE_RENUMBER builds Renumber,
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/appendix/porting.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/appendix/porting.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/appendix/porting.dox	2018-04-19 17:04:36.629220569 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/appendix/porting.dox	2018-04-19 17:25:17.100784765 +0200
@@ -34,9 +34,9 @@
 The MEDLoader high level API is hence accessible:
  - at the MEDCoupling namespace level in C++ (direct static functions, no more MEDLoader class)
  - at the MEDLoader module level in Python. Scripts using the high level API of the MEDLoader
-typically need to get read of all the occurences of "MEDLoader." in their code.  
+typically need to get read of all the occurrences of "MEDLoader." in their code.  
 
-Note that on the Python side the module MEDLoader is still here, but doesn't containt the MEDLoader class anymore.
+Note that on the Python side the module MEDLoader is still here, but doesn't contain the MEDLoader class anymore.
 As before it re-includes all of MEDCoupling classes, plus the low level MEDLoader classes (MEDFile* classes).
 
 \section port-full-ref Name changes - Reference list
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/appendix/references.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/appendix/references.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/appendix/references.dox	2018-04-19 17:04:36.629220569 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/appendix/references.dox	2018-04-19 17:25:17.097784706 +0200
@@ -2,7 +2,7 @@
 
 \page references References 
 
-Here follows a list of useful references :
+Below is a list of useful references :
 
 -# \anchor RefManualMedFile Reference Manual for Med File, V. Lefebvre,  E. Fayolle, Projet PAL: D&eacute;finition du mod&egrave;le d'&eacute;change de donn&eacute;es MED V2.2,  Note technique EDF/SINETICS, HI-26-03-012/A, https://hammi.extra.cea.fr/static/MED/web_med/index.html
 -# VTK home page: \c http://public.kitware.com/VTK
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/examples/medcouplingexamplesmeshes.doxy MEDCOUPLING_new/doc/user/doxygen/doxfiles/examples/medcouplingexamplesmeshes.doxy
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/examples/medcouplingexamplesmeshes.doxy	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/examples/medcouplingexamplesmeshes.doxy	2018-04-19 17:25:17.044783658 +0200
@@ -102,7 +102,7 @@
 \snippet MEDCouplingExamplesTest.cxx CppSnippet_MEDCouplingUMesh_buildFacePartOfMySelfNode_2
 <br>If the last parameter is \c true
 \ref MEDCoupling::MEDCouplingUMesh::buildFacePartOfMySelfNode "buildFacePartOfMySelfNode()" looks
-for segements whose all nodes are given to it, hence it finds segments bounding the cell #0 only.
+for segments whose all nodes are given to it, hence it finds segments bounding the cell #0 only.
 <br>If the last parameter is \c false
 \ref MEDCoupling::MEDCouplingUMesh::buildFacePartOfMySelfNode "buildFacePartOfMySelfNode()" looks
 for any segment whose nodes are given to it, hence it adds more segments to \b mesh2.
@@ -549,7 +549,7 @@
   - #4 (== \b desc[ \b descIndx[ 0 ] + 3 ]).
   <br>Ids are positive since order of nodes in the corresponding cells of \b mesh and \b mesh2
   are same. For example nodes of SEG2 #3 are [4,1] and nodes of QUAD4 #0 are [0,3,\b 4,\b 1].
-- The cell #1 of \b mesh (TRI3) is bound by 3 (== \b descIndx[2] - \b descIndx[1]) segements of
+- The cell #1 of \b mesh (TRI3) is bound by 3 (== \b descIndx[2] - \b descIndx[1]) segments of
   \b mesh2 whose ids in FORTRAN mode are:
   - #-3 (== \b desc[ \b descIndx[ 1 ]]),
   - #5 (== \b desc[ \b descIndx[ 1 ] + 1 ]) and
@@ -582,7 +582,7 @@
   - #1 (== \b desc[ \b descIndx[ 0 ] + 1 ]),
   - #2 (== \b desc[ \b descIndx[ 0 ] + 2 ]) and
   - #3 (== \b desc[ \b descIndx[ 0 ] + 3 ]).
-- The cell #1 of \b mesh (TRI3) is bound by 3 (== \b descIndx[2] - \b descIndx[1]) segements of
+- The cell #1 of \b mesh (TRI3) is bound by 3 (== \b descIndx[2] - \b descIndx[1]) segments of
   \b mesh2 whose ids are:
   - #2 (== \b desc[ \b descIndx[ 1 ]]),
   - #4 (== \b desc[ \b descIndx[ 1 ] + 1 ]) and
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/examples/medcouplingexamplesother.doxy MEDCOUPLING_new/doc/user/doxygen/doxfiles/examples/medcouplingexamplesother.doxy
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/examples/medcouplingexamplesother.doxy	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/examples/medcouplingexamplesother.doxy	2018-04-19 17:25:17.047783718 +0200
@@ -203,7 +203,7 @@
 \ref medcoupling "MEDCoupling" allows to make bridges between the approaches. For example \a pfl \ref MEDCoupling::DataArrayInt "DataArrayInt instance" retrieved directly
 from the file in the second approach can be retrieved starting from first approach.
 
-Starting from mesh \a firstApproachMesh of read field in first approach \a fread, whith the whole mesh \a wholeMesh the profile \a pflComputed can be computed :
+Starting from mesh \a firstApproachMesh of read field in first approach \a fread, with the whole mesh \a wholeMesh the profile \a pflComputed can be computed :
 
 \snippet MEDLoaderExamplesTest.py PySnippetReadFieldPartial1_5
 
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/faq.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/faq.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/faq.dox	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/faq.dox	2018-04-19 17:25:17.056783896 +0200
@@ -46,7 +46,7 @@
 Take a look at \ref library
 
 \subsubsection f-visu How can I visualize a mesh and/or a field?
-Use the PARAVIS module of SALOME to visualize your MED file. The following dedicated fitlers have been 
+Use the PARAVIS module of SALOME to visualize your MED file. The following dedicated filters have been 
 written specifically for MED files: Extract group, Extract cell types, ELNO Mesh, ELNO Points, ELNO Surface.
 
 \subsubsection f-p0p1 What does a P0- (or P1-) field mean?
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/arrays/arrays.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/arrays/arrays.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/arrays/arrays.dox	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/arrays/arrays.dox	2018-04-19 17:25:17.094784647 +0200
@@ -15,7 +15,7 @@
 understood to efficiently deal with \ref meshes "Meshes" and \ref fields "Fields".
 
 \ref MEDCoupling::DataArray "DataArrays" are the atomic element of potentially heavy-memory objects in 
-the 3 modules mentionned above.
+the 3 modules mentioned above.
 
 There are for the moment two types of arrays :
  - double precision float (64 bits) array incarnated by \ref MEDCoupling::DataArrayDouble "DataArrayDouble class".
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/arrays/numbering.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/arrays/numbering.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/arrays/numbering.dox	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/arrays/numbering.dox	2018-04-19 17:25:17.092784607 +0200
@@ -16,7 +16,7 @@
 
 \section MEDCouplingArrayRenumberingO2N Old-to-new mode
 
-The old to new mode is particularly recommanded for surjective and bijective applications. This 
+The old to new mode is particularly recommended for surjective and bijective applications. This 
 is typically the case of \ref MEDCoupling::MEDCouplingUMesh::mergeNodes "MEDCouplingUMesh::mergeNodes" method.
 Let's consider a call to \ref MEDCoupling::MEDCouplingUMesh::mergeNodes "mergeNodes" that reduces the 
 number of nodes from 5 nodes to 3 nodes.\n
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/cpp/cpp.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/cpp/cpp.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/cpp/cpp.dox	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/cpp/cpp.dox	2018-04-19 17:25:17.091784588 +0200
@@ -1,5 +1,5 @@
 /*!
-  \page cpp Note for C++ developpers
+  \page cpp Note for C++ developers
   
 Using the C++ API provided by MED requires you to be familiar with some specificities which are not
 visible to the Python user.
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/distrib/parallel.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/distrib/parallel.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/distrib/parallel.dox	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/distrib/parallel.dox	2018-04-19 17:25:17.064784054 +0200
@@ -12,8 +12,8 @@
 The core elements of the API are:
 - \ref CommInterface-det "CommInterface", this is the wrapper around the MPI library, and an instance
 of this object is required in many constructors of the following objects.  
-- \ref ParaMESH-det "ParaMESH", the parallel instanciation of a \ref meshes "MEDCoupling mesh" 
-- \ref ParaFIELD-det "ParaFIELD", the parallel instanciation of a \ref fields "MEDCoupling field"
+- \ref ParaMESH-det "ParaMESH", the parallel instantiation of a \ref meshes "MEDCoupling mesh" 
+- \ref ParaFIELD-det "ParaFIELD", the parallel instantiation of a \ref fields "MEDCoupling field"
 - \ref MPIProcessorGroup-det "MPIProcessorGroup" (which inherits from the abstract 
 \ref MEDCoupling::ProcessorGroup "ProcessorGroup"), a group of processors (typically MPI nodes)
 
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/fields/discretization.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/fields/discretization.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/fields/discretization.dox	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/fields/discretization.dox	2018-04-19 17:25:17.073784232 +0200
@@ -23,10 +23,10 @@
     - Kriging points:  built with \ref MEDCoupling::TypeOfField "ON_NODES_KR"
 
 The spatial discretization is at the center of the \ref interpolation "interpolation" mechanisms,
-since one of the main interpolation paramter is indeed specifying from which source discretization
+since one of the main interpolation parameter is indeed specifying from which source discretization
 to which target discretization one wants to go. For example:
-- a P0->P0 interpolation means that a field on cells will be transfered to another cell-based field;
-- a P1->P0 interpolation means that a field on nodes this time will be transfered to a cell-based field. 
+- a P0->P0 interpolation means that a field on cells will be transferred to another cell-based field;
+- a P1->P0 interpolation means that a field on nodes this time will be transferred to a cell-based field. 
 - etc ...
 
 Finally, in the code itself, the class \ref MEDCoupling::MEDCouplingFieldDiscretization "MEDCouplingFieldDiscretization"
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/interpolation/Geometric2D.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/interpolation/Geometric2D.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/interpolation/Geometric2D.dox	2018-04-19 17:04:36.630220589 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/interpolation/Geometric2D.dox	2018-04-19 17:25:17.081784390 +0200
@@ -106,7 +106,7 @@
 \subsection interpkernelGeo2DBoolOpStep3 Step3 : Result polygon building.
 
 This stage links each edge with wanted loc. \b Contrary to last 2 steps it is obviously boolean
-operation dependant. Let's take the case of the intersection that is used in
+operation dependent. Let's take the case of the intersection that is used in
 P0->P0 interpolation. \n The principle of result polygon building is to build polygon by taking
 edges localized as \b in or \b on.
 
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/interpolation/interptheory.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/interpolation/interptheory.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/interpolation/interptheory.dox	2018-04-19 17:04:36.631220609 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/interpolation/interptheory.dox	2018-04-19 17:25:17.084784449 +0200
@@ -257,7 +257,7 @@
     \end{tabular}\right]
 \f]
 
-This type of nature is particulary recommended to interpolate an intensive \b density
+This type of nature is particularly recommended to interpolate an intensive \b density
 field (moderator density, power density).
 The difference with \ref TableNatureOfFieldExampleConservVol "conservative volumic" seen above is that here the
 target field is homogenized to the \b whole target cell. It explains why this nature of field does not follow the maximum principle.
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/interpolation/mapped_bary.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/interpolation/mapped_bary.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/interpolation/mapped_bary.dox	2018-04-19 17:04:36.631220609 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/interpolation/mapped_bary.dox	2018-04-19 17:25:17.076784291 +0200
@@ -46,7 +46,7 @@
 
 \subsection{Rectangle}
 
-Finally it is worth puting aside the case \f$\mathbf{N} = 0\f$ (rectangle), which boils down to solving an ordinary
+Finally it is worth putting aside the case \f$\mathbf{N} = 0\f$ (rectangle), which boils down to solving an ordinary
 2-unknows system:
 \f[ x = \frac{p_x A_y - p_y A_x}{C_x A_y - C_y A_x}, y = \frac{C_x p_y-C_y p_x}{C_x A_y - C_y A_x} \f]
 
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/meshes/meshes.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/meshes/meshes.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/meshes/meshes.dox	2018-04-19 17:04:36.632220629 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/meshes/meshes.dox	2018-04-19 17:25:17.070784173 +0200
@@ -6,7 +6,7 @@
 
 Several types of meshes are available in MEDCoupling:
 
-- \subpage MEDCouplingPointSetPage "Point set mesh" (abstract, can not be instanciated)
+- \subpage MEDCouplingPointSetPage "Point set mesh" (abstract, can not be instantiated)
 - \subpage MEDCouplingUMeshPage "Unstructured meshes"
 - \subpage MEDCouplingCMeshPage "Cartesian meshes"
 - \subpage MEDCouplingExtrudedPage "3D Extruded meshes"
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/misc/tools.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/misc/tools.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/reference/misc/tools.dox	2018-04-19 17:04:36.632220629 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/reference/misc/tools.dox	2018-04-19 17:25:17.086784489 +0200
@@ -55,7 +55,7 @@
         --meshname=<string>    : name of the input mesh (not used with --distributed option)
         --ndomains=<number>    : number of subdomains in the output file, default is 1
         --plain-master         : creates a plain masterfile instead of an XML file
-        --creates-boundary-faces: creates the necessary faces so that faces joints are created in the output files
+        --create-boundary-faces: creates the necessary faces so that faces joints are created in the output files
         --family-splitting     : preserves the family names instead of focusing on the groups
 \endcode
 
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/start/library.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/start/library.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/start/library.dox	2018-04-19 17:04:36.632220629 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/start/library.dox	2018-04-19 17:25:17.050783777 +0200
@@ -8,7 +8,7 @@
 
 "MED" can (unfortunately) refer to:
 - <b>\ref med-file "MED file format"</b>: the file format used to save a mesh (".med" extension)
-- <b>\ref med-file "MED-file library"</b>: the C++ library developped by EdF R&D (and provided
+- <b>\ref med-file "MED-file library"</b>: the C++ library developed by EdF R&D (and provided
  with SALOME) to read/write MED file (warning: for advanced users only!)
 - <b> \ref medcoupling "MEDCoupling"</b>: the (relatively) high level API to deal with mesh and fields in memory
 - <b>\ref medloader MEDLoader</b>: part of the library dedicated to file I/O = a more user-friendly API than the MED-file library API
@@ -19,7 +19,7 @@
 
 The most common confusion is between the MED library (what you are reading at present) and
 the MED-file library ("MED fichier").
-The MED-file library is part of the prerequisites of the MED libary, and its only purpose is to read and write
+The MED-file library is part of the prerequisites of the MED library, and its only purpose is to read and write
 MED files. This is a low level API written in C, and giving a fine-grain access to the structure
 of the MED files (.med). The architecture diagramm below details those points further.
 
diff -Naur MEDCOUPLING_old/doc/user/doxygen/doxfiles/start/start.dox MEDCOUPLING_new/doc/user/doxygen/doxfiles/start/start.dox
--- MEDCOUPLING_old/doc/user/doxygen/doxfiles/start/start.dox	2018-04-19 17:04:36.632220629 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/doxfiles/start/start.dox	2018-04-19 17:25:17.055783876 +0200
@@ -1,7 +1,7 @@
 /*!
 \page start Getting started
 
-If you are completly new to MED, this page will help you grasp the main concepts
+If you are completely new to MED, this page will help you grasp the main concepts
 used overall in the \ref library "MED world", and have an idea of what you can achieve with MED.
 
 The <a class="el" href="tutorial/index.html">tutorial</a> is also a good way to start.
diff -Naur MEDCOUPLING_old/doc/user/doxygen/Doxyfile_med_user.in MEDCOUPLING_new/doc/user/doxygen/Doxyfile_med_user.in
--- MEDCOUPLING_old/doc/user/doxygen/Doxyfile_med_user.in	2018-04-19 17:04:36.629220569 +0200
+++ MEDCOUPLING_new/doc/user/doxygen/Doxyfile_med_user.in	2018-04-19 17:25:16.841779646 +0200
@@ -161,8 +161,13 @@
                          MEDFileData.*xx \
                          MEDFileParameter.*xx \
                          MEDFileMesh.*xx \
+			 MEDFileFieldGlobs.*xx \
+			 MEDFileFieldInternal.*xx \
+			 MEDFileField1TS.*xx \
+			 MEDFileFieldMultiTS.*xx \
                          MEDFileField.*xx \
-                         *Servant.*xx \
+			 MEDFileFieldVisitor.hxx \
+			 *Servant.*xx \
                          *.dox
 RECURSIVE              = YES
 EXCLUDE                = CVS
diff -Naur MEDCOUPLING_old/MEDCouplingConfig.cmake.in MEDCOUPLING_new/MEDCouplingConfig.cmake.in
--- MEDCOUPLING_old/MEDCouplingConfig.cmake.in	2018-04-19 17:04:36.584219672 +0200
+++ MEDCOUPLING_new/MEDCouplingConfig.cmake.in	2018-04-19 17:25:18.169805896 +0200
@@ -1,6 +1,6 @@
 # - Config file for the @PROJECT_NAME@ package
 # It defines the following variables. 
-# Specific to the pacakge @PROJECT_NAME@ itself:
+# Specific to the package @PROJECT_NAME@ itself:
 #  @PROJECT_NAME_UC@_ROOT_DIR_EXP - the root path of the installation providing this CMake file
 #
 
@@ -30,7 +30,7 @@
 # Load the dependencies for the libraries of @PROJECT_NAME@ 
 # (contains definitions for IMPORTED targets). This is only 
 # imported if we are not built as a subproject (in this case targets are already there)
-IF(NOT TARGET medcoupling AND NOT @PROJECT_NAME@_BINARY_DIR)
+IF(NOT TARGET medcouplingcpp AND NOT @PROJECT_NAME@_BINARY_DIR)
   INCLUDE("@PACKAGE_MEDCOUPLING_INSTALL_CMAKE_LOCAL@/@PROJECT_NAME@Targets.cmake")
 ENDIF()   
 
@@ -114,7 +114,8 @@
 
 # Exposed MEDCoupling targets:
 SET(MEDCoupling_interpkernel interpkernel)
-SET(MEDCoupling_medcoupling medcoupling)
+SET(MEDCoupling_medcouplingcpp medcouplingcpp)
+SET(MEDCoupling_medcoupling    medcouplingcpp)
 SET(MEDCoupling_medcouplingremapper medcouplingremapper)
 SET(MEDCoupling_medloader medloader)
 SET(MEDCoupling_renumbercpp renumbercpp)
diff -Naur MEDCOUPLING_old/src/CMakeLists.txt MEDCOUPLING_new/src/CMakeLists.txt
--- MEDCOUPLING_old/src/CMakeLists.txt	2018-04-19 17:04:36.669221367 +0200
+++ MEDCOUPLING_new/src/CMakeLists.txt	2018-04-19 17:25:17.367790043 +0200
@@ -27,6 +27,7 @@
 ADD_SUBDIRECTORY(MEDCoupling)
 IF(MEDCOUPLING_ENABLE_PYTHON)
   ADD_SUBDIRECTORY(MEDCoupling_Swig)
+  ADD_SUBDIRECTORY(PyWrapping)
 ENDIF(MEDCOUPLING_ENABLE_PYTHON)
 
 IF(NOT MEDCOUPLING_MICROMED)
diff -Naur MEDCOUPLING_old/src/CTestTestfileInstall.cmake MEDCOUPLING_new/src/CTestTestfileInstall.cmake
--- MEDCOUPLING_old/src/CTestTestfileInstall.cmake	2018-04-19 17:04:36.669221367 +0200
+++ MEDCOUPLING_new/src/CTestTestfileInstall.cmake	2018-04-19 17:25:18.144805402 +0200
@@ -30,3 +30,5 @@
 #SUBDIRS(ParaMEDMEMTest)
 SUBDIRS(MEDPartitioner_Swig)
 SUBDIRS(RENUMBER_Swig)
+SUBDIRS(PyWrapping)
+
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Bases/InterpKernelAssert.hxx MEDCOUPLING_new/src/INTERP_KERNEL/Bases/InterpKernelAssert.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Bases/InterpKernelAssert.hxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Bases/InterpKernelAssert.hxx	2018-04-19 17:25:17.507792810 +0200
@@ -0,0 +1,34 @@
+// Copyright (C) 2018  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#ifndef __INTERPKERNELASSERT_HXX__
+#define __INTERPKERNELASSERT_HXX__
+
+#include "InterpKernelException.hxx"
+
+#include <sstream>
+
+#define IKAssert(a) { bool verdict(a);           \
+    if(!verdict) { std::ostringstream osszz; osszz << "Assertion \"" << #a << "\" failed into " << __FILE__ << " at line " << __LINE__ << " !"; throw INTERP_KERNEL::Exception(osszz.str()); } }
+
+#define IKAssertMsg(a,b) { bool verdict(a);           \
+    if(!verdict) { std::ostringstream osszz; osszz << "Assertion \"" << #a << "\" failed into " << __FILE__ << " at line " << __LINE__ << " with message \"" << b << "\" !"; throw INTERP_KERNEL::Exception(osszz.str()); } }
+
+#endif
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Bases/NormalizedGeometricTypes MEDCOUPLING_new/src/INTERP_KERNEL/Bases/NormalizedGeometricTypes
--- MEDCOUPLING_old/src/INTERP_KERNEL/Bases/NormalizedGeometricTypes	2018-04-19 17:04:36.670221387 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Bases/NormalizedGeometricTypes	2018-04-19 17:25:17.505792771 +0200
@@ -47,6 +47,7 @@
       NORM_HEXGP12 = 22,
       NORM_PYRA13  = 23,
       NORM_PENTA15 = 25,
+      NORM_PENTA18 = 28,
       NORM_HEXA20  = 30,
       NORM_HEXA27  = 27,
       NORM_POLYHED = 31,
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/BoundingBox.cxx MEDCOUPLING_new/src/INTERP_KERNEL/BoundingBox.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/BoundingBox.cxx	2018-04-19 17:04:36.670221387 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/BoundingBox.cxx	2018-04-19 17:25:17.462791921 +0200
@@ -162,4 +162,14 @@
     return valid;
   }
 
+  void BoundingBox::toCompactData(double data[6]) const
+  {
+    data[0]=_coords[XMIN];
+    data[1]=_coords[XMAX];
+    data[2]=_coords[YMIN];
+    data[3]=_coords[YMAX];
+    data[4]=_coords[ZMIN];
+    data[5]=_coords[ZMAX];
+  }
+
 }
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/BoundingBox.hxx MEDCOUPLING_new/src/INTERP_KERNEL/BoundingBox.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/BoundingBox.hxx	2018-04-19 17:04:36.670221387 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/BoundingBox.hxx	2018-04-19 17:25:17.537793403 +0200
@@ -53,6 +53,8 @@
 
     inline void dumpCoords() const;
 
+    void toCompactData(double data[6]) const;
+
   private:
     
     bool isValid() const;
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/CellModel.cxx MEDCOUPLING_new/src/INTERP_KERNEL/CellModel.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/CellModel.cxx	2018-04-19 17:04:36.671221407 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/CellModel.cxx	2018-04-19 17:25:17.403790755 +0200
@@ -16,7 +16,7 @@
 //
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
-// Author : Anthony Geay (CEA/DEN)
+// Author : Anthony Geay (EDF R&D)
 
 #include "CellModel.hxx"
 
@@ -36,7 +36,7 @@
                                             "NORM_SEG4", "", "", "", "NORM_TETRA4",//10->14
                                             "NORM_PYRA5", "NORM_PENTA6", "", "NORM_HEXA8", "",//15->19
                                             "NORM_TETRA10", "", "NORM_HEXGP12", "NORM_PYRA13", "",//20->24
-                                            "NORM_PENTA15", "", "NORM_HEXA27", "", "",//25->29
+                                            "NORM_PENTA15", "", "NORM_HEXA27", "NORM_PENTA18", "",//25->29
                                             "NORM_HEXA20", "NORM_POLYHED", "NORM_QPOLYG", "NORM_POLYL", "",//30->34
                                             "", "", "", "", "",//35->39
                                             "NORM_ERROR"};
@@ -100,6 +100,7 @@
     _map_of_unique_instance.insert(std::make_pair(NORM_HEXGP12,CellModel(NORM_HEXGP12)));
     _map_of_unique_instance.insert(std::make_pair(NORM_PYRA13,CellModel(NORM_PYRA13)));
     _map_of_unique_instance.insert(std::make_pair(NORM_PENTA15,CellModel(NORM_PENTA15)));
+    _map_of_unique_instance.insert(std::make_pair(NORM_PENTA18,CellModel(NORM_PENTA18)));
     _map_of_unique_instance.insert(std::make_pair(NORM_HEXA20,CellModel(NORM_HEXA20)));
     _map_of_unique_instance.insert(std::make_pair(NORM_HEXA27,CellModel(NORM_HEXA27)));
     _map_of_unique_instance.insert(std::make_pair(NORM_POLYGON,CellModel(NORM_POLYGON)));
@@ -352,6 +353,26 @@
           _little_sons_con[0][0]=0; _little_sons_con[0][1]=1; _little_sons_con[0][2]=6;  _nb_of_little_sons=9;
           _little_sons_con[1][0]=1; _little_sons_con[1][1]=2; _little_sons_con[1][2]=7;
           _little_sons_con[2][0]=2; _little_sons_con[2][1]=0; _little_sons_con[2][2]=8;
+          _little_sons_con[3][0]=3; _little_sons_con[3][1]=4; _little_sons_con[3][2]=9;
+          _little_sons_con[4][0]=4; _little_sons_con[4][1]=5; _little_sons_con[4][2]=10;
+          _little_sons_con[5][0]=5; _little_sons_con[5][1]=3; _little_sons_con[5][2]=11;
+          _little_sons_con[6][0]=0; _little_sons_con[6][1]=3; _little_sons_con[6][2]=12;
+          _little_sons_con[7][0]=1; _little_sons_con[7][1]=4; _little_sons_con[7][2]=13;
+          _little_sons_con[8][0]=2; _little_sons_con[8][1]=5; _little_sons_con[8][2]=14;
+        }
+        break;
+      case NORM_PENTA18:
+        {
+          _nb_of_pts=18; _nb_of_sons=5; _dim=3; _linear_type=NORM_PENTA6; _is_simplex=false;
+          _sons_type[0]=NORM_TRI6; _sons_type[1]=NORM_TRI6; _sons_type[2]=NORM_QUAD9; _sons_type[3]=NORM_QUAD9; _sons_type[4]=NORM_QUAD9;
+          _sons_con[0][0]=0; _sons_con[0][1]=1; _sons_con[0][2]=2; _sons_con[0][3]=6; _sons_con[0][4]=7; _sons_con[0][5]=8; _nb_of_sons_con[0]=6;
+          _sons_con[1][0]=3; _sons_con[1][1]=5; _sons_con[1][2]=4; _sons_con[1][3]=11; _sons_con[1][4]=10; _sons_con[1][5]=9; _nb_of_sons_con[1]=6;
+          _sons_con[2][0]=0; _sons_con[2][1]=3; _sons_con[2][2]=4; _sons_con[2][3]=1; _sons_con[2][4]=12; _sons_con[2][5]=9; _sons_con[2][6]=13; _sons_con[2][7]=6; _sons_con[2][8]=15; _nb_of_sons_con[2]=9;
+          _sons_con[3][0]=1; _sons_con[3][1]=4; _sons_con[3][2]=5; _sons_con[3][3]=2; _sons_con[3][4]=13; _sons_con[3][5]=10; _sons_con[3][6]=14; _sons_con[3][7]=7; _sons_con[3][8]=16; _nb_of_sons_con[3]=9;
+          _sons_con[4][0]=2; _sons_con[4][1]=4; _sons_con[4][2]=5; _sons_con[4][3]=0; _sons_con[4][4]=14; _sons_con[4][5]=11; _sons_con[4][6]=12; _sons_con[4][7]=8; _sons_con[4][8]=17; _nb_of_sons_con[4]=9; _quadratic=true;
+          _little_sons_con[0][0]=0; _little_sons_con[0][1]=1; _little_sons_con[0][2]=6;  _nb_of_little_sons=9;
+          _little_sons_con[1][0]=1; _little_sons_con[1][1]=2; _little_sons_con[1][2]=7;
+          _little_sons_con[2][0]=2; _little_sons_con[2][1]=0; _little_sons_con[2][2]=8;
           _little_sons_con[3][0]=3; _little_sons_con[3][1]=4; _little_sons_con[3][2]=9;
           _little_sons_con[4][0]=4; _little_sons_con[4][1]=5; _little_sons_con[4][2]=10;
           _little_sons_con[5][0]=5; _little_sons_con[5][1]=3; _little_sons_con[5][2]=11;
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/CMakeLists.txt MEDCOUPLING_new/src/INTERP_KERNEL/CMakeLists.txt
--- MEDCOUPLING_old/src/INTERP_KERNEL/CMakeLists.txt	2018-04-19 17:04:36.670221387 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/CMakeLists.txt	2018-04-19 17:25:17.404790774 +0200
@@ -37,6 +37,7 @@
   Interpolation3D.cxx
   Interpolation2D3D.cxx
   Interpolation3D1D.cxx
+  Interpolation1D0D.cxx
   MeshElement.cxx
   InterpKernelMeshQuality.cxx
   InterpKernelCellSimplify.cxx
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/CurveIntersector.txx MEDCOUPLING_new/src/INTERP_KERNEL/CurveIntersector.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/CurveIntersector.txx	2018-04-19 17:04:36.671221407 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/CurveIntersector.txx	2018-04-19 17:25:17.483792336 +0200
@@ -104,7 +104,7 @@
   }
 
   /*!
-    Computes the bouding box of a given element. iP in numPol mode.
+    Computes the bounding box of a given element. iP in numPol mode.
   */
   template<class MyMeshType, class MyMatrix>
   void CurveIntersector<MyMeshType,MyMatrix>::getElemBB (double*           bb,
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/DirectedBoundingBox.cxx MEDCOUPLING_new/src/INTERP_KERNEL/DirectedBoundingBox.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/DirectedBoundingBox.cxx	2018-04-19 17:04:36.671221407 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/DirectedBoundingBox.cxx	2018-04-19 17:25:17.426791209 +0200
@@ -201,7 +201,7 @@
 
   //================================================================================
   /*!
-   * \brief Creates empty box intended to further initalization via setData()
+   * \brief Creates empty box intended to further initialization via setData()
    */
   //================================================================================
 
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/ExprEval/InterpKernelExprParser.cxx MEDCOUPLING_new/src/INTERP_KERNEL/ExprEval/InterpKernelExprParser.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/ExprEval/InterpKernelExprParser.cxx	2018-04-19 17:04:36.672221426 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/ExprEval/InterpKernelExprParser.cxx	2018-04-19 17:25:17.650795637 +0200
@@ -547,7 +547,7 @@
 }
 
 /*!
- * This method has the responsability to see if this->_expr can be seen as a unary function of something.
+ * This method has the responsibility to see if this->_expr can be seen as a unary function of something.
  * Something defined as the contain of highest level barckets.
  * Typically '(3*x+2)' and 'cos(4*l+p*n)' will be intercepted by this method whereas '3*x+2' not...etc..
  */
@@ -594,9 +594,9 @@
 }
 
 /*!
- *  This method has the responsability to see if this->_expr is interpretable without any recursion.
+ *  This method has the responsibility to see if this->_expr is interpretable without any recursion.
  * \return true if no recursion needed, false if this->_expr is too complex to be interpreted at this level.
- * \throw exception if this->_expr is simple enough to try to interprate this and this expression contains an error.
+ * \throw exception if this->_expr is simple enough to try to interpret this and this expression contains an error.
  */
 bool ExprParser::tryToInterpALeaf()
 {
@@ -917,7 +917,7 @@
           if(curLevel==0)
             {
               std::ostringstream errMsg;
-              char MSGTYP1[]="Error in brackets : closing brackets ')' before openning '('";
+              char MSGTYP1[]="Error in brackets : closing brackets ')' before opening '('";
               errMsg << EXPR_PARSE_ERR_MSG << MSGTYP1;
               LocateError(errMsg,_expr,(int)std::distance(_expr.begin(),iter));
               throw INTERP_KERNEL::Exception(errMsg.str().c_str());
@@ -941,7 +941,7 @@
  */
 double ExprParser::ReplaceAndTraduce(std::string& expr, int id, std::size_t bg, std::size_t end, int& delta)
 {
-  static const char MSG[]="Interal error : A string expected to be a float is not one ! Bug to signal !";
+  static const char MSG[]="Internal error : A string expected to be a float is not one ! Bug to signal !";
   std::istringstream stream;
   std::ostringstream oss;
   std::size_t end2=end!=std::string::npos?end-bg:end;
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/ExprEval/InterpKernelUnit.hxx MEDCOUPLING_new/src/INTERP_KERNEL/ExprEval/InterpKernelUnit.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/ExprEval/InterpKernelUnit.hxx	2018-04-19 17:04:36.672221426 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/ExprEval/InterpKernelUnit.hxx	2018-04-19 17:25:17.653795696 +0200
@@ -83,7 +83,7 @@
 
   /*!
    * This class deals with units.
-   * This class has two main responsabilities :
+   * This class has two main responsibilities :
    *      - interprete units by giving simply their representation in string type.
    *      - performing operations on these units.
    *
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/GaussPoints/CleanUpGauss.py MEDCOUPLING_new/src/INTERP_KERNEL/GaussPoints/CleanUpGauss.py
--- MEDCOUPLING_old/src/INTERP_KERNEL/GaussPoints/CleanUpGauss.py	2018-04-19 17:04:36.672221426 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/GaussPoints/CleanUpGauss.py	2018-04-19 17:25:17.481792296 +0200
@@ -18,7 +18,6 @@
 # Author : Anthony Geay (EDF R&D)
 
 import re
-import sys
 
 s1=2709
 s2=2848
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/GenMathFormulae.hxx MEDCOUPLING_new/src/INTERP_KERNEL/GenMathFormulae.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/GenMathFormulae.hxx	2018-04-19 17:04:36.673221446 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/GenMathFormulae.hxx	2018-04-19 17:25:17.407790834 +0200
@@ -28,7 +28,7 @@
 namespace INTERP_KERNEL
 {
   /*!
-   * This method computes eigenvalues of a 3x3 symetric matrix stored with 6 values in 'matrix'. The convension chosen for 'matrix' is described here:
+   * This method computes eigenvalues of a 3x3 symmetric matrix stored with 6 values in 'matrix'. The convension chosen for 'matrix' is described here:
    * matrix[0]=m_xx, matrix[1]=m_yy, matrix[2]=m_zz,
    * matrix[3]=m_xy, matrix[4]=m_yz, matrix[5]=m_xz
    * This method returns the 3 eigenvalues in 'eigenVals'.
@@ -55,7 +55,7 @@
   }
   
   /*!
-   * This method computes one eigenvector of a 3x3 symetric matrix stored with 6 values in 'matrix'. The convension chosen for 'matrix' is described here:
+   * This method computes one eigenvector of a 3x3 symmetric matrix stored with 6 values in 'matrix'. The convension chosen for 'matrix' is described here:
    * matrix[0]=m_xx, matrix[1]=m_yy, matrix[2]=m_zz,
    * matrix[3]=m_xy, matrix[4]=m_yz, matrix[5]=m_xz
    * This method returns the eigenvector of the corresponding eigenvalue in 'eigenVal'. The returned eigenValue is normalized.
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DBounds.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DBounds.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DBounds.cxx	2018-04-19 17:04:36.673221446 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DBounds.cxx	2018-04-19 17:25:17.625795143 +0200
@@ -148,15 +148,16 @@
 
 Bounds *Bounds::nearlyAmIIntersectingWith(const Bounds& other) const
 {
-  if( (other._x_min > _x_max+QUADRATIC_PLANAR::_precision) || (other._x_max < _x_min-QUADRATIC_PLANAR::_precision) || (other._y_min > _y_max+QUADRATIC_PLANAR::_precision) 
-      || (other._y_max < _y_min-QUADRATIC_PLANAR::_precision) )
+  double eps = QuadraticPlanarPrecision::getPrecision();
+  if( (other._x_min > _x_max+eps) || (other._x_max < _x_min-eps) || (other._y_min > _y_max+eps)
+      || (other._y_max < _y_min-eps) )
     return 0;
   if( (other._x_min >= _x_max ) || (other._x_max <= _x_min) || (other._y_min >= _y_max) || (other._y_max <= _y_min) )
     {
-      return new Bounds(std::max(_x_min-QUADRATIC_PLANAR::_precision,other._x_min),
-          std::min(_x_max+QUADRATIC_PLANAR::_precision,other._x_max),
-          std::max(_y_min-QUADRATIC_PLANAR::_precision,other._y_min),
-          std::min(_y_max+QUADRATIC_PLANAR::_precision,other._y_max));//In approx cases.
+      return new Bounds(std::max(_x_min-eps,other._x_min),
+          std::min(_x_max+eps,other._x_max),
+          std::max(_y_min-eps,other._y_min),
+          std::min(_y_max+eps,other._y_max));//In approx cases.
     }
   else
     return new Bounds(std::max(_x_min,other._x_min),std::min(_x_max,other._x_max),std::max(_y_min,other._y_min),std::min(_y_max,other._y_max));
@@ -183,7 +184,7 @@
   bool thinY=Node::areDoubleEquals(_y_min,_y_max);
   if(!thinX)
     {
-      if((Node::areDoubleEquals(x,_x_min) || Node::areDoubleEquals(x,_x_max)) && ((y<_y_max+QUADRATIC_PLANAR::_precision) && (y>_y_min-QUADRATIC_PLANAR::_precision)))
+      if((Node::areDoubleEquals(x,_x_min) || Node::areDoubleEquals(x,_x_max)) && ((y<_y_max+QuadraticPlanarPrecision::getPrecision()) && (y>_y_min-QuadraticPlanarPrecision::getPrecision())))
         return ON_BOUNDARY_POS;
     }
   else
@@ -191,7 +192,7 @@
       return OUT;
   if(!thinY)
     {
-      if((Node::areDoubleEquals(y,_y_min) || Node::areDoubleEquals(y,_y_max)) && ((x<_x_max+QUADRATIC_PLANAR::_precision) && (x>_x_min-QUADRATIC_PLANAR::_precision)))
+      if((Node::areDoubleEquals(y,_y_min) || Node::areDoubleEquals(y,_y_max)) && ((x<_x_max+QuadraticPlanarPrecision::getPrecision()) && (x>_x_min-QuadraticPlanarPrecision::getPrecision())))
         return ON_BOUNDARY_POS;
     }
   else
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DComposedEdge.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DComposedEdge.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DComposedEdge.cxx	2018-04-19 17:04:36.673221446 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DComposedEdge.cxx	2018-04-19 17:25:17.634795321 +0200
@@ -541,14 +541,14 @@
   std::set<Node *> nodes;
   getAllNodes(nodes);
   for(std::set<Node *>::const_iterator iter=nodes.begin();iter!=nodes.end();iter++)
-    if(sqrt((*iter)->distanceWithSq(*nodeToTest))<QUADRATIC_PLANAR::_precision)
+    if(sqrt((*iter)->distanceWithSq(*nodeToTest))<QuadraticPlanarPrecision::getPrecision())
       return true;
   double ref(isInOrOutAlg(nodeToTest,nodes,inOutSwitch));
   bool ret(false);
   for(std::set< IntersectElement >::iterator iter4=inOutSwitch.begin();iter4!=inOutSwitch.end();iter4++)
     {
       double val((*iter4).getVal1());
-      if(fabs(val-ref)>=QUADRATIC_PLANAR::_precision)
+      if(fabs(val-ref)>=QuadraticPlanarPrecision::getPrecision())
         {
           if(val<ref)
             {
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeArcCircle.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeArcCircle.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeArcCircle.cxx	2018-04-19 17:04:36.673221446 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeArcCircle.cxx	2018-04-19 17:25:17.619795024 +0200
@@ -131,7 +131,7 @@
       a2.getCenter(centerL); radiusL=a2.getRadius();
       a1.getCenter(centerB); radiusB=a1.getRadius();
     }
-  // dividing from the begining by radiusB^2 to keep precision
+  // dividing from the beginning by radiusB^2 to keep precision
   distBetweenCenters=Node::distanceBtw2PtSq(centerL,centerB);
   cst=distBetweenCenters/(radiusB*radiusB);
   cst+=radiusL*radiusL/(radiusB*radiusB);
@@ -174,7 +174,7 @@
 {
   _dist=Node::distanceBtw2Pt(getE1().getCenter(),getE2().getCenter());
   double radius1=getE1().getRadius(); double radius2=getE2().getRadius();
-  if(_dist>radius1+radius2+QUADRATIC_PLANAR::_precision || _dist+std::min(radius1,radius2)+QUADRATIC_PLANAR::_precision<std::max(radius1,radius2))
+  if(_dist>radius1+radius2+QuadraticPlanarPrecision::getPrecision() || _dist+std::min(radius1,radius2)+QuadraticPlanarPrecision::getPrecision()<std::max(radius1,radius2))
     {
       obviousNoIntersection=true;
       areOverlapped=false;
@@ -328,7 +328,7 @@
       ((*(_e2.getStartNode()))[0]-center[0])*((*(_e2.getEndNode()))[1]-center[1])-
       ((*(_e2.getStartNode()))[1]-center[1])*((*(_e2.getEndNode()))[0]-center[0]);
   _determinant=getE1().getRadius()*getE1().getRadius()/_drSq-_cross*_cross/(_drSq*_drSq);
-  if(_determinant>-2*QUADRATIC_PLANAR::_precision)//QUADRATIC_PLANAR::_precision*QUADRATIC_PLANAR::_precision*_drSq*_drSq/(2.*_dx*_dx))
+  if(_determinant>-2*QuadraticPlanarPrecision::getPrecision())//QuadraticPlanarPrecision::getPrecision()*QuadraticPlanarPrecision::getPrecision()*_drSq*_drSq/(2.*_dx*_dx))
     obviousNoIntersection=false;
   else
     obviousNoIntersection=true;   
@@ -351,7 +351,7 @@
 {
   std::list< IntersectElement > ret;
   const double *center=getE1().getCenter();
-  if(!(fabs(_determinant)<(2.*QUADRATIC_PLANAR::_precision)))//QUADRATIC_PLANAR::_precision*QUADRATIC_PLANAR::_precision*_drSq*_drSq/(2.*_dx*_dx))
+  if(!(fabs(_determinant)<(2.*QuadraticPlanarPrecision::getPrecision())))//QuadraticPlanarPrecision::getPrecision()*QuadraticPlanarPrecision::getPrecision()*_drSq*_drSq/(2.*_dx*_dx))
     {
       double determinant=EdgeArcCircle::SafeSqrt(_determinant);
       double x1=(_cross*_dy/_drSq+Node::sign(_dy)*_dx*determinant)+center[0];
@@ -466,7 +466,7 @@
 /*!
  * 'eps' is expected to be > 0.
  * 'conn' is of size 3. conn[0] is start id, conn[1] is end id and conn[2] is middle id.
- * 'offset' is typically the number of nodes already existing in global 2D curve mesh. Additionnal coords 'addCoo' ids will be put after the already existing.
+ * 'offset' is typically the number of nodes already existing in global 2D curve mesh. Additional coords 'addCoo' ids will be put after the already existing.
  */
 void EdgeArcCircle::tesselate(const int *conn, int offset, double eps, std::vector<int>& newConn, std::vector<double>& addCoo) const
 {
@@ -644,9 +644,9 @@
   //
   double myDelta1(angle1-_angle0),myDelta2(angle2-_angle0);
   if(_angle>0.)
-    { myDelta1=myDelta1>-QUADRATIC_PLANAR::_precision?myDelta1:myDelta1+2.*M_PI; myDelta2=myDelta2>-QUADRATIC_PLANAR::_precision?myDelta2:myDelta2+2.*M_PI; }
+    { myDelta1=myDelta1>-QuadraticPlanarPrecision::getPrecision()?myDelta1:myDelta1+2.*M_PI; myDelta2=myDelta2>-QuadraticPlanarPrecision::getPrecision()?myDelta2:myDelta2+2.*M_PI; }
   else
-    { myDelta1=myDelta1<QUADRATIC_PLANAR::_precision?myDelta1:myDelta1-2.*M_PI; myDelta2=myDelta2<QUADRATIC_PLANAR::_precision?myDelta2:myDelta2-2.*M_PI; }
+    { myDelta1=myDelta1<QuadraticPlanarPrecision::getPrecision()?myDelta1:myDelta1-2.*M_PI; myDelta2=myDelta2<QuadraticPlanarPrecision::getPrecision()?myDelta2:myDelta2-2.*M_PI; }
   ////
   mid[0]=_center[0]+_radius*cos(_angle0+(myDelta1+myDelta2)/2.);
   mid[1]=_center[1]+_radius*sin(_angle0+(myDelta1+myDelta2)/2.);
@@ -703,14 +703,14 @@
   double myDelta2=val2-_angle0;
   if(_angle>0.)
     {
-      myDelta1=myDelta1>-(_radius*QUADRATIC_PLANAR::_precision)?myDelta1:myDelta1+2.*M_PI;//in some cases val1 or val2 are so close to angle0 that myDelta is close to 0. but negative.
-      myDelta2=myDelta2>-(_radius*QUADRATIC_PLANAR::_precision)?myDelta2:myDelta2+2.*M_PI;
+      myDelta1=myDelta1>-(_radius*QuadraticPlanarPrecision::getPrecision())?myDelta1:myDelta1+2.*M_PI;//in some cases val1 or val2 are so close to angle0 that myDelta is close to 0. but negative.
+      myDelta2=myDelta2>-(_radius*QuadraticPlanarPrecision::getPrecision())?myDelta2:myDelta2+2.*M_PI;
       return myDelta1<myDelta2;
     }
   else
     {
-      myDelta1=myDelta1<(_radius*QUADRATIC_PLANAR::_precision)?myDelta1:myDelta1-2.*M_PI;
-      myDelta2=myDelta2<(_radius*QUADRATIC_PLANAR::_precision)?myDelta2:myDelta2-2.*M_PI;
+      myDelta1=myDelta1<(_radius*QuadraticPlanarPrecision::getPrecision())?myDelta1:myDelta1-2.*M_PI;
+      myDelta2=myDelta2<(_radius*QuadraticPlanarPrecision::getPrecision())?myDelta2:myDelta2-2.*M_PI;
       return myDelta2<myDelta1;
     }
 }
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.cxx	2018-04-19 17:04:36.673221446 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.cxx	2018-04-19 17:25:17.627795182 +0200
@@ -288,7 +288,7 @@
 }
 
 /*!
- * This methode is const because 'node' is supposed to be equal geomitrically to _node.
+ * This method is const because 'node' is supposed to be equal geometrically to _node.
  */
 void IntersectElement::setNode(Node *node) const
 {
@@ -746,7 +746,7 @@
   if(intersector->intersect(whereToFind,newNodes,order,commonNode))
     {
       if(newNodes.empty())
-        throw Exception("Internal error occured - error in intersector implementation!");// This case should never happen
+        throw Exception("Internal error occurred - error in intersector implementation!");// This case should never happen
       std::vector<Node *>::iterator iter=newNodes.begin();
       std::vector<Node *>::reverse_iterator iterR=newNodes.rbegin();
       f1->addSubEdgeInVector(f1->getStartNode(),*iter,outValForF1);
@@ -930,7 +930,7 @@
 
 inline bool eqpair(const std::pair<double,Node *>& p1, const std::pair<double,Node *>& p2)
 {
-  return fabs(p1.first-p2.first)<QUADRATIC_PLANAR::_precision;
+  return fabs(p1.first-p2.first)<QuadraticPlanarPrecision::getPrecision();
 }
 
 /**
@@ -1005,12 +1005,12 @@
   for(std::vector< std::pair<double,Node *> >::const_iterator it=an2.begin();it!=itend;it++)
     {
       int idd=(*mapp2.find((*it).second)).second;
-      if((*it).first<QUADRATIC_PLANAR::_precision)
+      if((*it).first<QuadraticPlanarPrecision::getPrecision())
         {
           startId=idd;
           continue;
         }
-      if((*it).first>1-QUADRATIC_PLANAR::_precision)
+      if((*it).first>1-QuadraticPlanarPrecision::getPrecision())
         {
           endId=idd;
           continue;
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.hxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.hxx	2018-04-19 17:04:36.673221446 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdge.hxx	2018-04-19 17:25:17.616794965 +0200
@@ -146,7 +146,7 @@
   class INTERPKERNEL_EXPORT EdgeIntersector
   {
   protected:
-    //! All non symetric methods are relative to 'e1'.
+    //! All non symmetric methods are relative to 'e1'.
     EdgeIntersector(const Edge& e1, const Edge& e2):_e1(e1),_e2(e2) { }
   public:
     virtual ~EdgeIntersector() { }
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeLin.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeLin.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeLin.cxx	2018-04-19 17:04:36.674221466 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DEdgeLin.cxx	2018-04-19 17:25:17.609794826 +0200
@@ -108,20 +108,20 @@
 bool SegSegIntersector::areColinears() const
 {
   double determinant=_matrix[0]*_matrix[3]-_matrix[1]*_matrix[2];
-  return fabs(determinant)<QUADRATIC_PLANAR::_arc_detection_precision;
+  return fabs(determinant)<QuadraticPlanarArcDetectionPrecision::getArcDetectionPrecision();
 }
 
 /*!
  * Should be called \b once ! non const method.
  * \param whereToFind specifies the box where final seek should be done. Essentially it is used for caracteristic reason.
- * \param colinearity returns if regarding QUADRATIC_PLANAR::_precision ; e1 and e2 are colinears
+ * \param colinearity returns if regarding QuadraticPlanarPrecision::getPrecision() ; e1 and e2 are colinears
  *                    If true 'this' is modified ! So this method be called once above all if true is returned for this parameter.
  * \param areOverlapped if colinearity if true, this parameter looks if e1 and e2 are overlapped.
  */
 void SegSegIntersector::areOverlappedOrOnlyColinears(const Bounds *whereToFind, bool& colinearity, bool& areOverlapped)
 {
   double determinant=_matrix[0]*_matrix[3]-_matrix[1]*_matrix[2];
-  if(fabs(determinant)>2.*QUADRATIC_PLANAR::_precision)//2*_precision due to max of offset on _start and _end
+  if(fabs(determinant)>2.*QuadraticPlanarPrecision::getPrecision())//2*_precision due to max of offset on _start and _end
     {
       colinearity=false; areOverlapped=false;
       _matrix[0]/=determinant; _matrix[1]/=determinant; _matrix[2]/=determinant; _matrix[3]/=determinant;
@@ -136,7 +136,7 @@
       double deno=sqrt(_matrix[0]*_matrix[0]+_matrix[1]*_matrix[1]);
       double x=(*(_e1.getStartNode()))[0]-(*(_e2.getStartNode()))[0];
       double y=(*(_e1.getStartNode()))[1]-(*(_e2.getStartNode()))[1];
-      areOverlapped=fabs((_matrix[1]*y+_matrix[0]*x)/deno)<QUADRATIC_PLANAR::_precision;
+      areOverlapped=fabs((_matrix[1]*y+_matrix[0]*x)/deno)<QuadraticPlanarPrecision::getPrecision();
     }
 }
 
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DNode.hxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DNode.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DNode.hxx	2018-04-19 17:04:36.674221466 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DNode.hxx	2018-04-19 17:25:17.631795261 +0200
@@ -88,9 +88,9 @@
     static double dot(const double *vect1, const double *vect2) { return vect1[0]*vect2[0]+vect1[1]*vect2[1]; }
     static double sign(double val) { if(val>=0) return 1.; else return -1.; }
     static double norm(const double *vect) { return sqrt(vect[0]*vect[0]+vect[1]*vect[1]); }
-    static bool areDoubleEquals(double a, double b) { return fabs(a-b) < QUADRATIC_PLANAR::_precision; }
+    static bool areDoubleEquals(double a, double b) { return fabs(a-b) < QuadraticPlanarPrecision::getPrecision(); }
     //! idem areDoubleEquals except that precision of comparison is modified.
-    static bool areDoubleEqualsWP(double a, double b, double k) { return fabs(a-b) < k*QUADRATIC_PLANAR::_precision; }
+    static bool areDoubleEqualsWP(double a, double b, double k) { return fabs(a-b) < k*QuadraticPlanarPrecision::getPrecision(); }
     static double distanceBtw2Pt(const double *a, const double *b) { return sqrt((a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1])); }
     static double distanceBtw2PtSq(const double *a, const double *b) { return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]); }
     //
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.cxx	2018-04-19 17:04:36.674221466 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.cxx	2018-04-19 17:25:17.621795064 +0200
@@ -20,16 +20,38 @@
 
 #include "InterpKernelGeo2DPrecision.hxx"
 
-double INTERP_KERNEL::QUADRATIC_PLANAR::_precision=1e-14;
+double INTERP_KERNEL::QuadraticPlanarPrecision::_precision=1e-14;
+double INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::_arc_detection_precision=1e-14;
+
+INTERP_KERNEL::QuadraticPlanarPrecision::QuadraticPlanarPrecision(double precision):
+    _initial_precision(_precision)
+{
+  _precision=precision;
+}
+
+INTERP_KERNEL::QuadraticPlanarPrecision::~QuadraticPlanarPrecision()
+{
+  _precision = _initial_precision;
+}
+
+INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::QuadraticPlanarArcDetectionPrecision(double precision):
+    _initial_arc_detection_precision(_arc_detection_precision)
+{
+  _arc_detection_precision=precision;
+}
+
+INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::~QuadraticPlanarArcDetectionPrecision()
+{
+  _arc_detection_precision = _initial_arc_detection_precision;
+}
 
-double INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=1e-14;
 
-void INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(double precision)
+void INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(double precision)
 { 
-  INTERP_KERNEL::QUADRATIC_PLANAR::_precision=precision;
+  _precision=precision;
 }
 
-void INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(double precision)
+void INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(double precision)
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=precision;
+  _arc_detection_precision=precision;
 }
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.hxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.hxx	2018-04-19 17:04:36.674221466 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DPrecision.hxx	2018-04-19 17:25:17.623795103 +0200
@@ -25,14 +25,50 @@
 
 namespace INTERP_KERNEL
 {
-  class INTERPKERNEL_EXPORT QUADRATIC_PLANAR
+  /* !!TODO: a more global review of the code should be done, so that eps is always a parameter of all methods
+     instead of being stored as a static attribute.
+  */
+
+  /** Class storing the precision for the detection of colinear segments, coincident points, etc ...
+   * in Geometric2D computations.
+   *
+   * RAII pattern allowing to temporarily override Geometric2D precision.
+   * When the instance is destroyed, the previous precision is set back.
+   *
+   */
+  class QuadraticPlanarPrecision
   {
   public:
-    static double _precision;
-    static double _arc_detection_precision;
+    QuadraticPlanarPrecision(double prec);
+    virtual ~QuadraticPlanarPrecision();
+
     static void setPrecision(double precision);
+    inline static double getPrecision() { return _precision; }
+  private:
+    static double _precision;
+    double _initial_precision;
+  };
+
+  /** Class storing the precision for the detection of degenerated arc of circles
+   * in Geometric2D computations.
+   *
+   * RAII pattern allowing to temporarily override Geometric2D precision.
+   * When the instance is destroyed, the previous precision is set back.
+   */
+  class QuadraticPlanarArcDetectionPrecision
+  {
+  public:
+    QuadraticPlanarArcDetectionPrecision(double prec);
+    virtual ~QuadraticPlanarArcDetectionPrecision();
+
     static void setArcDetectionPrecision(double precision);
+    inline static double getArcDetectionPrecision() { return _arc_detection_precision; }
+  private:
+    static double _arc_detection_precision;
+    double _initial_arc_detection_precision;
+
   };
 }
 
 #endif
+
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DQuadraticPolygon.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DQuadraticPolygon.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DQuadraticPolygon.cxx	2018-04-19 17:04:36.674221466 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2D/InterpKernelGeo2DQuadraticPolygon.cxx	2018-04-19 17:25:17.628795202 +0200
@@ -267,11 +267,11 @@
 }
 
 /*!
- * This method splits 'this' with 'other' into smaller pieces localizable. 'mapThis' is a map that gives the correspondance
+ * This method splits 'this' with 'other' into smaller pieces localizable. 'mapThis' is a map that gives the correspondence
  * between nodes contained in 'this' and node ids in a global mesh.
- * In the same way, 'mapOther' gives the correspondance between nodes contained in 'other' and node ids in a
- * global mesh from wich 'other' is extracted.
- * This method has 1 out paramater : 'edgesThis', After the call of this method, it contains the nodal connectivity (including type)
+ * In the same way, 'mapOther' gives the correspondence between nodes contained in 'other' and node ids in a
+ * global mesh from which 'other' is extracted.
+ * This method has 1 out parameter : 'edgesThis', After the call of this method, it contains the nodal connectivity (including type)
  * of 'this' into globlal "this mesh".
  * This method has 2 in/out parameters : 'subDivOther' and 'addCoo'.'otherEdgeIds' is useful to put values in
  * 'edgesThis', 'subDivOther' and 'addCoo'.
@@ -1090,7 +1090,7 @@
     }
   if(!found)
     throw Exception("Internal error: polygons incompatible with each others. Should never happen!");
-  //Ok we found correspondance between this and pol1. Searching for right direction to close polygon.
+  //Ok we found correspondence between this and pol1. Searching for right direction to close polygon.
   ElementaryEdge *e=_sub_edges.back();
   if(e->getLoc()==FULL_ON_1)
     {
@@ -1140,7 +1140,7 @@
   if(!direction)
     it.previousLoop();
   Node *nodeToTest;
-  int szMax(pol1Splitted.size()+1),ii(0);// here a protection against agressive users of IntersectMeshes of invalid input meshes
+  int szMax(pol1Splitted.size()+1),ii(0);// here a protection against aggressive users of IntersectMeshes of invalid input meshes
   std::list<QuadraticPolygon *>::iterator ret;
   do
     {
@@ -1157,7 +1157,7 @@
       ii++;
     }
   while(ret==iEnd && ii<szMax);
-  if(ii==szMax)// here a protection against agressive users of IntersectMeshes of invalid input meshes
+  if(ii==szMax)// here a protection against aggressive users of IntersectMeshes of invalid input meshes
     throw INTERP_KERNEL::Exception("QuadraticPolygon::fillAsMuchAsPossibleWith : Something is invalid with input polygons !");
   return ret;
 }
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2DIntersector.hxx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2DIntersector.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2DIntersector.hxx	2018-04-19 17:04:36.674221466 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2DIntersector.hxx	2018-04-19 17:25:17.415790992 +0200
@@ -54,6 +54,8 @@
     QuadraticPolygon *buildPolygonOfOneEdgeFrom(const std::vector<double>& coords, NormalizedCellType type);
     QuadraticPolygon *buildPolygonAFrom(ConnType cell, int nbOfPoints, NormalizedCellType type);
     QuadraticPolygon *buildPolygonBFrom(ConnType cell, int nbOfPoints, NormalizedCellType type);
+
+    QuadraticPlanarPrecision _precision;
   };
 }
 
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2DIntersector.txx MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2DIntersector.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Geometric2DIntersector.txx	2018-04-19 17:04:36.674221466 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Geometric2DIntersector.txx	2018-04-19 17:25:17.398790656 +0200
@@ -44,9 +44,9 @@
   GEO2D_INTERSECTOR::Geometric2DIntersector(const MyMeshType& meshT, const MyMeshType& meshS,
                                             double dimCaracteristic, double md3DSurf, double minDot3DSurf, double medianPlane,
                                             double precision, int orientation):
-    InterpType<MyMeshType,MyMatrix,GEO2D_INTERSECTOR >(meshT,meshS,dimCaracteristic, precision, md3DSurf, minDot3DSurf, medianPlane, true, orientation, 0)
+    InterpType<MyMeshType,MyMatrix,GEO2D_INTERSECTOR >(meshT,meshS,dimCaracteristic, precision, md3DSurf, minDot3DSurf, medianPlane, true, orientation, 0),
+    _precision(precision)
   {
-    QUADRATIC_PLANAR::_precision=precision;
   }
   
   INTERSECTOR_TEMPLATE
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation1D0D.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation1D0D.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation1D0D.cxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation1D0D.cxx	2018-04-19 17:25:17.662795874 +0200
@@ -0,0 +1,57 @@
+// Copyright (C) 2018  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony GEAY (EDF R&D)
+
+#include "Interpolation1D0D.hxx"
+#include "Interpolation1D0D.txx"
+
+namespace INTERP_KERNEL
+{
+  /**
+   * \class Interpolation1D0D
+   * \brief Class used to calculate the interpolation between a 1D mesh and 0D mesh (in 3D space)
+   * Can be seen as a specialization of Interpolation3D, and allows notably the adjustment of bounind boxes.
+   * 
+   */
+
+  Interpolation1D0D::Interpolation1D0D()
+  {}
+
+  Interpolation1D0D::Interpolation1D0D(const InterpolationOptions& io):Interpolation<Interpolation1D0D>(io)
+  {}
+
+  /**
+   * Inspired from PlanarIntersector<MyMeshType,MyMatrix>::adjustBoundingBoxes
+   */
+  void Interpolation1D0D::adjustBoundingBoxes(std::vector<double>& bbox)
+  {
+    const int SPACE_DIM = 3;
+    const double adj(getPrecision());// here precision is used instead of getBoundingBoxAdjustment and getBoundingBoxAdjustmentAbs because in the context only precision is relevant
+
+    long size = bbox.size()/(2*SPACE_DIM);
+    for (int i=0; i<size; i++)
+      {
+        for(int idim=0; idim<SPACE_DIM; idim++)
+          {
+            bbox[i*2*SPACE_DIM+2*idim  ] -= adj;
+            bbox[i*2*SPACE_DIM+2*idim+1] += adj;
+          }
+      }
+  }
+}
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation1D0D.hxx MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation1D0D.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation1D0D.hxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation1D0D.hxx	2018-04-19 17:25:17.637795380 +0200
@@ -0,0 +1,45 @@
+// Copyright (C) 2018  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : A Geay (EDF R&D)
+
+#ifndef __INTERPOLATION1D0D_HXX__
+#define __INTERPOLATION1D0D_HXX__
+
+#include "INTERPKERNELDefines.hxx"
+#include "Interpolation.hxx"
+#include "NormalizedUnstructuredMesh.hxx"
+#include "InterpolationOptions.hxx"
+
+#include <vector>
+
+namespace INTERP_KERNEL
+{
+  class INTERPKERNEL_EXPORT Interpolation1D0D : public Interpolation<Interpolation1D0D>
+  {
+  public:
+    Interpolation1D0D();
+    Interpolation1D0D(const InterpolationOptions& io);
+    template<class MyMeshType, class MatrixType>
+    int interpolateMeshes(const MyMeshType& srcMesh, const MyMeshType& targetMesh, MatrixType& result, const std::string& method);
+  private:
+    void adjustBoundingBoxes(std::vector<double>& bbox);
+  };
+}
+
+#endif
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation1D0D.txx MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation1D0D.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation1D0D.txx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation1D0D.txx	2018-04-19 17:25:17.423791150 +0200
@@ -0,0 +1,123 @@
+// Copyright (C) 2018  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#ifndef __INTERPOLATION1D0D_TXX__
+#define __INTERPOLATION1D0D_TXX__
+
+#include "Interpolation1D0D.hxx"
+#include "Interpolation.txx"
+#include "MeshElement.txx"
+#include "PointLocator3DIntersectorP0P0.txx"
+#include "PointLocator3DIntersectorP0P1.txx"
+#include "PointLocator3DIntersectorP1P0.txx"
+#include "PointLocator3DIntersectorP1P1.txx"
+#include "Log.hxx"
+
+#include "BBTree.txx"
+
+#include "InterpKernelAssert.hxx"
+
+namespace INTERP_KERNEL
+{
+  /**
+   *  Very similar to Interpolation3D::interpolateMeshes, except for the bounding boxes that can be
+   *  adjusted in a similar fashion as in InterpolationPlanar::performAdjustmentOfBB()
+   **/
+  template<class MyMeshType, class MatrixType>
+  int Interpolation1D0D::interpolateMeshes(const MyMeshType& srcMesh, const MyMeshType& targetMesh, MatrixType& result, const std::string& method)
+  {
+#if __cplusplus >= 201103L
+    constexpr int SPACEDIM=MyMeshType::MY_SPACEDIM;
+    using ConnType=typename MyMeshType::MyConnType;
+    IKAssert(SPACEDIM==3);
+
+    if(InterpolationOptions::getIntersectionType() != PointLocator)
+      INTERP_KERNEL::Exception("Invalid 1D/0D intersection type specified : must be PointLocator.");
+
+    std::string methC ( InterpolationOptions::filterInterpolationMethod(method) );
+    if(methC!="P1P1")
+      throw Exception("Invalid method chosen must be in \"P1P1\".");
+
+    const double epsilon(getPrecision());
+    // create MeshElement objects corresponding to each element of the two meshes
+    const unsigned long numSrcElems(srcMesh.getNumberOfElements()), numTargetElems(targetMesh.getNumberOfElements());
+
+    LOG(2, "Source mesh has " << numSrcElems << " elements and target mesh has " << numTargetElems << " elements ");
+
+    std::vector<MeshElement<ConnType>*> srcElems(numSrcElems);
+
+    std::map<MeshElement<ConnType>*, int> indices;
+
+    for(unsigned long i = 0 ; i < numSrcElems ; ++i)
+      srcElems[i] = new MeshElement<ConnType>(i, srcMesh);       
+
+    // create empty maps for all source elements
+    result.resize(targetMesh.getNumberOfNodes());
+
+    // create BBTree structure
+    // - get bounding boxes
+    std::vector<double> bboxes(2*SPACEDIM*numSrcElems);
+    int* srcElemIdx = new int[numSrcElems];
+    for(unsigned long i = 0; i < numSrcElems ; ++i)
+      {
+        // get source bboxes in right order
+        srcElems[i]->getBoundingBox()->toCompactData(bboxes.data()+6*i);
+        srcElemIdx[i] = srcElems[i]->getIndex();
+      }
+
+    adjustBoundingBoxes(bboxes);
+    const double *bboxPtr(nullptr);
+    if(numSrcElems>0)
+      bboxPtr=&bboxes[0];
+    BBTree<SPACEDIM,ConnType> tree(bboxPtr, srcElemIdx, 0, numSrcElems);
+    const ConnType *trgConnPtr(targetMesh.getConnectivityPtr()),*trgConnIPtr(targetMesh.getConnectivityIndexPtr());
+    const ConnType *srcConnPtr(srcMesh.getConnectivityPtr()),*srcConnIPtr(srcMesh.getConnectivityIndexPtr());
+    const double *trgCooPtr(targetMesh.getCoordinatesPtr()),*srcCooPtr(srcMesh.getCoordinatesPtr());
+    for(unsigned long i = 0; i < numTargetElems; ++i)
+      {
+        IKAssert(trgConnIPtr[i+1]==i+1 && trgConnIPtr[i]==i);
+        std::vector<ConnType> srcSegCondidates;
+        const double *trgCellPosition(trgCooPtr+SPACEDIM*trgConnPtr[i]);
+        typename MatrixType::value_type& resRow(result[trgConnPtr[i]]);
+        tree.getElementsAroundPoint(trgCellPosition, srcSegCondidates);
+        for(auto srcSeg: srcSegCondidates)
+          {
+            IKAssertMsg(srcConnIPtr[srcSeg+1]==2*(srcSeg+1) && srcConnIPtr[srcSeg]==2*srcSeg,"Only implemented for linear 1D source");
+            double bc0(0.),bc1(0.);
+            ConnType srcNode0(srcConnPtr[2*srcSeg]),srcNode1(srcConnPtr[2*srcSeg+1]);
+            if(IsPointOn3DSeg(srcCooPtr+SPACEDIM*srcNode0,srcCooPtr+SPACEDIM*srcNode1,trgCellPosition,epsilon,bc0,bc1))
+              {
+                resRow.insert(std::make_pair(srcNode0,bc0));
+                resRow.insert(std::make_pair(srcNode1,bc1));
+                continue;
+              }
+          }
+      }
+    delete [] srcElemIdx;
+    for(unsigned long i = 0 ; i < numSrcElems ; ++i)
+      delete srcElems[i];
+    return srcMesh.getNumberOfNodes();
+  }
+#else
+  throw INTERP_KERNEL::Exception("Go buying a C++11 compiler :)");
+#endif
+}
+
+#endif
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation2D1D.txx MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation2D1D.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation2D1D.txx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation2D1D.txx	2018-04-19 17:25:17.485792376 +0200
@@ -94,7 +94,7 @@
 
     /****************************************************************/
     /* Create a search tree based on the bounding boxes             */
-    /* Instanciate the intersector and initialise the result vector */
+    /* Instantiate the intersector and initialise the result vector */
     /****************************************************************/
 
     long start_filtering=clock();
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation2DCurve.hxx MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation2DCurve.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation2DCurve.hxx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation2DCurve.hxx	2018-04-19 17:25:17.521793087 +0200
@@ -31,7 +31,7 @@
   public:
     Interpolation2DCurve();
     Interpolation2DCurve(const InterpolationOptions& io);
-    // geometric precision, intersection tolerance, coice of the median line,
+    // geometric precision, intersection tolerance, choice of the median line,
     void setOptions(double precision, double tolerance, double medianLine);
   };
 }
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation3DSurf.cxx MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation3DSurf.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/Interpolation3DSurf.cxx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/Interpolation3DSurf.cxx	2018-04-19 17:25:17.640795439 +0200
@@ -42,13 +42,13 @@
      - Values: between 0 and 1.
      - Default: 0.5.
      -# doRotat: rotate the coordinate system such that the target cell is in the Oxy plane.
-     - Values: true (necessarilly if Intersection_type=Triangle), false.
+     - Values: true (necessarily if Intersection_type=Triangle), false.
      - Default: true (as default Intersection_type=Triangle)
      -# precision: Level of precision of the computations is precision times the characteristic size of the mesh.
      - Values: positive real number.
      - Default: 1.0E-12.
      -# printLevel: Level of verboseness during the computations.
-     - Values: interger between 0 and 3.
+     - Values: integer between 0 and 3.
      - Default: 0.
   */
   void Interpolation3DSurf::setOptions(double precision, int printLevel, double medianPlan, 
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationCurve.txx MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationCurve.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationCurve.txx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationCurve.txx	2018-04-19 17:25:17.384790379 +0200
@@ -168,7 +168,7 @@
       throw INTERP_KERNEL::Exception("Invalid method specified ! Must be in : \"P0P0\" \"P0P1\" \"P1P0\" or \"P1P1\"");
     /****************************************************************/
     /* Create a search tree based on the bounding boxes             */
-    /* Instanciate the intersector and initialise the result vector */
+    /* Instantiate the intersector and initialise the result vector */
     /****************************************************************/
  
     long start_filtering=clock();
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationOptions.cxx MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationOptions.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationOptions.cxx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationOptions.cxx	2018-04-19 17:25:17.660795835 +0200
@@ -96,12 +96,12 @@
 
 double INTERP_KERNEL::InterpolationOptions::getArcDetectionPrecision() const
 {
-  return INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision;
+  return INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::getArcDetectionPrecision();
 }
 
 void INTERP_KERNEL::InterpolationOptions::setArcDetectionPrecision(double p)
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=p;
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(p);
 }
 
 std::string INTERP_KERNEL::InterpolationOptions::getIntersectionTypeRepr() const
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationPlanar.hxx MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationPlanar.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationPlanar.hxx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationPlanar.hxx	2018-04-19 17:25:17.387790438 +0200
@@ -37,7 +37,7 @@
     InterpolationPlanar();
     InterpolationPlanar(const InterpolationOptions & io);
 
-    // geometric precision, debug print level, coice of the median plane, intersection etc ...
+    // geometric precision, debug print level, choice of the median plane, intersection etc ...
     void setOptions(double precision, int printLevel,
                     IntersectionType intersectionType, int orientation=0);
     
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationPlanar.txx MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationPlanar.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationPlanar.txx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationPlanar.txx	2018-04-19 17:25:17.370790102 +0200
@@ -79,7 +79,7 @@
    *   - Values: positive real number.
    *   - Default: 1.0E-12.
    *  -# PrintLevel: Level of verboseness during the computations.
-   *   - Values: interger between 0 and 3.
+   *   - Values: integer between 0 and 3.
    *   - Default: 0.
    */
   template<class RealPlanar>
@@ -376,7 +376,7 @@
       throw INTERP_KERNEL::Exception("Invalid method specified or intersection type ! Must be in : \"P0P0\" \"P0P1\" \"P1P0\" or \"P1P1\"");
     /****************************************************************/
     /* Create a search tree based on the bounding boxes             */
-    /* Instanciate the intersector and initialise the result vector */
+    /* Instantiate the intersector and initialise the result vector */
     /****************************************************************/
  
     long start_filtering=clock();
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationUtils.hxx MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationUtils.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/InterpolationUtils.hxx	2018-04-19 17:04:36.676221506 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/InterpolationUtils.hxx	2018-04-19 17:25:17.449791664 +0200
@@ -68,7 +68,7 @@
   /*   calcul la surface d'un triangle                  */
   /*_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ */
 
-  inline double Surf_Tri(const double* P_1,const double* P_2,const double* P_3)
+  inline double Surf_Tri(const double *P_1,const double *P_2,const double *P_3)
   {
     double A=(P_3[1]-P_1[1])*(P_2[0]-P_1[0])-(P_2[1]-P_1[1])*(P_3[0]-P_1[0]);
     double Surface = 0.5*fabs(A);
@@ -83,9 +83,9 @@
   //fonction qui calcul le determinant des vecteurs: P3P1 et P3P2
   //(cf doc CGAL).
 
-  inline double mon_determinant(const double* P_1,
-                                const double*  P_2,
-                                const double* P_3)
+  inline double mon_determinant(const double *P_1,
+                                const double *P_2,
+                                const double *P_3)
   {
     double mon_det=(P_1[0]-P_3[0])*(P_2[1]-P_3[1])-(P_2[0]-P_3[0])*(P_1[1]-P_3[1]);
     return mon_det;
@@ -98,8 +98,7 @@
   {
     double X=P_1[0]-P_2[0];
     double Y=P_1[1]-P_2[1];
-    double norme=sqrt(X*X+Y*Y);
-    return norme;
+    return sqrt(X*X+Y*Y);
   }
 
   /*_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ */
@@ -537,6 +536,29 @@
   }
 
   /*!
+   * Compute barycentric coords of point \a point relative to segment S [segStart,segStop] in 3D space.
+   * If point \a point is further from S than eps false is returned.
+   * If point \a point projection on S is outside S false is also returned.
+   * If point \a point is closer from S than eps and its projection inside S true is returned and \a bc0 and \a bc1 output parameter set.
+   */
+  inline bool IsPointOn3DSeg(const double segStart[3], const double segStop[3], const double point[3], double eps, double& bc0, double& bc1)
+  {
+    double AB[3]={segStop[0]-segStart[0],segStop[1]-segStart[1],segStop[2]-segStart[2]},AP[3]={point[0]-segStart[0],point[1]-segStart[1],point[2]-segStart[2]};
+    double l_AB(sqrt(AB[0]*AB[0]+AB[1]*AB[1]+AB[2]*AB[2]));
+    double AP_dot_AB((AP[0]*AB[0]+AP[1]*AB[1]+AP[2]*AB[2])/(l_AB*l_AB));
+    double projOfPOnAB[3]={segStart[0]+AP_dot_AB*AB[0],segStart[1]+AP_dot_AB*AB[1],segStart[2]+AP_dot_AB*AB[2]};
+    double V_dist_P_AB[3]={point[0]-projOfPOnAB[0],point[1]-projOfPOnAB[1],point[2]-projOfPOnAB[2]};
+    double dist_P_AB(sqrt(V_dist_P_AB[0]*V_dist_P_AB[0]+V_dist_P_AB[1]*V_dist_P_AB[1]+V_dist_P_AB[2]*V_dist_P_AB[2]));
+    if(dist_P_AB>=eps)
+      return false;//to far from segment [segStart,segStop]
+    if(AP_dot_AB<-eps || AP_dot_AB>1.+eps)
+      return false;
+    AP_dot_AB=std::max(AP_dot_AB,0.); AP_dot_AB=std::min(AP_dot_AB,1.);
+    bc0=1.-AP_dot_AB; bc1=AP_dot_AB;
+    return true;
+  }
+
+  /*!
    * Calculate pseudo barycentric coordinates of a point p with respect to the quadrangle vertices.
    * This method makes the assumption that:
    *  - spacedim == meshdim (2 here).
@@ -837,7 +859,7 @@
   }
 
   /*! Function that compares two angles from the values of the pairs (sin,cos)*/
-  /*! Angles are considered in [0, 2Pi] bt are not computed explicitely */
+  /*! Angles are considered in [0, 2Pi] bt are not computed explicitly */
   class AngleLess
   {
   public:
@@ -1048,9 +1070,9 @@
     // just to be able to compile
   }
   
-  /*_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _*/
-  /* Checks wether point A is inside the quadrangle BCDE */
-  /*_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _*/  
+  /*_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ */
+  /* Checks whether point A is inside the quadrangle BCDE */
+  /*_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ */
 
   template<int dim> inline double check_inside(const double* A,const double* B,const double* C,const double* D,
                                                const double* E,double* ABC, double* ADE)
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/MeshElement.txx MEDCOUPLING_new/src/INTERP_KERNEL/MeshElement.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/MeshElement.txx	2018-04-19 17:04:36.678221546 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/MeshElement.txx	2018-04-19 17:25:17.535793364 +0200
@@ -61,8 +61,6 @@
     delete _box;
   }
 
-  
-
   /////////////////////////////////////////////////////////////////////
   /// ElementBBoxOrder                                    /////////////
   /////////////////////////////////////////////////////////////////////
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/PlanarIntersector.txx MEDCOUPLING_new/src/INTERP_KERNEL/PlanarIntersector.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/PlanarIntersector.txx	2018-04-19 17:04:36.678221546 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/PlanarIntersector.txx	2018-04-19 17:25:17.604794728 +0200
@@ -93,7 +93,7 @@
   }
 
   /*!
-    Computes the bouding box of a given element. iP in numPol mode.
+    Computes the bounding box of a given element. iP in numPol mode.
   */
   template<class MyMeshType, class MyMatrix>
   void PlanarIntersector<MyMeshType,MyMatrix>::getElemBB(double* bb, const MyMeshType& mesh, ConnType iP, ConnType nb_nodes)
@@ -380,7 +380,7 @@
               Coords_B[SPACEDIM*i_B+idim] -=  proj*linear_comb[idim];
           }
         
-        //Buid the matrix sending  A into the Oxy plane and apply it to A and B  
+        //Build the matrix sending  A into the Oxy plane and apply it to A and B  
         if(do_rotate)
           {
             TranslationRotationMatrix rotation;
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/PointLocator2DIntersector.txx MEDCOUPLING_new/src/INTERP_KERNEL/PointLocator2DIntersector.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/PointLocator2DIntersector.txx	2018-04-19 17:04:36.679221566 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/PointLocator2DIntersector.txx	2018-04-19 17:25:17.513792929 +0200
@@ -118,7 +118,7 @@
                                                const double *             sourceTria,
                                                std::vector<double>&       res)
   {
-    throw INTERP_KERNEL::Exception("intersectGeoBary incompatible with PointLocator. Desactivate P1P0Bary to avoid the problem");
+    throw INTERP_KERNEL::Exception("intersectGeoBary incompatible with PointLocator. Deactivate P1P0Bary to avoid the problem");
     return 0.;
   }
 
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/PolygonAlgorithms.txx MEDCOUPLING_new/src/INTERP_KERNEL/PolygonAlgorithms.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/PolygonAlgorithms.txx	2018-04-19 17:04:36.679221566 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/PolygonAlgorithms.txx	2018-04-19 17:25:17.599794629 +0200
@@ -37,7 +37,7 @@
   /*************************************************************/
   /* Computes the 3D intersection between two COPLANAR         */
   /* Segments [A,B] and [C,D], stores the result in V.         */
-  /* If A belongs to [CD] then the vertex E (preceeding A)     */
+  /* If A belongs to [CD] then the vertex E (preceding A)      */
   /* is used to decide if the crossing is real. If A coincides */
   /* with C or D, a special treatment is performed             */
   /*************************************************************/
@@ -71,7 +71,7 @@
             {
               if(distance2<DIM>(A,D)<_epsilon)
                 crossprod<DIM>(A,C,E,_vdouble);//store the crossprod between vectors AC and AE (E=vertex preceding A)                     
-              return false;//case of paralell segments
+              return false;//case of parallel segments
             }
           case 3://beware AB and CD may belong to a vertical plane
             det = determinant(&AB[1],&DC[1]);//determinant of the last two coefficients
@@ -94,7 +94,7 @@
                   {
                     if(distance2<DIM>(A,D)<_epsilon)
                       crossprod<DIM>(A,C,E,_vdouble);//store the crossprod between vectors AC and AE (E=vertex preceding A)                     
-                    return false;//case of paralell segments
+                    return false;//case of parallel segments
                   }
               }
           }
@@ -123,7 +123,7 @@
                 return true;
               }
             else if( same_side > _epsilon ) _terminus= !_is_in_intersection;//reflexion
-            else //separation of overlaping edges
+            else //separation of overlapping edges
               {
                 if(_Inter.empty() ) _terminus=true;
                 else if(!_is_in_intersection)
@@ -147,7 +147,7 @@
                 return true;
               }
             else if(fabs(in_between)<=_epsilon && dotprod<DIM>(Vdoublebis,Vdoublebis) > _epsilon)
-              //ie _vdouble=0, separation of overlaping edges at a double point
+              //ie _vdouble=0, separation of overlapping edges at a double point
               {
                 //crossprod<DIM>(A,E,B,_vdouble); 
                 if(dotprod<DIM>(_vdouble,Vdoublebis) >=_epsilon )//crossing
@@ -269,7 +269,7 @@
   /*******************************************************/
   /* adds the possible crossings between segments [A,B] (with end-point global indices i and i_next) */
   /*and segments [C,D] and [E,F] to the list inter and updates _End_segments */
-  /* In cases of ambiguity, the vertex G is used to decide wether the crossing should be accepted */
+  /* In cases of ambiguity, the vertex G is used to decide whether the crossing should be accepted */
   /*******************************************************/
   template<int DIM>
   inline void PolygonAlgorithms<DIM>::addCrossings( const double * A, const double * B, int i , int i_next,
@@ -405,7 +405,7 @@
 
     std::multimap< int, std::pair< int,bool> >::iterator mi;
 
-    /********** Initalisation of events with P1 and P2 vertices ************/
+    /********** Initialisation of events with P1 and P2 vertices ************/
     for(i_loc=0;i_loc<N1;i_loc++)
       mmap_events.insert(std::make_pair(&P_1[DIM*i_loc],i_loc));
     for(i_loc=0;i_loc<N2;i_loc++)
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/SplitterTetra.hxx MEDCOUPLING_new/src/INTERP_KERNEL/SplitterTetra.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/SplitterTetra.hxx	2018-04-19 17:04:36.680221586 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/SplitterTetra.hxx	2018-04-19 17:25:17.497792613 +0200
@@ -88,7 +88,7 @@
     };
   
   // Each sub-node is the barycenter of 4 other nodes.
-  // For the faces, these are on the orignal mesh.
+  // For the faces, these are on the original mesh.
   // For the barycenter, the four face sub-nodes are used.
   static const int GENERAL_24_SUB_NODES[28] = 
     {
@@ -175,7 +175,7 @@
 
   // Define 8 hexahedral subzones as in Grandy, p449
   // the values correspond to the nodes that correspond to nodes 1,2,3,4,5,6,7,8 in the subcell
-  // For the correspondance of the nodes, see the GENERAL_48_SUB_NODES table in calculateSubNodes
+  // For the correspondence of the nodes, see the GENERAL_48_SUB_NODES table in calculateSubNodes
   static const int GENERAL_48_SUBZONES[64] = 
     {
       0,8,21,12,9,20,26,22,
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/SplitterTetra.txx MEDCOUPLING_new/src/INTERP_KERNEL/SplitterTetra.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/SplitterTetra.txx	2018-04-19 17:04:36.680221586 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/SplitterTetra.txx	2018-04-19 17:25:17.465791980 +0200
@@ -1108,7 +1108,7 @@
   {
     // The two nodes of the original mesh cell used in each tetrahedron.
     // The tetrahedra all have nodes (cellCenter, faceCenter, edgeNode1, edgeNode2)
-    // For the correspondance of the nodes, see the GENERAL_48_SUB_NODES table in calculateSubNodes
+    // For the correspondence of the nodes, see the GENERAL_48_SUB_NODES table in calculateSubNodes
     
     // nodes to use for tetrahedron
     const double* nodes[4];
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangle.hxx MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangle.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangle.hxx	2018-04-19 17:04:36.680221586 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangle.hxx	2018-04-19 17:25:17.390790498 +0200
@@ -89,7 +89,7 @@
    * For the other two halfstrips (above the xy and yz edges), other double products are used, which 
    * are stored in the table DP_FOR_HALFSTRIP_INTERSECTION. This allows us to treat
    * all the edges equally, avoiding switch() - statements. It is the careful choice of order of the enumeration types that makes this
-   * possible. Notably, there is a correspondance between the TetraEdge type and the DoubleProduct type (see Grandy, table III) that
+   * possible. Notably, there is a correspondence between the TetraEdge type and the DoubleProduct type (see Grandy, table III) that
    * is used throughout the code, permitting statements such as DoubleProduct(some_edge) to work.
    *    When an intersection point has been detected it is calculated with a corresponding calc* - method in the cases where it
    * is not known directly. It is then added to the polygon A and/or B as necessary.
@@ -347,7 +347,7 @@
 
     static const double TRIPLE_PRODUCT_ANGLE_THRESHOLD;
 
-    // correspondance facet - double product
+    // correspondence facet - double product
     // Grandy, table IV
     static const DoubleProduct DP_FOR_SEG_FACET_INTERSECTION[12];
 
@@ -362,14 +362,14 @@
     // for Segment-Facet and Segment-Edge intersections
     static const int DP_INDEX[12];
 
-    // correspondance edge - corners
+    // correspondence edge - corners
     static const TetraCorner CORNERS_FOR_EDGE[12];
 
-    // correspondance edge - facets
+    // correspondence edge - facets
     // facets shared by each edge
     static const TetraFacet FACET_FOR_EDGE[12];
 
-    // correspondance edge - corners
+    // correspondence edge - corners
     static const TetraEdge EDGES_FOR_CORNER[12];
    
     // double products used in segment-halfstrip test
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangleInline.hxx MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangleInline.hxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangleInline.hxx	2018-04-19 17:04:36.680221586 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangleInline.hxx	2018-04-19 17:25:17.491792494 +0200
@@ -170,7 +170,7 @@
   
   //  assert(edge < H01);
   
-  // correspondance edge - triple products
+  // correspondence edge - triple products
   // for edges OX, ..., ZX (Grandy, table III)
   static const TetraCorner TRIPLE_PRODUCTS[12] = 
     {
@@ -212,8 +212,8 @@
 
 inline bool TransformedTriangle::testSegmentIntersectsFacet(const TriSegment seg, const TetraFacet facet) const
 {
-  // use correspondance facet a = 0 <=> offset for coordinate a in _coords
-  // and also correspondance segment AB => corner A
+  // use correspondence facet a = 0 <=> offset for coordinate a in _coords
+  // and also correspondence segment AB => corner A
   const double coord1 = _coords[5*seg + facet];
   const double coord2 = _coords[5*( (seg + 1) % 3) + facet];
   
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx	2018-04-19 17:04:36.680221586 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangleIntersect.cxx	2018-04-19 17:25:17.526793186 +0200
@@ -28,10 +28,10 @@
 {
 
   // ----------------------------------------------------------------------------------
-  //  Correspondance tables describing all the variations of formulas. 
+  //  Correspondence tables describing all the variations of formulas. 
   // ----------------------------------------------------------------------------------
 
-  /// \brief Correspondance between facets and double products.
+  /// \brief Correspondence between facets and double products.
   ///
   /// This table encodes Grandy, table IV. Use 3*facet + {0,1,2} as index
   const TransformedTriangle::DoubleProduct TransformedTriangle::DP_FOR_SEG_FACET_INTERSECTION[12] = 
@@ -78,7 +78,7 @@
       9, 10, 11  // XYZ
     };
 
-  /// \brief Correspondance edge - corners.
+  /// \brief Correspondence edge - corners.
   ///
   /// Gives the two corners associated with each edge
   /// Use 2*edge + {0, 1} as index
@@ -92,7 +92,7 @@
       Z, X  // ZX
     };
 
-  /// \brief Correspondance edge - facets.
+  /// \brief Correspondence edge - facets.
   ///
   /// Gives the two facets shared by and edge. Use 2*facet + {0, 1} as index
   const TransformedTriangle::TetraFacet TransformedTriangle::FACET_FOR_EDGE[12] =
@@ -105,7 +105,7 @@
       OZX, XYZ  // ZX
     };
 
-  /// \brief Correspondance corners - edges.
+  /// \brief Correspondence corners - edges.
   ///
   /// Gives edges meeting at a given corner. Use 3*corner + {0,1,2} as index
   const TransformedTriangle::TetraEdge TransformedTriangle::EDGES_FOR_CORNER[12] =
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangleMath.cxx MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangleMath.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/TransformedTriangleMath.cxx	2018-04-19 17:04:36.699221965 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/TransformedTriangleMath.cxx	2018-04-19 17:25:17.452791723 +0200
@@ -127,7 +127,7 @@
           }
       }
   
-    // -- (2) check that each double product statisfies Grandy, [47], else set to 0
+    // -- (2) check that each double product satisfies Grandy, [47], else set to 0
     for(TriSegment seg = PQ ; seg <= RP ; seg = TriSegment(seg + 1))
       {
         for(DoubleProduct dp = C_YZ ; dp <=  C_10 ; dp = DoubleProduct(dp + 1))
@@ -270,7 +270,7 @@
           {
             const DoubleProduct dp = DP_FOR_DETERMINANT_EXPANSION[3*corner + (row - 1)];
 
-            // get edge by using correspondance between Double Product and Edge
+            // get edge by using correspondence between Double Product and Edge
             TetraEdge edge = TetraEdge(dp);
            
             // use edge only if it is surrounded by the surface
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/VolSurfUser.cxx MEDCOUPLING_new/src/INTERP_KERNEL/VolSurfUser.cxx
--- MEDCOUPLING_old/src/INTERP_KERNEL/VolSurfUser.cxx	2018-04-19 17:04:36.700221985 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/VolSurfUser.cxx	2018-04-19 17:25:17.411790913 +0200
@@ -246,7 +246,7 @@
   }
 
   /*!
-   * \param [out] matrix contain a dense matrix of size 12 with 3 rows containing each 4 colums. This matrix is the reduction of 4x4 matrix but the last
+   * \param [out] matrix contain a dense matrix of size 12 with 3 rows containing each 4 columns. This matrix is the reduction of 4x4 matrix but the last
    *              line containing [0,0,0,1] is omitted.
    */
   bool ComputeRotTranslationMatrixToPut3PointsOnOXY(const double *p0, const double *p1, const double *p2, double *matrix)
diff -Naur MEDCOUPLING_old/src/INTERP_KERNEL/VolSurfUser.txx MEDCOUPLING_new/src/INTERP_KERNEL/VolSurfUser.txx
--- MEDCOUPLING_old/src/INTERP_KERNEL/VolSurfUser.txx	2018-04-19 17:04:36.700221985 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNEL/VolSurfUser.txx	2018-04-19 17:25:17.435791387 +0200
@@ -156,6 +156,7 @@
             
       case INTERP_KERNEL::NORM_PENTA6 :
       case INTERP_KERNEL::NORM_PENTA15 :
+      case INTERP_KERNEL::NORM_PENTA18 :
         {
           int N1 = OTT<ConnType,numPol>::coo2C(connec[0]);
           int N2 = OTT<ConnType,numPol>::coo2C(connec[1]);
diff -Naur MEDCOUPLING_old/src/INTERP_KERNELTest/CMakeLists.txt MEDCOUPLING_new/src/INTERP_KERNELTest/CMakeLists.txt
--- MEDCOUPLING_old/src/INTERP_KERNELTest/CMakeLists.txt	2018-04-19 17:04:36.701222005 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNELTest/CMakeLists.txt	2018-04-19 17:25:17.930801172 +0200
@@ -89,7 +89,7 @@
 TARGET_LINK_LIBRARIES(InterpKernelTestUtils interpkernel)
 ADD_LIBRARY(InterpKernelTest ${InterpKernelTest_SOURCES})
 
-SET(InterpKernelTest_LIBS medcoupling interpkernel ${CPPUNIT_LIBRARIES})
+SET(InterpKernelTest_LIBS medcouplingcpp interpkernel ${CPPUNIT_LIBRARIES})
 IF(NOT MEDCOUPLING_MICROMED)
   SET(InterpKernelTest_LIBS medloader ${InterpKernelTest_LIBS})
 ENDIF(NOT MEDCOUPLING_MICROMED)
diff -Naur MEDCOUPLING_old/src/INTERP_KERNELTest/InterpolationOptionsTest.cxx MEDCOUPLING_new/src/INTERP_KERNELTest/InterpolationOptionsTest.cxx
--- MEDCOUPLING_old/src/INTERP_KERNELTest/InterpolationOptionsTest.cxx	2018-04-19 17:04:36.701222005 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNELTest/InterpolationOptionsTest.cxx	2018-04-19 17:25:17.927801112 +0200
@@ -79,7 +79,7 @@
     MEDCouplingNormalizedUnstructuredMesh<2,2> wrap_target_mesh(target_mesh_mc);
     // Go for interpolation...
     INTERP_KERNEL::Interpolation2D myInterpolator;
-    //optionnal call to parametrize your interpolation. First precision, tracelevel, intersector wanted.
+    //optional call to parametrize your interpolation. First precision, tracelevel, intersector wanted.
     myInterpolator.setPrecision(1e-7);
     myInterpolator.setPrintLevel(1);
     source_mesh->decrRef();
diff -Naur MEDCOUPLING_old/src/INTERP_KERNELTest/MeshTestToolkit.txx MEDCOUPLING_new/src/INTERP_KERNELTest/MeshTestToolkit.txx
--- MEDCOUPLING_old/src/INTERP_KERNELTest/MeshTestToolkit.txx	2018-04-19 17:04:36.701222005 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNELTest/MeshTestToolkit.txx	2018-04-19 17:25:17.943801429 +0200
@@ -402,7 +402,7 @@
    * @param  mesh2path   the path to the file containing the target mesh, relative to {$MEDCOUPLING_ROOT_DIR}/share/resources/med/
    * @param  mesh2       the name of the target mesh
    * @param  correctVol  the total volume of the intersection of the two meshes
-   * @param  prec        maximum relative error to be tolerated in volume comparisions
+   * @param  prec        maximum relative error to be tolerated in volume comparisons
    * @param  doubleTest  if false, only the test with mesh 1 as the source mesh and mesh 2 as the target mesh will be performed
    *
    */
@@ -467,7 +467,7 @@
    * @param  mesh1       the name of the source mesh
    * @param  mesh2       the name of the target mesh
    * @param  correctVol  the total volume of the intersection of the two meshes
-   * @param  prec        maximum relative error to be tolerated in volume comparisions
+   * @param  prec        maximum relative error to be tolerated in volume comparisons
    * @param  doubleTest  if false, only the test with mesh 1 as the source mesh and mesh 2 as the target mesh will be performed
    *
    */
diff -Naur MEDCOUPLING_old/src/INTERP_KERNELTest/QuadraticPlanarInterpTest2.cxx MEDCOUPLING_new/src/INTERP_KERNELTest/QuadraticPlanarInterpTest2.cxx
--- MEDCOUPLING_old/src/INTERP_KERNELTest/QuadraticPlanarInterpTest2.cxx	2018-04-19 17:04:36.702222025 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNELTest/QuadraticPlanarInterpTest2.cxx	2018-04-19 17:25:17.924801053 +0200
@@ -349,7 +349,7 @@
       delete intersector; e2->decrRef(); e1->decrRef();
     }
   // Tangent intersection
-  QUADRATIC_PLANAR::setPrecision(1e-5);
+  QuadraticPlanarPrecision::setPrecision(1e-5);
   for(unsigned k=0;k<8;k++)
     {
       double center2[2]; center[0]=0.; center[1]=0.;
@@ -361,7 +361,7 @@
       bool obvious,areOverlapped;
       intersector->areOverlappedOrOnlyColinears(0,obvious,areOverlapped);
       CPPUNIT_ASSERT(!obvious && !areOverlapped);
-      CPPUNIT_ASSERT(intersector->intersect(0,v4,order,v3)); CPPUNIT_ASSERT(order); // order has no sence here because v4.size() expected to 1 but for valgrind serenity test.
+      CPPUNIT_ASSERT(intersector->intersect(0,v4,order,v3)); CPPUNIT_ASSERT(order); // order has no sense here because v4.size() expected to 1 but for valgrind serenity test.
       CPPUNIT_ASSERT_EQUAL(1,(int)v4.size()); CPPUNIT_ASSERT_EQUAL(0,(int)v3.getNumberOfAssociations());
       CPPUNIT_ASSERT_DOUBLES_EQUAL(e1->getRadius(),Node::distanceBtw2Pt(e1->getCenter(),(*(v4[0]))),ADMISSIBLE_ERROR);
       CPPUNIT_ASSERT_DOUBLES_EQUAL(e2->getRadius(),Node::distanceBtw2Pt(e2->getCenter(),(*(v4[0]))),ADMISSIBLE_ERROR);
@@ -370,7 +370,7 @@
       v4.clear(); v4.clear();
       delete intersector; e2->decrRef(); e1->decrRef();
     }
-  QUADRATIC_PLANAR::setPrecision(1e-14);
+  QuadraticPlanarPrecision::setPrecision(1e-14);
   // Extremities # 1
   for(unsigned k=0;k<8;k++)
     {
diff -Naur MEDCOUPLING_old/src/INTERP_KERNELTest/QuadraticPlanarInterpTest4.cxx MEDCOUPLING_new/src/INTERP_KERNELTest/QuadraticPlanarInterpTest4.cxx
--- MEDCOUPLING_old/src/INTERP_KERNELTest/QuadraticPlanarInterpTest4.cxx	2018-04-19 17:04:36.702222025 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNELTest/QuadraticPlanarInterpTest4.cxx	2018-04-19 17:25:17.961801784 +0200
@@ -495,8 +495,8 @@
  */
 void QuadraticPlanarInterpTest::checkHighLevelFunctionTest1()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-12);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-9);
+  QuadraticPlanarPrecision::setPrecision(1e-12);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-9);
   double coords[]={
     8.8334591186000004, 5.0999999999999996,
     7.1014083111000001, 6.0999999999999996,
@@ -581,13 +581,13 @@
   pol=QuadraticPolygon::BuildArcCirclePolygon(nodes);
   pol->getBarycenter(tmp,tmp2);
   delete pol;
-  QUADRATIC_PLANAR::setPrecision(1e-14);
+  QuadraticPlanarPrecision::setPrecision(1e-14);
 }
 
 void QuadraticPlanarInterpTest::check1DInterpLin()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-7);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-9);
+  QuadraticPlanarPrecision::setPrecision(1e-7);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-9);
   const int NB_OF_CELL_AXIAL_1=30;
   static const double Z_VALS_1[NB_OF_CELL_AXIAL_1+1]=
     { -0.1550 , -0.1356, -0.1162, -0.0969, -0.0775 ,-0.0581, -0.0387, -0.0194,  0.0000 , 0.0500, 
@@ -631,7 +631,7 @@
       CPPUNIT_ASSERT_EQUAL(1,(int)m[i+2].size());
       CPPUNIT_ASSERT_DOUBLES_EQUAL(1.,m[i+2][i+9],1e-12);
     }
-  QUADRATIC_PLANAR::setPrecision(1e-14);
+  QuadraticPlanarPrecision::setPrecision(1e-14);
 }
 
 /*!
@@ -639,8 +639,8 @@
  */
 void QuadraticPlanarInterpTest::checkEpsilonCoherency1()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-12);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-5);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-12);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-5);
 
   const double pol1[]={
     -2.1083388455000001, 1.2172499999999999,
@@ -709,8 +709,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression2()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-12);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-9);
+  QuadraticPlanarPrecision::setPrecision(1e-12);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-9);
   double coords1[]=
     {
       15.141499999899999, -26.226033271399999,
@@ -801,8 +801,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression4()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-12);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-9);
+  QuadraticPlanarPrecision::setPrecision(1e-12);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-9);
   double coords1[]=
     {
       10.962340811000001, -22.417749999000002,
@@ -857,8 +857,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression5()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-12);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-5);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-12);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-5);
   double coords1[]=
     {
       -1.7320508075000001, 1,
@@ -913,8 +913,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression6()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-12);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-5);
+  QuadraticPlanarPrecision::setPrecision(1e-12);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-5);
   double coords1[]=
     {
       10.962340811000001, -22.417749999000002,
@@ -965,8 +965,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression7()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-5);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-5);
+  QuadraticPlanarPrecision::setPrecision(1e-5);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-5);
   double coords1[]=
     {
       -2., 0,
@@ -1017,8 +1017,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression8()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-3);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-5);
+  QuadraticPlanarPrecision::setPrecision(1e-3);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-5);
   double coords1[]=
     {
       -13.933240959000001, -28.559499999,
@@ -1068,8 +1068,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression9()
 {
-  QUADRATIC_PLANAR::setPrecision(1e-7);
-  QUADRATIC_PLANAR::setArcDetectionPrecision(1e-8);
+  QuadraticPlanarPrecision::setPrecision(1e-7);
+  QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-8);
   double coords1[]=
     {
       -0.04476229252902969, -0.085118027765365603,
@@ -1119,8 +1119,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression10()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords1[]=
     { -0.002269581957210453, -0.09851030343724453,
       -0.004268022334182935, -0.1059685844580936,
@@ -1149,8 +1149,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression11()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords1[]=
     { -0.002269581957210453, -0.09851030343724453,
       -0.004268022334182935, -0.1059685844580936,
@@ -1200,8 +1200,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression12()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-6);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-6);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords1[]=
     { -0.5032251558760915, -0.8716087994449138,
       -0.4695268343089433, -0.8806382374805872,
@@ -1252,8 +1252,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegression13()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-6);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-6);
 
   double coords_1[194]={ 
     0, 0, 0.304375, -7.454791178893722e-17, 0.2152256265236553, -0.2152256265236555, -5.591093384170291e-17, -0.304375, 
@@ -1348,8 +1348,8 @@
 */
 void QuadraticPlanarInterpTest::checkNonRegression14()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-6);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-6);
 
   double coords[72]={
     1.,0.,1.3,0.,-1.3,0.,-1.,0.,1.15,0.,0.,1.3,-1.15,0.,0.,1.,
@@ -1418,8 +1418,8 @@
  */
 void QuadraticPlanarInterpTest::checkNonRegression15()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-6);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-6);
 
   double coords[72]={
     1.,0.,1.3,0.,-1.3,0.,-1.,0.,1.15,0.,0.,1.3,-1.15,0.,0.,1.,
@@ -1494,8 +1494,8 @@
  */
 void QuadraticPlanarInterpTest::checkNonRegression16()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords1[194]={ 
     0, 0, 0.304375, 0, 0.2152256265236554, 0.2152256265236554, 1.86369779472343e-17, 0.304375, 
     -0.2152256265236554, 0.2152256265236554, -0.304375, 3.727395589446861e-17, -0.2152256265236555, -0.2152256265236554, -5.591093384170291e-17, -0.304375, 
@@ -1574,8 +1574,8 @@
  */
 void QuadraticPlanarInterpTest::checkNonRegression17()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1., 0., 1., 0. , 1.5, 0., -1.5, 0., 
     0. , 1., 1.25, 0., 0., 1.5, -1.25, 0.};
@@ -1614,7 +1614,7 @@
 
 void QuadraticPlanarInterpTest::checkNormalize()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-14);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-14);
   Node *n1=new Node(0.,0.);                Node *n4=new Node(0.,-3.);
   Node *n2=new Node(10.,0.);               Node *n5=new Node(10.,-3.);
   Node *n3=new Node(5.,10.);               Node *n6=new Node(5.,7.);
@@ -1665,7 +1665,7 @@
 
 void QuadraticPlanarInterpTest::checkMakePartitionAbs1()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-14);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-14);
   Node *n0=new Node(0.,0.);                Node *n4=new Node(0.5,0.25);
   Node *n1=new Node(0.,0.5);               Node *n5=new Node(0.3,1.2);
   Node *n2=new Node(1.,0.5);               Node *n6=new Node(1.1,1.3);
diff -Naur MEDCOUPLING_old/src/INTERP_KERNELTest/QuadraticPlanarInterpTest5.cxx MEDCOUPLING_new/src/INTERP_KERNELTest/QuadraticPlanarInterpTest5.cxx
--- MEDCOUPLING_old/src/INTERP_KERNELTest/QuadraticPlanarInterpTest5.cxx	2018-04-19 17:04:36.702222025 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNELTest/QuadraticPlanarInterpTest5.cxx	2018-04-19 17:25:17.951801587 +0200
@@ -45,8 +45,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0000()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.383022221559489, 0.3213938048432697, -0.5745333323392334, 0.4820907072649046, 0.5745333323392335, 0.4820907072649044, 0.383022221559489, 0.3213938048432696,
     -0.4787777769493612, 0.4017422560540872, 4.592273826833915e-17, 0.75, 0.4787777769493612, 0.401742256054087, 3.061515884555943e-17, 0.5 };
@@ -71,8 +71,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0001()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.383022221559489, 0.3213938048432697, -0.5745333323392334, 0.4820907072649046, 0.5745333323392335, 0.4820907072649044, 0.383022221559489, 0.3213938048432696,
     -0.4787777769493612, 0.4017422560540872, 4.592273826833915e-17, 0.75, 0.4787777769493612, 0.401742256054087, 3.061515884555943e-17, 0.5 };
@@ -97,8 +97,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0002()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.383022221559489, 0.3213938048432697, -0.5745333323392334, 0.4820907072649046, 0.5745333323392335, 0.4820907072649044, 0.383022221559489, 0.3213938048432696,
     -0.4787777769493612, 0.4017422560540872, 4.592273826833915e-17, 0.75, 0.4787777769493612, 0.401742256054087, 3.061515884555943e-17, 0.5 };
@@ -123,8 +123,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0003()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.3535533905932737, 0.3535533905932738, -0.5303300858899106, 0.5303300858899107, 0.5303300858899107, 0.5303300858899106, 0.3535533905932738, 0.3535533905932737,
     -0.4419417382415922, 0.4419417382415922, 4.592273826833915e-17, 0.75, 0.4419417382415922, 0.4419417382415922, 3.061515884555943e-17, 0.5 };
@@ -149,8 +149,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0004()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.4596194077712559, 0.4596194077712559, -0.5303300858899106, 0.5303300858899107, 0.5303300858899107, 0.5303300858899106, 0.4596194077712559, 0.4596194077712559,
     -0.4949747468305832, 0.4949747468305833, 4.592273826833915e-17, 0.75, 0.4949747468305833, 0.4949747468305832, 3.979970649922726e-17, 0.65 };
@@ -175,8 +175,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0005()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.383022221559489, 0.3213938048432697, -0.6128355544951823, 0.5142300877492316, 0.6128355544951825, 0.5142300877492314, 0.383022221559489, 0.3213938048432696,
     -0.4979288880273356, 0.4178119462962507, 4.898425415289509e-17, 0.8, 0.4979288880273357, 0.4178119462962505, 3.061515884555943e-17, 0.5 };
@@ -201,8 +201,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0006()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.383022221559489, 0.3213938048432697, -0.5362311101832845, 0.4499513267805776, 0.5362311101832846, 0.4499513267805774, 0.383022221559489, 0.3213938048432696,
     -0.4596266658713867, 0.3856725658119237, 4.28612223837832e-17, 0.7, 0.4596266658713868, 0.3856725658119236, 3.061515884555943e-17, 0.5 };
@@ -227,8 +227,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0007()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.383022221559489, 0.3213938048432697, -0.5362311101832845, 0.4499513267805776, 0.5362311101832846, 0.4499513267805774, 0.383022221559489, 0.3213938048432696,
     -0.4596266658713867, 0.3856725658119237, 4.28612223837832e-17, 0.7, 0.4596266658713868, 0.3856725658119236, 3.061515884555943e-17, 0.5 };
@@ -253,8 +253,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0008()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.383022221559489, 0.3213938048432697, -0.5362311101832845, 0.4499513267805776, 0.5362311101832846, 0.4499513267805774, 0.383022221559489, 0.3213938048432696,
     -0.4596266658713867, 0.3856725658119237, 4.28612223837832e-17, 0.7, 0.4596266658713868, 0.3856725658119236, 3.061515884555943e-17, 0.5 };
@@ -279,8 +279,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0009()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.3863703305156274, -0.1035276180410081, -0.4829629131445342, -0.1294095225512602, 0.4829629131445342, -0.1294095225512604, 0.3863703305156274, -0.1035276180410083,
     -0.4346666218300808, -0.1164685702961342, 1.416374613080751e-16, 0.5, 0.4346666218300808, -0.1164685702961343, 1.133099690464601e-16, 0.4 };
@@ -304,8 +304,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0010()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.3863703305156274, -0.1035276180410081, -0.4829629131445342, -0.1294095225512602, 0.4829629131445342, -0.1294095225512604, 0.3863703305156274, -0.1035276180410083,
 -0.4346666218300808, -0.1164685702961342, 1.416374613080751e-16, 0.5, 0.4346666218300808, -0.1164685702961343, 1.133099690464601e-16, 0.4 };
@@ -329,8 +329,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0011()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.3863703305156274, -0.1035276180410081, -0.4829629131445342, -0.1294095225512602, 0.4829629131445342, -0.1294095225512604, 0.3863703305156274, -0.1035276180410083,
 -0.4346666218300808, -0.1164685702961342, 1.416374613080751e-16, 0.5, 0.4346666218300808, -0.1164685702961343, 1.133099690464601e-16, 0.4 };
@@ -372,8 +372,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar2511()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.3863703305156274, -0.1035276180410081, -0.4829629131445342, -0.1294095225512602, 0.4829629131445342, -0.1294095225512604, 0.3863703305156274, -0.1035276180410083,
     -0.4346666218300808, -0.1164685702961342, 1.416374613080751e-16, 0.5, 0.4346666218300808, -0.1164685702961343, 1.133099690464601e-16, 0.4, };
@@ -416,8 +416,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0012()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1, 1.224606353822377e-16, -1.6, 1.959370166115804e-16, 9.796850830579018e-17, 1.6, 6.123031769111886e-17, 1,
     -1.3, 1.591988259969091e-16, -1.131370849898476, 1.131370849898476, 7.959941299845453e-17, 1.3, -0.7071067811865475, 0.7071067811865476 };
@@ -450,8 +450,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0013()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1, 1.224606353822377e-16, -1.6, 1.959370166115804e-16, 9.796850830579018e-17, 1.6, 6.123031769111886e-17, 1,
     -1.3, 1.591988259969091e-16, -1.131370849898476, 1.131370849898476, 7.959941299845453e-17, 1.3, -0.7071067811865475, 0.7071067811865476 };
@@ -484,8 +484,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0014()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1, 1.224606353822377e-16, -1.6, 1.959370166115804e-16, 9.796850830579018e-17, 1.6, 6.123031769111886e-17, 1,
 -1.3, 1.591988259969091e-16, -1.131370849898476, 1.131370849898476, 7.959941299845453e-17, 1.3, -0.7071067811865475, 0.7071067811865476 };
@@ -528,8 +528,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0015()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1, 1.224606353822377e-16, -1.6, 1.959370166115804e-16, 9.796850830579018e-17, 1.6, 6.123031769111886e-17, 1,
 -1.3, 1.591988259969091e-16, -1.131370849898476, 1.131370849898476, 7.959941299845453e-17, 1.3, -0.7071067811865475, 0.7071067811865476 };
@@ -572,8 +572,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0016()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1, 1.224606353822377e-16, -1.6, 1.959370166115804e-16, 9.796850830579018e-17, 1.6, 6.123031769111886e-17, 1,
 -1.3, 1.591988259969091e-16, -1.131370849898476, 1.131370849898476, 7.959941299845453e-17, 1.3, -0.7071067811865475, 0.7071067811865476 };
@@ -616,8 +616,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0017()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1, 1.224606353822377e-16, -1.6, 1.959370166115804e-16, 9.796850830579018e-17, 1.6, 6.123031769111886e-17, 1,
     -1.3, 1.591988259969091e-16, -1.131370849898476, 1.131370849898476, 7.959941299845453e-17, 1.3, -0.7071067811865475, 0.7071067811865476 };
@@ -661,8 +661,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0018()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -1, 1.224606353822377e-16, -1.6, 1.959370166115804e-16, 9.796850830579018e-17, 1.6, 6.123031769111886e-17, 1,
     -1.3, 1.591988259969091e-16, -1.131370849898476, 1.131370849898476, 7.959941299845453e-17, 1.3, -0.7071067811865475, 0.7071067811865476 };
@@ -706,8 +706,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0019()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
     -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5 };
@@ -732,8 +732,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0020()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
     -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5 };
@@ -777,8 +777,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0021()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
     -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5 };
@@ -821,8 +821,8 @@
 }
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0022()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
     -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5 };
@@ -847,8 +847,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0023()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
     -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5, };
@@ -873,8 +873,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0024()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
 -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5 };
@@ -898,8 +898,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar2524()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
 -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5 };
@@ -923,8 +923,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0025()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.5, 6.123031769111886e-17, -0.8, 9.796850830579018e-17, 0.8, 0, 0.5, 0,
     -0.65, 7.959941299845453e-17, 4.898425415289509e-17, 0.8, 0.65, 0, 3.061515884555943e-17, 0.5 };
@@ -958,8 +958,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0026()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.4, 4.898425415289509e-17, -0.75, 9.184547653667829e-17, 0.75, 0, 0.4, 0,
     -0.575, 7.041486534478669e-17, 4.592273826833915e-17, 0.75, 0.575, 0, 2.449212707644755e-17, 0.4 };
@@ -993,8 +993,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0027()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.4, 4.898425415289509e-17, -0.75, 9.184547653667829e-17, 0.75, 0, 0.4, 0,
     -0.575, 7.041486534478669e-17, 4.592273826833915e-17, 0.75, 0.575, 0, 2.449212707644755e-17, 0.4 };
@@ -1038,8 +1038,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0028()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.4, 4.898425415289509e-17, -0.75, 9.184547653667829e-17, 0.75, 0, 0.4, 0,
     -0.575, 7.041486534478669e-17, 4.592273826833915e-17, 0.75, 0.575, 0, 2.449212707644755e-17, 0.4 };
@@ -1083,8 +1083,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0029()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.4, 4.898425415289509e-17, -0.75, 9.184547653667829e-17, 0.75, 0, 0.4, 0,
     -0.575, 7.041486534478669e-17, 4.592273826833915e-17, 0.75, 0.575, 0, 2.449212707644755e-17, 0.4 };
@@ -1128,8 +1128,8 @@
 
 void QuadraticPlanarInterpTest::checkNonRegressionOmar0030()
 {
-  INTERP_KERNEL::QUADRATIC_PLANAR::setPrecision(1e-7);
-  INTERP_KERNEL::QUADRATIC_PLANAR::setArcDetectionPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarPrecision::setPrecision(1e-7);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision::setArcDetectionPrecision(1e-7);
   double coords[16]={
     -0.4, 4.898425415289509e-17, -0.75, 9.184547653667829e-17, 0.75, 0, 0.4, 0,
     -0.575, 7.041486534478669e-17, 4.592273826833915e-17, 0.75, 0.575, 0, 2.449212707644755e-17, 0.4 };
diff -Naur MEDCOUPLING_old/src/INTERP_KERNELTest/SingleElementPlanarTests.cxx MEDCOUPLING_new/src/INTERP_KERNELTest/SingleElementPlanarTests.cxx
--- MEDCOUPLING_old/src/INTERP_KERNELTest/SingleElementPlanarTests.cxx	2018-04-19 17:04:36.703222045 +0200
+++ MEDCOUPLING_new/src/INTERP_KERNELTest/SingleElementPlanarTests.cxx	2018-04-19 17:25:17.937801310 +0200
@@ -231,7 +231,7 @@
   {
     INTERP_KERNEL::PolygonAlgorithms<2> intersector (_Epsilon, _Precision);;
     /*
-      ////////////////// TEST DESACTIVATED by A. GEAY because memory fault : 
+      ////////////////// TEST DEACTIVATED by A. GEAY because memory fault : 
       // conditional jump INTERP_KERNEL::PolygonAlgorithms<2>::intersectConvexPolygons(double const*, double const*, int, int) (PolygonAlgorithms.txx:629)
     std::deque< double > actual_result = intersector.intersectConvexPolygons(_square1,_square1,4,4);
     std::deque< double > expected_result;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/CMakeLists.txt MEDCOUPLING_new/src/MEDCoupling/CMakeLists.txt
--- MEDCOUPLING_old/src/MEDCoupling/CMakeLists.txt	2018-04-19 17:04:36.704222065 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/CMakeLists.txt	2018-04-19 17:25:18.014802832 +0200
@@ -80,12 +80,13 @@
   MEDCouplingRemapper.cxx
   )
 
-ADD_LIBRARY(medcoupling ${medcoupling_SOURCES})
-TARGET_LINK_LIBRARIES(medcoupling interpkernel)
-INSTALL(TARGETS medcoupling EXPORT ${PROJECT_NAME}TargetGroup DESTINATION ${MEDCOUPLING_INSTALL_LIBS})
+ADD_LIBRARY(medcouplingcpp ${medcoupling_SOURCES})
+SET_TARGET_PROPERTIES(medcouplingcpp PROPERTIES OUTPUT_NAME "medcoupling")
+TARGET_LINK_LIBRARIES(medcouplingcpp interpkernel)
+INSTALL(TARGETS medcouplingcpp EXPORT ${PROJECT_NAME}TargetGroup DESTINATION ${MEDCOUPLING_INSTALL_LIBS})
 
 ADD_LIBRARY(medcouplingremapper ${medcouplingremapper_SOURCES})
-TARGET_LINK_LIBRARIES(medcouplingremapper medcoupling)
+TARGET_LINK_LIBRARIES(medcouplingremapper medcouplingcpp)
 INSTALL(TARGETS medcouplingremapper EXPORT ${PROJECT_NAME}TargetGroup DESTINATION ${MEDCOUPLING_INSTALL_LIBS})
 
 FILE(GLOB medcoupling_HEADERS_HXX "${CMAKE_CURRENT_SOURCE_DIR}/*.hxx")
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MCAuto.hxx MEDCOUPLING_new/src/MEDCoupling/MCAuto.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MCAuto.hxx	2018-04-19 17:04:36.704222065 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MCAuto.hxx	2018-04-19 17:25:18.015802852 +0200
@@ -101,6 +101,7 @@
     const T& operator*() { return *_ptr; }
     const T& operator*() const { return *_ptr; }
     operator const T *() const { return _ptr; }
+    T *shameOnMeConstCast() const { return const_cast<T*>(_ptr); }
   private:
     void referPtr(const T *ptr) { _ptr=ptr; if(_ptr) _ptr->incrRef(); }
     void destroyPtr() { if(_ptr) _ptr->decrRef(); }
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCoupling1GTUMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCoupling1GTUMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCoupling1GTUMesh.cxx	2018-04-19 17:04:36.704222065 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCoupling1GTUMesh.cxx	2018-04-19 17:25:18.048803504 +0200
@@ -145,7 +145,7 @@
  * \a this is composed in cell types.
  * The returned array is of size 3*n where n is the number of different types present in \a this. 
  * For every k in [0,n] ret[3*k+2]==-1 because it has no sense here. 
- * This parameter is kept only for compatibility with other methode listed above.
+ * This parameter is kept only for compatibility with other method listed above.
  */
 std::vector<int> MEDCoupling1GTUMesh::getDistributionOfTypes() const
 {
@@ -178,7 +178,7 @@
  *          - After \a code contains [NORM_...,nbCells,0], \a idsInPflPerType [[0,1]] and \a idsPerType is [[1,2]] <br>
 
  */
-void MEDCoupling1GTUMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const
+void MEDCoupling1GTUMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller) const
 {
   if(!profile)
     throw INTERP_KERNEL::Exception("MEDCoupling1GTUMesh::splitProfilePerType : input profile is NULL !");
@@ -188,7 +188,7 @@
   code.resize(3); idsInPflPerType.resize(1);
   code[0]=(int)getCellModelEnum(); code[1]=nbTuples;
   idsInPflPerType.resize(1);
-  if(profile->isIota(nbOfCells))
+  if(smartPflKiller && profile->isIota(nbOfCells))
     {
       code[2]=-1;
       idsInPflPerType[0]=const_cast<DataArrayInt *>(profile); idsInPflPerType[0]->incrRef();
@@ -1635,7 +1635,7 @@
 }
 
 /*!
- * \return DataArrayInt * - the internal reference to the nodal connectivity. The caller is not reponsible to deallocate it.
+ * \return DataArrayInt * - the internal reference to the nodal connectivity. The caller is not responsible to deallocate it.
  */
 DataArrayInt *MEDCoupling1SGTUMesh::getNodalConnectivity() const
 {
@@ -1646,7 +1646,7 @@
 /*!
  * Allocates memory to store an estimation of the given number of cells. Closer is the estimation to the number of cells effectively inserted,
  * less will be the needs to realloc. If the number of cells to be inserted is not known simply put 0 to this parameter.
- * If a nodal connectivity previouly existed before the call of this method, it will be reset.
+ * If a nodal connectivity previously existed before the call of this method, it will be reset.
  *
  *  \param [in] nbOfCells - estimation of the number of cell \a this mesh will contain.
  */
@@ -1666,7 +1666,7 @@
  * \param [in] nodalConnOfCellEnd - the end (excluded) of nodal connectivity of the cell to add.
  * \throw If the length of the input nodal connectivity array of the cell to add is not equal to number of nodes per cell relative to the unique geometric type
  *        attached to \a this.
- * \thow If the nodal connectivity array in \a this is null (call MEDCoupling1SGTUMesh::allocateCells before).
+ * \throw If the nodal connectivity array in \a this is null (call MEDCoupling1SGTUMesh::allocateCells before).
  */
 void MEDCoupling1SGTUMesh::insertNextCell(const int *nodalConnOfCellBg, const int *nodalConnOfCellEnd)
 {
@@ -3302,7 +3302,7 @@
  * \param [in] nodalConnOfCellEnd - the end (excluded) of nodal connectivity of the cell to add.
  * \throw If the length of the input nodal connectivity array of the cell to add is not equal to number of nodes per cell relative to the unique geometric type
  *        attached to \a this.
- * \thow If the nodal connectivity array in \a this is null (call MEDCoupling1SGTUMesh::allocateCells before).
+ * \throw If the nodal connectivity array in \a this is null (call MEDCoupling1SGTUMesh::allocateCells before).
  */
 void MEDCoupling1DGTUMesh::insertNextCell(const int *nodalConnOfCellBg, const int *nodalConnOfCellEnd)
 {
@@ -3338,7 +3338,7 @@
 }
 
 /*!
- * \return DataArrayInt * - the internal reference to the nodal connectivity. The caller is not reponsible to deallocate it.
+ * \return DataArrayInt * - the internal reference to the nodal connectivity. The caller is not responsible to deallocate it.
  */
 DataArrayInt *MEDCoupling1DGTUMesh::getNodalConnectivity() const
 {
@@ -3347,7 +3347,7 @@
 }
 
 /*!
- * \return DataArrayInt * - the internal reference to the nodal connectivity index. The caller is not reponsible to deallocate it.
+ * \return DataArrayInt * - the internal reference to the nodal connectivity index. The caller is not responsible to deallocate it.
  */
 DataArrayInt *MEDCoupling1DGTUMesh::getNodalConnectivityIndex() const
 {
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCoupling1GTUMesh.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCoupling1GTUMesh.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCoupling1GTUMesh.hxx	2018-04-19 17:04:36.705222084 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCoupling1GTUMesh.hxx	2018-04-19 17:25:18.029803128 +0200
@@ -46,7 +46,7 @@
     MEDCOUPLING_EXPORT INTERP_KERNEL::NormalizedCellType getTypeOfCell(std::size_t cellId) const;
     MEDCOUPLING_EXPORT std::set<INTERP_KERNEL::NormalizedCellType> getAllGeoTypes() const;
     MEDCOUPLING_EXPORT std::vector<int> getDistributionOfTypes() const;
-    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const;
+    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller=true) const;
     MEDCOUPLING_EXPORT DataArrayInt *checkTypeConsistencyAndContig(const std::vector<int>& code, const std::vector<const DataArrayInt *>& idsPerType) const;
     MEDCOUPLING_EXPORT void writeVTKLL(std::ostream& ofs, const std::string& cellData, const std::string& pointData, DataArrayByte *byteData) const;
     MEDCOUPLING_EXPORT std::string getVTKDataSetType() const;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingAMRAttribute.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingAMRAttribute.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingAMRAttribute.cxx	2018-04-19 17:04:36.705222084 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingAMRAttribute.cxx	2018-04-19 17:25:18.120804927 +0200
@@ -802,7 +802,7 @@
 
 /*!
  * Assign the info on components for all DataArrayDouble instance recursively stored in \a this.
- * The first dim of input \a compNames is the field id in the same order than those implicitely specified in \a fieldNames parameter of MEDCouplingAMRAttribute::New.
+ * The first dim of input \a compNames is the field id in the same order than those implicitly specified in \a fieldNames parameter of MEDCouplingAMRAttribute::New.
  * The second dim of \a compNames represent the component names component per component corresponding to the field. The size of this 2nd dimension has
  * to perfectly fit with those specified in MEDCouplingAMRAttribute::New.
  */
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingCartesianAMRMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingCartesianAMRMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingCartesianAMRMesh.cxx	2018-04-19 17:04:36.706222105 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingCartesianAMRMesh.cxx	2018-04-19 17:25:17.991802377 +0200
@@ -385,7 +385,7 @@
 
 /*!
  * \a p1 is expected to be more refined than \a p2. \a p1 and \a p2 have to share a common ancestor. Compared to UpdateNeighborsOfOneWithTwoExt here \a p1 and \a p2 are \b not at the same level !
- * This method has 3 outputs. 2 two first are the resp the position of \a p1 and \a p2 relative to \a p1. And \a factToApplyOn2 is the coeff of refinement to be applied on \a p2 to be virtualy
+ * This method has 3 outputs. 2 two first are the resp the position of \a p1 and \a p2 relative to \a p1. And \a factToApplyOn2 is the coeff of refinement to be applied on \a p2 to be virtually
  * on the same level as \a p1.
  */
 void MEDCouplingCartesianAMRPatch::ComputeZonesOfTwoRelativeToOneDiffLev(int ghostLev, const MEDCouplingCartesianAMRPatch *p1, const MEDCouplingCartesianAMRPatch *p2, std::vector< std::pair<int,int> >& p1Zone, std::vector< std::pair<int,int> >& p2Zone, std::vector<int>& factToApplyOn2)
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingCMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingCMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingCMesh.cxx	2018-04-19 17:04:36.705222084 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingCMesh.cxx	2018-04-19 17:25:18.020802951 +0200
@@ -770,7 +770,7 @@
 
 void MEDCouplingCMesh::renumberCells(const int *old2NewBg, bool check)
 {
-  throw INTERP_KERNEL::Exception("Functionnality of renumbering cell not available for CMesh !");
+  throw INTERP_KERNEL::Exception("Functionality of renumbering cell not available for CMesh !");
 }
 
 void MEDCouplingCMesh::getTinySerializationInformation(std::vector<double>& tinyInfoD, std::vector<int>& tinyInfo, std::vector<std::string>& littleStrings) const
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingCurveLinearMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingCurveLinearMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingCurveLinearMesh.cxx	2018-04-19 17:04:36.706222105 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingCurveLinearMesh.cxx	2018-04-19 17:25:18.098804492 +0200
@@ -255,7 +255,7 @@
   double tt=getTime(tmpp1,tmpp2);
   ret << "Time attached to the mesh [unit] : " << tt << " [" << getTimeUnit() << "]\n";
   ret << "Iteration : " << tmpp1  << " Order : " << tmpp2 << "\n";
-  ret << "The nodal stucture of curve linear mesh is : [";
+  ret << "The nodal structure of curve linear mesh is : [";
   std::copy(_structure.begin(),_structure.end(),std::ostream_iterator<int>(ret,",")); ret << "]\n";
   ret << "The coords array is this : ";
   if((const DataArrayDouble *)_coords)
@@ -375,7 +375,7 @@
 }
 
 /*!
- * \param [in,out] f field feeded with good values.
+ * \param [in,out] f field fed with good values.
  * \sa MEDCouplingCurveLinearMesh::getMeasureField
  */
 void MEDCouplingCurveLinearMesh::getMeasureFieldMeshDim1(bool isAbs, MEDCouplingFieldDouble *field) const
@@ -401,7 +401,7 @@
 }
 
 /*!
- * \param [in,out] f field feeded with good values.
+ * \param [in,out] f field fed with good values.
  * \sa MEDCouplingCurveLinearMesh::getMeasureField
  */
 void MEDCouplingCurveLinearMesh::getMeasureFieldMeshDim2(bool isAbs, MEDCouplingFieldDouble *field) const
@@ -427,7 +427,7 @@
 }
 
 /*!
- * \param [in,out] f field feeded with good values.
+ * \param [in,out] f field fed with good values.
  * \sa MEDCouplingCurveLinearMesh::getMeasureField
  */
 void MEDCouplingCurveLinearMesh::getMeasureFieldMeshDim3(bool isAbs, MEDCouplingFieldDouble *field) const
@@ -733,7 +733,7 @@
 }
 
 /*!
- * \param [in,out] bary Barycenter array feeded with good values.
+ * \param [in,out] bary Barycenter array fed with good values.
  * \sa MEDCouplingCurveLinearMesh::computeCellCenterOfMass
  */
 void MEDCouplingCurveLinearMesh::getBarycenterAndOwnerMeshDim3(DataArrayDouble *bary) const
@@ -759,7 +759,7 @@
 }
 
 /*!
- * \param [in,out] bary Barycenter array feeded with good values.
+ * \param [in,out] bary Barycenter array fed with good values.
  * \sa MEDCouplingCurveLinearMesh::computeCellCenterOfMass
  */
 void MEDCouplingCurveLinearMesh::getBarycenterAndOwnerMeshDim2(DataArrayDouble *bary) const
@@ -782,7 +782,7 @@
 }
 
 /*!
- * \param [in,out] bary Barycenter array feeded with good values.
+ * \param [in,out] bary Barycenter array fed with good values.
  * \sa MEDCouplingCurveLinearMesh::computeCellCenterOfMass
  */
 void MEDCouplingCurveLinearMesh::getBarycenterAndOwnerMeshDim1(DataArrayDouble *bary) const
@@ -794,7 +794,7 @@
 
 void MEDCouplingCurveLinearMesh::renumberCells(const int *old2NewBg, bool check)
 {
-  throw INTERP_KERNEL::Exception("Functionnality of renumbering cell not available for CurveLinear Mesh !");
+  throw INTERP_KERNEL::Exception("Functionality of renumbering cell not available for CurveLinear Mesh !");
 }
 
 void MEDCouplingCurveLinearMesh::getTinySerializationInformation(std::vector<double>& tinyInfoD, std::vector<int>& tinyInfo, std::vector<std::string>& littleStrings) const
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingDefinitionTime.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingDefinitionTime.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingDefinitionTime.cxx	2018-04-19 17:04:36.706222105 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingDefinitionTime.cxx	2018-04-19 17:25:18.101804552 +0200
@@ -53,9 +53,9 @@
         return new MEDCouplingDefinitionTimeSliceLT(f,meshId,arrId[0],arrId[1],fieldId);
       }
     case NO_TIME:
-      throw INTERP_KERNEL::Exception("Invalide time discretization ! NO_TIME ! Impossible to build a definition time slice !");
+      throw INTERP_KERNEL::Exception("Invalid time discretization ! NO_TIME ! Impossible to build a definition time slice !");
     default:
-      throw INTERP_KERNEL::Exception("Invalide time discretization : Not recognized !");
+      throw INTERP_KERNEL::Exception("Invalid time discretization : Not recognized !");
   }
 }
 
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingField.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingField.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingField.cxx	2018-04-19 17:04:36.706222105 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingField.cxx	2018-04-19 17:25:17.999802535 +0200
@@ -34,7 +34,7 @@
     throw INTERP_KERNEL::Exception("MEDCouplingField::checkConsistencyLight : no spatial discretization !");
 }
 
-bool MEDCouplingField::isEqualIfNotWhy(const MEDCouplingField *other, double meshPrec, double valsPrec, std::string& reason) const
+bool MEDCouplingField::isEqualIfNotWhyProtected(const MEDCouplingField *other, double meshPrec, std::string& reason) const
 {
   if(!other)
     throw INTERP_KERNEL::Exception("MEDCouplingField::isEqualIfNotWhy : other instance is NULL !");
@@ -57,7 +57,7 @@
       reason=oss.str();
       return false;
     }
-  if(!_type->isEqualIfNotWhy(other->_type,valsPrec,reason))
+  if(!_type->isEqualIfNotWhy(other->_type,meshPrec,reason))
     {
       reason.insert(0,"Spatial discretizations differ :");
       return false;
@@ -78,36 +78,21 @@
 }
 
 /*!
- * Checks if \a this and another MEDCouplingField are fully equal.
- *  \param [in] other - the field to compare with \a this one.
- *  \param [in] meshPrec - precision used to compare node coordinates of the underlying mesh.
- *  \param [in] valsPrec - precision used to compare field values.
- *  \return bool - \c true if the two fields are equal, \c false else.
- *  \throw If \a other is NULL.
- */
-bool MEDCouplingField::isEqual(const MEDCouplingField *other, double meshPrec, double valsPrec) const
-{
-  std::string tmp;
-  return isEqualIfNotWhy(other,meshPrec,valsPrec,tmp);
-}
-
-/*!
  * Checks if \a this and another MEDCouplingField are equal. The textual
  * information like names etc. is not considered.
  *  \param [in] other - the field to compare with \a this one.
  *  \param [in] meshPrec - precision used to compare node coordinates of the underlying mesh.
- *  \param [in] valsPrec - precision used to compare field values.
  *  \return bool - \c true if the two fields are equal, \c false else.
  *  \throw If \a other is NULL.
  *  \throw If the spatial discretization of \a this field is NULL.
  */
-bool MEDCouplingField::isEqualWithoutConsideringStr(const MEDCouplingField *other, double meshPrec, double valsPrec) const
+bool MEDCouplingField::isEqualWithoutConsideringStrProtected(const MEDCouplingField *other, double meshPrec) const
 {
   if(!other)
     throw INTERP_KERNEL::Exception("MEDCouplingField::isEqualWithoutConsideringStr : input field is NULL !");
   if(!_type)
     throw INTERP_KERNEL::Exception("MEDCouplingField::isEqualWithoutConsideringStr : spatial discretization of this is NULL !");
-  if(!_type->isEqualWithoutConsideringStr(other->_type,valsPrec))
+  if(!_type->isEqualWithoutConsideringStr(other->_type,meshPrec))
     return false;
   if(_nature!=other->_nature)
     return false;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldDiscretization.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldDiscretization.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldDiscretization.cxx	2018-04-19 17:04:36.707222124 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldDiscretization.cxx	2018-04-19 17:25:18.104804611 +0200
@@ -140,7 +140,7 @@
     case MEDCouplingFieldDiscretizationKriging::TYPE:
       return new MEDCouplingFieldDiscretizationKriging;
     default:
-      throw INTERP_KERNEL::Exception("Choosen discretization is not implemented yet.");
+      throw INTERP_KERNEL::Exception("Chosen discretization is not implemented yet.");
   }
 }
 
@@ -361,7 +361,7 @@
 
 /*!
  * This method is typically the first step of renumbering. The implementation is empty it is not a bug only gauss is impacted
- * virtualy by this method.
+ * virtually by this method.
  */
 void MEDCouplingFieldDiscretization::renumberCells(const int *old2NewBg, bool check)
 {
@@ -1183,7 +1183,7 @@
 
 /*!
  * This method is typically the first step of renumbering. The impact on _discr_per_cell is necessary here.
- * virtualy by this method.
+ * virtually by this method.
  */
 void MEDCouplingFieldDiscretizationPerCell::renumberCells(const int *old2NewBg, bool check)
 {
@@ -1663,7 +1663,7 @@
     {
       if(dc[i]>=nbOfDesc)
         {
-          std::ostringstream oss; oss << "Cell # " << i << " of mesh \"" << mesh->getName() << "\" has an undefined gauss location ! Should never happend !";
+          std::ostringstream oss; oss << "Cell # " << i << " of mesh \"" << mesh->getName() << "\" has an undefined gauss location ! Should never happened !";
           throw INTERP_KERNEL::Exception(oss.str().c_str());
         }
       if(dc[i]<0)
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldDouble.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldDouble.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldDouble.cxx	2018-04-19 17:04:36.708222144 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldDouble.cxx	2018-04-19 17:25:18.027803089 +0200
@@ -22,12 +22,14 @@
 #include "MEDCouplingFieldTemplate.hxx"
 #include "MEDCouplingFieldT.txx"
 #include "MEDCouplingFieldInt.hxx"
+#include "MEDCouplingFieldFloat.hxx"
 #include "MEDCouplingUMesh.hxx"
 #include "MEDCouplingTimeDiscretization.hxx"
 #include "MEDCouplingFieldDiscretization.hxx"
 #include "MCAuto.txx"
 #include "MEDCouplingVoronoi.hxx"
 #include "MEDCouplingNatureOfField.hxx"
+#include "MEDCouplingMemArray.txx"
 
 #include "InterpKernelAutoPtr.hxx"
 #include "InterpKernelGaussCoords.hxx"
@@ -188,8 +190,8 @@
 }
 
 /*!
- * This method converts a field on nodes (\a this) to a cell field (returned field). The convertion is a \b non \b conservative remapping !
- * This method is useful only for users that need a fast convertion from node to cell spatial discretization. The algorithm applied is simply to attach
+ * This method converts a field on nodes (\a this) to a cell field (returned field). The conversion is a \b non \b conservative remapping !
+ * This method is useful only for users that need a fast conversion from node to cell spatial discretization. The algorithm applied is simply to attach
  * to each cell the average of values on nodes constituting this cell.
  *
  * \return MEDCouplingFieldDouble* - a new instance of MEDCouplingFieldDouble. The
@@ -244,8 +246,8 @@
 }
 
 /*!
- * This method converts a field on cell (\a this) to a node field (returned field). The convertion is a \b non \b conservative remapping !
- * This method is useful only for users that need a fast convertion from cell to node spatial discretization. The algorithm applied is simply to attach
+ * This method converts a field on cell (\a this) to a node field (returned field). The conversion is a \b non \b conservative remapping !
+ * This method is useful only for users that need a fast conversion from cell to node spatial discretization. The algorithm applied is simply to attach
  * to each node the average of values on cell sharing this node. If \a this lies on a mesh having orphan nodes the values applied on them will be NaN (division by 0.).
  *
  * \return MEDCouplingFieldDouble* - a new instance of MEDCouplingFieldDouble. The
@@ -368,76 +370,6 @@
 }
 
 /*!
- * Permutes values of \a this field according to a given permutation array for cells
- * renumbering. The underlying mesh is deeply copied and its cells are also permuted. 
- * The number of cells remains the same; for that the permutation array \a old2NewBg
- * should not contain equal ids.
- * ** Warning, this method modifies the mesh aggreagated by \a this (by performing a deep copy ) **.
- *
- *  \param [in] old2NewBg - the permutation array in "Old to New" mode. Its length is
- *         to be equal to \a this->getMesh()->getNumberOfCells().
- *  \param [in] check - if \c true, \a old2NewBg is transformed to a new permutation
- *         array, so that its maximal cell id to correspond to (be less than) the number
- *         of cells in mesh. This new array is then used for the renumbering. If \a 
- *         check == \c false, \a old2NewBg is used as is, that is less secure as validity 
- *         of ids in \a old2NewBg is not checked.
- *  \throw If the mesh is not set.
- *  \throw If the spatial discretization of \a this field is NULL.
- *  \throw If \a check == \c true and \a old2NewBg contains equal ids.
- *  \throw If mesh nature does not allow renumbering (e.g. structured mesh).
- * 
- *  \if ENABLE_EXAMPLES
- *  \ref cpp_mcfielddouble_renumberCells "Here is a C++ example".<br>
- *  \ref  py_mcfielddouble_renumberCells "Here is a Python example".
- *  \endif
- */
-void MEDCouplingFieldDouble::renumberCells(const int *old2NewBg, bool check)
-{
-  renumberCellsWithoutMesh(old2NewBg,check);
-  MCAuto<MEDCouplingMesh> m=_mesh->deepCopy();
-  m->renumberCells(old2NewBg,check);
-  setMesh(m);
-  updateTime();
-}
-
-/*!
- * Permutes values of \a this field according to a given permutation array for cells
- * renumbering. The underlying mesh is \b not permuted. 
- * The number of cells remains the same; for that the permutation array \a old2NewBg
- * should not contain equal ids.
- * This method performs a part of job of renumberCells(). The reasonable use of this
- * method is only for multi-field instances lying on the same mesh to avoid a
- * systematic duplication and renumbering of _mesh attribute. 
- * \warning Use this method with a lot of care!
- *  \param [in] old2NewBg - the permutation array in "Old to New" mode. Its length is
- *         to be equal to \a this->getMesh()->getNumberOfCells().
- *  \param [in] check - if \c true, \a old2NewBg is transformed to a new permutation
- *         array, so that its maximal cell id to correspond to (be less than) the number
- *         of cells in mesh. This new array is then used for the renumbering. If \a 
- *         check == \c false, \a old2NewBg is used as is, that is less secure as validity 
- *         of ids in \a old2NewBg is not checked.
- *  \throw If the mesh is not set.
- *  \throw If the spatial discretization of \a this field is NULL.
- *  \throw If \a check == \c true and \a old2NewBg contains equal ids.
- *  \throw If mesh nature does not allow renumbering (e.g. structured mesh).
- */
-void MEDCouplingFieldDouble::renumberCellsWithoutMesh(const int *old2NewBg, bool check)
-{
-  if(!_mesh)
-    throw INTERP_KERNEL::Exception("Expecting a defined mesh to be able to operate a renumbering !");
-  if(_type.isNull())
-    throw INTERP_KERNEL::Exception("Expecting a spatial discretization to be able to operate a renumbering !");
-  //
-  _type->renumberCells(old2NewBg,check);
-  std::vector<DataArrayDouble *> arrays;
-  timeDiscr()->getArrays(arrays);
-  std::vector<DataArray *> arrays2(arrays.size()); std::copy(arrays.begin(),arrays.end(),arrays2.begin());
-  _type->renumberArraysForCell(_mesh,arrays2,old2NewBg,check);
-  //
-  updateTime();
-}
-
-/*!
  * Permutes values of \a this field according to a given permutation array for node
  * renumbering. The underlying mesh is deeply copied and its nodes are also permuted. 
  * The number of nodes can change, contrary to renumberCells().
@@ -449,7 +381,7 @@
  *  \throw If the spatial discretization of \a this field is NULL.
  *  \throw If \a check == \c true and \a old2NewBg contains equal ids.
  *  \throw If mesh nature does not allow renumbering (e.g. structured mesh).
- *  \throw If values at merged nodes deffer more than \a eps.
+ *  \throw If values at merged nodes differ more than \a eps.
  * 
  *  \if ENABLE_EXAMPLES
  *  \ref cpp_mcfielddouble_renumberNodes "Here is a C++ example".<br>
@@ -489,7 +421,7 @@
  *         the values differ more than \a eps, an exception is thrown.
  *  \throw If the mesh is not set.
  *  \throw If the spatial discretization of \a this field is NULL.
- *  \throw If values at merged nodes deffer more than \a eps.
+ *  \throw If values at merged nodes differ more than \a eps.
  */
 void MEDCouplingFieldDouble::renumberNodesWithoutMesh(const int *old2NewBg, int newNbOfNodes, double eps)
 {
@@ -522,21 +454,32 @@
   return getArray()->findIdsInRange(vmin,vmax);
 }
 
-MEDCouplingFieldInt *MEDCouplingFieldDouble::convertToIntField() const
+template<class U>
+typename Traits<U>::FieldType *ConvertToUField(const MEDCouplingFieldDouble *self)
 {
-  MCAuto<MEDCouplingFieldTemplate> tmp(MEDCouplingFieldTemplate::New(*this));
+  MCAuto<MEDCouplingFieldTemplate> tmp(MEDCouplingFieldTemplate::New(*self));
   int t1,t2;
-  double t0(getTime(t1,t2));
-  MCAuto<MEDCouplingFieldInt> ret(MEDCouplingFieldInt::New(*tmp,getTimeDiscretization()));
+  double t0(self->getTime(t1,t2));
+  MCAuto<typename Traits<U>::FieldType > ret(Traits<U>::FieldType::New(*tmp,self->getTimeDiscretization()));
   ret->setTime(t0,t1,t2);
-  if(getArray())
+  if(self->getArray())
     {
-      MCAuto<DataArrayInt> arr(getArray()->convertToIntArr());
+      MCAuto<typename Traits<U>::ArrayType> arr(self->getArray()->convertToOtherTypeOfArr<U>());
       ret->setArray(arr);
     }
   return ret.retn();
 }
 
+MEDCouplingFieldInt *MEDCouplingFieldDouble::convertToIntField() const
+{
+  return ConvertToUField<int>(this);
+}
+
+MEDCouplingFieldFloat *MEDCouplingFieldDouble::convertToFloatField() const
+{
+  return ConvertToUField<float>(this);
+}
+
 MEDCouplingFieldDouble::MEDCouplingFieldDouble(TypeOfField type, TypeOfTimeDiscretization td):MEDCouplingFieldT<double>(type,MEDCouplingTimeDiscretization::New(td))
 {
 }
@@ -616,7 +559,7 @@
 /*!
  * Returns the maximal value and all its locations within \a this scalar field.
  * Only the first of available data arrays is checked.
- *  \param [out] tupleIds - a new instance of DataArrayInt containg indices of
+ *  \param [out] tupleIds - a new instance of DataArrayInt containing indices of
  *               tuples holding the maximal value. The caller is to delete it using
  *               decrRef() as it is no more needed.
  *  \return double - the maximal value among all values of the first array of \a this filed.
@@ -680,7 +623,7 @@
 /*!
  * Returns the minimal value and all its locations within \a this scalar field.
  * Only the first of available data arrays is checked.
- *  \param [out] tupleIds - a new instance of DataArrayInt containg indices of
+ *  \param [out] tupleIds - a new instance of DataArrayInt containing indices of
  *               tuples holding the minimal value. The caller is to delete it using
  *               decrRef() as it is no more needed.
  *  \return double - the minimal value among all values of the first array of \a this filed.
@@ -1644,7 +1587,7 @@
  *  \throw If \a other == NULL.
  *  \throw If any of the meshes is not well defined.
  *  \throw If the two meshes do not match.
- *  \throw If field values at merged nodes (if any) deffer more than \a eps.
+ *  \throw If field values at merged nodes (if any) differ more than \a eps.
  *
  *  \if ENABLE_EXAMPLES
  *  \ref cpp_mcfielddouble_changeUnderlyingMesh "Here is a C++ example".<br>
@@ -1692,7 +1635,7 @@
  *  \throw If any of the meshes is not set or is not well defined.
  *  \throw If the two meshes do not match.
  *  \throw If the two fields are not coherent for merge.
- *  \throw If field values at merged nodes (if any) deffer more than \a eps.
+ *  \throw If field values at merged nodes (if any) differ more than \a eps.
  *
  *  \if ENABLE_EXAMPLES
  *  \ref cpp_mcfielddouble_substractInPlaceDM "Here is a C++ example".<br>
@@ -1725,7 +1668,7 @@
  *  \throw If the mesh is not well defined.
  *  \throw If the spatial discretization of \a this field is NULL.
  *  \throw If the data array is not set.
- *  \throw If field values at merged nodes (if any) deffer more than \a epsOnVals.
+ *  \throw If field values at merged nodes (if any) differ more than \a epsOnVals.
  */
 bool MEDCouplingFieldDouble::mergeNodes(double eps, double epsOnVals)
 {
@@ -1764,7 +1707,7 @@
  *  \throw If the mesh is not well defined.
  *  \throw If the spatial discretization of \a this field is NULL.
  *  \throw If the data array is not set.
- *  \throw If field values at merged nodes (if any) deffer more than \a epsOnVals.
+ *  \throw If field values at merged nodes (if any) differ more than \a epsOnVals.
  */
 bool MEDCouplingFieldDouble::mergeNodesCenter(double eps, double epsOnVals)
 {
@@ -1801,7 +1744,7 @@
  *  \throw If the mesh is not well defined.
  *  \throw If the spatial discretization of \a this field is NULL.
  *  \throw If the data array is not set.
- *  \throw If field values at merged nodes (if any) deffer more than \a epsOnVals.
+ *  \throw If field values at merged nodes (if any) differ more than \a epsOnVals.
  */
 bool MEDCouplingFieldDouble::zipCoords(double epsOnVals)
 {
@@ -1842,7 +1785,7 @@
  *  \throw If the mesh is not well defined.
  *  \throw If the spatial discretization of \a this field is NULL.
  *  \throw If the data array is not set.
- *  \throw If field values at merged cells (if any) deffer more than \a epsOnVals.
+ *  \throw If field values at merged cells (if any) differ more than \a epsOnVals.
  */
 bool MEDCouplingFieldDouble::zipConnectivity(int compType, double epsOnVals)
 {
@@ -2070,7 +2013,7 @@
 
 /*!
  * This is expected to be a 3 components vector field on nodes (if not an exception will be thrown). \a this is also expected to lie on a MEDCouplingPointSet mesh.
- * Finaly \a this is also expected to be consistent.
+ * Finally \a this is also expected to be consistent.
  * In these conditions this method returns a newly created field (to be dealed by the caller).
  * The returned field will also 3 compo vector field be on nodes lying on the same mesh than \a this.
  * 
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldDouble.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldDouble.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldDouble.hxx	2018-04-19 17:04:36.708222144 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldDouble.hxx	2018-04-19 17:25:17.994802437 +0200
@@ -41,8 +41,6 @@
     MEDCOUPLING_EXPORT std::string writeVTK(const std::string& fileName, bool isBinary=true) const;
     MEDCOUPLING_EXPORT bool areCompatibleForMerge(const MEDCouplingField *other) const;
     MEDCOUPLING_EXPORT bool areCompatibleForMeld(const MEDCouplingFieldDouble *other) const;
-    MEDCOUPLING_EXPORT void renumberCells(const int *old2NewBg, bool check=true);
-    MEDCOUPLING_EXPORT void renumberCellsWithoutMesh(const int *old2NewBg, bool check=true);
     MEDCOUPLING_EXPORT void renumberNodes(const int *old2NewBg, double eps=1e-15);
     MEDCOUPLING_EXPORT void renumberNodesWithoutMesh(const int *old2NewBg, int newNbOfNodes, double eps=1e-15);
     MEDCOUPLING_EXPORT DataArrayInt *findIdsInRange(double vmin, double vmax) const;
@@ -52,6 +50,7 @@
     MEDCOUPLING_EXPORT MEDCouplingFieldDouble *nodeToCellDiscretization() const;
     MEDCOUPLING_EXPORT MEDCouplingFieldDouble *cellToNodeDiscretization() const;
     MEDCOUPLING_EXPORT MEDCouplingFieldInt *convertToIntField() const;
+    MEDCOUPLING_EXPORT MEDCouplingFieldFloat *convertToFloatField() const;
     MEDCOUPLING_EXPORT double getIJK(int cellId, int nodeIdInCell, int compoId) const;
     MEDCOUPLING_EXPORT double accumulate(int compId) const;
     MEDCOUPLING_EXPORT void accumulate(double *res) const;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingField.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingField.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingField.hxx	2018-04-19 17:04:36.706222105 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingField.hxx	2018-04-19 17:25:18.045803445 +0200
@@ -48,9 +48,6 @@
     MEDCOUPLING_EXPORT virtual bool areCompatibleForMerge(const MEDCouplingField *other) const;
     MEDCOUPLING_EXPORT virtual bool areStrictlyCompatible(const MEDCouplingField *other) const;
     MEDCOUPLING_EXPORT virtual bool areStrictlyCompatibleForMulDiv(const MEDCouplingField *other) const;
-    MEDCOUPLING_EXPORT virtual bool isEqualIfNotWhy(const MEDCouplingField *other, double meshPrec, double valsPrec, std::string& reason) const;
-    MEDCOUPLING_EXPORT virtual bool isEqual(const MEDCouplingField *other, double meshPrec, double valsPrec) const;
-    MEDCOUPLING_EXPORT virtual bool isEqualWithoutConsideringStr(const MEDCouplingField *other, double meshPrec, double valsPrec) const;
     MEDCOUPLING_EXPORT virtual void copyTinyStringsFrom(const MEDCouplingField *other);
     MEDCOUPLING_EXPORT void setMesh(const MEDCoupling::MEDCouplingMesh *mesh);
     MEDCOUPLING_EXPORT const MEDCoupling::MEDCouplingMesh *getMesh() const { return _mesh; }
@@ -96,6 +93,8 @@
     MEDCOUPLING_EXPORT MEDCouplingField(const MEDCouplingField& other, bool deepCopy=true);
     MEDCOUPLING_EXPORT MEDCouplingField(MEDCouplingFieldDiscretization *type, NatureOfField nature=NoNature);
     MEDCOUPLING_EXPORT virtual ~MEDCouplingField();
+    MEDCOUPLING_EXPORT bool isEqualIfNotWhyProtected(const MEDCouplingField *other, double meshPrec, std::string& reason) const;
+    MEDCOUPLING_EXPORT bool isEqualWithoutConsideringStrProtected(const MEDCouplingField *other, double meshPrec) const;
   protected:
     std::string _name;
     std::string _desc;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldTemplate.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldTemplate.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldTemplate.cxx	2018-04-19 17:04:36.708222144 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldTemplate.cxx	2018-04-19 17:25:18.095804433 +0200
@@ -59,6 +59,22 @@
   return new MEDCouplingFieldTemplate(f,false);
 }
 
+bool MEDCouplingFieldTemplate::isEqualIfNotWhy(const MEDCouplingFieldTemplate *other, double meshPrec, std::string& reason) const
+{
+  return isEqualIfNotWhyProtected(other,meshPrec,reason);
+}
+
+bool MEDCouplingFieldTemplate::isEqual(const MEDCouplingFieldTemplate *other, double meshPrec) const
+{
+  std::string tmp;
+  return isEqualIfNotWhyProtected(other,meshPrec,tmp);
+}
+
+bool MEDCouplingFieldTemplate::isEqualWithoutConsideringStr(const MEDCouplingFieldTemplate *other, double meshPrec) const
+{
+  return isEqualWithoutConsideringStrProtected(other,meshPrec);
+}
+
 /*!
  * The user should \b not use this method. Only useful for CORBA serialization/unserialization.
  */
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldTemplate.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldTemplate.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldTemplate.hxx	2018-04-19 17:04:36.708222144 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldTemplate.hxx	2018-04-19 17:25:18.043803405 +0200
@@ -48,6 +48,9 @@
     MEDCOUPLING_EXPORT static MEDCouplingFieldTemplate *NewWithoutCheck(const MEDCouplingFieldDouble& f);
     MEDCOUPLING_EXPORT static MEDCouplingFieldTemplate *NewWithoutCheck(const MEDCouplingFieldFloat& f);
     MEDCOUPLING_EXPORT static MEDCouplingFieldTemplate *NewWithoutCheck(const MEDCouplingFieldInt& f);
+    MEDCOUPLING_EXPORT bool isEqualIfNotWhy(const MEDCouplingFieldTemplate *other, double meshPrec, std::string& reason) const;
+    MEDCOUPLING_EXPORT bool isEqual(const MEDCouplingFieldTemplate *other, double meshPrec) const;
+    MEDCOUPLING_EXPORT bool isEqualWithoutConsideringStr(const MEDCouplingFieldTemplate *other, double meshPrec) const;
     MEDCOUPLING_EXPORT std::string simpleRepr() const;
     MEDCOUPLING_EXPORT std::string advancedRepr() const;
     MEDCOUPLING_EXPORT void checkConsistencyLight() const;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldT.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldT.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldT.hxx	2018-04-19 17:04:36.708222144 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldT.hxx	2018-04-19 17:25:18.038803306 +0200
@@ -75,8 +75,9 @@
     MEDCOUPLING_EXPORT double getStartTime(int& iteration, int& order) const { return _time_discr->getStartTime(iteration,order); }
     MEDCOUPLING_EXPORT double getEndTime(int& iteration, int& order) const { return _time_discr->getEndTime(iteration,order); }
     MEDCOUPLING_EXPORT T getIJ(int tupleId, int compoId) const { return getArray()->getIJ(tupleId,compoId); }
-    MEDCOUPLING_EXPORT bool isEqualIfNotWhy(const MEDCouplingField *other, double meshPrec, double valsPrec, std::string& reason) const;
-    MEDCOUPLING_EXPORT bool isEqualWithoutConsideringStr(const MEDCouplingField *other, double meshPrec, double valsPrec) const;
+    MEDCOUPLING_EXPORT virtual bool isEqual(const MEDCouplingFieldT<T> *other, double meshPrec, T valsPrec) const;
+    MEDCOUPLING_EXPORT virtual bool isEqualIfNotWhy(const MEDCouplingFieldT<T> *other, double meshPrec, T valsPrec, std::string& reason) const;
+    MEDCOUPLING_EXPORT virtual bool isEqualWithoutConsideringStr(const MEDCouplingFieldT<T> *other, double meshPrec, T valsPrec) const;
     MEDCOUPLING_EXPORT void copyTinyStringsFrom(const MEDCouplingField *other);
     MEDCOUPLING_EXPORT bool areStrictlyCompatible(const MEDCouplingField *other) const;
     MEDCOUPLING_EXPORT bool areStrictlyCompatibleForMulDiv(const MEDCouplingField *other) const;
@@ -87,6 +88,8 @@
     MEDCOUPLING_EXPORT bool areCompatibleForDiv(const MEDCouplingField *other) const;
     MEDCOUPLING_EXPORT void copyTinyAttrFrom(const MEDCouplingFieldT<T> *other);
     MEDCOUPLING_EXPORT void copyAllTinyAttrFrom(const MEDCouplingFieldT<T> *other);
+    MEDCOUPLING_EXPORT void renumberCells(const int *old2NewBg, bool check=true);
+    MEDCOUPLING_EXPORT void renumberCellsWithoutMesh(const int *old2NewBg, bool check=true);
     //
     MEDCOUPLING_EXPORT void getTinySerializationIntInformation(std::vector<int>& tinyInfo) const;
     MEDCOUPLING_EXPORT void getTinySerializationDbleInformation(std::vector<double>& tinyInfo) const;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldT.txx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldT.txx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingFieldT.txx	2018-04-19 17:04:36.708222144 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingFieldT.txx	2018-04-19 17:25:18.037803287 +0200
@@ -117,21 +117,22 @@
       }
     return ret.retn();
   }
+
+  template<class T>
+  bool MEDCouplingFieldT<T>::isEqual(const MEDCouplingFieldT<T> *other, double meshPrec, T valsPrec) const
+  {
+    std::string tmp;
+    return isEqualIfNotWhy(other,meshPrec,valsPrec,tmp);
+  }
   
   template<class T>
-  bool MEDCouplingFieldT<T>::isEqualIfNotWhy(const MEDCouplingField *other, double meshPrec, double valsPrec, std::string& reason) const
+  bool MEDCouplingFieldT<T>::isEqualIfNotWhy(const MEDCouplingFieldT<T> *other, double meshPrec, T valsPrec, std::string& reason) const
   {
     if(!other)
       throw INTERP_KERNEL::Exception("MEDCouplingFieldT::isEqualIfNotWhy : other instance is NULL !");
-    const MEDCouplingFieldT<T> *otherC(dynamic_cast<const MEDCouplingFieldT<T> *>(other));
-    if(!otherC)
-      {
-        reason="field given in input is not castable in MEDCouplingFieldT !";
-        return false;
-      }
-    if(!MEDCouplingField::isEqualIfNotWhy(other,meshPrec,valsPrec,reason))
+    if(!isEqualIfNotWhyProtected(other,meshPrec,reason))
       return false;
-    if(!_time_discr->isEqualIfNotWhy(otherC->_time_discr,T(valsPrec),reason))
+    if(!_time_discr->isEqualIfNotWhy(other->_time_discr,T(valsPrec),reason))
       {
         reason.insert(0,"In FieldT time discretizations differ :");
         return false;
@@ -150,14 +151,13 @@
    *  \throw If the spatial discretization of \a this field is NULL.
    */
   template<class T>
-  bool MEDCouplingFieldT<T>::isEqualWithoutConsideringStr(const MEDCouplingField *other, double meshPrec, double valsPrec) const
+  bool MEDCouplingFieldT<T>::isEqualWithoutConsideringStr(const MEDCouplingFieldT<T> *other, double meshPrec, T valsPrec) const
   {
-    const MEDCouplingFieldT<T> *otherC(dynamic_cast<const MEDCouplingFieldT<T> *>(other));
-    if(!otherC)
+    if(!other)
       return false;
-    if(!MEDCouplingField::isEqualWithoutConsideringStr(other,meshPrec,valsPrec))
+    if(!isEqualWithoutConsideringStrProtected(other,meshPrec))
       return false;
-    if(!_time_discr->isEqualWithoutConsideringStr(otherC->_time_discr,T(valsPrec)))
+    if(!_time_discr->isEqualWithoutConsideringStr(other->_time_discr,valsPrec))
       return false;
     return true;
   }
@@ -204,6 +204,78 @@
   }
   
   /*!
+   * Permutes values of \a this field according to a given permutation array for cells
+   * renumbering. The underlying mesh is deeply copied and its cells are also permuted. 
+   * The number of cells remains the same; for that the permutation array \a old2NewBg
+   * should not contain equal ids.
+   * ** Warning, this method modifies the mesh aggreagated by \a this (by performing a deep copy ) **.
+   *
+   *  \param [in] old2NewBg - the permutation array in "Old to New" mode. Its length is
+   *         to be equal to \a this->getMesh()->getNumberOfCells().
+   *  \param [in] check - if \c true, \a old2NewBg is transformed to a new permutation
+   *         array, so that its maximal cell id to correspond to (be less than) the number
+   *         of cells in mesh. This new array is then used for the renumbering. If \a 
+   *         check == \c false, \a old2NewBg is used as is, that is less secure as validity 
+   *         of ids in \a old2NewBg is not checked.
+   *  \throw If the mesh is not set.
+   *  \throw If the spatial discretization of \a this field is NULL.
+   *  \throw If \a check == \c true and \a old2NewBg contains equal ids.
+   *  \throw If mesh nature does not allow renumbering (e.g. structured mesh).
+   * 
+   *  \if ENABLE_EXAMPLES
+   *  \ref cpp_mcfielddouble_renumberCells "Here is a C++ example".<br>
+   *  \ref  py_mcfielddouble_renumberCells "Here is a Python example".
+   *  \endif
+   */
+  template<class T>
+  void MEDCouplingFieldT<T>::renumberCells(const int *old2NewBg, bool check)
+  {
+    renumberCellsWithoutMesh(old2NewBg,check);
+    MCAuto<MEDCouplingMesh> m(_mesh->deepCopy());
+    m->renumberCells(old2NewBg,check);
+    setMesh(m);
+    updateTime();
+  }
+
+  /*!
+   * Permutes values of \a this field according to a given permutation array for cells
+   * renumbering. The underlying mesh is \b not permuted. 
+   * The number of cells remains the same; for that the permutation array \a old2NewBg
+   * should not contain equal ids.
+   * This method performs a part of job of renumberCells(). The reasonable use of this
+   * method is only for multi-field instances lying on the same mesh to avoid a
+   * systematic duplication and renumbering of _mesh attribute. 
+   * \warning Use this method with a lot of care!
+   *  \param [in] old2NewBg - the permutation array in "Old to New" mode. Its length is
+   *         to be equal to \a this->getMesh()->getNumberOfCells().
+   *  \param [in] check - if \c true, \a old2NewBg is transformed to a new permutation
+   *         array, so that its maximal cell id to correspond to (be less than) the number
+   *         of cells in mesh. This new array is then used for the renumbering. If \a 
+   *         check == \c false, \a old2NewBg is used as is, that is less secure as validity 
+   *         of ids in \a old2NewBg is not checked.
+   *  \throw If the mesh is not set.
+   *  \throw If the spatial discretization of \a this field is NULL.
+   *  \throw If \a check == \c true and \a old2NewBg contains equal ids.
+   *  \throw If mesh nature does not allow renumbering (e.g. structured mesh).
+   */
+  template<class T>
+  void MEDCouplingFieldT<T>::renumberCellsWithoutMesh(const int *old2NewBg, bool check)
+  {
+    if(!_mesh)
+      throw INTERP_KERNEL::Exception("Expecting a defined mesh to be able to operate a renumbering !");
+    if(_type.isNull())
+      throw INTERP_KERNEL::Exception("Expecting a spatial discretization to be able to operate a renumbering !");
+    //
+    _type->renumberCells(old2NewBg,check);
+    std::vector< typename MEDCoupling::Traits<T>::ArrayType *> arrays;
+    timeDiscrSafe()->getArrays(arrays);
+    std::vector<DataArray *> arrays2(arrays.size()); std::copy(arrays.begin(),arrays.end(),arrays2.begin());
+    _type->renumberArraysForCell(_mesh,arrays2,old2NewBg,check);
+    //
+    updateTime();
+  }
+  
+  /*!
    * This method is more strict than MEDCouplingField::areCompatibleForMerge method.
    * This method is used for operation on fields to operate a first check before attempting operation.
    */
@@ -369,7 +441,7 @@
   }
 
   /*!
-   * Builds a newly created field, that the caller will have the responsability to deal with.
+   * Builds a newly created field, that the caller will have the responsibility to deal with.
    * \n This method makes the assumption that \a this field is correctly defined when this method is called (\a this->checkConsistencyLight() returns without any exception thrown), **no check of this will be done**.
    * \n This method returns a restriction of \a this so that only tuple ids specified in [ \a partBg , \a partEnd ) will be contained in the returned field.
    * \n Parameter [\a partBg, \a partEnd ) specifies **cell ids whatever the spatial discretization** of \a this (
@@ -432,7 +504,7 @@
   }
 
   /*!
-   * Builds a newly created field, that the caller will have the responsability to deal with (decrRef()).
+   * Builds a newly created field, that the caller will have the responsibility to deal with (decrRef()).
    * This method makes the assumption that the field is correctly defined when this method is called, no check of this will be done.
    * This method returns a restriction of \a this so that only tuples with ids specified in \a part will be contained in the returned field.
    * Parameter \a part specifies **cell ids whatever the spatial discretization of this** (
@@ -646,7 +718,7 @@
   }
 
   /*!
-   * Contrary to MEDCouplingPointSet class the returned arrays are \b not the responsabilities of the caller.
+   * Contrary to MEDCouplingPointSet class the returned arrays are \b not the responsibilities of the caller.
    * The values returned must be consulted only in readonly mode.
    */
   template<class T>
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingIMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingIMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingIMesh.cxx	2018-04-19 17:04:36.709222164 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingIMesh.cxx	2018-04-19 17:25:18.019802931 +0200
@@ -270,7 +270,7 @@
 
 /*!
  * This static method is useful to condense field on cells of a MEDCouplingIMesh instance coming from a refinement ( MEDCouplingIMesh::refineWithFactor for example)
- * to a coarse MEDCouplingIMesh instance. So this method can be seen as a specialization in P0P0 conservative interpolation non overlaping from fine image mesh
+ * to a coarse MEDCouplingIMesh instance. So this method can be seen as a specialization in P0P0 conservative interpolation non overlapping from fine image mesh
  * to a coarse image mesh. Only tuples ( deduced from \a fineLocInCoarse ) of \a coarseDA will be modified. Other tuples of \a coarseDA will be let unchanged.
  *
  * \param [in] coarseSt The cell structure of coarse mesh.
@@ -396,7 +396,7 @@
 
 /*!
  * This static method is useful to condense field on cells of a MEDCouplingIMesh instance coming from a refinement ( MEDCouplingIMesh::refineWithFactor for example)
- * to a coarse MEDCouplingIMesh instance. So this method can be seen as a specialization in P0P0 conservative interpolation non overlaping from fine image mesh
+ * to a coarse MEDCouplingIMesh instance. So this method can be seen as a specialization in P0P0 conservative interpolation non overlapping from fine image mesh
  * to a coarse image mesh. Only tuples ( deduced from \a fineLocInCoarse ) of \a coarseDA will be modified. Other tuples of \a coarseDA will be let unchanged.
  *
  * \param [in] coarseSt The cell structure of coarse mesh.
@@ -1232,7 +1232,7 @@
 
 void MEDCouplingIMesh::renumberCells(const int *old2NewBg, bool check)
 {
-  throw INTERP_KERNEL::Exception("Functionnality of renumbering cell not available for IMesh !");
+  throw INTERP_KERNEL::Exception("Functionality of renumbering cell not available for IMesh !");
 }
 
 void MEDCouplingIMesh::getTinySerializationInformation(std::vector<double>& tinyInfoD, std::vector<int>& tinyInfo, std::vector<std::string>& littleStrings) const
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.cxx	2018-04-19 17:04:36.709222164 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.cxx	2018-04-19 17:25:17.989802338 +0200
@@ -178,7 +178,7 @@
 
 const DataArrayDouble *MEDCouplingMappedExtrudedMesh::getDirectAccessOfCoordsArrIfInStructure() const
 {
-  throw INTERP_KERNEL::Exception("MEDCouplingMappedExtrudedMesh::getDirectAccessOfCoordsArrIfInStructure : no direct acess of DataArrayDouble holding nodes !");
+  throw INTERP_KERNEL::Exception("MEDCouplingMappedExtrudedMesh::getDirectAccessOfCoordsArrIfInStructure : no direct access of DataArrayDouble holding nodes !");
 }
 
 bool MEDCouplingMappedExtrudedMesh::isEqualIfNotWhy(const MEDCouplingMesh *other, double prec, std::string& reason) const
@@ -442,7 +442,7 @@
 
 void MEDCouplingMappedExtrudedMesh::renumberCells(const int *old2NewBg, bool check)
 {
-  throw INTERP_KERNEL::Exception("Functionnality of renumbering cells unavailable for ExtrudedMesh");
+  throw INTERP_KERNEL::Exception("Functionality of renumbering cells unavailable for ExtrudedMesh");
 }
 
 /*!
@@ -709,7 +709,7 @@
   throw INTERP_KERNEL::Exception("Not implemented yet !");
 }
 
-void MEDCouplingMappedExtrudedMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const
+void MEDCouplingMappedExtrudedMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller) const
 {
   throw INTERP_KERNEL::Exception("Not implemented yet !");
 }
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.hxx	2018-04-19 17:04:36.709222164 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMappedExtrudedMesh.hxx	2018-04-19 17:25:18.036803267 +0200
@@ -92,7 +92,7 @@
     MEDCOUPLING_EXPORT void scale(const double *point, double factor);
     MEDCOUPLING_EXPORT std::vector<int> getDistributionOfTypes() const;
     MEDCOUPLING_EXPORT DataArrayInt *checkTypeConsistencyAndContig(const std::vector<int>& code, const std::vector<const DataArrayInt *>& idsPerType) const;
-    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const;
+    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller=true) const;
     MEDCOUPLING_EXPORT MEDCouplingMesh *buildPart(const int *start, const int *end) const;
     MEDCOUPLING_EXPORT MEDCouplingMesh *buildPartAndReduceNodes(const int *start, const int *end, DataArrayInt*& arr) const;
     MEDCOUPLING_EXPORT DataArrayInt *simplexize(int policy);
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArrayChar.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArrayChar.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArrayChar.cxx	2018-04-19 17:04:36.714222264 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArrayChar.cxx	2018-04-19 17:25:18.138805283 +0200
@@ -845,7 +845,7 @@
 {
   std::size_t lgth=st.length();
   if(lgth==0)
-    throw INTERP_KERNEL::Exception("DataArrayAsciiChar contructor with string ! Size of input string is null !");
+    throw INTERP_KERNEL::Exception("DataArrayAsciiChar constructor with string ! Size of input string is null !");
   alloc(1,lgth);
   std::copy(st.begin(),st.begin()+lgth,getPointer());
 }
@@ -882,12 +882,12 @@
 DataArrayAsciiChar::DataArrayAsciiChar(const std::vector<std::string>& vst, char defaultChar)
 {
   if(vst.empty())
-    throw INTERP_KERNEL::Exception("DataArrayAsciiChar contructor with vector of strings ! Empty array !");
+    throw INTERP_KERNEL::Exception("DataArrayAsciiChar constructor with vector of strings ! Empty array !");
   std::size_t nbCompo=0;
   for(std::vector<std::string>::const_iterator it=vst.begin();it!=vst.end();it++)
     nbCompo=std::max(nbCompo,(*it).length());
   if(nbCompo==0)
-    throw INTERP_KERNEL::Exception("DataArrayAsciiChar contructor with vector of strings ! All strings in not empty vector are empty !");
+    throw INTERP_KERNEL::Exception("DataArrayAsciiChar constructor with vector of strings ! All strings in not empty vector are empty !");
   int nbTuples=(int)vst.size();
   alloc(nbTuples,(int)nbCompo);
   char *pt=getPointer();
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArray.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArray.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArray.cxx	2018-04-19 17:04:36.713222244 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArray.cxx	2018-04-19 17:25:18.118804888 +0200
@@ -25,6 +25,12 @@
 #include "InterpKernelAutoPtr.hxx"
 #include "InterpKernelExprParser.hxx"
 
+#include "InterpKernelAutoPtr.hxx"
+#include "InterpKernelGeo2DEdgeArcCircle.hxx"
+#include "InterpKernelAutoPtr.hxx"
+#include "InterpKernelGeo2DNode.hxx"
+#include "InterpKernelGeo2DEdgeLin.hxx"
+
 #include <set>
 #include <cmath>
 #include <limits>
@@ -631,7 +637,7 @@
 
 /*!
  * This method checks that [\b start, \b end) is compliant with ref length \b value.
- * typicaly start in [0,\b value) and end in [0,\b value). If value==start and start==end, it is supported.
+ * typically start in [0,\b value) and end in [0,\b value). If value==start and start==end, it is supported.
  */
 void DataArray::CheckValueInRangeEx(int value, int start, int end, const std::string& msg)
 {
@@ -665,9 +671,9 @@
  *
  * The input \a sliceId should be an id in [0, \a nbOfSlices) that specifies the slice of work.
  *
- * \param [in] start - the start of the input slice of the whole work to perform splitted into slices.
- * \param [in] stop - the stop of the input slice of the whole work to perform splitted into slices.
- * \param [in] step - the step (that can be <0) of the input slice of the whole work to perform splitted into slices.
+ * \param [in] start - the start of the input slice of the whole work to perform split into slices.
+ * \param [in] stop - the stop of the input slice of the whole work to perform split into slices.
+ * \param [in] step - the step (that can be <0) of the input slice of the whole work to perform split into slices.
  * \param [in] sliceId - the slice id considered
  * \param [in] nbOfSlices - the number of slices (typically the number of cores on which the work is expected to be sliced)
  * \param [out] startSlice - the start of the slice considered
@@ -1517,7 +1523,7 @@
 
 /*!
  * Returns the maximal value and all its locations within \a this one-dimensional array.
- *  \param [out] tupleIds - a new instance of DataArrayInt containg indices of
+ *  \param [out] tupleIds - a new instance of DataArrayInt containing indices of
  *               tuples holding the maximal value. The caller is to delete it using
  *               decrRef() as it is no more needed.
  *  \return double - the maximal value among all values of \a this array.
@@ -1535,7 +1541,7 @@
 
 /*!
  * Returns the minimal value and all its locations within \a this one-dimensional array.
- *  \param [out] tupleIds - a new instance of DataArrayInt containg indices of
+ *  \param [out] tupleIds - a new instance of DataArrayInt containing indices of
  *               tuples holding the minimal value. The caller is to delete it using
  *               decrRef() as it is no more needed.
  *  \return double - the minimal value among all values of \a this array.
@@ -1611,7 +1617,7 @@
 
 /*!
  * Returns the maximum norm of the vector defined by \a this array.
- * This method works even if the number of components is diferent from one.
+ * This method works even if the number of components is different from one.
  * If the number of elements in \a this is 0, -1. is returned.
  *  \return double - the value of the maximum norm, i.e.
  *          the maximal absolute value among values of \a this array (whatever its number of components).
@@ -1634,7 +1640,7 @@
 
 /*!
  * Returns the minimum norm (absolute value) of the vector defined by \a this array.
- * This method works even if the number of components is diferent from one.
+ * This method works even if the number of components is different from one.
  * If the number of elements in \a this is 0, std::numeric_limits<double>::max() is returned.
  *  \return double - the value of the minimum norm, i.e.
  *          the minimal absolute value among values of \a this array (whatever its number of components).
@@ -2490,6 +2496,38 @@
 }
 
 /*!
+ * This method expects that \a this stores 3 tuples containing 2 components each.
+ * Each of this tuples represent a point into 2D space.
+ * This method tries to find an arc of circle starting from first point (tuple) to 2nd and middle point (tuple) along 3nd and last point (tuple).
+ * If such arc of circle exists, the corresponding center, radius of circle is returned. And additionnaly the length of arc expressed with an \a ang output variable in ]0,2*pi[.
+ *  
+ *  \throw If \a this is not allocated.
+ *  \throw If \a this has not 3 tuples of 2 components
+ *  \throw If tuples/points in \a this are aligned
+ */
+void DataArrayDouble::asArcOfCircle(double center[2], double& radius, double& ang) const
+{
+  checkAllocated();
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(1e-14);
+  if(getNumberOfTuples()!=3 && getNumberOfComponents()!=2)
+    throw INTERP_KERNEL::Exception("DataArrayDouble::asArcCircle : this method expects");
+  const double *pt(begin());
+  MCAuto<INTERP_KERNEL::Node> n0(new INTERP_KERNEL::Node(pt[0],pt[1])),n1(new INTERP_KERNEL::Node(pt[2],pt[3])),n2(new INTERP_KERNEL::Node(pt[4],pt[5]));
+  {
+    INTERP_KERNEL::AutoCppPtr<INTERP_KERNEL::EdgeLin> e1(new INTERP_KERNEL::EdgeLin(n0,n2)),e2(new INTERP_KERNEL::EdgeLin(n2,n1));
+    INTERP_KERNEL::SegSegIntersector inters(*e1,*e2);
+    bool colinearity(inters.areColinears());
+    if(colinearity)
+      throw INTERP_KERNEL::Exception("DataArrayDouble::asArcOfCircle : 3 points in this have been detected as colinear !");
+  }
+  INTERP_KERNEL::AutoCppPtr<INTERP_KERNEL::EdgeArcCircle> ret(new INTERP_KERNEL::EdgeArcCircle(n0,n2,n1));
+  const double *c(ret->getCenter());
+  center[0]=c[0]; center[1]=c[1];
+  radius=ret->getRadius();
+  ang=ret->getAngle();
+}
+
+/*!
  * Sorts value within every tuple of \a this array.
  *  \param [in] asc - if \a true, the values are sorted in ascending order, else,
  *              in descending order.
@@ -3005,7 +3043,7 @@
 }
 
 /*!
- * Returns a new DataArrayInt contating indices of tuples of \a this one-dimensional
+ * Returns a new DataArrayInt containing indices of tuples of \a this one-dimensional
  * array whose values are within a given range. Textual data is not copied.
  *  \param [in] vmin - a lowest acceptable value (included).
  *  \param [in] vmax - a greatest acceptable value (included).
@@ -3036,7 +3074,7 @@
 }
 
 /*!
- * Returns a new DataArrayInt contating indices of tuples of \a this one-dimensional
+ * Returns a new DataArrayInt containing indices of tuples of \a this one-dimensional
  * array whose values are not within a given range. Textual data is not copied.
  *  \param [in] vmin - a lowest not acceptable value (excluded).
  *  \param [in] vmax - a greatest not acceptable value (excluded).
@@ -3955,7 +3993,7 @@
  *  \throw If any value of \a this can't be used as a valid index for 
  *         [\a indArrBg, \a indArrEnd).
  *
- *  \sa changeValue
+ *  \sa changeValue, findIdForEach
  */
 void DataArrayInt::transformWithIndArr(const int *indArrBg, const int *indArrEnd)
 {
@@ -3970,7 +4008,7 @@
       else
         {
           std::ostringstream oss; oss << "DataArrayInt::transformWithIndArr : error on tuple #" << i << " of this value is " << *pt << ", should be in [0," << nbElemsIn << ") !";
-          throw INTERP_KERNEL::Exception(oss.str().c_str());
+          throw INTERP_KERNEL::Exception(oss.str());
         }
     }
   this->declareAsNew();
@@ -3981,7 +4019,7 @@
   this->checkAllocated();
   if(this->getNumberOfComponents()!=1)
     throw INTERP_KERNEL::Exception("Call transformWithIndArr method on DataArrayInt with only one component, you can call 'rearrange' method before !");
-  const std::map<int,int> dat(m.data());
+  const std::map<int,int>& dat(m.data());
   int nbOfTuples(getNumberOfTuples()),*pt(getPointer());
   for(int i=0;i<nbOfTuples;i++,pt++)
     {
@@ -3991,7 +4029,7 @@
       else
         {
           std::ostringstream oss; oss << "DataArrayInt::transformWithIndArr : error on tuple #" << i << " of this value is " << *pt << " not in map !";
-          throw INTERP_KERNEL::Exception(oss.str().c_str());
+          throw INTERP_KERNEL::Exception(oss.str());
         }
     }
   this->declareAsNew();
@@ -4169,14 +4207,16 @@
  *  \sa invertArrayN2O2O2N
  *  \endif
  */
-MCAuto< MapKeyVal<int> > DataArrayInt::invertArrayN2O2O2NOptimized() const
+MCAuto< MapKeyVal<int> > DataArrayInt32::invertArrayN2O2O2NOptimized() const
 {
   checkAllocated();
+  if(getNumberOfComponents()!=1)
+    throw INTERP_KERNEL::Exception("DataArrayInt32::invertArrayN2O2O2NOptimized : single component expected !");
   MCAuto< MapKeyVal<int> > ret(MapKeyVal<int>::New());
   std::map<int,int>& m(ret->data());
   const int *new2Old(begin());
-  int nbOfNewElems(this->getNumberOfTuples());
-  for(int i=0;i<nbOfNewElems;i++)
+  std::size_t nbOfNewElems(this->getNumberOfTuples());
+  for(std::size_t i=0;i<nbOfNewElems;i++)
     {
       int v(new2Old[i]);
       m[v]=i;
@@ -4212,17 +4252,25 @@
 }
 
 /*!
- * This method tries to find the permutation to apply to the first input \a ids1 to obtain the same array (without considering strings informations) the second
+ * This method tries to find the permutation to apply to the first input \a ids1 to obtain the same array (without considering strings information) the second
  * input array \a ids2.
  * \a ids1 and \a ids2 are expected to be both a list of ids (both with number of components equal to one) not sorted and with values that can be negative.
  * This method will throw an exception is no such permutation array can be obtained. It is typically the case if there is some ids in \a ids1 not in \a ids2 or
  * inversely.
- * In case of success (no throw) : \c ids1->renumber(ret)->isEqual(ids2) where \a ret is the return of this method.
+ * In case of success both assertion will be true (no throw) :
+ * \c ids1->renumber(ret)->isEqual(ids2) where \a ret is the return of this method.
+ * \c ret->transformWithIndArr(ids2)->isEqual(ids1)
+ *
+ * \b Example:
+ * - \a ids1 : [3,1,103,4,6,10,-7,205]
+ * - \a ids2 : [-7,1,205,10,6,3,103,4]
+ * - \a return is : [5,1,6,7,4,3,0,2] because ids2[5]==ids1[0], ids2[1]==ids1[1], ids2[6]==ids1[2]...
  *
  * \return DataArrayInt * - a new instance of DataArrayInt. The caller is to delete this
  *          array using decrRef() as it is no more needed.
  * \throw If either ids1 or ids2 is null not allocated or not with one components.
  * 
+ * \sa DataArrayInt32::findIdForEach
  */
 DataArrayInt *DataArrayInt::FindPermutationFromFirstToSecond(const DataArrayInt *ids1, const DataArrayInt *ids2)
 {
@@ -4655,6 +4703,47 @@
 }
 
 /*!
+ * This method finds for each element \a ELT in [valsBg,valsEnd) elements in \a this equal to it. Associated to ELT
+ * this method will return the tuple id of last element found. If there is no element in \a this equal to ELT
+ * an exception will be thrown.
+ *
+ * In case of success this[ret]==vals. Samely ret->transformWithIndArr(this->begin(),this->end())==vals.
+ * Where \a vals is the [valsBg,valsEnd) array and \a ret the array returned by this method.
+ * This method can be seen as an extension of FindPermutationFromFirstToSecond.
+ * <br>
+ * \b Example: <br>
+ * - \a this: [17,27,2,10,-4,3,12,27,16]
+ * - \a val : [3,16,-4,27,17]
+ * - result: [5,8,4,7,0]
+ *
+ * \return - An array of size std::distance(valsBg,valsEnd)
+ *
+ * \sa DataArrayInt32::FindPermutationFromFirstToSecond
+ */
+MCAuto<DataArrayInt32> DataArrayInt32::findIdForEach(const int *valsBg, const int *valsEnd) const
+{
+  MCAuto<DataArrayInt32> ret(DataArrayInt32::New());
+  std::size_t nbOfTuplesOut(std::distance(valsBg,valsEnd));
+  ret->alloc(nbOfTuplesOut,1);
+  MCAuto< MapKeyVal<int> > zeMap(invertArrayN2O2O2NOptimized());
+  const std::map<int,int>& dat(zeMap->data());
+  int *ptToFeed(ret->getPointer());
+  for(const int *pt=valsBg;pt!=valsEnd;pt++)
+    {
+      std::map<int,int>::const_iterator it(dat.find(*pt));
+      if(it!=dat.end())
+        *ptToFeed++=(*it).second;
+      else
+        {
+          std::ostringstream oss; oss << "DataArrayInt32::findIdForEach : error for element at place " << std::distance(valsBg,pt);
+          oss << " of input array value is " << *pt << " which is not in this !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  return ret;
+}
+
+/*!
  * Assigns \a newValue to all elements holding \a oldValue within \a this
  * one-dimensional array.
  *  \param [in] oldValue - the value to replace.
@@ -5567,7 +5656,7 @@
 }
 
 /*!
- * This method allows to put a vector of vector of integer into a more compact data stucture (skyline). 
+ * This method allows to put a vector of vector of integer into a more compact data structure (skyline). 
  * This method is not available into python because no available optimized data structure available to map std::vector< std::vector<int> >.
  *
  * \param [in] v the input data structure to be translate into skyline format.
@@ -5791,7 +5880,7 @@
  * "MEDCouplingUMesh::buildDescendingConnectivity" and
  * \ref MEDCoupling::MEDCouplingUMesh::getNodalConnectivityIndex
  * "MEDCouplingUMesh::getNodalConnectivityIndex" etc.
- * This method preforms the reverse operation of DataArrayInt::computeOffsetsFull.
+ * This method performs the reverse operation of DataArrayInt::computeOffsetsFull.
  *  \return DataArrayInt * - a new instance of DataArrayInt, whose number of tuples
  *          equals to \a this->getNumberOfComponents() - 1, and number of components is 1.
  *          The caller is to delete this array using decrRef() as it is no more needed. 
@@ -5867,7 +5956,7 @@
  * components remains the same and number of tuples is inceamented by one.<br>
  * This method is useful for allToAllV in MPI with contiguous policy. This method
  * differs from computeOffsets() in that the number of tuples is changed by this one.
- * This method preforms the reverse operation of DataArrayInt::deltaShiftIndex.
+ * This method performs the reverse operation of DataArrayInt::deltaShiftIndex.
  *  \throw If \a this is not allocated.
  *  \throw If \a this->getNumberOfComponents() != 1.
  *
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArray.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArray.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArray.hxx	2018-04-19 17:04:36.713222244 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArray.hxx	2018-04-19 17:25:18.131805145 +0200
@@ -234,6 +234,8 @@
     MEDCOUPLING_EXPORT const T *getConstPointer() const { return _mem.getConstPointer(); }
     MEDCOUPLING_EXPORT const T *begin() const { return getConstPointer(); }
     MEDCOUPLING_EXPORT const T *end() const { return getConstPointer()+getNbOfElems(); }
+    MEDCOUPLING_EXPORT T *rwBegin() { return getPointer(); }
+    MEDCOUPLING_EXPORT T *rwEnd() { return getPointer()+getNbOfElems(); }
     void alloc(std::size_t nbOfTuple, std::size_t nbOfCompo=1);
     void useArray(const T *array, bool ownership, DeallocType type, int nbOfTuple, int nbOfCompo);
     void useExternalArrayWithRWAccess(const T *array, int nbOfTuple, int nbOfCompo);
@@ -285,6 +287,8 @@
     void setContigPartOfSelectedValuesSlice(int tupleIdStart, const DataArray *aBase, int bg, int end2, int step);
     T getMaxValue(int& tupleId) const;
     T getMaxValueInArray() const;
+    T getMaxAbsValue(std::size_t& tupleId) const;
+    T getMaxAbsValueInArray() const;
     T getMinValue(int& tupleId) const;
     T getMinValueInArray() const;
     MEDCOUPLING_EXPORT void getTuple(int tupleId, T *res) const { std::copy(_mem.getConstPointerLoc(tupleId*_info_on_compo.size()),_mem.getConstPointerLoc((tupleId+1)*_info_on_compo.size()),res); }
@@ -349,13 +353,13 @@
     MEDCOUPLING_EXPORT void reprZipWithoutNameStream(std::ostream& stream) const;
     MEDCOUPLING_EXPORT void reprNotTooLongWithoutNameStream(std::ostream& stream) const;
     MEDCOUPLING_EXPORT std::string reprNotTooLong() const;
+    template<class U>
+    MCAuto< typename Traits<U>::ArrayType > convertToOtherTypeOfArr() const;
   protected:
     static typename Traits<T>::ArrayType *PerformCopyOrIncrRef(bool dCpy, const typename Traits<T>::ArrayType& self);
     template<class OP>
     MCAuto<DataArrayInt32> findIdsAdv(const OP& op) const;
   private:
-    template<class U>
-    MCAuto< typename Traits<U>::ArrayType > convertToOtherTypeOfArr() const;
     template<class FCT>
     void somethingEqual(const typename Traits<T>::ArrayType *other);
   };
@@ -470,6 +474,7 @@
     MEDCOUPLING_EXPORT DataArrayDouble *maxPerTupleWithCompoId(DataArrayInt32* &compoIdOfMaxPerTuple) const;
     MEDCOUPLING_EXPORT DataArrayDouble *buildEuclidianDistanceDenseMatrix() const;
     MEDCOUPLING_EXPORT DataArrayDouble *buildEuclidianDistanceDenseMatrixWith(const DataArrayDouble *other) const;
+    MEDCOUPLING_EXPORT void asArcOfCircle(double center[2], double& radius, double& ang) const;
     MEDCOUPLING_EXPORT void sortPerTuple(bool asc);
     MEDCOUPLING_EXPORT void applyInv(double numerator);
     MEDCOUPLING_EXPORT void applyPow(double val);
@@ -596,6 +601,7 @@
     MEDCOUPLING_EXPORT DataArrayInt32 *findIdsEqualList(const int *valsBg, const int *valsEnd) const;
     MEDCOUPLING_EXPORT DataArrayInt32 *findIdsNotEqualList(const int *valsBg, const int *valsEnd) const;
     MEDCOUPLING_EXPORT DataArrayInt32 *findIdsEqualTuple(const int *tupleBg, const int *tupleEnd) const;
+    MEDCOUPLING_EXPORT MCAuto<DataArrayInt32> findIdForEach(const int *valsBg, const int *valsEnd) const;
     MEDCOUPLING_EXPORT int changeValue(int oldValue, int newValue);
     MEDCOUPLING_EXPORT int findIdFirstEqualTuple(const std::vector<int>& tupl) const;
     MEDCOUPLING_EXPORT int findIdFirstEqual(int value) const;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArray.txx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArray.txx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMemArray.txx	2018-04-19 17:04:36.714222264 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMemArray.txx	2018-04-19 17:25:18.136805243 +0200
@@ -404,7 +404,7 @@
   /*!
    * This method performs systematically an allocation of \a newNbOfElements elements in \a this.
    * \a _nb_of_elem and \a _nb_of_elem_alloc will be equal even if only std::min<std::size_t>(_nb_of_elem,newNbOfElements) come from the .
-   * The remaing part of the new allocated chunk are available but not set previouly !
+   * The remaining part of the new allocated chunk are available but not set previously !
    * 
    * So this method should not be confused with MemArray<T>::reserve that is close to MemArray<T>::reAlloc but not same.
    */
@@ -704,7 +704,7 @@
   }
   
   /*!
-   * This method desallocated \a this without modification of informations relative to the components.
+   * This method deallocated \a this without modification of information relative to the components.
    * After call of this method, DataArrayDouble::isAllocated will return false.
    * If \a this is already not allocated, \a this is let unchanged.
    */
@@ -718,7 +718,7 @@
    * This method reserve nbOfElems elements in memory ( nbOfElems*8 bytes ) \b without impacting the number of tuples in \a this.
    * If \a this has already been allocated, this method checks that \a this has only one component. If not an INTERP_KERNEL::Exception will be thrown.
    * If \a this has not already been allocated, number of components is set to one.
-   * This method allows to reduce number of reallocations on invokation of DataArrayDouble::pushBackSilent and DataArrayDouble::pushBackValsSilent on \a this.
+   * This method allows to reduce number of reallocations on invocation of DataArrayDouble::pushBackSilent and DataArrayDouble::pushBackValsSilent on \a this.
    * 
    * \sa DataArrayDouble::pack, DataArrayDouble::pushBackSilent, DataArrayDouble::pushBackValsSilent
    */
@@ -769,7 +769,7 @@
   }
   
   /*!
-   * This method adds at the end of \a this a serie of values [\c valsBg,\c valsEnd). This method do \b not update its time label to avoid useless incrementation
+   * This method adds at the end of \a this a series of values [\c valsBg,\c valsEnd). This method do \b not update its time label to avoid useless incrementation
    * of counter. So the caller is expected to call TimeLabel::declareAsNew on \a this at the end of the push session.
    *
    *  \param [in] valsBg - an array of values to push at the end of \c this.
@@ -2185,6 +2185,7 @@
    *  \return double - the maximal value among all values of \a this array.
    *  \throw If \a this->getNumberOfComponents() != 1
    *  \throw If \a this->getNumberOfTuples() < 1
+   *  \sa getMaxAbsValue, getMinValue
    */
   template<class T>
   T DataArrayTemplate<T>::getMaxValue(int& tupleId) const
@@ -2206,6 +2207,7 @@
    *  one component.
    *  \return double - the maximal value among all values of \a this array.
    *  \throw If \a this is not allocated.
+   *  \sa getMaxAbsValueInArray, getMinValueInArray
    */
   template<class T>
   T DataArrayTemplate<T>::getMaxValueInArray() const
@@ -2216,6 +2218,50 @@
   }
   
   /*!
+   * Returns the maximal absolute value in \a this and the first occurrence location associated to it.
+   * \return the element in this (positive or negative) having the max abs value in \a this.
+   *  \throw If \a this is not allocated.
+   *  \throw If \a this is non one component array.
+   *  \throw If \a this is empty.
+   */
+  template<class T>
+  T DataArrayTemplate<T>::getMaxAbsValue(std::size_t& tupleId) const
+  {
+    checkAllocated();
+    if(getNumberOfComponents()!=1)
+      throw INTERP_KERNEL::Exception("DataArrayDouble::getMaxAbsValue : must be applied on DataArrayDouble with only one component, you can call 'rearrange' method before or call 'getMaxValueInArray' method !");
+    std::size_t nbTuples(this->getNumberOfTuples());
+    if(nbTuples==0)
+      throw INTERP_KERNEL::Exception("DataArrayTemplate<T>::getMaxAbsValue : empty array !");
+    T ret((T)-1);
+    tupleId=0;
+    const T *pt(begin());
+    for(std::size_t i=0;i<nbTuples;i++,pt++)
+      {
+        T cand(std::abs(*pt));
+        if(cand>ret)
+          {
+            ret=cand;
+            tupleId=i;
+          }
+      }
+    return this->getIJ(tupleId,0);
+  }
+
+  /*!
+   * Returns the maximal absolute value in \a this.
+   *  \throw If \a this is not allocated.
+   *  \throw If \a this is non one component array.
+   *  \throw If \a this is empty.
+   */
+  template<class T>
+  T DataArrayTemplate<T>::getMaxAbsValueInArray() const
+  {
+    std::size_t dummy;
+    return getMaxAbsValue(dummy);
+  }
+
+  /*!
    * Returns the minimal value and its location within \a this one-dimensional array.
    *  \param [out] tupleId - index of the tuple holding the minimal value.
    *  \return double - the minimal value among all values of \a this array.
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMesh.cxx	2018-04-19 17:04:36.715222284 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMesh.cxx	2018-04-19 17:25:18.028803109 +0200
@@ -237,7 +237,7 @@
 }
 
 /*!
- * This method is very poor and looks only if \a this and \a other are candidate for merge of fields lying repectively on them.
+ * This method is very poor and looks only if \a this and \a other are candidate for merge of fields lying respectively on them.
  */
 bool MEDCouplingMesh::areCompatibleForMerge(const MEDCouplingMesh *other) const
 {
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMesh.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMesh.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingMesh.hxx	2018-04-19 17:04:36.715222284 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingMesh.hxx	2018-04-19 17:25:17.980802160 +0200
@@ -109,7 +109,7 @@
     MEDCOUPLING_EXPORT virtual const DataArrayDouble *getDirectAccessOfCoordsArrIfInStructure() const = 0;
     MEDCOUPLING_EXPORT virtual std::vector<int> getDistributionOfTypes() const = 0;
     MEDCOUPLING_EXPORT virtual DataArrayInt *checkTypeConsistencyAndContig(const std::vector<int>& code, const std::vector<const DataArrayInt *>& idsPerType) const = 0;
-    MEDCOUPLING_EXPORT virtual void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const = 0;
+    MEDCOUPLING_EXPORT virtual void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller=true) const = 0;
     MEDCOUPLING_EXPORT virtual void getBoundingBox(double *bbox) const = 0;
     MEDCOUPLING_EXPORT virtual MEDCouplingFieldDouble *getMeasureField(bool isAbs) const = 0;
     MEDCOUPLING_EXPORT virtual MEDCouplingFieldDouble *getMeasureFieldOnNode(bool isAbs) const = 0;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingNormalizedUnstructuredMesh.txx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingNormalizedUnstructuredMesh.txx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingNormalizedUnstructuredMesh.txx	2018-04-19 17:04:36.715222284 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingNormalizedUnstructuredMesh.txx	2018-04-19 17:25:18.106804650 +0200
@@ -22,6 +22,7 @@
 #define __MEDCOUPLINGNORMALIZEDUNSTRUCTUREDMESH_TXX__
 
 #include "MEDCouplingNormalizedUnstructuredMesh.hxx"
+#include "InterpKernelAssert.hxx"
 
 #include "MEDCouplingUMesh.hxx"
 #include "MEDCoupling1GTUMesh.hxx"
@@ -124,6 +125,7 @@
 template<int SPACEDIM,int MESHDIM>
 void MEDCouplingNormalizedUnstructuredMesh<SPACEDIM,MESHDIM>::prepare()
 {
+  IKAssert(_mesh->getSpaceDimension()==SPACEDIM);
   const MEDCoupling::MEDCouplingUMesh *m1(dynamic_cast<const MEDCoupling::MEDCouplingUMesh *>(_mesh));
   if(m1)
     {
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingPointSet.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingPointSet.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingPointSet.cxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingPointSet.cxx	2018-04-19 17:25:18.113804789 +0200
@@ -371,7 +371,7 @@
 /*!
  * @param comm in param in the same format than one returned by findCommonNodes method (\ref numbering-indirect).
  * @param commI in param in the same format than one returned by findCommonNodes method (\ref numbering-indirect).
- * @return the old to new correspondance array.
+ * @return the old to new correspondence array.
  */
 DataArrayInt *MEDCouplingPointSet::buildNewNumberingFromCommonNodesFormat(const DataArrayInt *comm, const DataArrayInt *commIndex,
                                                                           int& newNbOfNodes) const
@@ -1042,7 +1042,7 @@
 {
   if(!srcMesh || !trgMesh)
     throw INTERP_KERNEL::Exception("MEDCouplingPointSet::ComputeNbOfInteractionsWithSrcCells : the input meshes must be not NULL !");
-  MCAuto<DataArrayDouble> sbbox(srcMesh->getBoundingBoxForBBTree()),tbbox(trgMesh->getBoundingBoxForBBTree());
+  MCAuto<DataArrayDouble> sbbox(srcMesh->getBoundingBoxForBBTree(eps)),tbbox(trgMesh->getBoundingBoxForBBTree(eps));
   return tbbox->computeNbOfInteractionsWith(sbbox,eps);
 }
 
@@ -1112,7 +1112,7 @@
  * \param [out] beginOut valid only if \a arr not NULL !
  * \param [out] endOut valid only if \a arr not NULL !
  * \param [out] stepOut valid only if \a arr not NULL !
- * \param [out] arr correspondance old to new in node ids.
+ * \param [out] arr correspondence old to new in node ids.
  * 
  * \sa MEDCouplingUMesh::buildPartOfMySelfSlice
  */
@@ -1181,6 +1181,9 @@
  */
 bool MEDCouplingPointSet::isButterfly2DCell(const std::vector<double>& res, bool isQuad, double eps)
 {
+  INTERP_KERNEL::QuadraticPlanarPrecision prec(eps);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(eps);
+
   std::size_t nbOfNodes(res.size()/2);
   std::vector<INTERP_KERNEL::Node *> nodes(nbOfNodes);
   for(std::size_t i=0;i<nbOfNodes;i++)
@@ -1188,8 +1191,6 @@
       INTERP_KERNEL::Node *tmp=new INTERP_KERNEL::Node(res[2*i],res[2*i+1]);
       nodes[i]=tmp;
     }
-  INTERP_KERNEL::QUADRATIC_PLANAR::_precision=eps;
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=eps;
   INTERP_KERNEL::QuadraticPolygon *pol=0;
   if(isQuad)
     pol=INTERP_KERNEL::QuadraticPolygon::BuildArcCirclePolygon(nodes);
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRefCountObject.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRefCountObject.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRefCountObject.cxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRefCountObject.cxx	2018-04-19 17:25:17.998802516 +0200
@@ -75,6 +75,15 @@
     return BIGENDIAN_STR;
 }
 
+bool MEDCoupling::IsCXX11Compiled()
+{
+#if __cplusplus >= 201103L
+  return true;
+#else
+  return false;
+#endif
+}
+
 //=
 
 std::size_t BigMemoryObject::getHeapMemorySize() const
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRefCountObject.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRefCountObject.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRefCountObject.hxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRefCountObject.hxx	2018-04-19 17:25:18.001802575 +0200
@@ -64,7 +64,8 @@
   MEDCOUPLING_EXPORT int MEDCouplingSizeOfVoidStar();
   MEDCOUPLING_EXPORT bool MEDCouplingByteOrder();
   MEDCOUPLING_EXPORT const char *MEDCouplingByteOrderStr();
-
+  MEDCOUPLING_EXPORT bool IsCXX11Compiled();
+  
   class BigMemoryObject
   {
   public:
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRemapper.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRemapper.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRemapper.cxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRemapper.cxx	2018-04-19 17:25:17.996802476 +0200
@@ -36,6 +36,7 @@
 #include "Interpolation2D1D.txx"
 #include "Interpolation2D3D.txx"
 #include "Interpolation3D1D.txx"
+#include "Interpolation1D0D.txx"
 #include "InterpolationCU.txx"
 #include "InterpolationCC.txx"
 
@@ -70,14 +71,8 @@
  */
 int MEDCouplingRemapper::prepare(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method)
 {
-  if(!srcMesh || !targetMesh)
-    throw INTERP_KERNEL::Exception("MEDCouplingRemapper::prepare : presence of NULL input pointer !");
-  std::string srcMethod,targetMethod;
-  INTERP_KERNEL::Interpolation<INTERP_KERNEL::Interpolation3D>::CheckAndSplitInterpolationMethod(method,srcMethod,targetMethod);
-  MCAuto<MEDCouplingFieldTemplate> src=MEDCouplingFieldTemplate::New(MEDCouplingFieldDiscretization::GetTypeOfFieldFromStringRepr(srcMethod));
-  src->setMesh(srcMesh);
-  MCAuto<MEDCouplingFieldTemplate> target=MEDCouplingFieldTemplate::New(MEDCouplingFieldDiscretization::GetTypeOfFieldFromStringRepr(targetMethod));
-  target->setMesh(targetMesh);
+  MCAuto<MEDCouplingFieldTemplate> src,target;
+  BuildFieldTemplatesFrom(srcMesh,targetMesh,method,src,target);
   return prepareEx(src,target);
 }
 
@@ -92,19 +87,52 @@
  */
 int MEDCouplingRemapper::prepareEx(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target)
 {
-  if(!src || !target)
-    throw INTERP_KERNEL::Exception("MEDCouplingRemapper::prepareEx : presence of NULL input pointer !");
-  if(!src->getMesh() || !target->getMesh())
-    throw INTERP_KERNEL::Exception("MEDCouplingRemapper::prepareEx : presence of NULL mesh pointer in given field template !");
-  releaseData(true);
-  _src_ft=const_cast<MEDCouplingFieldTemplate *>(src); _src_ft->incrRef();
-  _target_ft=const_cast<MEDCouplingFieldTemplate *>(target); _target_ft->incrRef();
+  restartUsing(src,target);
   if(isInterpKernelOnlyOrNotOnly())
     return prepareInterpKernelOnly();
   else
     return prepareNotInterpKernelOnly();
 }
 
+void MEDCouplingRemapper::setCrudeMatrix(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method, const std::vector<std::map<int,double> >& m)
+{
+  MCAuto<MEDCouplingFieldTemplate> src,target;
+  BuildFieldTemplatesFrom(srcMesh,targetMesh,method,src,target);
+  setCrudeMatrixEx(src,target,m);
+}
+
+void MEDCouplingRemapper::setCrudeMatrixEx(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target, const std::vector<std::map<int,double> >& m)
+{
+#if __cplusplus >= 201103L
+  restartUsing(src,target);
+  if(m.size()!=target->getNumberOfTuplesExpected())
+    {
+      std::ostringstream oss; oss << "MEDCouplingRemapper::setMatrixEx : input matrix has " << m.size() << " rows whereas there are " << target->getNumberOfTuplesExpected() << " expected !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  auto srcNbElem(src->getNumberOfTuplesExpected());
+  for(auto it: m)
+    {
+      for(auto it2: it)
+        {
+          auto idToTest(it2.first);
+          if(idToTest<0 || idToTest>=srcNbElem)
+            {
+              std::ostringstream oss; oss << "MEDCouplingRemapper::setMatrixEx : presence of elt #" << idToTest << " ! not in [0," << srcNbElem << ") !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+        }
+    }
+  _matrix=m;
+  _deno_multiply.clear();
+  _deno_multiply.resize(_matrix.size());
+  _deno_reverse_multiply.clear();
+  _deno_reverse_multiply.resize(srcNbElem);
+#else
+  throw INTERP_KERNEL::Exception("Breaking news : 10% off for C++11 compiler :)");
+#endif
+}
+
 int MEDCouplingRemapper::prepareInterpKernelOnly()
 {
   int meshInterpType=((int)_src_ft->getMesh()->getType()*16)+(int)_target_ft->getMesh()->getType();
@@ -311,14 +339,14 @@
 }
 
 /*!
- * This method returns the interpolation matrix policy. This policy specifies which interpolation matrix method to keep or prefered.
+ * This method returns the interpolation matrix policy. This policy specifies which interpolation matrix method to keep or preferred.
  * If interpolation matrix policy is :
  *
- * - set to IK_ONLY_PREFERED (0) (the default) : the INTERP_KERNEL only method is prefered. That is to say, if it is possible to treat the case
+ * - set to IK_ONLY_PREFERED (0) (the default) : the INTERP_KERNEL only method is preferred. That is to say, if it is possible to treat the case
  *   regarding spatial discretization of source and target with INTERP_KERNEL only method, INTERP_KERNEL only method will be performed.
  *   If not, the \b not only INTERP_KERNEL method will be attempt.
  * 
- * - set to NOT_IK_ONLY_PREFERED (1) : the \b NOT only INTERP_KERNEL method is prefered. That is to say, if it is possible to treat the case
+ * - set to NOT_IK_ONLY_PREFERED (1) : the \b NOT only INTERP_KERNEL method is preferred. That is to say, if it is possible to treat the case
  *   regarding spatial discretization of source and target with \b NOT only INTERP_KERNEL method, \b NOT only INTERP_KERNEL method, will be performed.
  *   If not, the INTERP_KERNEL only method will be attempt.
  * 
@@ -340,11 +368,11 @@
  *
  * If interpolation matrix policy is :
  *
- * - set to IK_ONLY_PREFERED (0) (the default) : the INTERP_KERNEL only method is prefered. That is to say, if it is possible to treat the case
+ * - set to IK_ONLY_PREFERED (0) (the default) : the INTERP_KERNEL only method is preferred. That is to say, if it is possible to treat the case
  *   regarding spatial discretization of source and target with INTERP_KERNEL only method, INTERP_KERNEL only method will be performed.
  *   If not, the \b not only INTERP_KERNEL method will be attempt.
  * 
- * - set to NOT_IK_ONLY_PREFERED (1) : the \b NOT only INTERP_KERNEL method is prefered. That is to say, if it is possible to treat the case
+ * - set to NOT_IK_ONLY_PREFERED (1) : the \b NOT only INTERP_KERNEL method is preferred. That is to say, if it is possible to treat the case
  *   regarding spatial discretization of source and target with \b NOT only INTERP_KERNEL method, \b NOT only INTERP_KERNEL method, will be performed.
  *   If not, the INTERP_KERNEL only method will be attempt.
  * 
@@ -440,6 +468,15 @@
       INTERP_KERNEL::Interpolation3D1D interpolation(*this);
       nbCols=interpolation.interpolateMeshes(source_mesh_wrapper,target_mesh_wrapper,_matrix,method);
     }
+  else if(srcMeshDim==1 && trgMeshDim==0 && srcSpaceDim==3)
+    {
+      if(getIntersectionType()!=INTERP_KERNEL::PointLocator)
+        throw INTERP_KERNEL::Exception("Invalid interpolation requested between 1D and 0D into 3D space ! Select PointLocator as intersection type !");
+      MEDCouplingNormalizedUnstructuredMesh<3,3> source_mesh_wrapper(src_mesh);
+      MEDCouplingNormalizedUnstructuredMesh<3,3> target_mesh_wrapper(target_mesh);
+      INTERP_KERNEL::Interpolation1D0D interpolation(*this);
+      nbCols=interpolation.interpolateMeshes(source_mesh_wrapper,target_mesh_wrapper,_matrix,method);
+    }
   else if(srcMeshDim==1 && trgMeshDim==3 && srcSpaceDim==3)
     {
       if(getIntersectionType()!=INTERP_KERNEL::PointLocator)
@@ -507,7 +544,7 @@
           INTERP_KERNEL::Interpolation2D1D::DuplicateFacesType duplicateFaces=interpolation.retrieveDuplicateFaces();
           if(!duplicateFaces.empty())
             {
-              std::ostringstream oss; oss << "An unexpected situation happend ! For the following 1D Cells are part of edges shared by 2D cells :\n";
+              std::ostringstream oss; oss << "An unexpected situation happened ! For the following 1D Cells are part of edges shared by 2D cells :\n";
               for(std::map<int,std::set<int> >::const_iterator it=duplicateFaces.begin();it!=duplicateFaces.end();it++)
                 {
                   oss << "1D Cell #" << (*it).first << " is part of common edge of following 2D cells ids : ";
@@ -526,7 +563,7 @@
       INTERP_KERNEL::Interpolation2D3D::DuplicateFacesType duplicateFaces=interpolation.retrieveDuplicateFaces();
       if(!duplicateFaces.empty())
         {
-          std::ostringstream oss; oss << "An unexpected situation happend ! For the following 2D Cells are part of edges shared by 3D cells :\n";
+          std::ostringstream oss; oss << "An unexpected situation happened ! For the following 2D Cells are part of edges shared by 3D cells :\n";
           for(std::map<int,std::set<int> >::const_iterator it=duplicateFaces.begin();it!=duplicateFaces.end();it++)
             {
               oss << "2D Cell #" << (*it).first << " is part of common face of following 3D cells ids : ";
@@ -557,7 +594,7 @@
           INTERP_KERNEL::Interpolation2D3D::DuplicateFacesType duplicateFaces=interpolation.retrieveDuplicateFaces();
           if(!duplicateFaces.empty())
             {
-              std::ostringstream oss; oss << "An unexpected situation happend ! For the following 2D Cells are part of edges shared by 3D cells :\n";
+              std::ostringstream oss; oss << "An unexpected situation happened ! For the following 2D Cells are part of edges shared by 3D cells :\n";
               for(std::map<int,std::set<int> >::const_iterator it=duplicateFaces.begin();it!=duplicateFaces.end();it++)
                 {
                   oss << "2D Cell #" << (*it).first << " is part of common face of following 3D cells ids : ";
@@ -951,7 +988,7 @@
 
 /*!
  * This method builds a code considering already set field discretization int \a this : \a _src_ft and \a _target_ft.
- * This method returns 3 informations (2 in ouput parameters and 1 in return).
+ * This method returns 3 information (2 in output parameters and 1 in return).
  * 
  * \param [out] srcMeth the string code of the discretization of source field template
  * \param [out] trgMeth the string code of the discretization of target field template
@@ -975,6 +1012,18 @@
   return method;
 }
 
+void MEDCouplingRemapper::BuildFieldTemplatesFrom(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method, MCAuto<MEDCouplingFieldTemplate>& src, MCAuto<MEDCouplingFieldTemplate>& target)
+{
+  if(!srcMesh || !targetMesh)
+    throw INTERP_KERNEL::Exception("MEDCouplingRemapper::BuildFieldTemplatesFrom : presence of NULL input pointer !");
+  std::string srcMethod,targetMethod;
+  INTERP_KERNEL::Interpolation<INTERP_KERNEL::Interpolation3D>::CheckAndSplitInterpolationMethod(method,srcMethod,targetMethod);
+  src=MEDCouplingFieldTemplate::New(MEDCouplingFieldDiscretization::GetTypeOfFieldFromStringRepr(srcMethod));
+  src->setMesh(srcMesh);
+  target=MEDCouplingFieldTemplate::New(MEDCouplingFieldDiscretization::GetTypeOfFieldFromStringRepr(targetMethod));
+  target->setMesh(targetMesh);
+}
+
 void MEDCouplingRemapper::releaseData(bool matrixSuppression)
 {
   _src_ft=0;
@@ -987,6 +1036,17 @@
     }
 }
 
+void MEDCouplingRemapper::restartUsing(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target)
+{
+  if(!src || !target)
+    throw INTERP_KERNEL::Exception("MEDCouplingRemapper::restartUsingData : presence of NULL input pointer !");
+  if(!src->getMesh() || !target->getMesh())
+    throw INTERP_KERNEL::Exception("MEDCouplingRemapper::prepareEx : presence of NULL mesh pointer in given field template !");
+  releaseData(true);
+  _src_ft.takeRef(const_cast<MEDCouplingFieldTemplate *>(src));
+  _target_ft.takeRef(const_cast<MEDCouplingFieldTemplate *>(target));
+}
+
 void MEDCouplingRemapper::transferUnderground(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField, bool isDftVal, double dftValue)
 {
   if(!srcField || !targetField)
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRemapper.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRemapper.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingRemapper.hxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingRemapper.hxx	2018-04-19 17:25:18.125805026 +0200
@@ -56,6 +56,8 @@
     MEDCOUPLINGREMAPPER_EXPORT ~MEDCouplingRemapper();
     MEDCOUPLINGREMAPPER_EXPORT int prepare(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method);
     MEDCOUPLINGREMAPPER_EXPORT int prepareEx(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target);
+    MEDCOUPLINGREMAPPER_EXPORT void setCrudeMatrix(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method, const std::vector<std::map<int,double> >& m);
+    MEDCOUPLINGREMAPPER_EXPORT void setCrudeMatrixEx(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target, const std::vector<std::map<int,double> >& m);
     MEDCOUPLINGREMAPPER_EXPORT void transfer(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField, double dftValue);
     MEDCOUPLINGREMAPPER_EXPORT void partialTransfer(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField);
     MEDCOUPLINGREMAPPER_EXPORT void reverseTransfer(MEDCouplingFieldDouble *srcField, const MEDCouplingFieldDouble *targetField, double dftValue);
@@ -75,6 +77,7 @@
     MEDCOUPLINGREMAPPER_EXPORT int getNumberOfColsOfMatrix() const;
     MEDCOUPLINGREMAPPER_EXPORT static void PrintMatrix(const std::vector<std::map<int,double> >& m);
     MEDCOUPLINGREMAPPER_EXPORT static std::string BuildMethodFrom(const std::string& meth1, const std::string& meth2);
+    MEDCOUPLINGREMAPPER_EXPORT void BuildFieldTemplatesFrom(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method, MCAuto<MEDCouplingFieldTemplate>& src, MCAuto<MEDCouplingFieldTemplate>& target);
   private:
     int prepareInterpKernelOnly();
     int prepareInterpKernelOnlyUU();
@@ -93,6 +96,7 @@
     void checkPrepare() const;
     std::string checkAndGiveInterpolationMethodStr(std::string& srcMeth, std::string& trgMeth) const;
     void releaseData(bool matrixSuppression);
+    void restartUsing(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target);
     void transferUnderground(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField, bool isDftVal, double dftValue);
     void computeDeno(NatureOfField nat, const MEDCouplingFieldDouble *srcField, const MEDCouplingFieldDouble *trgField);
     void computeDenoFromScratch(NatureOfField nat, const MEDCouplingFieldDouble *srcField, const MEDCouplingFieldDouble *trgField);
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingSkyLineArray.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingSkyLineArray.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingSkyLineArray.cxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingSkyLineArray.cxx	2018-04-19 17:25:18.009802733 +0200
@@ -20,6 +20,8 @@
 #include "MEDCouplingSkyLineArray.hxx"
 
 #include <sstream>
+#include <deque>
+#include <set>
 
 using namespace MEDCoupling;
 
@@ -384,8 +386,6 @@
  */
 void MEDCouplingSkyLineArray::deletePack(const int superIdx, const int idx)
 {
-  using namespace std;
-
   checkSuperIndex("deletePack");
   validSuperIndexAndIndex("deletePack", superIdx, idx);
 
@@ -393,12 +393,12 @@
   int * siP(_super_index->getPointer()), *iP(_index->getPointer());
   const int start = iP[siP[superIdx]+idx], end = iP[siP[superIdx]+idx+1];
   // _values
-  copy(vP+end, vP+_values->getNbOfElems(), vP+start);
+  std::copy(vP+end, vP+_values->getNbOfElems(), vP+start);
   _values->reAlloc(_values->getNbOfElems() - (end-start));
 
   // _index
   int nt = _index->getNbOfElems();
-  copy(iP+siP[superIdx]+idx+1, iP+nt, iP+siP[superIdx]+idx);
+  std::copy(iP+siP[superIdx]+idx+1, iP+nt, iP+siP[superIdx]+idx);
   _index->reAlloc(nt-1); iP = _index->getPointer();  // better not forget this ...
   for(int ii = siP[superIdx]+idx; ii < nt-1; ii++)
     iP[ii] -= (end-start);
@@ -408,6 +408,128 @@
     (siP[ii])--;
 }
 
+void MEDCouplingSkyLineArray::deleteSimplePack(const int idx)
+{
+  validIndex("deleteSimplePack", idx);
+  
+  int* iP(_index->getPointer());
+  const int start(iP[idx]), end(iP[idx+1]);
+
+  // _values
+  int initValSz( _values->getNbOfElems() );
+  int deltaSz( start-end );  // should be negative
+  int *vP(_values->getPointer());
+  if (deltaSz < 0)
+    {
+      std::copy(vP+end, vP+initValSz, vP+start);
+      _values->reAlloc(initValSz+deltaSz);
+    }
+  else
+    throw INTERP_KERNEL::Exception("MEDCouplingSkyLineArray::deleteSimplePack");
+  // _index
+  int nt(_index->getNbOfElems());
+  std::copy(iP+idx+1, iP+nt, iP+idx);
+  for(int ii = idx; ii < nt-1; ii++)
+    iP[ii] += deltaSz;
+  _index->reAlloc(nt-1);
+}
+
+void MEDCouplingSkyLineArray::replaceSimplePacks(const DataArrayInt* idx, const std::vector<const DataArrayInt*>& packs)
+{    
+  if (idx->empty())
+    return;
+    
+  for (const int * id = idx->begin(); id != idx->end(); id++)
+    validIndex("deleteSimplePacks", *id);
+    
+  if (idx->getNbOfElems() != packs.size())
+    throw INTERP_KERNEL::Exception("MEDCouplingSkyLineArray::deleteSimplePacks: size of list of pack is incorrect");
+    
+  // copy _index, _values into a deque<set<int>>
+  std::deque< std::set<int> > valuesByIdx;
+  int* vP(_values->getPointer());
+  int* iP(_index->getPointer());
+  std::size_t nt ( _index->getNbOfElems() );
+  for (int ii = 0; ii < nt-1; ii++)
+    valuesByIdx.push_back(std::set<int>(vP+iP[ii], vP+iP[ii+1]));
+    
+  // modify the deque<set<int>> according to idx and packs
+  int ii(0);
+  for (const int *id = idx->begin(); id != idx->end(); id++)
+    {
+      valuesByIdx[*id] = std::set<int>(packs[ii]->begin(), packs[ii]->end());
+      ii++;
+    }
+  // copy back the deque<set<int>> into _index, _values
+  int valSz(0);
+  *iP = 0;
+  for (std::deque< std::set<int> >::const_iterator values=valuesByIdx.begin();values!=valuesByIdx.end();values++)
+    {
+      valSz += (*values).size();
+      *(++iP) = valSz;
+    }
+  _values->reAlloc(valSz);
+  iP = _index->getPointer();
+  vP = _values->getPointer();
+  for (auto values : valuesByIdx)
+    {
+      std::copy(values.begin(), values.end(), vP+(*iP));
+      iP++;
+    }
+}
+
+void MEDCouplingSkyLineArray::deleteSimplePacks(const DataArrayInt* idx)
+{    
+  for (auto id = idx->begin(); id != idx->end(); id++)
+    validIndex("deleteSimplePacks", *id);
+  
+  std::set<int> packsToDelete(idx->begin(), idx->end());
+    
+  // _values
+  int* iP(_index->getPointer());
+  int initValSz = _values->getNbOfElems();
+  int *vP(_values->getPointer());
+  int end_prec(0),start_prec(0);
+  for(std::set<int>::const_iterator ii=packsToDelete.begin();ii!=packsToDelete.end();ii++)
+    {
+      int start = iP[*ii];
+      if (end_prec != 0)
+        std::copy(vP+end_prec, vP+start, vP+start_prec);
+      start_prec += start-end_prec;
+      end_prec = iP[*ii+1];
+    }
+  if (end_prec != 0)
+    std::copy(vP+end_prec, vP+initValSz, vP+start_prec);
+  _values->reAlloc(initValSz-(end_prec-start_prec));
+    
+  // _index
+  int nt = _index->getNbOfElems();
+  int offset = 0;
+  end_prec = 0;
+  start_prec = 0;
+  int deleted = 0;
+  for(std::set<int>::const_iterator ii=packsToDelete.begin();ii!=packsToDelete.end();ii++)
+    {
+      if (end_prec != 0)
+        {
+          std::copy(iP+end_prec, iP+*ii, iP+start_prec);
+          for (int i=start_prec; i<*ii; i++)
+            iP[i] -= offset;
+        }
+      offset += iP[*ii+1] - iP[*ii];
+      start_prec = *ii-deleted;
+      end_prec = *ii+1;
+      deleted += 1;
+    }
+  if (end_prec != 0)
+    {
+      std::copy(iP+end_prec, iP+nt, iP+start_prec);
+      for (int i=start_prec; i<nt; i++)
+        iP[i] -= offset;
+    }
+  _index->reAlloc(nt-deleted);
+}
+
 /**!
  * Insert a new pack in super-pack at index 'superIdx'. The pack is inserted at the end of the pack list of the chosen super-pack.
  */
@@ -448,12 +570,10 @@
  */
 void MEDCouplingSkyLineArray::replaceSimplePack(const int idx, const int * packBg, const int * packEnd)
 {
-  using namespace std;
-
   validIndex("replaceSimplePack", idx);
 
   int * iP(_index->getPointer());
-  int newSz = distance(packBg, packEnd);
+  int newSz = std::distance(packBg, packEnd);
   const int start = iP[idx], end = iP[idx+1];
 
   // _values
@@ -464,13 +584,13 @@
       if (deltaSz > 0)
         _values->reAlloc(initValSz+deltaSz);
       int *vP(_values->getPointer());
-      copy(vP+end, vP+initValSz, vP+end+deltaSz);
+      std::copy(vP+end, vP+initValSz, vP+end+deltaSz);
       if (deltaSz < 0)
         _values->reAlloc(initValSz+deltaSz);
     }
 
   // copy new pack
-  copy(packBg, packEnd, _values->getPointer()+start);
+  std::copy(packBg, packEnd, _values->getPointer()+start);
 
   // _index
   for(int ii = idx+1; ii < (int)_index->getNbOfElems(); ii++)
@@ -481,15 +601,13 @@
  * Replace pack with super index 'superIdx' and index 'idx' with the provided new pack.
  * Function can be used only for 3-level SkyLine.
  */
-void MEDCouplingSkyLineArray::replacePack(const int superIdx, const int idx, const int * packBg, const int * packEnd)
+void MEDCouplingSkyLineArray::replacePack(const int superIdx, const int idx, const int *packBg, const int *packEnd)
 {
-  using namespace std;
-
   checkSuperIndex("replacePack");
   validSuperIndexAndIndex("replacePack", superIdx, idx);
 
   int * siP(_super_index->getPointer()), *iP(_index->getPointer());
-  int newSz = distance(packBg, packEnd);
+  int newSz = std::distance(packBg, packEnd);
   const int start = iP[siP[superIdx]+idx], end = iP[siP[superIdx]+idx+1];
 
   // _values
@@ -500,13 +618,13 @@
       if (deltaSz > 0)
         _values->reAlloc(initValSz+deltaSz);
       int *vP(_values->getPointer());
-      copy(vP+end, vP+initValSz, vP+end+deltaSz);
+      std::copy(vP+end, vP+initValSz, vP+end+deltaSz);
       if (deltaSz < 0)
         _values->reAlloc(initValSz+deltaSz);
     }
 
   // copy new pack
-  copy(packBg, packEnd, _values->getPointer()+start);
+  std::copy(packBg, packEnd, _values->getPointer()+start);
 
   // _index
   for(int ii = siP[superIdx]+idx+1; ii < (int)_index->getNbOfElems(); ii++)
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingSkyLineArray.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingSkyLineArray.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingSkyLineArray.hxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingSkyLineArray.hxx	2018-04-19 17:25:18.042803386 +0200
@@ -90,11 +90,15 @@
                      std::vector<int>& out) const;
 
     void deletePack(const int superIdx, const int idx);
+    void deleteSimplePack(const int idx);
     void pushBackPack(const int superIdx, const int * packBg, const int * packEnd);
 
     void replaceSimplePack(const int idx, const int * packBg, const int * packEnd);
     void replacePack(const int superIdx, const int idx, const int * packBg, const int * packEnd);
 
+    void deleteSimplePacks(const DataArrayInt* idx);
+    void replaceSimplePacks(const DataArrayInt* idx, const std::vector<const DataArrayInt*>& packs);
+    
     void convertToPolyhedronConn( MCAuto<DataArrayInt>& c,  MCAuto<DataArrayInt>& cI) const;
 
   private:
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingStructuredMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingStructuredMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingStructuredMesh.cxx	2018-04-19 17:04:36.716222304 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingStructuredMesh.cxx	2018-04-19 17:25:18.023803010 +0200
@@ -310,7 +310,7 @@
  *          - After \a code contains [NORM_...,nbCells,0], \a idsInPflPerType [[0,1]] and \a idsPerType is [[1,2]] <br>
 
  */
-void MEDCouplingStructuredMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const
+void MEDCouplingStructuredMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller) const
 {
   if(!profile || !profile->isAllocated())
     throw INTERP_KERNEL::Exception("MEDCouplingStructuredMesh::splitProfilePerType : input profile is NULL or not allocated !");
@@ -321,7 +321,7 @@
   code.resize(3); idsInPflPerType.resize(1);
   code[0]=(int)getTypeOfCell(0); code[1]=nbOfCells;
   idsInPflPerType.resize(1);
-  if(profile->isIota(nbOfCells))
+  if(smartPflKiller && profile->isIota(nbOfCells))
     {
       code[2]=-1;
       idsInPflPerType[0]=profile->deepCopy();
@@ -1887,7 +1887,7 @@
 
 /*!
  * This method builds the explicit entity array from the structure in \a st and the range in \a partCompactFormat.
- * If the range contains invalid values regarding sructure an exception will be thrown.
+ * If the range contains invalid values regarding structure an exception will be thrown.
  *
  * \return DataArrayInt * - a new object.
  * \sa MEDCouplingStructuredMesh::IsPartStructured, MEDCouplingStructuredMesh::DeduceNumberOfGivenRangeInCompactFrmt, SwitchOnIdsFrom, ExtractFieldOfBoolFrom, ExtractFieldOfDoubleFrom, MultiplyPartOf
@@ -1956,7 +1956,7 @@
  * \param [in] st - the structure of grid ( \b without considering ghost cells).
  * \param [in] part - the part in the structure ( \b without considering ghost cells) contained in grid whose structure is defined by \a st.
  * \param [in] factor - the factor, the tuples in \a da will be multiply by.
- * \param [in,out] da - The DataArray in wich only tuples specified by \a part will be modified.
+ * \param [in,out] da - The DataArray in which only tuples specified by \a part will be modified.
  *
  * \sa BuildExplicitIdsFrom
  */
@@ -2037,7 +2037,7 @@
  * \param [in] part - the part in the structure ( \b without considering ghost cells) contained in grid whose structure is defined by \a st.
  * \param [in] ghostSize - \a ghostSize must be >= 0.
  * \param [in] factor - the factor, the tuples in \a da will be multiply by.
- * \param [in,out] da - The DataArray in wich only tuples specified by \a part will be modified.
+ * \param [in,out] da - The DataArray in which only tuples specified by \a part will be modified.
  *
  * \sa MultiplyPartOf, PutInGhostFormat
  */
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingStructuredMesh.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingStructuredMesh.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingStructuredMesh.hxx	2018-04-19 17:04:36.717222324 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingStructuredMesh.hxx	2018-04-19 17:25:18.142805362 +0200
@@ -49,7 +49,7 @@
     //tools
     MEDCOUPLING_EXPORT std::vector<int> getDistributionOfTypes() const;
     MEDCOUPLING_EXPORT DataArrayInt *checkTypeConsistencyAndContig(const std::vector<int>& code, const std::vector<const DataArrayInt *>& idsPerType) const;
-    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const;
+    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller=true) const;
     MEDCOUPLING_EXPORT MEDCoupling1SGTUMesh *build1SGTUnstructured() const;
     MEDCOUPLING_EXPORT MEDCouplingUMesh *buildUnstructured() const;
     MEDCOUPLING_EXPORT MEDCouplingMesh *buildPart(const int *start, const int *end) const;
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingTimeDiscretization.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingTimeDiscretization.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingTimeDiscretization.cxx	2018-04-19 17:04:36.717222324 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingTimeDiscretization.cxx	2018-04-19 17:25:18.007802694 +0200
@@ -374,7 +374,7 @@
       if(arrays1[i]!=0 && arrays2[i]!=0)
         arrays1[i]->setSelectedComponents(arrays2[i],compoIds);
       else if(arrays1[i]!=0 || arrays2[i]!=0)
-        throw INTERP_KERNEL::Exception("TimeDiscretization::setSelectedComponents : some time array in correspondance are not defined symetrically !");
+        throw INTERP_KERNEL::Exception("TimeDiscretization::setSelectedComponents : some time array in correspondence are not defined symmetrically !");
     }
 }
 
@@ -710,7 +710,7 @@
     case MEDCouplingTimeDiscretizationInt::DISCRETIZATION:
       return new MEDCouplingTimeDiscretizationInt;
     default:
-      throw INTERP_KERNEL::Exception("Time discretization not implemented yet for intergers !");
+      throw INTERP_KERNEL::Exception("Time discretization not implemented yet for integers !");
   }
 }
 
@@ -771,14 +771,12 @@
     case MEDCouplingTimeDiscretizationFloat::DISCRETIZATION:
       return new MEDCouplingTimeDiscretizationFloat;
     default:
-      throw INTERP_KERNEL::Exception("Time discretization not implemented yet for intergers !");
+      throw INTERP_KERNEL::Exception("Time discretization not implemented yet for integers !");
   }
 }
 
 bool MEDCouplingTimeDiscretizationFloat::isEqualIfNotWhy(const MEDCouplingTimeDiscretizationTemplate<float> *other, float prec, std::string& reason) const
 {
-  if(prec!=0)
-    throw INTERP_KERNEL::Exception("isEqualIfNotWhy : only precision equal to 0 supported for int !");
   if(!other)
     {
       reason="Time discretization is NULL.";
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingTimeLabel.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingTimeLabel.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingTimeLabel.cxx	2018-04-19 17:04:36.717222324 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingTimeLabel.cxx	2018-04-19 17:25:18.132805164 +0200
@@ -54,7 +54,7 @@
 }
 
 /*!
- * This method has to be called with a lot of care. It set agressively the time in this with the
+ * This method has to be called with a lot of care. It set aggressively the time in this with the
  * time in \a other.
  */
 void TimeLabel::forceTimeOfThis(const TimeLabel& other) const
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh.cxx	2018-04-19 17:04:36.722222424 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh.cxx	2018-04-19 17:25:17.986802279 +0200
@@ -56,8 +56,8 @@
 double MEDCouplingUMesh::EPS_FOR_POLYH_ORIENTATION=1.e-14;
 
 /// @cond INTERNAL
-const INTERP_KERNEL::NormalizedCellType MEDCouplingUMesh::MEDMEM_ORDER[N_MEDMEM_ORDER] = { INTERP_KERNEL::NORM_POINT1, INTERP_KERNEL::NORM_SEG2, INTERP_KERNEL::NORM_SEG3, INTERP_KERNEL::NORM_SEG4, INTERP_KERNEL::NORM_POLYL, INTERP_KERNEL::NORM_TRI3, INTERP_KERNEL::NORM_QUAD4, INTERP_KERNEL::NORM_TRI6, INTERP_KERNEL::NORM_TRI7, INTERP_KERNEL::NORM_QUAD8, INTERP_KERNEL::NORM_QUAD9, INTERP_KERNEL::NORM_POLYGON, INTERP_KERNEL::NORM_QPOLYG, INTERP_KERNEL::NORM_TETRA4, INTERP_KERNEL::NORM_PYRA5, INTERP_KERNEL::NORM_PENTA6, INTERP_KERNEL::NORM_HEXA8, INTERP_KERNEL::NORM_HEXGP12, INTERP_KERNEL::NORM_TETRA10, INTERP_KERNEL::NORM_PYRA13, INTERP_KERNEL::NORM_PENTA15, INTERP_KERNEL::NORM_HEXA20, INTERP_KERNEL::NORM_HEXA27, INTERP_KERNEL::NORM_POLYHED };
-const int MEDCouplingUMesh::MEDCOUPLING2VTKTYPETRADUCER[INTERP_KERNEL::NORM_MAXTYPE+1]={1,3,21,5,9,7,22,34,23,28,-1,-1,-1,-1,10,14,13,-1,12,-1,24,-1,16,27,-1,26,-1,29,-1,-1,25,42,36,4};
+const INTERP_KERNEL::NormalizedCellType MEDCouplingUMesh::MEDMEM_ORDER[N_MEDMEM_ORDER] = { INTERP_KERNEL::NORM_POINT1, INTERP_KERNEL::NORM_SEG2, INTERP_KERNEL::NORM_SEG3, INTERP_KERNEL::NORM_SEG4, INTERP_KERNEL::NORM_POLYL, INTERP_KERNEL::NORM_TRI3, INTERP_KERNEL::NORM_QUAD4, INTERP_KERNEL::NORM_TRI6, INTERP_KERNEL::NORM_TRI7, INTERP_KERNEL::NORM_QUAD8, INTERP_KERNEL::NORM_QUAD9, INTERP_KERNEL::NORM_POLYGON, INTERP_KERNEL::NORM_QPOLYG, INTERP_KERNEL::NORM_TETRA4, INTERP_KERNEL::NORM_PYRA5, INTERP_KERNEL::NORM_PENTA6, INTERP_KERNEL::NORM_HEXA8, INTERP_KERNEL::NORM_HEXGP12, INTERP_KERNEL::NORM_TETRA10, INTERP_KERNEL::NORM_PYRA13, INTERP_KERNEL::NORM_PENTA15, INTERP_KERNEL::NORM_PENTA18, INTERP_KERNEL::NORM_HEXA20, INTERP_KERNEL::NORM_HEXA27, INTERP_KERNEL::NORM_POLYHED };
+const int MEDCouplingUMesh::MEDCOUPLING2VTKTYPETRADUCER[INTERP_KERNEL::NORM_MAXTYPE+1]={1,3,21,5,9,7,22,34,23,28,-1,-1,-1,-1,10,14,13,-1,12,-1,24,-1,16,27,-1,26,-1,29,32,-1,25,42,36,4};
 /// @endcond
 
 MEDCouplingUMesh *MEDCouplingUMesh::New()
@@ -301,9 +301,10 @@
 }
 
 /*!
- * Allocates memory to store an estimation of the given number of cells. The closer is the estimation to the number of cells effectively inserted,
- * the less will the library need to reallocate memory. If the number of cells to be inserted is not known simply put 0 to this parameter.
- * If a nodal connectivity previouly existed before the call of this method, it will be reset.
+ * Allocates memory to store an estimation of the given number of cells. 
+ * The closer the estimation to the number of cells effectively inserted, the less need the library requires
+ * to reallocate memory. If the number of cells to be inserted is not known simply assign 0 to this parameter.
+ * If a nodal connectivity previously existed before the call of this method, it will be reset.
  *
  *  \param [in] nbOfCells - estimation of the number of cell \a this mesh will contain.
  *
@@ -403,7 +404,7 @@
 
 /*!
  * Entry point for iteration over cells groups geo types per geotypes. Warning the returned cell iterator should be deallocated.
- * If \a this is not so that that cells are grouped by geo types this method will throw an exception.
+ * If \a this is not so that the cells are grouped by geo types, this method will throw an exception.
  * In this case MEDCouplingUMesh::sortCellsInMEDFileFrmt or MEDCouplingUMesh::rearrange2ConsecutiveCellTypes methods for example can be called before invoking this method.
  * Useful for python users.
  */
@@ -975,7 +976,12 @@
   {
     int *neighIdx(neighborsIdx->getPointer());
     for(std::vector< std::set<int> >::const_iterator it=st0.begin();it!=st0.end();it++,neighIdx++)
-      neighIdx[1]=neighIdx[0]+(*it).size()-1;
+      {
+        if ((*it).empty())
+          neighIdx[1]=neighIdx[0];
+        else
+          neighIdx[1]=neighIdx[0]+(*it).size()-1;
+      }
   }
   neighbors=DataArrayInt::New(); neighbors->alloc(neighborsIdx->back(),1);
   {
@@ -1308,12 +1314,14 @@
   connINew->alloc(nbOfCells+1,1);
   int *connINewPtr=connINew->getPointer(); *connINewPtr++=0;
   MCAuto<DataArrayInt> connNew=DataArrayInt::New(); connNew->alloc(0,1);
+  MCAuto<DataArrayInt> E_Fi(DataArrayInt::New()), E_F(DataArrayInt::New()), F_Ei(DataArrayInt::New()), F_E(DataArrayInt::New());
+  MCAuto<MEDCouplingUMesh> m_faces(buildDescendingConnectivity(E_F, E_Fi, F_E, F_Ei));
   bool changed=false;
   for(int i=0;i<nbOfCells;i++,connINewPtr++)
     {
       if(conn[index[i]]==(int)INTERP_KERNEL::NORM_POLYHED)
         {
-          SimplifyPolyhedronCell(eps,coords,conn+index[i],conn+index[i+1],connNew);
+          SimplifyPolyhedronCell(eps,coords, i,connNew, m_faces, E_Fi, E_F, F_Ei, F_E);
           changed=true;
         }
       else
@@ -1698,7 +1706,7 @@
  * \param [in] startCellId specifies the cellId starting from which the equality computation will be carried out. By default it is 0, which it means that all cells in \a this will be scanned.
  * \param [out] commonCellsArr common cells ids (\ref numbering-indirect)
  * \param [out] commonCellsIArr common cells ids (\ref numbering-indirect)
- * \return the correspondance array old to new in a newly allocated array.
+ * \return the correspondence array old to new in a newly allocated array.
  * 
  */
 void MEDCouplingUMesh::findCommonCells(int compType, int startCellId, DataArrayInt *& commonCellsArr, DataArrayInt *& commonCellsIArr) const
@@ -1895,7 +1903,7 @@
 /*!
  * Build a sub part of \b this lying or not on the same coordinates than \b this (regarding value of \b keepCoords).
  * By default coordinates are kept. This method is close to MEDCouplingUMesh::buildPartOfMySelf except that here input
- * cellIds is not given explicitely but by a range python like.
+ * cellIds is not given explicitly but by a range python like.
  * 
  * \param start
  * \param end
@@ -2277,7 +2285,7 @@
  * This method expects that \b this and \b otherDimM1OnSameCoords share the same coordinates array.
  * otherDimM1OnSameCoords->getMeshDimension() is expected to be equal to this->getMeshDimension()-1.
  * This method searches for nodes needed to be duplicated. These nodes are nodes fetched by \b otherDimM1OnSameCoords which are not part of the boundary of \b otherDimM1OnSameCoords.
- * If a node is in the boundary of \b this \b and in the boundary of \b otherDimM1OnSameCoords this node is considerd as needed to be duplicated.
+ * If a node is in the boundary of \b this \b and in the boundary of \b otherDimM1OnSameCoords this node is considered as needed to be duplicated.
  * When the set of node ids \b nodeIdsToDuplicate is computed, cell ids in \b this is searched so that their connectivity includes at least 1 node in \b nodeIdsToDuplicate.
  *
  * \param [in] otherDimM1OnSameCoords a mesh lying on the same coords than \b this and with a mesh dimension equal to those of \b this minus 1. WARNING this input
@@ -2422,7 +2430,7 @@
  * This method operates a modification of the connectivity and coords in \b this.
  * Every time that a node id in [ \b nodeIdsToDuplicateBg, \b nodeIdsToDuplicateEnd ) will append in nodal connectivity of \b this 
  * its ids will be modified to id this->getNumberOfNodes()+std::distance(nodeIdsToDuplicateBg,std::find(nodeIdsToDuplicateBg,nodeIdsToDuplicateEnd,id)).
- * More explicitely the renumber array in nodes is not explicitely given in old2new to avoid to build a big array of renumbering whereas typically few node ids needs to be
+ * More explicitly the renumber array in nodes is not explicitly given in old2new to avoid to build a big array of renumbering whereas typically few node ids needs to be
  * renumbered. The node id nodeIdsToDuplicateBg[0] will have id this->getNumberOfNodes()+0, node id nodeIdsToDuplicateBg[1] will have id this->getNumberOfNodes()+1,
  * node id nodeIdsToDuplicateBg[2] will have id this->getNumberOfNodes()+2...
  * 
@@ -2563,7 +2571,7 @@
  * Coordinates are \b NOT considered here and will remain unchanged by this method. this->_coords can ever been null for the needs of this method.
  * Every time that a node id in [ \b nodeIdsToDuplicateBg, \b nodeIdsToDuplicateEnd ) will append in nodal connectivity of \b this 
  * its ids will be modified to id offset+std::distance(nodeIdsToDuplicateBg,std::find(nodeIdsToDuplicateBg,nodeIdsToDuplicateEnd,id)).
- * More explicitely the renumber array in nodes is not explicitely given in old2new to avoid to build a big array of renumbering whereas typically few node ids needs to be
+ * More explicitly the renumber array in nodes is not explicitly given in old2new to avoid to build a big array of renumbering whereas typically few node ids needs to be
  * renumbered. The node id nodeIdsToDuplicateBg[0] will have id offset+0, node id nodeIdsToDuplicateBg[1] will have id offset+1,
  * node id nodeIdsToDuplicateBg[2] will have id offset+2...
  * 
@@ -2934,7 +2942,7 @@
 }
 
 /*!
- * This method builds a newly allocated instance (with the same name than \a this) that the caller has the responsability to deal with.
+ * This method builds a newly allocated instance (with the same name than \a this) that the caller has the responsibility to deal with.
  * This method returns an instance with all arrays allocated (connectivity, connectivity index, coordinates)
  * but with length of these arrays set to 0. It allows to define an "empty" mesh (with nor cells nor nodes but compliant with
  * some algos).
@@ -2996,7 +3004,7 @@
 
 /*!
  * Returns types of cells of the specified part of \a this mesh.
- * This method avoids computing sub-mesh explicitely to get its types.
+ * This method avoids computing sub-mesh explicitly to get its types.
  *  \param [in] begin - an array of cell ids of interest.
  *  \param [in] end - the end of \a begin, i.e. a pointer to its (last+1)-th element.
  *  \return std::set<INTERP_KERNEL::NormalizedCellType> - a set of enumeration items
@@ -3839,7 +3847,7 @@
  * If not an exception will thrown. If this is an empty mesh with no cell an exception will be thrown too.
  * No consideration of coordinate is done by this method.
  * A 1D mesh is said contiguous if : a cell i with nodal connectivity (k,p) the cell i+1 the nodal connectivity should be (p,m)
- * If not false is returned. In case that false is returned a call to MEDCoupling::MEDCouplingUMesh::mergeNodes could be usefull.
+ * If not false is returned. In case that false is returned a call to MEDCoupling::MEDCouplingUMesh::mergeNodes could be useful.
  */
 bool MEDCouplingUMesh::isContiguous1D() const
 {
@@ -5417,6 +5425,8 @@
 DataArrayDouble *MEDCouplingUMesh::getBoundingBoxForBBTree2DQuadratic(double arcDetEps) const
 {
   checkFullyDefined();
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(arcDetEps);
+
   int spaceDim(getSpaceDimension()),mDim(getMeshDimension()),nbOfCells(getNumberOfCells());
   if(spaceDim!=2 || mDim!=2)
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::getBoundingBoxForBBTree2DQuadratic : This method should be applied on mesh with mesh dimension equal to 2 and space dimension also equal to 2!");
@@ -5428,7 +5438,6 @@
     {
       const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel((INTERP_KERNEL::NormalizedCellType)conn[*connI]));
       int sz(connI[1]-connI[0]-1);
-      INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=arcDetEps;
       std::vector<INTERP_KERNEL::Node *> nodes(sz);
       INTERP_KERNEL::QuadraticPolygon *pol(0);
       for(int j=0;j<sz;j++)
@@ -5465,6 +5474,7 @@
   int spaceDim(getSpaceDimension()),mDim(getMeshDimension()),nbOfCells(getNumberOfCells());
   if(spaceDim!=2 || mDim!=1)
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::getBoundingBoxForBBTree1DQuadratic : This method should be applied on mesh with mesh dimension equal to 1 and space dimension also equal to 2!");
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(arcDetEps);
   MCAuto<DataArrayDouble> ret(DataArrayDouble::New()); ret->alloc(nbOfCells,2*spaceDim);
   double *bbox(ret->getPointer());
   const double *coords(_coords->begin());
@@ -5473,7 +5483,6 @@
     {
       const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel((INTERP_KERNEL::NormalizedCellType)conn[*connI]));
       int sz(connI[1]-connI[0]-1);
-      INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=arcDetEps;
       std::vector<INTERP_KERNEL::Node *> nodes(sz);
       INTERP_KERNEL::Edge *edge(0);
       for(int j=0;j<sz;j++)
@@ -5524,7 +5533,7 @@
  * \a this is composed in cell types.
  * The returned array is of size 3*n where n is the number of different types present in \a this. 
  * For every k in [0,n] ret[3*k+2]==-1 because it has no sense here. 
- * This parameter is kept only for compatibility with other methode listed above.
+ * This parameter is kept only for compatibility with other method listed above.
  */
 std::vector<int> MEDCouplingUMesh::getDistributionOfTypes() const
 {
@@ -5569,7 +5578,7 @@
  * 
  * If all geometric types in \a code are exactly those in \a this null pointer is returned.
  * If it exists a geometric type in \a this \b not in \a code \b no exception is thrown 
- * and a DataArrayInt instance is returned that the user has the responsability to deallocate.
+ * and a DataArrayInt instance is returned that the user has the responsibility to deallocate.
  */
 DataArrayInt *MEDCouplingUMesh::checkTypeConsistencyAndContig(const std::vector<int>& code, const std::vector<const DataArrayInt *>& idsPerType) const
 {
@@ -5672,7 +5681,7 @@
  *              This vector can be empty in case of all geometric type cells are fully covered in ascending in the given input \a profile.
  * \throw if \a profile has not exactly one component. It throws too, if \a profile contains some values not in [0,getNumberOfCells()) or if \a this is not fully defined
  */
-void MEDCouplingUMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const
+void MEDCouplingUMesh::splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller) const
 {
   if(!profile)
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::splitProfilePerType : input profile is NULL !");
@@ -5714,7 +5723,7 @@
       code[3*i]=(int)types[castId];
       code[3*i+1]=tmp3->getNumberOfTuples();
       MCAuto<DataArrayInt> tmp4=rankInsideCast->selectByTupleId(tmp3->begin(),tmp3->begin()+tmp3->getNumberOfTuples());
-      if(!tmp4->isIota(typeRangeVals[castId+1]-typeRangeVals[castId]))
+      if(!smartPflKiller || !tmp4->isIota(typeRangeVals[castId+1]-typeRangeVals[castId]))
         {
           tmp4->copyStringInfoFrom(*profile);
           idsPerType2.push_back(tmp4);
@@ -5880,7 +5889,7 @@
 /*!
  * This method returns 2 newly allocated DataArrayInt instances. The first is an array of size 'this->getNumberOfCells()' with one component,
  * that tells for each cell the pos of its type in the array on type given in input parameter. The 2nd output parameter is an array with the same
- * number of tuples than input type array and with one component. This 2nd output array gives type by type the number of occurence of type in 'this'.
+ * number of tuples than input type array and with one component. This 2nd output array gives type by type the number of occurrence of type in 'this'.
  */
 DataArrayInt *MEDCouplingUMesh::getLevArrPerCellTypes(const INTERP_KERNEL::NormalizedCellType *orderBg, const INTERP_KERNEL::NormalizedCellType *orderEnd, DataArrayInt *&nbPerType) const
 {
@@ -5919,7 +5928,7 @@
 /*!
  * This method behaves exactly as MEDCouplingUMesh::getRenumArrForConsecutiveCellTypesSpec but the order is those defined in MED file spec.
  *
- * \return a new object containing the old to new correspondance.
+ * \return a new object containing the old to new correspondence.
  *
  * \sa MEDCouplingUMesh::getRenumArrForConsecutiveCellTypesSpec, MEDCouplingUMesh::sortCellsInMEDFileFrmt.
  */
@@ -5929,7 +5938,7 @@
 }
 
 /*!
- * This method is similar to method MEDCouplingUMesh::rearrange2ConsecutiveCellTypes except that the type order is specfied by [ \a orderBg , \a orderEnd ) (as MEDCouplingUMesh::checkConsecutiveCellTypesAndOrder method) and that this method is \b const and performs \b NO permutation in \a this.
+ * This method is similar to method MEDCouplingUMesh::rearrange2ConsecutiveCellTypes except that the type order is specified by [ \a orderBg , \a orderEnd ) (as MEDCouplingUMesh::checkConsecutiveCellTypesAndOrder method) and that this method is \b const and performs \b NO permutation in \a this.
  * This method returns an array of size getNumberOfCells() that gives a renumber array old2New that can be used as input of MEDCouplingMesh::renumberCells.
  * The mesh after this call to MEDCouplingMesh::renumberCells will pass the test of MEDCouplingUMesh::checkConsecutiveCellTypesAndOrder with the same inputs.
  * The returned array minimizes the permutations that is to say the order of cells inside same geometric type remains the same.
@@ -5948,7 +5957,7 @@
  * This method tries to minimizes the number of needed permutations. So, this method behaves not exactly as
  * MEDCouplingUMesh::sortCellsInMEDFileFrmt.
  *
- * \return the array giving the correspondance old to new.
+ * \return the array giving the correspondence old to new.
  */
 DataArrayInt *MEDCouplingUMesh::rearrange2ConsecutiveCellTypes()
 {
@@ -6121,7 +6130,7 @@
 /*!
  * This method takes in input a vector of MEDCouplingUMesh instances lying on the same coordinates with same mesh dimensions.
  * Each mesh in \b ms must be sorted by type with the same order (typically using MEDCouplingUMesh::sortCellsInMEDFileFrmt).
- * This method is particulary useful for MED file interaction. It allows to aggregate several meshes and keeping the type sorting
+ * This method is particularly useful for MED file interaction. It allows to aggregate several meshes and keeping the type sorting
  * and the track of the permutation by chunk of same geotype cells to retrieve it. The traditional formats old2new and new2old
  * are not used here to avoid the build of big permutation array.
  *
@@ -6784,7 +6793,7 @@
  * Makes all given meshes share the nodal connectivity array. The common connectivity
  * array is created by concatenating the connectivity arrays of all given meshes. All
  * the given meshes must be of the same space dimension but dimension of cells **can
- * differ**. This method is particulary useful in MEDLoader context to build a \ref
+ * differ**. This method is particularly useful in MEDLoader context to build a \ref
  * MEDCoupling::MEDFileUMesh "MEDFileUMesh" instance that expects that underlying
  * MEDCouplingUMesh'es of different dimension share the same nodal connectivity array.
  *  \param [in,out] meshes - a vector of meshes to update.
@@ -6838,7 +6847,7 @@
 /*!
  * Merges nodes coincident with a given precision within all given meshes that share
  * the nodal connectivity array. The given meshes **can be of different** mesh
- * dimension. This method is particulary useful in MEDLoader context to build a \ref
+ * dimension. This method is particularly useful in MEDLoader context to build a \ref
  * MEDCoupling::MEDFileUMesh "MEDFileUMesh" instance that expects that underlying
  * MEDCouplingUMesh'es of different dimension share the same nodal connectivity array. 
  *  \param [in,out] meshes - a vector of meshes to update.
@@ -6889,7 +6898,7 @@
 
 
 /*!
- * This static operates only for coords in 3D. The polygon is specfied by its connectivity nodes in [ \a begin , \a end ).
+ * This static operates only for coords in 3D. The polygon is specified by its connectivity nodes in [ \a begin , \a end ).
  */
 bool MEDCouplingUMesh::IsPolygonWellOriented(bool isQuadratic, const double *vec, const int *begin, const int *end, const double *coords)
 {
@@ -6933,7 +6942,7 @@
 }
 
 /*!
- * The polyhedron is specfied by its connectivity nodes in [ \a begin , \a end ).
+ * The polyhedron is specified by its connectivity nodes in [ \a begin , \a end ).
  */
 bool MEDCouplingUMesh::IsPolyhedronWellOriented(const int *begin, const int *end, const double *coords)
 {
@@ -7019,48 +7028,62 @@
  * \param [in] end end of nodal connectivity of a single polyhedron cell (excluded)
  * \param [out] res the result is put at the end of the vector without any alteration of the data.
  */
-void MEDCouplingUMesh::SimplifyPolyhedronCell(double eps, const DataArrayDouble *coords, const int *begin, const int *end, DataArrayInt *res)
+void MEDCouplingUMesh::SimplifyPolyhedronCell(double eps, const DataArrayDouble *coords, int index, DataArrayInt *res, MEDCouplingUMesh *faces,
+                                              DataArrayInt *E_Fi, DataArrayInt *E_F, DataArrayInt *F_Ei, DataArrayInt *F_E)
 {
-  int nbFaces=std::count(begin+1,end,-1)+1;
+  int nbFaces = E_Fi->getIJ(index + 1, 0) - E_Fi->getIJ(index, 0);
   MCAuto<DataArrayDouble> v=DataArrayDouble::New(); v->alloc(nbFaces,3);
   double *vPtr=v->getPointer();
-  MCAuto<DataArrayDouble> p=DataArrayDouble::New(); p->alloc(nbFaces,1);
+  MCAuto<DataArrayDouble> p=DataArrayDouble::New(); p->alloc(nbFaces,2);
   double *pPtr=p->getPointer();
-  const int *stFaceConn=begin+1;
+  int *e_fi = E_Fi->getPointer(), *e_f = E_F->getPointer(), *f_ei = F_Ei->getPointer(), *f_e = F_E->getPointer();
+  const int *f_idx = faces->getNodalConnectivityIndex()->getPointer(), *f_cnn = faces->getNodalConnectivity()->getPointer();
   for(int i=0;i<nbFaces;i++,vPtr+=3,pPtr++)
     {
-      const int *endFaceConn=std::find(stFaceConn,end,-1);
-      ComputeVecAndPtOfFace(eps,coords->begin(),stFaceConn,endFaceConn,vPtr,pPtr);
-      stFaceConn=endFaceConn+1;
+      int face = e_f[e_fi[index] + i];
+      ComputeVecAndPtOfFace(eps, coords->begin(), f_cnn + f_idx[face] + 1, f_cnn + f_idx[face + 1], vPtr, pPtr);
+      // to differentiate faces going to different cells:
+      pPtr++, *pPtr = 0;
+      for (int j = f_ei[face]; j < f_ei[face + 1]; j++)
+        *pPtr += f_e[j];
     }
   pPtr=p->getPointer(); vPtr=v->getPointer();
   DataArrayInt *comm1=0,*commI1=0;
   v->findCommonTuples(eps,-1,comm1,commI1);
+  for (int i = 0; i < nbFaces; i++)
+    if (comm1->findIdFirstEqual(i) < 0)
+      {
+        comm1->pushBackSilent(i);
+        commI1->pushBackSilent(comm1->getNumberOfTuples());
+      }
   MCAuto<DataArrayInt> comm1Auto(comm1),commI1Auto(commI1);
   const int *comm1Ptr=comm1->begin();
   const int *commI1Ptr=commI1->begin();
   int nbOfGrps1=commI1Auto->getNumberOfTuples()-1;
   res->pushBackSilent((int)INTERP_KERNEL::NORM_POLYHED);
   //
-  MCAuto<MEDCouplingUMesh> mm=MEDCouplingUMesh::New("",3);
-  mm->setCoords(const_cast<DataArrayDouble *>(coords)); mm->allocateCells(1); mm->insertNextCell(INTERP_KERNEL::NORM_POLYHED,(int)std::distance(begin+1,end),begin+1);
-  mm->finishInsertingCells();
-  //
   for(int i=0;i<nbOfGrps1;i++)
     {
       int vecId=comm1Ptr[commI1Ptr[i]];
       MCAuto<DataArrayDouble> tmpgrp2=p->selectByTupleId(comm1Ptr+commI1Ptr[i],comm1Ptr+commI1Ptr[i+1]);
       DataArrayInt *comm2=0,*commI2=0;
       tmpgrp2->findCommonTuples(eps,-1,comm2,commI2);
+      for (int j = 0; j < commI1Ptr[i+1] - commI1Ptr[i]; j++)
+        if (comm2->findIdFirstEqual(j) < 0)
+          {
+            comm2->pushBackSilent(j);
+            commI2->pushBackSilent(comm2->getNumberOfTuples());
+          }
       MCAuto<DataArrayInt> comm2Auto(comm2),commI2Auto(commI2);
       const int *comm2Ptr=comm2->begin();
       const int *commI2Ptr=commI2->begin();
       int nbOfGrps2=commI2Auto->getNumberOfTuples()-1;
       for(int j=0;j<nbOfGrps2;j++)
         {
-          if(commI2Ptr[j+1]-commI2Ptr[j]<=1)
+          if(commI2Ptr[j+1] == commI2Ptr[j] + 1)
             {
-              res->insertAtTheEnd(begin,end);
+              int face = e_f[e_fi[index] + comm1Ptr[commI1Ptr[i] + comm2Ptr[commI2Ptr[j]]]]; //hmmm
+              res->insertAtTheEnd(f_cnn + f_idx[face] + 1, f_cnn + f_idx[face + 1]);
               res->pushBackSilent(-1);
             }
           else
@@ -7068,13 +7091,12 @@
               int pointId=comm1Ptr[commI1Ptr[i]+comm2Ptr[commI2Ptr[j]]];
               MCAuto<DataArrayInt> ids2=comm2->selectByTupleIdSafeSlice(commI2Ptr[j],commI2Ptr[j+1],1);
               ids2->transformWithIndArr(comm1Ptr+commI1Ptr[i],comm1Ptr+commI1Ptr[i+1]);
-              DataArrayInt *tmp0=DataArrayInt::New(),*tmp1=DataArrayInt::New(),*tmp2=DataArrayInt::New(),*tmp3=DataArrayInt::New();
-              MCAuto<MEDCouplingUMesh> mm2=mm->buildDescendingConnectivity(tmp0,tmp1,tmp2,tmp3); tmp0->decrRef(); tmp1->decrRef(); tmp2->decrRef(); tmp3->decrRef();
-              MCAuto<MEDCouplingUMesh> mm3=static_cast<MEDCouplingUMesh *>(mm2->buildPartOfMySelf(ids2->begin(),ids2->end(),true));
+              ids2->transformWithIndArr(e_f + e_fi[index], e_f + e_fi[index + 1]);
+              MCAuto<MEDCouplingUMesh> mm3=static_cast<MEDCouplingUMesh *>(faces->buildPartOfMySelf(ids2->begin(),ids2->end(),true));
               MCAuto<DataArrayInt> idsNodeTmp=mm3->zipCoordsTraducer();
               MCAuto<DataArrayInt> idsNode=idsNodeTmp->invertArrayO2N2N2O(mm3->getNumberOfNodes());
               const int *idsNodePtr=idsNode->begin();
-              double center[3]; center[0]=pPtr[pointId]*vPtr[3*vecId]; center[1]=pPtr[pointId]*vPtr[3*vecId+1]; center[2]=pPtr[pointId]*vPtr[3*vecId+2];
+              double center[3]; center[0]=pPtr[2*pointId]*vPtr[3*vecId]; center[1]=pPtr[2*pointId]*vPtr[3*vecId+1]; center[2]=pPtr[2*pointId]*vPtr[3*vecId+2];
               double vec[3]; vec[0]=vPtr[3*vecId+1]; vec[1]=-vPtr[3*vecId]; vec[2]=0.;
               double norm=vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2];
               if(std::abs(norm)>eps)
@@ -7884,7 +7906,7 @@
  * This method works on an input pair (\b arrIn, \b arrIndxIn) where \b arrIn indexes is in \b arrIndxIn.
  * This method builds an output pair (\b arrOut,\b arrIndexOut) that is a copy from \b arrIn for all cell ids \b not \b in [ \b idsOfSelectBg , \b idsOfSelectEnd ) and for
  * cellIds \b in [ \b idsOfSelectBg , \b idsOfSelectEnd ) a copy coming from the corresponding values in input pair (\b srcArr, \b srcArrIndex).
- * This method is an generalization of MEDCouplingUMesh::SetPartOfIndexedArraysSameIdx that performs the same thing but by without building explicitely a result output arrays.
+ * This method is an generalization of MEDCouplingUMesh::SetPartOfIndexedArraysSameIdx that performs the same thing but by without building explicitly a result output arrays.
  *
  * \param [in] idsOfSelectBg begin of set of ids of the input extraction (included)
  * \param [in] idsOfSelectEnd end of set of ids of the input extraction (excluded)
@@ -7950,7 +7972,7 @@
 
 /*!
  * This method works on an input pair (\b arrIn, \b arrIndxIn) where \b arrIn indexes is in \b arrIndxIn.
- * This method is an specialization of MEDCouplingUMesh::SetPartOfIndexedArrays in the case of assignement do not modify the index in \b arrIndxIn.
+ * This method is an specialization of MEDCouplingUMesh::SetPartOfIndexedArrays in the case of assignment do not modify the index in \b arrIndxIn.
  *
  * \param [in] idsOfSelectBg begin of set of ids of the input extraction (included)
  * \param [in] idsOfSelectEnd end of set of ids of the input extraction (excluded)
@@ -8047,7 +8069,7 @@
  * This method works on an input pair (\b arrIn, \b arrIndxIn) where \b arrIn indexes is in \b arrIndxIn.
  * This method builds an output pair (\b arrOut,\b arrIndexOut) that is a copy from \b arrIn for all cell ids \b not \b in [ \b idsOfSelectBg , \b idsOfSelectEnd ) and for
  * cellIds \b in [\b idsOfSelectBg, \b idsOfSelectEnd) a copy coming from the corresponding values in input pair (\b srcArr, \b srcArrIndex).
- * This method is an generalization of MEDCouplingUMesh::SetPartOfIndexedArraysSameIdx that performs the same thing but by without building explicitely a result output arrays.
+ * This method is an generalization of MEDCouplingUMesh::SetPartOfIndexedArraysSameIdx that performs the same thing but by without building explicitly a result output arrays.
  *
  * \param [in] start begin of set of ids of the input extraction (included)
  * \param [in] end end of set of ids of the input extraction (excluded)
@@ -8112,7 +8134,7 @@
 
 /*!
  * This method works on an input pair (\b arrIn, \b arrIndxIn) where \b arrIn indexes is in \b arrIndxIn.
- * This method is an specialization of MEDCouplingUMesh::SetPartOfIndexedArrays in the case of assignement do not modify the index in \b arrIndxIn.
+ * This method is an specialization of MEDCouplingUMesh::SetPartOfIndexedArrays in the case of assignment do not modify the index in \b arrIndxIn.
  *
  * \param [in] start begin of set of ids of the input extraction (included)
  * \param [in] end end of set of ids of the input extraction (excluded)
@@ -8282,7 +8304,7 @@
  *         decrRef() as it is no more needed.
  * \return MEDCoupling1SGTUMesh * - the mesh containing only INTERP_KERNEL::NORM_TETRA4 cells.
  *
- * \warning This method operates on each cells in this independantly ! So it can leads to non conform mesh in returned value ! If you expect to have a conform mesh in output
+ * \warning This method operates on each cells in this independently ! So it can leads to non conform mesh in returned value ! If you expect to have a conform mesh in output
  * the policy PLANAR_FACE_6 should be used on a mesh sorted with MEDCoupling1SGTUMesh::sortHexa8EachOther.
  * 
  * \throw If \a this is not a 3D mesh (spaceDim==3 and meshDim==3).
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh.hxx	2018-04-19 17:04:36.722222424 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh.hxx	2018-04-19 17:25:18.041803366 +0200
@@ -196,6 +196,7 @@
     MEDCOUPLING_EXPORT void orientCorrectlyPolyhedrons();
     MEDCOUPLING_EXPORT void invertOrientationOfAllCells();
     MEDCOUPLING_EXPORT void getFastAveragePlaneOfThis(double *vec, double *pos) const;
+    MEDCOUPLING_EXPORT void attractSeg3MidPtsAroundNodes(double ratio, const int *nodeIdsBg, const int *nodeIdsEnd);
     //Mesh quality
     MEDCOUPLING_EXPORT MEDCouplingFieldDouble *getEdgeRatioField() const;
     MEDCOUPLING_EXPORT MEDCouplingFieldDouble *getAspectRatioField() const;
@@ -205,7 +206,7 @@
     //utilities for MED File RW
     MEDCOUPLING_EXPORT std::vector<int> getDistributionOfTypes() const;
     MEDCOUPLING_EXPORT DataArrayInt *checkTypeConsistencyAndContig(const std::vector<int>& code, const std::vector<const DataArrayInt *>& idsPerType) const;
-    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType) const;
+    MEDCOUPLING_EXPORT void splitProfilePerType(const DataArrayInt *profile, std::vector<int>& code, std::vector<DataArrayInt *>& idsInPflPerType, std::vector<DataArrayInt *>& idsPerType, bool smartPflKiller=true) const;
     MEDCOUPLING_EXPORT MEDCouplingUMesh *emulateMEDMEMBDC(const MEDCouplingUMesh *nM1LevMesh, DataArrayInt *desc, DataArrayInt *descIndx, DataArrayInt *&revDesc, DataArrayInt *&revDescIndx, DataArrayInt *& nM1LevMeshIds, DataArrayInt *&meshnM1Old2New) const;
     MEDCOUPLING_EXPORT DataArrayInt *sortCellsInMEDFileFrmt();
     MEDCOUPLING_EXPORT bool checkConsecutiveCellTypes() const;
@@ -251,7 +252,8 @@
     MEDCOUPLING_EXPORT static void CorrectExtrudedStaticCell(int *begin, int *end);
     MEDCOUPLING_EXPORT static bool IsTetra4WellOriented(const int *begin, const int *end, const double *coords);
     MEDCOUPLING_EXPORT static bool IsPyra5WellOriented(const int *begin, const int *end, const double *coords);
-    MEDCOUPLING_EXPORT static void SimplifyPolyhedronCell(double eps, const DataArrayDouble *coords, const int *begin, const int *end, DataArrayInt *res);
+    MEDCOUPLING_EXPORT static void SimplifyPolyhedronCell(double eps, const DataArrayDouble *coords, int index, DataArrayInt *res, MEDCouplingUMesh *faces,
+                                                          DataArrayInt *E_Fi, DataArrayInt *E_F, DataArrayInt *F_Ei, DataArrayInt *F_E);
     MEDCOUPLING_EXPORT static void ComputeVecAndPtOfFace(double eps, const double *coords, const int *begin, const int *end, double *v, double *p);
     MEDCOUPLING_EXPORT static void TryToCorrectPolyhedronOrientation(int *begin, int *end, const double *coords);
     MEDCOUPLING_EXPORT static MEDCouplingUMesh *Intersect2DMeshes(const MEDCouplingUMesh *m1, const MEDCouplingUMesh *m2, double eps, DataArrayInt *&cellNb1, DataArrayInt *&cellNb2);
@@ -355,9 +357,10 @@
                                                 std::vector<int> & pointIds, std::vector<int> & hitSegs);
     static void ReplaceEdgeInFace(const int * sIdxConn, const int * sIdxConnE, int startNode, int endNode,
                                       const std::vector<int>& insidePoints, std::vector<int>& modifiedFace);
+    void attractSeg3MidPtsAroundNodesUnderground(double ratio, const int *nodeIdsBg, const int *nodeIdsEnd);
   public:
     MEDCOUPLING_EXPORT static DataArrayInt *ComputeRangesFromTypeDistribution(const std::vector<int>& code);
-    MEDCOUPLING_EXPORT static const int N_MEDMEM_ORDER=24;
+    MEDCOUPLING_EXPORT static const int N_MEDMEM_ORDER=25;
     MEDCOUPLING_EXPORT static const INTERP_KERNEL::NormalizedCellType MEDMEM_ORDER[N_MEDMEM_ORDER];
     MEDCOUPLING_EXPORT static const int MEDCOUPLING2VTKTYPETRADUCER[INTERP_KERNEL::NORM_MAXTYPE+1];
     /// @endcond
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh_internal.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh_internal.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh_internal.cxx	2018-04-19 17:04:36.722222424 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh_internal.cxx	2018-04-19 17:25:18.122804967 +0200
@@ -348,7 +348,7 @@
   double epsa=fabs(eps);
   if(epsa<std::numeric_limits<double>::min())
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::tessellate2DCurveInternal : epsilon is null ! Please specify a higher epsilon. If too tiny it can lead to a huge amount of nodes and memory !");
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=1.e-10;
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(1.e-10);  // RAII
   int nbCells=getNumberOfCells();
   int nbNodes=getNumberOfNodes();
   const int *conn=_nodal_connec->begin();
@@ -414,7 +414,7 @@
 
 /*!
  * This private method is used to subdivide edges of a mesh with meshdim==2. If \a this has no a meshdim equal to 2 an exception will be thrown.
- * This method completly ignore coordinates.
+ * This method completely ignores coordinates.
  * \param nodeSubdived is the nodal connectivity of subdivision of edges
  * \param nodeIndxSubdived is the nodal connectivity index of subdivision of edges
  * \param desc is descending connectivity in format specified in MEDCouplingUMesh::buildDescendingConnectivity2
@@ -1585,7 +1585,7 @@
  * This method is part of the Slice3D algorithm. It is the first step of assembly process, ones coordinates have been computed (by MEDCouplingUMesh::split3DCurveWithPlane method).
  * This method allows to compute given the status of 3D curve cells and the descending connectivity 3DSurf->3DCurve to deduce the intersection of each 3D surf cells
  * with a plane. The result will be put in 'cut3DSuf' out parameter.
- * \param [in] cut3DCurve  input paramter that gives for each 3DCurve cell if it owns fully to the plane or partially.
+ * \param [in] cut3DCurve  input parameter that gives for each 3DCurve cell if it owns fully to the plane or partially.
  * \param [out] nodesOnPlane, returns all the nodes that are on the plane.
  * \param [in] nodal3DSurf is the nodal connectivity of 3D surf mesh.
  * \param [in] nodalIndx3DSurf is the nodal connectivity index of 3D surf mesh.
@@ -1663,7 +1663,7 @@
  * This method is part of the Slice3D algorithm. It is the second step of assembly process, ones coordinates have been computed (by MEDCouplingUMesh::split3DCurveWithPlane method).
  * This method allows to compute given the result of 3D surf cells with plane and the descending connectivity 3D->3DSurf to deduce the intersection of each 3D cells
  * with a plane. The result will be put in 'nodalRes' 'nodalResIndx' and 'cellIds' out parameters.
- * \param cut3DSurf  input paramter that gives for each 3DSurf its intersection with plane (result of MEDCouplingUMesh::AssemblyForSplitFrom3DCurve).
+ * \param cut3DSurf  input parameter that gives for each 3DSurf its intersection with plane (result of MEDCouplingUMesh::AssemblyForSplitFrom3DCurve).
  * \param desc is the descending connectivity 3D->3DSurf
  * \param descIndx is the descending connectivity index 3D->3DSurf
  */
@@ -1754,3 +1754,88 @@
           types.insert((INTERP_KERNEL::NormalizedCellType)conn[*pt]);
     }
 }
+
+/*!
+ * This method expects that \a this a quadratic 1D, 2D or 3D mesh.
+ * This method will 'attract' middle points of seg3 (deduced from this by explosion if needed) of cells connected to nodes specified in [\a nodeIdsBg, \a nodeIdsEnd )
+ * For those selected mid points, their coordinates will be modified by applying a dilation between node in input [\a nodeIdsBg, \a nodeIdsEnd ) and the corresponding mid points using \a ratio input value.
+ * So this method is non const because coordinates are modified.
+ * If there is a couple of 2 points in [\a nodeIdsBg, \a nodeIdsEnd ) that are boundaries of a seg3, the corresponding mid point will remain untouched.
+ *
+ * \param [in] ratio - ratio of dilation
+ * \param [in] nodeIdsBg - start (included) of input node list
+ * \param [in] nodeIdsEnd - end (excluded) of input node list
+ * \throw if there is a point in [\a nodeIdsBg, \a nodeIdsEnd ) that is a mid point of a seg3
+ * \warning in case of throw the coordinates may be partially modified before the exception arises
+ */
+void MEDCouplingUMesh::attractSeg3MidPtsAroundNodes(double ratio, const int *nodeIdsBg, const int *nodeIdsEnd)
+{
+  checkFullyDefined();
+  int mdim(getMeshDimension());
+  if(mdim==2 || mdim==3)
+    {
+      MCAuto<MEDCouplingUMesh> edges;
+      {
+        MCAuto<DataArrayInt> a,b,c,d;
+        edges=this->explodeIntoEdges(a,b,c,d);
+      }
+      return edges->attractSeg3MidPtsAroundNodesUnderground(ratio,nodeIdsBg,nodeIdsEnd);
+    }
+  if(mdim==1)
+    return attractSeg3MidPtsAroundNodesUnderground(ratio,nodeIdsBg,nodeIdsEnd);
+  throw INTERP_KERNEL::Exception("MEDCouplingUMesh::attractSeg3MidPtsAroundNodes : not managed dimension ! Should be in [1,2,3] !");
+}
+
+/*!
+ * \a this is expected to have meshdim==1.
+ */
+void MEDCouplingUMesh::attractSeg3MidPtsAroundNodesUnderground(double ratio, const int *nodeIdsBg, const int *nodeIdsEnd)
+{
+#if __cplusplus >= 201103L
+  int spaceDim(getSpaceDimension());
+  double *coords(getCoords()->getPointer());
+  auto nbNodes(getNumberOfNodes());
+  auto nbCells(getNumberOfCells());
+  std::vector<bool> fastFinder(nbNodes,false);
+  for(auto work=nodeIdsBg;work!=nodeIdsEnd;work++)
+    if(*work>=0 && *work<nbNodes)
+      fastFinder[*work]=true;
+  MCAuto<DataArrayInt> cellsIds(getCellIdsLyingOnNodes(nodeIdsBg,nodeIdsEnd,false));
+  const int *nc(_nodal_connec->begin()),*nci(_nodal_connec_index->begin());
+  for(auto cellId=0;cellId<nbCells;cellId++,nci++)
+    {
+      const int *isSelected(std::find_if(nc+nci[0]+1,nc+nci[1],[&fastFinder](int v) { return fastFinder[v]; }));
+      if(isSelected!=nc+nci[1])
+        {
+          if((INTERP_KERNEL::NormalizedCellType)nc[nci[0]]==INTERP_KERNEL::NORM_SEG3 && nci[1]-nci[0]==4)
+            {
+              bool aa(fastFinder[nc[*nci+1]]),bb(fastFinder[nc[*nci+2]]),cc(fastFinder[nc[*nci+3]]);
+              if(!cc)
+                {
+                  if(aa^bb)
+                    {
+                      auto ptToMove(nc[*nci+3]);
+                      auto attractor(aa?nc[*nci+1]:nc[*nci+2]),endPt(aa?nc[*nci+2]:nc[*nci+1]);
+                      std::transform(coords+spaceDim*attractor,coords+spaceDim*(attractor+1),coords+spaceDim*endPt,
+                                     coords+spaceDim*ptToMove,[ratio](const double& stPt, const double& endPt) { return stPt+ratio*(endPt-stPt); });
+                    }
+                  else
+                    continue;//both 2 boundary nodes of current seg3 are un nodeIds input list -> skip it.
+                }
+              else
+                {
+                  std::ostringstream oss; oss << "MEDCouplingUMesh::attractSeg3MidPtsAroundNodes : cell #" << cellId << " has a mid point " << nc[*nci+3] << " ! This node is in input list !";
+                  throw INTERP_KERNEL::Exception(oss.str());
+                }
+            }
+          else
+            {
+              std::ostringstream oss; oss << "MEDCouplingUMesh::attractSeg3MidPtsAroundNodes : cell #" << cellId << " sharing one of the input nodes list its geo type is NOT SEG3 !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+        }
+    }
+#else
+  throw INTERP_KERNEL::Exception("MEDCouplingUMesh::attractSeg3MidPtsAroundNodes : for your information new compiler have arrived since Fortran66 compiler :)");
+#endif 
+}
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh_internal.hxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh_internal.hxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh_internal.hxx	2018-04-19 17:04:36.722222424 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh_internal.hxx	2018-04-19 17:25:18.111804749 +0200
@@ -102,6 +102,10 @@
 void MEDCouplingUMesh::getCellsContainingPointsAlg(const double *coords, const double *pos, int nbOfPoints,
                                                    double eps, MCAuto<DataArrayInt>& elts, MCAuto<DataArrayInt>& eltsIndex) const
 {
+  // Override precision for this method only:
+  INTERP_KERNEL::QuadraticPlanarPrecision prec(eps);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(eps);
+
   elts=DataArrayInt::New(); eltsIndex=DataArrayInt::New(); eltsIndex->alloc(nbOfPoints+1,1); eltsIndex->setIJ(0,0,0); elts->alloc(0,1);
   int *eltsIndexPtr(eltsIndex->getPointer());
   MCAuto<DataArrayDouble> bboxArr(getBoundingBoxForBBTree(eps));
@@ -132,8 +136,6 @@
             {
               if(SPACEDIM!=2)
                 throw INTERP_KERNEL::Exception("MEDCouplingUMesh::getCellsContainingPointsAlg : not implemented yet for POLYGON and QPOLYGON in spaceDim 3 !");
-              INTERP_KERNEL::QUADRATIC_PLANAR::_precision=eps;
-              INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=eps;
               std::vector<INTERP_KERNEL::Node *> nodes(sz);
               INTERP_KERNEL::QuadraticPolygon *pol(0);
               for(int j=0;j<sz;j++)
diff -Naur MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh_intersection.cxx MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh_intersection.cxx
--- MEDCOUPLING_old/src/MEDCoupling/MEDCouplingUMesh_intersection.cxx	2018-04-19 17:04:36.723222444 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/MEDCouplingUMesh_intersection.cxx	2018-04-19 17:25:18.034803227 +0200
@@ -282,7 +282,7 @@
   }
 
   /**
-   * Construct a mapping between set of Nodes and the standart MEDCoupling connectivity format (c, cI).
+   * Construct a mapping between set of Nodes and the standard MEDCoupling connectivity format (c, cI).
    */
   void MEDCouplingUMeshBuildQPFromMesh3(const double *coo1, int offset1, const double *coo2, int offset2, const std::vector<double>& addCoo,
                                         const int *desc1Bg, const int *desc1End, const std::vector<std::vector<int> >& intesctEdges1,
@@ -337,7 +337,7 @@
       // This initializes posBaseElt.
       if(nbOfTurn==0)
         {
-          for(unsigned i=1;i<nbs && nbOfHit<maxNbOfHit;i++) // 2nd condition is to avoid ending with a cell wih one single edge
+          for(unsigned i=1;i<nbs && nbOfHit<maxNbOfHit;i++) // 2nd condition is to avoid ending with a cell with one single edge
             {
               cm.fillSonCellNodalConnectivity2(nbs-i,connBg+1,sz,tmpConn,typeOfSon);
               INTERP_KERNEL::Edge *eCand(MEDCouplingUMeshBuildQPFromEdge2(typeOfSon,tmpConn,coords,m));
@@ -357,7 +357,7 @@
         }
       // Now move forward:
       const unsigned fwdStart = (nbOfTurn == 0 ? 0 : posBaseElt);  // the first element to be inspected going forward
-      for(unsigned j=fwdStart+1;j<nbs && nbOfHit<maxNbOfHit;j++)  // 2nd condition is to avoid ending with a cell wih one single edge
+      for(unsigned j=fwdStart+1;j<nbs && nbOfHit<maxNbOfHit;j++)  // 2nd condition is to avoid ending with a cell with one single edge
         {
           cm.fillSonCellNodalConnectivity2((int)j,connBg+1,sz,tmpConn,typeOfSon); // get edge #j's connectivity
           INTERP_KERNEL::Edge *eCand(MEDCouplingUMeshBuildQPFromEdge2(typeOfSon,tmpConn,coords,m));
@@ -375,9 +375,9 @@
               break;
         }
       //push [posBaseElt,posEndElt) in newConnOfCell using e
-      // The if clauses below are (volontary) not mutually exclusive: on a quad cell with 2 edges, the end of the connectivity is also its begining!
+      // The if clauses below are (voluntary) not mutually exclusive: on a quad cell with 2 edges, the end of the connectivity is also its beginning!
       if(nbOfTurn==0)
-        // at the begining of the connectivity (insert type)
+        // at the beginning of the connectivity (insert type)
         EnterTheResultOf2DCellFirst(e,posBaseElt,posEndElt,(int)nbs,cm.isQuadratic(),coords,connBg+1,offset,newConnOfCell,appendedCoords,middles);
       else if((nbOfHit+nbOfTurn) != (nbs-1))
         // in the middle
@@ -430,7 +430,7 @@
  * (Only present for its coords in case of 'subDiv' shares some nodes of 'm1')
  * \param m2 is expected to be a mesh of meshDimension equal to 1 and spaceDim equal to 2. No check of that is performed by this method.
  * \param addCoo input parameter with additional nodes linked to intersection of the 2 meshes.
- * \param[out] intersectEdge the same content as subDiv, but correclty oriented.
+ * \param[out] intersectEdge the same content as subDiv, but correctly oriented.
  */
 void MEDCouplingUMesh::BuildIntersectEdges(const MEDCouplingUMesh *m1, const MEDCouplingUMesh *m2,
                                            const std::vector<double>& addCoo,
@@ -1170,11 +1170,11 @@
                                          std::vector< std::vector<int> >& intersectEdge1, std::vector< std::vector<int> >& colinear2, std::vector< std::vector<int> >& subDiv2, std::vector<double>& addCoo, std::map<int,int>& mergedNodes)
 {
   static const int SPACEDIM=2;
-  INTERP_KERNEL::QUADRATIC_PLANAR::_precision=eps;
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=eps;
+  INTERP_KERNEL::QuadraticPlanarPrecision prec(eps);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(eps);
   const int *c1(m1Desc->getNodalConnectivity()->begin()),*ci1(m1Desc->getNodalConnectivityIndex()->begin());
   // Build BB tree of all edges in the tool mesh (second mesh)
-  MCAuto<DataArrayDouble> bbox1Arr(m1Desc->getBoundingBoxForBBTree()),bbox2Arr(m2Desc->getBoundingBoxForBBTree());
+  MCAuto<DataArrayDouble> bbox1Arr(m1Desc->getBoundingBoxForBBTree(eps)),bbox2Arr(m2Desc->getBoundingBoxForBBTree(eps));
   const double *bbox1(bbox1Arr->begin()),*bbox2(bbox2Arr->begin());
   int nDescCell1(m1Desc->getNumberOfCells()),nDescCell2(m2Desc->getNumberOfCells());
   intersectEdge1.resize(nDescCell1);
@@ -1206,7 +1206,7 @@
           for(std::size_t iii=0;iii<szz;iii++,itt++)
             { (*itt)->incrRef(); nodesSafe[iii]=*itt; }
           // end of protection
-          // Performs egde cutting:
+          // Performs edge cutting:
           pol1->splitAbs(*pol2,map1,map2,offset1,offset2,candidates2,intersectEdge1[i],i,colinear2,subDiv2,addCoo,mergedNodes);
           delete pol2;
           delete pol1;
@@ -1252,7 +1252,7 @@
  * (newly created) nodes corresponding to the edge intersections.
  * Output params:
  * @param[out] cr, crI connectivity of the resulting mesh
- * @param[out] cNb1, cNb2 correspondance arrays giving for the merged mesh the initial cells IDs in m1 / m2
+ * @param[out] cNb1, cNb2 correspondence arrays giving for the merged mesh the initial cells IDs in m1 / m2
  * TODO: describe input parameters
  */
 void MEDCouplingUMesh::BuildIntersecting2DCellsFromEdges(double eps, const MEDCouplingUMesh *m1, const int *desc1, const int *descIndx1,
@@ -1269,7 +1269,7 @@
   const int *conn2(m2->getNodalConnectivity()->begin()),*connI2(m2->getNodalConnectivityIndex()->begin());
   int offset2(offset1+m2->getNumberOfNodes());
   int offset3(offset2+((int)addCoords.size())/2);
-  MCAuto<DataArrayDouble> bbox1Arr(m1->getBoundingBoxForBBTree()),bbox2Arr(m2->getBoundingBoxForBBTree());
+  MCAuto<DataArrayDouble> bbox1Arr(m1->getBoundingBoxForBBTree(eps)),bbox2Arr(m2->getBoundingBoxForBBTree(eps));
   const double *bbox1(bbox1Arr->begin()),*bbox2(bbox2Arr->begin());
   // Here a BBTree on 2D-cells, not on segments:
   BBTree<SPACEDIM,int> myTree(bbox2,0,0,m2->getNumberOfCells(),eps);
@@ -1431,7 +1431,7 @@
 }
 
 /*!
- * It is the linear part of MEDCouplingUMesh::split2DCells. Here no additionnal nodes will be added in \b this. So coordinates pointer remain unchanged (is not even touch).
+ * It is the linear part of MEDCouplingUMesh::split2DCells. Here no additional nodes will be added in \b this. So coordinates pointer remain unchanged (is not even touch).
  *
  * \sa MEDCouplingUMesh::split2DCells
  */
@@ -1467,7 +1467,7 @@
 
 
 /*!
- * It is the quadratic part of MEDCouplingUMesh::split2DCells. Here some additionnal nodes can be added at the end of coordinates array object.
+ * It is the quadratic part of MEDCouplingUMesh::split2DCells. Here some additional nodes can be added at the end of coordinates array object.
  *
  * \return  int - the number of new nodes created.
  * \sa MEDCouplingUMesh::split2DCells
@@ -1567,6 +1567,8 @@
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::Intersect2DMeshes : input meshes must be not NULL !");
   m1->checkFullyDefined();
   m2->checkFullyDefined();
+  INTERP_KERNEL::QuadraticPlanarPrecision prec(eps);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(eps);
   if(m1->getMeshDimension()!=2 || m1->getSpaceDimension()!=2 || m2->getMeshDimension()!=2 || m2->getSpaceDimension()!=2)
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::Intersect2DMeshes works on umeshes m1 AND m2  with meshdim equal to 2 and spaceDim equal to 2 too!");
 
@@ -1617,7 +1619,7 @@
 /*!
  * Partitions the first given 2D mesh using the second given 1D mesh as a tool.
  * Thus the final result contains the aggregation of nodes of \a mesh2D, then nodes of \a mesh1D, then new nodes that are the result of the intersection
- * and finaly, in case of quadratic polygon the centers of edges new nodes.
+ * and finally, in case of quadratic polygon the centers of edges new nodes.
  * The meshes should be in 2D space. In addition, returns two arrays mapping cells of the resulting mesh to cells of the input.
  *
  * \param [in] mesh2D - the 2D mesh (spacedim=meshdim=2) to be intersected using \a mesh1D tool. The mesh must be so that each point in the space covered by \a mesh2D
@@ -1647,8 +1649,8 @@
   // Step 1: compute all edge intersections (new nodes)
   std::vector< std::vector<int> > intersectEdge1, colinear2, subDiv2;
   std::vector<double> addCoo,addCoordsQuadratic;  // coordinates of newly created nodes
-  INTERP_KERNEL::QUADRATIC_PLANAR::_precision=eps;
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=eps;
+  INTERP_KERNEL::QuadraticPlanarPrecision prec(eps);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(eps);
   //
   // Build desc connectivity
   DataArrayInt *desc1(DataArrayInt::New()),*descIndx1(DataArrayInt::New()),*revDesc1(DataArrayInt::New()),*revDescIndx1(DataArrayInt::New());
@@ -1702,7 +1704,9 @@
   MCAuto<DataArrayDouble> baryRet1(ret1NonCol->computeCellCenterOfMass());
   MCAuto<DataArrayInt> elts,eltsIndex;
   mesh2D->getCellsContainingPoints(baryRet1->begin(),baryRet1->getNumberOfTuples(),eps,elts,eltsIndex);
-  MCAuto<DataArrayInt> eltsIndex2(eltsIndex->deltaShiftIndex());
+  MCAuto<DataArrayInt> eltsIndex2(DataArrayInt::New()); eltsIndex2->alloc(0,1);
+  if (eltsIndex->getNumberOfTuples() > 1)
+    eltsIndex2 = eltsIndex->deltaShiftIndex();
   MCAuto<DataArrayInt> eltsIndex3(eltsIndex2->findIdsEqual(1));
   if(eltsIndex2->count(0)+eltsIndex3->getNumberOfTuples()!=ret1NonCol->getNumberOfCells())
     throw INTERP_KERNEL::Exception("Intersect2DMeshWith1DLine : internal error 1 !");
@@ -1809,7 +1813,7 @@
  * \b WARNING this method lead to have a non geometric type sorted mesh (for MED file users) !
  * This method performs a conformization of \b this. So if a edge in \a this can be split into entire edges in \a this this method
  * will suppress such edges to use sub edges in \a this. So this method does not add nodes in \a this if merged edges are both linear (INTERP_KERNEL::NORM_SEG2).
- * In the other cases new nodes can be created. If any are created, they will be appended at the end of the coordinates object before the invokation of this method.
+ * In the other cases new nodes can be created. If any are created, they will be appended at the end of the coordinates object before the invocation of this method.
  *
  * Whatever the returned value, this method does not alter the order of cells in \a this neither the orientation of cells.
  * The modified cells, if any, are systematically declared as NORM_POLYGON or NORM_QPOLYG depending on the initial quadraticness of geometric type.
@@ -1836,14 +1840,14 @@
   MCAuto<DataArrayInt> desc1(DataArrayInt::New()),descIndx1(DataArrayInt::New()),revDesc1(DataArrayInt::New()),revDescIndx1(DataArrayInt::New());
   MCAuto<MEDCouplingUMesh> mDesc(buildDescendingConnectivity(desc1,descIndx1,revDesc1,revDescIndx1));
   const int *c(mDesc->getNodalConnectivity()->begin()),*ci(mDesc->getNodalConnectivityIndex()->begin()),*rd(revDesc1->begin()),*rdi(revDescIndx1->begin());
-  MCAuto<DataArrayDouble> bboxArr(mDesc->getBoundingBoxForBBTree());
+  MCAuto<DataArrayDouble> bboxArr(mDesc->getBoundingBoxForBBTree(eps));
   const double *bbox(bboxArr->begin()),*coords(getCoords()->begin());
   int nCell(getNumberOfCells()),nDescCell(mDesc->getNumberOfCells());
   std::vector< std::vector<int> > intersectEdge(nDescCell),overlapEdge(nDescCell);
   std::vector<double> addCoo;
   BBTree<SPACEDIM,int> myTree(bbox,0,0,nDescCell,-eps);
-  INTERP_KERNEL::QUADRATIC_PLANAR::_precision=eps;
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=eps;
+  INTERP_KERNEL::QuadraticPlanarPrecision prec(eps);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(eps);
   for(int i=0;i<nDescCell;i++)
     {
       std::vector<int> candidates;
@@ -1948,7 +1952,7 @@
  * If yes, the cell is "repaired" to minimize at most its number of edges. So this method do not change the overall shape of cells in \a this (with eps precision).
  * This method do not take care of shared edges between cells, so this method can lead to a non conform mesh (\a this). If a conform mesh is required you're expected
  * to invoke MEDCouplingUMesh::mergeNodes and MEDCouplingUMesh::conformize2D right after this call.
- * This method works on any 2D geometric types of cell (even static one). If a cell is touched its type becomes dynamic automaticaly. For 2D "repaired" quadratic cells
+ * This method works on any 2D geometric types of cell (even static one). If a cell is touched its type becomes dynamic automatically. For 2D "repaired" quadratic cells
  * new nodes for center of merged edges is are systematically created and appended at the end of the previously existing nodes.
  *
  * If the returned array is empty it means that nothing has changed in \a this (as if it were a const method). If the array is not empty the connectivity of \a this is modified
@@ -1970,8 +1974,8 @@
   checkConsistencyLight();
   if(getSpaceDimension()!=2 || getMeshDimension()!=2)
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::colinearize2D : This method only works for meshes with spaceDim=2 and meshDim=2 !");
-  INTERP_KERNEL::QUADRATIC_PLANAR::_arc_detection_precision=eps;
-  INTERP_KERNEL::QUADRATIC_PLANAR::_precision=eps;
+  INTERP_KERNEL::QuadraticPlanarPrecision prec(eps);
+  INTERP_KERNEL::QuadraticPlanarArcDetectionPrecision arcPrec(eps);
   int nbOfCells(getNumberOfCells()),nbOfNodes(getNumberOfNodes());
   const int *cptr(_nodal_connec->begin()),*ciptr(_nodal_connec_index->begin());
   MCAuto<DataArrayInt> newc(DataArrayInt::New()),newci(DataArrayInt::New()); newci->alloc(nbOfCells+1,1); newc->alloc(0,1); newci->setIJ(0,0,0);
@@ -2084,7 +2088,7 @@
     throw INTERP_KERNEL::Exception("MEDCouplingUMesh::ReplaceEdgeInFace: internal error, should never happen!");
   int d = distance(startPos, endPos);
   if (d == 1 || d == (1-dst)) // don't use modulo, for neg numbers, result is implementation defined ...
-    modifiedFace.insert(++startPos, ++insidePoints.begin(), --insidePoints.end());  // insidePoints also contains start and end node. Those dont need to be inserted.
+    modifiedFace.insert(++startPos, ++insidePoints.begin(), --insidePoints.end());  // insidePoints also contains start and end node. Those don't need to be inserted.
   else
     modifiedFace.insert(++endPos, ++insidePoints.rbegin(), --insidePoints.rend());
 }
@@ -2138,7 +2142,7 @@
     MCAuto<MEDCouplingSkyLineArray> connSlaDesc(MEDCouplingSkyLineArray::New(mDesc->getNodalConnectivityIndex(), mDesc->getNodalConnectivity()));
 
     // Build BBTree
-    MCAuto<DataArrayDouble> bboxArr(mDesc->getBoundingBoxForBBTree());
+    MCAuto<DataArrayDouble> bboxArr(mDesc->getBoundingBoxForBBTree(eps));
     const double *bbox(bboxArr->begin()); getCoords()->begin();
     int nDescCell(mDesc->getNumberOfCells());
     BBTree<SPACEDIM,int> myTree(bbox,0,0,nDescCell,-eps);
@@ -2162,7 +2166,7 @@
     fill(hit.begin(), hit.end(), false);
     vector<int> hitPoly; // the final result: which 3D cells have been modified.
 
-    for( vector<pair<double,int>>::const_iterator it = S.begin(); it != S.end(); it++)
+    for( vector<pair<double,int> >::const_iterator it = S.begin(); it != S.end(); it++)
       {
         int faceIdx = (*it).second;
         if (hit[faceIdx]) continue;
@@ -2260,7 +2264,7 @@
           {
             if (packsIds[jj] == -1)
               // The below should never happen - if a face is used several times, with a different layout of the nodes
-              // it means that is is already conform, so it is *not* hit by the algorithm. The algorithm only hits
+              // it means that it is already conform, so it is *not* hit by the algorithm. The algorithm only hits
               // faces which are actually used only once, by a single cell. This is different for edges below.
               throw INTERP_KERNEL::Exception("MEDCouplingUMesh::conformize3D: Could not find face in connectivity! Internal error.");
             else
@@ -2308,7 +2312,7 @@
 //    mDesc2->writeVTK("/tmp/toto_desc2_confInter.vtu");
     const int *revDescIP2(revDescI2->getConstPointer()), *revDescP2(revDesc2->getConstPointer());
     const int *cDesc2(mDesc2->getNodalConnectivity()->begin()),*cIDesc2(mDesc2->getNodalConnectivityIndex()->begin());
-    MCAuto<DataArrayDouble> bboxArr(mDesc2->getBoundingBoxForBBTree());
+    MCAuto<DataArrayDouble> bboxArr(mDesc2->getBoundingBoxForBBTree(eps));
     const double *bbox2(bboxArr->begin());
     int nDesc2Cell=mDesc2->getNumberOfCells();
     BBTree<SPACEDIM,int> myTree2(bbox2,0,0,nDesc2Cell,-eps);
@@ -2318,7 +2322,7 @@
     DataArrayDouble * lens = lenF->getArray();
 
     // Sort edges by decreasing length:
-    vector<pair<double,int>> S;
+    vector<pair<double,int> > S;
     for(std::size_t i=0;i < lens->getNumberOfTuples();i++)
       {
         pair<double,int> p = make_pair(lens->getIJ(i, 0), i);
@@ -2329,7 +2333,7 @@
     vector<bool> hit(nDesc2Cell);
     fill(hit.begin(), hit.end(), false);
 
-    for( vector<pair<double,int>>::const_iterator it = S.begin(); it != S.end(); it++)
+    for( vector<pair<double,int> >::const_iterator it = S.begin(); it != S.end(); it++)
       {
         int eIdx = (*it).second;
         if (hit[eIdx])
@@ -2397,7 +2401,7 @@
             mPartCand->getNodalConnectivity()->begin(), mPartCand->getNodalConnectivityIndex()->begin(),
             idsGoodLine->begin(), idsGoodLine->end(),
             /*out*/insidePoints, hitSegs);
-        // Optim: smaller segments completly included in eIdx and not split won't need any further treatment:
+        // Optim: smaller segments completely included in eIdx and not split won't need any further treatment:
         for (vector<int>::const_iterator its=hitSegs.begin(); its != hitSegs.end(); ++its)
           hit[cands2[*its]] = true;
 
diff -Naur MEDCOUPLING_old/src/MEDCoupling/Test/CMakeLists.txt MEDCOUPLING_new/src/MEDCoupling/Test/CMakeLists.txt
--- MEDCOUPLING_old/src/MEDCoupling/Test/CMakeLists.txt	2018-04-19 17:04:36.723222444 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/Test/CMakeLists.txt	2018-04-19 17:25:18.061803761 +0200
@@ -57,7 +57,7 @@
 SALOME_GENERATE_TESTS_ENVIRONMENT(tests_env)
 
 ADD_EXECUTABLE(TestMEDCoupling ${TestMEDCoupling_SOURCES})
-TARGET_LINK_LIBRARIES(TestMEDCoupling medcoupling ${CPPUNIT_LIBRARIES} ${PLATFORM_LIBS})
+TARGET_LINK_LIBRARIES(TestMEDCoupling medcouplingcpp ${CPPUNIT_LIBRARIES} ${PLATFORM_LIBS})
 ADD_TEST(TestMEDCoupling TestMEDCoupling)
 SET_TESTS_PROPERTIES(TestMEDCoupling PROPERTIES ENVIRONMENT "${tests_env}")
 
@@ -67,7 +67,7 @@
 SET_TESTS_PROPERTIES(TestMEDCouplingRemapper PROPERTIES ENVIRONMENT "${tests_env}")
 
 ADD_EXECUTABLE(TestMEDCouplingExamples ${TestMEDCouplingExamples_SOURCES})
-TARGET_LINK_LIBRARIES(TestMEDCouplingExamples medcoupling ${CPPUNIT_LIBRARIES} ${PLATFORM_LIBS})
+TARGET_LINK_LIBRARIES(TestMEDCouplingExamples medcouplingcpp ${CPPUNIT_LIBRARIES} ${PLATFORM_LIBS})
 ADD_TEST(TestMEDCouplingExamples TestMEDCouplingExamples)
 SET_TESTS_PROPERTIES(TestMEDCouplingExamples PROPERTIES ENVIRONMENT "${tests_env}")
 
diff -Naur MEDCOUPLING_old/src/MEDCoupling/Test/MEDCouplingBasicsTest4.cxx MEDCOUPLING_new/src/MEDCoupling/Test/MEDCouplingBasicsTest4.cxx
--- MEDCOUPLING_old/src/MEDCoupling/Test/MEDCouplingBasicsTest4.cxx	2018-04-19 17:04:36.725222483 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/Test/MEDCouplingBasicsTest4.cxx	2018-04-19 17:25:18.083804196 +0200
@@ -937,7 +937,7 @@
   m->checkConsistency();//OK because we are in polyhedron connec
   m->getNodalConnectivity()->setIJ(36,0,14);
   m->checkConsistencyLight();
-  CPPUNIT_ASSERT_THROW(m->checkConsistency(),INTERP_KERNEL::Exception);//Throw beacause now cell 5 is a TETRA4 (14) so mimatch of number index and static type.
+  CPPUNIT_ASSERT_THROW(m->checkConsistency(),INTERP_KERNEL::Exception);//Throw because now cell 5 is a TETRA4 (14) so mismatch of number index and static type.
   m->decrRef();
 }
 
diff -Naur MEDCOUPLING_old/src/MEDCoupling/Test/MEDCouplingBasicsTestInterp.cxx MEDCOUPLING_new/src/MEDCoupling/Test/MEDCouplingBasicsTestInterp.cxx
--- MEDCOUPLING_old/src/MEDCoupling/Test/MEDCouplingBasicsTestInterp.cxx	2018-04-19 17:04:36.726222503 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/Test/MEDCouplingBasicsTestInterp.cxx	2018-04-19 17:25:18.077804077 +0200
@@ -1465,7 +1465,7 @@
   sourceMesh->allocateCells(0);
   sourceMesh->finishInsertingCells();
   DataArrayDouble *myCoords=DataArrayDouble::New();
-  myCoords->alloc(0,0);
+  myCoords->alloc(0,2);
   sourceMesh->setCoords(myCoords);
   myCoords->decrRef();
   MEDCouplingUMesh *targetMesh=MEDCouplingUMesh::New();
diff -Naur MEDCOUPLING_old/src/MEDCoupling/Test/MEDCouplingExamplesTest.cxx MEDCOUPLING_new/src/MEDCoupling/Test/MEDCouplingExamplesTest.cxx
--- MEDCOUPLING_old/src/MEDCoupling/Test/MEDCouplingExamplesTest.cxx	2018-04-19 17:04:36.727222523 +0200
+++ MEDCOUPLING_new/src/MEDCoupling/Test/MEDCouplingExamplesTest.cxx	2018-04-19 17:25:18.066803860 +0200
@@ -2378,7 +2378,7 @@
   fieldOnCells->setMesh(mesh);
   mesh->decrRef(); // no more need of mesh because mesh has been attached to fieldOnCells
   MEDCoupling::DataArrayDouble *array=MEDCoupling::DataArrayDouble::New();
-  array->alloc(fieldOnCells->getMesh()->getNumberOfCells(),9);//Implicitely fieldOnCells will be a 9 components field.
+  array->alloc(fieldOnCells->getMesh()->getNumberOfCells(),9);//Implicitly fieldOnCells will be a 9 components field.
   array->fillWithValue(7.);
   fieldOnCells->setArray(array);
   array->decrRef();
@@ -2430,7 +2430,7 @@
   fieldOnNodes->setMesh(mesh);
   mesh->decrRef(); // no more need of mesh because mesh has been attached to fieldOnNodes
   MEDCoupling::DataArrayDouble *array=MEDCoupling::DataArrayDouble::New();
-  array->alloc(fieldOnNodes->getMesh()->getNumberOfNodes(),1);//Implicitely fieldOnNodes will be a 1 component field.
+  array->alloc(fieldOnNodes->getMesh()->getNumberOfNodes(),1);//Implicitly fieldOnNodes will be a 1 component field.
   array->fillWithValue(8.);
   fieldOnNodes->setArray(array);
   array->decrRef();
@@ -2457,7 +2457,7 @@
   fieldOnCells->setMesh(mesh);
   mesh->decrRef(); // no more need of mesh because mesh has been attached to fieldOnCells
   MEDCoupling::DataArrayDouble *array=MEDCoupling::DataArrayDouble::New();
-  array->alloc(fieldOnCells->getMesh()->getNumberOfCells(),2);//Implicitely fieldOnCells will be a 2 components field.
+  array->alloc(fieldOnCells->getMesh()->getNumberOfCells(),2);//Implicitly fieldOnCells will be a 2 components field.
   array->fillWithValue(7.);
   fieldOnCells->setArray(array);
   array->decrRef();
@@ -2485,7 +2485,7 @@
   fieldOnNodes->setMesh(mesh);
   mesh->decrRef(); // no more need of mesh because mesh has been attached to fieldOnNodes
   MEDCoupling::DataArrayDouble *array=MEDCoupling::DataArrayDouble::New();
-  array->alloc(fieldOnNodes->getMesh()->getNumberOfNodes(),3);//Implicitely fieldOnNodes will be a 3 components field.
+  array->alloc(fieldOnNodes->getMesh()->getNumberOfNodes(),3);//Implicitly fieldOnNodes will be a 3 components field.
   array->fillWithValue(8.);
   fieldOnNodes->setArray(array);
   array->decrRef();
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/CMakeLists.txt MEDCOUPLING_new/src/MEDCoupling_Swig/CMakeLists.txt
--- MEDCOUPLING_old/src/MEDCoupling_Swig/CMakeLists.txt	2018-04-19 17:04:36.728222543 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/CMakeLists.txt	2018-04-19 17:25:17.264788007 +0200
@@ -46,6 +46,7 @@
 SET (MC_Swig_interf
     MEDCoupling.i
     MEDCouplingCommon.i
+    MEDCouplingRemapperCommon.i
     MEDCouplingRefCountObject.i
     MEDCouplingMemArray.i
     MEDCouplingFieldDiscretization.i
@@ -60,7 +61,7 @@
 INCLUDE_DIRECTORIES(
   ${PYTHON_INCLUDE_DIRS}
   ${NUMPY_INCLUDE_DIR}
-  ${PTHREAD_INCLUDE_DIR} # pthread dependancy due to python2.7 library
+  ${PTHREAD_INCLUDE_DIR} # pthread dependency due to python2.7 library
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_BINARY_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/../MEDCoupling
@@ -87,7 +88,7 @@
 ENDIF()
 
 SWIG_ADD_MODULE(MEDCoupling python MEDCoupling.i)
-SWIG_LINK_LIBRARIES(MEDCoupling ${PYTHON_LIBRARIES} ${PLATFORM_LIBS} medcoupling)
+SWIG_LINK_LIBRARIES(MEDCoupling ${PYTHON_LIBRARIES} ${PLATFORM_LIBS} medcouplingcpp)
 SWIG_CHECK_GENERATION(MEDCoupling)
 SET_SOURCE_FILES_PROPERTIES(MEDCouplingRemapper.i PROPERTIES CPLUSPLUS ON)
 IF ("${PYTHON_VERSION_MAJOR}" STREQUAL "3")
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingBasicsTest3.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingBasicsTest3.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingBasicsTest3.py	2018-04-19 17:04:36.729222563 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingBasicsTest3.py	2018-04-19 17:25:17.250787731 +0200
@@ -1444,7 +1444,7 @@
         m.checkConsistency();#OK because we are in polyhedron connec
         m.getNodalConnectivity().setIJ(36,0,14);
         m.checkConsistencyLight();
-        self.assertRaises(InterpKernelException,m.checkConsistency);#Throw beacause now cell 5 is a TETRA4 (14) so mimatch of number index and static type.
+        self.assertRaises(InterpKernelException,m.checkConsistency);#Throw because now cell 5 is a TETRA4 (14) so mismatch of number index and static type.
         pass
 
     def testUnPolyze2(self):
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingBasicsTest5.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingBasicsTest5.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingBasicsTest5.py	2018-04-19 17:04:36.732222623 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingBasicsTest5.py	2018-04-19 17:25:17.247787671 +0200
@@ -17,7 +17,6 @@
 #
 # See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 #
-
 from MEDCoupling import *
 import unittest
 from math import pi,e,sqrt,cos,sin
@@ -1462,7 +1461,7 @@
         self.assertEqual(f4.getMesh(),None)
         pass
 
-    # test a simple node to cell convertion of a field
+    # test a simple node to cell conversion of a field
     def testSwig2NodeToCellDiscretization1(self):
         f=MEDCouplingFieldDouble(ON_NODES) ; f.setTime(1.1,2,3)
         a1=DataArrayDouble(4) ; a1.iota()
@@ -1891,7 +1890,7 @@
         gaussCoords=refCoords[:] ; gaussCoords[14]=0.9999999999999 # change z of point #4 0.999... instead of 1. because with shape function it leads to division by 0. !
         fGauss.setGaussLocalizationOnType(NORM_PYRA13,refCoords,gaussCoords,weights)
         arrOfDisc2=fGauss.getLocalizationOfDiscr()
-        self.assertTrue(arrOfDisc2.isEqual(coo,1e-10)) # be less exigent 1e-10 instead of 1e-12 due to shape function sensitivity arount 0.,0.,1. !
+        self.assertTrue(arrOfDisc2.isEqual(coo,1e-10)) # be less exigent 1e-10 instead of 1e-12 due to shape function sensitivity around 0.,0.,1. !
         pass
 
     def testSwig2Tri7GP1(self):
@@ -2123,7 +2122,7 @@
         pass
 
     def testSwig2Colinearize2D3(self):
-        """ colinearize was too agressive, potentially producing cells with one edge """
+        """ colinearize was too aggressive, potentially producing cells with one edge """
         # Flat polygon  with 3 edges - nothing should happen (min number of edges for a linear polyg)
         coo = DataArrayDouble([0.0,0.0,  2.0,0.0,   1.5,0.0,  1.0,0.0,  0.5,0.0], 5,2)
         m = MEDCouplingUMesh("m", 2)
@@ -3902,32 +3901,32 @@
         arr2=DataArrayInt([(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(20,21),(22,23)]) ; arr2.setInfoOnComponents(["aa","bbb"])
         f2.setArray(arr2) ; f2.setName("f1") ; f2.setTime(2.,3,4)
         #
-        self.assertTrue(f1.isEqual(f2,1e-12,0.))
+        self.assertTrue(f1.isEqual(f2,1e-12,0))
         f1.getArray()[:]*=2
-        self.assertTrue(not f1.isEqual(f2,1e-12,0.))
-        self.assertTrue(not f1.isEqualWithoutConsideringStr(f2,1e-12,0.))
+        self.assertTrue(not f1.isEqual(f2,1e-12,0))
+        self.assertTrue(not f1.isEqualWithoutConsideringStr(f2,1e-12,0))
         f1.getArray()[:]/=2
-        self.assertTrue(f1.isEqual(f2,1e-12,0.))
+        self.assertTrue(f1.isEqual(f2,1e-12,0))
         #
         f1.setName("F1")
-        self.assertTrue(not f1.isEqual(f2,1e-12,0.))
+        self.assertTrue(not f1.isEqual(f2,1e-12,0))
         f1.setName("f1")
-        self.assertTrue(f1.isEqual(f2,1e-12,0.))
+        self.assertTrue(f1.isEqual(f2,1e-12,0))
         #
         f1.getArray().setInfoOnComponents(["aa","bbbb"])
-        self.assertTrue(not f1.isEqual(f2,1e-12,0.))
-        self.assertTrue(f1.isEqualWithoutConsideringStr(f2,1e-12,0.))
+        self.assertTrue(not f1.isEqual(f2,1e-12,0))
+        self.assertTrue(f1.isEqualWithoutConsideringStr(f2,1e-12,0))
         f1.getArray().setInfoOnComponents(["aa","bbb"])
-        self.assertTrue(f1.isEqual(f2,1e-12,0.))
+        self.assertTrue(f1.isEqual(f2,1e-12,0))
         #
         f3=f2.deepCopy()
-        self.assertTrue(f1.isEqual(f3,1e-12,0.))
+        self.assertTrue(f1.isEqual(f3,1e-12,0))
         #
         for fd,expected in ((ON_NODES,False),(ON_CELLS,True)):
             f4=MEDCouplingFieldInt(fd) ; f4.setMesh(m2) ; f4.setTime(2.,3,4)
             arr4=DataArrayInt([(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(20,21),(22,23)]) ; arr4.setInfoOnComponents(["aa","bbb"])
             f4.setArray(arr4) ; f4.setName("f1")
-            self.assertEqual(f1.isEqual(f4,1e-12,0.),expected)
+            self.assertEqual(f1.isEqual(f4,1e-12,0),expected)
             pass
         pass
 
@@ -4276,6 +4275,35 @@
         self.assertEqual(fieldOnCell.getMesh().buildDescendingConnectivity()[0].getNumberOfCells(),2*7+21)
         pass
 
+    def testVoronoi3D_8(self):
+        """More aggressive 3D test. Bug EDF 15094"""
+        mesh = MEDCouplingUMesh("myMeshForAnthony",3)
+        coords = [2.20449946892035, 0.0015302058397972198, -0.014025000000000001, 2.20449522028465, 0.00459061457029268, -0.0109750000232271, 2.20449946892035, 0.0015302058397972198, -0.0125000000116135, 2.20577243296484, 0.00153108944037966, -0.0137555135576553, 2.20517315768831, 0.0045920262990614006, -0.010764118475206199, 2.2054749202977, 0.0015308829283677198, -0.012259816016430801, 2.20449787568164, 0.00306041094231961, -0.0125000000116135, 2.20449787568164, 0.00306041094231961, -0.011737500017420301, 2.20449946892035, 0.0015302058397972198, -0.0132625000058068, 2.20513595094259, 0.0015306476400884401, -0.0138902567788277, 2.20483418898648, 0.0045913204346770395, -0.0108695592492167, 2.20498719460902, 0.00153054438408247, -0.0123799080140222, 2.20547332635401, 0.0030617651191343705, -0.012259816016430801, 2.20532457012796, 0.00306155860717217, -0.0115119672458185, 2.20562367663127, 0.0015309861843736902, -0.013007664787043, 2.20582504233773, 0.0045933837758852306, -0.010139577890770399, 2.20642582267143, 0.004594634833691141, -0.009125379014333041, 2.20612543250458, 0.00459400930478819, -0.00963247845255172, 2.2069524110381, 0.004595731395029229, -0.00776049693994639, 2.20668911685476, 0.004595183114360191, -0.00844293797713971, 2.20832419990944, 0.0076643330146060895, -0.0108392857142857, 2.20832419990944, 0.0076643330146060895, -0.008671428571428571, 2.20704504094678, 0.00765989349423635, -0.008671428571428571, 2.20704504094678, 0.00765989349423635, -0.0108392857142857, 2.2062381754171, 0.00459424407928538, -0.00868052596233734, 2.20832419990944, 0.0076643330146060895, -0.00975535714285714, 2.20768462042811, 0.00766211325442122, -0.008671428571428571, 2.20704504094678, 0.00765989349423635, -0.00975535714285714, 2.20768462042811, 0.00766211325442122, -0.0108392857142857, 2.20737554490036, 0.00612882358882901, -0.009982332364309381, 2.20763883863969, 0.00612955462931014, -0.00821596275568748, 2.2066421405633703, 0.00612678727660696, -0.00867597726688296, 2.20643557437203, 0.006126213741329251, -0.0104894318025281, 2.2065952932276, 0.00459498773715731, -0.00822051145114186, 2.20603160887741, 0.00459381392758531, -0.00941005192655387]
+        da = DataArrayDouble.New(coords,35,3)
+        mesh.setCoords(da)
+        mesh.allocateCells()
+        mesh.insertNextCell(NORM_PENTA15, [0, 2, 1, 3, 5, 4, 8, 7, 6, 14, 13, 12, 9, 11, 10])
+        mesh.insertNextCell(NORM_HEXA20, [20, 23, 22, 21, 16, 15, 24, 18, 28, 27, 26, 25, 17, 34, 33, 19, 29, 32, 31, 30])
+        mesh.zipCoords()
+        f=MEDCouplingFieldDouble(ON_GAUSS_PT)
+        f.setMesh(mesh)
+        f.setName("myFieldForAnthony")
+        f.setGaussLocalizationOnCells([0],[-1, 1, 0, -1, 0, 0, -1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, -1, 0.5, 0, -1, 0, 0.5, -1, 0.5, 0.5, 1, 0.5, 0, 1, 0, 0.5, 1, 0.5, 0.5, 0, 1, 0, 0, 0, 0, 0, 0, 1],[-0.774597, 0.333333, 0.333333, -0.774597, 0.470142, 0.470142, -0.774597, 0.0597159, 0.470142, -0.774597, 0.470142, 0.0597159, -0.774597, 0.101287, 0.101287, -0.774597, 0.797427, 0.101287, -0.774597, 0.101287, 0.797427, 0, 0.333333, 0.333333, 0, 0.470142, 0.470142, 0, 0.0597159, 0.470142, 0, 0.470142, 0.0597159, 0, 0.101287, 0.101287, 0, 0.797427, 0.101287, 0, 0.101287, 0.797427, 0.774597, 0.333333, 0.333333, 0.774597, 0.470142, 0.470142, 0.774597, 0.0597159, 0.470142, 0.774597, 0.470142, 0.0597159, 0.774597, 0.101287, 0.101287, 0.774597, 0.797427, 0.101287, 0.774597, 0.101287, 0.797427],[0.0625, 0.0367762, 0.0367762, 0.0367762, 0.0349831, 0.0349831, 0.0349831, 0.1, 0.0588418, 0.0588418, 0.0588418, 0.055973, 0.055973, 0.055973, 0.0625, 0.0367762, 0.0367762, 0.0367762, 0.0349831, 0.0349831, 0.0349831])
+        f.setGaussLocalizationOnCells([1],[-1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, 0, -1, 0, 1, -1, 1, 0, -1, 0, -1, -1, -1, 0, 1, 0, 1, 1, 1, 0, 1, 0, -1, 1, -1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0],[-0.774597, -0.774597, -0.774597, -0.774597, -0.774597, 0, -0.774597, -0.774597, 0.774597, -0.774597, 0, -0.774597, -0.774597, 0, 0, -0.774597, 0, 0.774597, -0.774597, 0.774597, -0.774597, -0.774597, 0.774597, 0, -0.774597, 0.774597, 0.774597, 0, -0.774597, -0.774597, 0, -0.774597, 0, 0, -0.774597, 0.774597, 0, 0, -0.774597, 0, 0, 0, 0, 0, 0.774597, 0, 0.774597, -0.774597, 0, 0.774597, 0, 0, 0.774597, 0.774597, 0.774597, -0.774597, -0.774597, 0.774597, -0.774597, 0, 0.774597, -0.774597, 0.774597, 0.774597, 0, -0.774597, 0.774597, 0, 0, 0.774597, 0, 0.774597, 0.774597, 0.774597, -0.774597, 0.774597, 0.774597, 0, 0.774597, 0.774597, 0.774597],[0.171468, 0.274348, 0.171468, 0.274348, 0.438957, 0.274348, 0.171468, 0.274348, 0.171468, 0.274348, 0.438957, 0.274348, 0.438957, 0.702332, 0.438957, 0.274348, 0.438957, 0.274348, 0.171468, 0.274348, 0.171468, 0.274348, 0.438957, 0.274348, 0.171468, 0.274348, 0.171468])
+        arr = DataArrayDouble(48, 3)
+        arr[:, 0] = list(range(48))
+        arr[:, 1] = 100 + arr[:, 0]
+        arr[:, 2] = 200 + arr[:, 0]
+        f.setArray(arr)
+        fieldOnCell=f.voronoize(1e-12) # hot point
+        fieldOnCell.checkConsistencyLight()
+        self.assertEqual(fieldOnCell.getMesh().getNumberOfCells(),48)
+        self.assertEqual(fieldOnCell.getMesh().getNumberOfNodes(),127)
+        meaRef=f.getMesh().getMeasureField(True).getArray(); meaRef.rearrange(2); meaRef2 = meaRef.sumPerTuple()
+        mea=fieldOnCell.getMesh().getMeasureField(True).getArray(); mea.rearrange(48); mea2 = mea.sumPerTuple()
+        self.assertTrue(mea2.isEqual(meaRef2,1e-9))
+        pass
+
     def testVoronoi3DSurf_1(self):
         tmp=MEDCouplingCMesh("mesh")
         arr=DataArrayDouble(5) ; arr.iota()
@@ -4445,7 +4473,7 @@
         self.assertTrue(f3.getMesh().getMeasureField(False).getArray().isEqual(ref,1e-12))
         self.assertTrue(f3.getArray().isEqual(DataArrayDouble([0,1,2,3]),1e-12))
         pass
-    
+
     def testVoronoi3D_4(self):
         """Idem testVoronoi3D_3 except that here quadratic cells are considered"""
         coo=DataArrayDouble([0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.5,0.0,0.0,0.0,0.5,0.0,0.5,0.5,0.5,0.5,0.0,0.5,0.0,0.0,0.5,0.0,0.5],10,3)
@@ -4592,8 +4620,16 @@
     def testUMeshComputeEnlargedNeighborsOfNodes(self):
         m=MEDCouplingCMesh() ; arr=DataArrayDouble(4) ; arr.iota() ; m.setCoords(arr,arr) ; m=m.buildUnstructured()
         a,b=m.computeEnlargedNeighborsOfNodes()
-        self.assertTrue(a.isEqual(DataArrayInt([1,4,5,0,2,4,5,6,1,3,5,6,7,2,6,7,0,1,5,8,9,0,1,2,4,6,8,9,10,1,2,3,5,7,9,10,11,2,3,6,10,11,4,5,9,12,13,4,5,6,8,10,12,13,14,5,6,7,9,11,13,14,15,6,7,10,14,15,8,9,13,8,9,10,12,14,9,10,11,13,15,10,11,14])))
-        self.assertTrue(b.isEqual(DataArrayInt([0,3,8,13,16,21,29,37,42,47,55,63,68,71,76,81,84])))
+        aExp=DataArrayInt([1,4,5,0,2,4,5,6,1,3,5,6,7,2,6,7,0,1,5,8,9,0,1,2,4,6,8,9,10,1,2,3,5,7,9,10,11,2,3,6,10,11,4,5,9,12,13,4,5,6,8,10,12,13,14,5,6,7,9,11,13,14,15,6,7,10,14,15,8,9,13,8,9,10,12,14,9,10,11,13,15,10,11,14])
+        bExp=DataArrayInt([0,3,8,13,16,21,29,37,42,47,55,63,68,71,76,81,84])
+        self.assertTrue(a.isEqual(aExp))
+        self.assertTrue(b.isEqual(bExp))
+        m2=m[[1,2,3]]
+        c,d=m2.computeEnlargedNeighborsOfNodes()
+        cExp=DataArrayInt([2,5,6,1,3,5,6,7,2,6,7,5,8,9,1,2,4,6,8,9,1,2,3,5,7,2,3,6,4,5,9,4,5,8])
+        dExp=DataArrayInt([0,0,3,8,11,14,20,25,28,31,34,34,34,34,34,34,34])
+        self.assertTrue(c.isEqual(cExp))
+        self.assertTrue(d.isEqual(dExp))
         pass
 
     def testDAIfindIdsExt1(self):
@@ -4738,7 +4774,22 @@
         m.insertNextCell(NORM_POLYGON,[0,1,2,3,4,5])
         self.assertTrue(m.computePlaneEquationOf3DFaces().isEqual(DataArrayDouble([0,1,0,-1],1,4),1e-12))
         pass
-    
+
+    def testSimplifyPolyhedra(self):
+        mesh = MEDCouplingUMesh('mesh', 3)
+        coo = DataArrayDouble([(-0.01225,-0.0212176,0.02),(-0.00634107,-0.0236652,0.02),(1.50019e-18,-0.0245,0.02),(0.00634107,-0.0236652,0.02),(0.01225,-0.0212176,0.02),(-0.0153864,-0.02665,0),(-0.00714085,-0.02665,0),(1.63184e-18,-0.02665,0),(0.00714085,-0.02665,0),(0.0153864,-0.02665,0),(-0.00714085,-0.02665,0.0101475),(1.63184e-18,-0.02665,0.013145),(0.00714085,-0.02665,0.0101475),(-0.013,-0.0225167,0.02),(-0.0067293,-0.0251141,0.02),(1.59204e-18,-0.026,0.02),(0.0067293,-0.0251141,0.02),(0.013,-0.0225167,0.02),(-0.0161658,-0.028,0),(-0.00750258,-0.028,0),(1.71451e-18,-0.028,0),(0.00750258,-0.028,0),(0.0161658,-0.028,0),(-0.00750258,-0.028,0.0105625),(1.71451e-18,-0.028,0.0136825),(0.00750258,-0.028,0.0105625)])
+        mesh.setCoords(coo)
+        c = DataArrayInt([31, 13, 14, 15, 16, 17, 4, 3, 2, 1, 0, -1, 18, 5, 6, 7, 8, 9, 22, 21, 20, 19, -1, 19, 23, 18, -1, 23, 14, 13, 18, -1, 20, 24, 23, 19, -1, 24, 15, 14, 23, -1, 21, 25, 24, 20, -1, 25, 16, 15, 24, -1, 22, 25, 21, -1, 22, 17, 16, 25, -1, 9, 4, 17, 22, -1, 8, 12, 9, -1, 12, 3, 4, 9, -1, 7, 11, 12, 8, -1, 11, 2, 3, 12, -1, 6, 10, 11, 7, -1, 10, 1, 2, 11, -1, 5, 10, 6, -1, 5, 0, 1, 10, -1, 18, 13, 0, 5])
+        cI = DataArrayInt([0, 108])
+        mesh.setConnectivity(c, cI)
+        mesh.simplifyPolyhedra(1.0e-8)
+        c, cI = mesh.getNodalConnectivity(), mesh.getNodalConnectivityIndex()
+        tgt_c = DataArrayInt([31, 23, 18, 19, 20, 21, 22, 25, 24, -1, 12, 9, 8, 7, 6, 5, 10, 11, -1, 13, 14, 15, 16, 17, 4, 3, 2, 1, 0, -1, 18, 5, 6, 7, 8, 9, 22, 21, 20, 19, -1, 23, 14, 13, 18, -1, 24, 15, 14, 23, -1, 25, 16, 15, 24, -1, 22, 17, 16, 25, -1, 9, 4, 17, 22, -1, 12, 3, 4, 9, -1, 11, 2, 3, 12, -1, 10, 1, 2, 11, -1, 5, 0, 1, 10, -1, 18, 13, 0, 5])
+        tgt_cI = DataArrayInt([0, 90])
+        self.assertEqual(c.getValues(), tgt_c.getValues())
+        self.assertEqual(cI.getValues(), tgt_cI.getValues())
+        pass
+
     pass
 
 if __name__ == '__main__':
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingBasicsTest6.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingBasicsTest6.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingBasicsTest6.py	2018-04-19 17:04:36.732222623 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingBasicsTest6.py	2018-04-19 17:25:17.252787770 +0200
@@ -106,6 +106,112 @@
         level3(self)
         gtumesh(self)
         pass
+
+    def testPenta18_1(self):
+        arr=DataArrayDouble([
+            (0.,1.,1.),(0.,0.,1.),(1.,0.,1.),
+            (0.,1.,0.),(0.,0.,0.),(1.,0.,0.),
+            (0.,0.5,1.),(0.5,0.,1.),(0.5,0.5,1.),
+            (0.,0.5,0.),(0.5,0.,0.),(0.5,0.5,0.),
+            (0.,1.,0.5),(0.,0.,0.5),(1.,0.,0.5),
+            (0.,0.5,0.5),(0.5,0.,0.5),(0.5,0.5,0.5)])
+        m=MEDCouplingUMesh("mesh",3)
+        m.setCoords(arr)
+        m.allocateCells(1)
+        m.insertNextCell(NORM_PENTA18,list(range(18)))
+        m.checkConsistencyLight()
+        self.assertTrue(m.getMeasureField(True).getArray().isEqual(DataArrayDouble([0.5]),1e-12))
+        #
+        f=MEDCouplingFieldDouble(ON_NODES)
+        f.setMesh(m)
+        f.setName("FieldOnPenta18")
+        f.setArray(DataArrayDouble(list(range(18))))
+        f.checkConsistencyLight()
+        #
+        m2,d,di,rd,rdi=m.buildDescendingConnectivity()
+        self.assertTrue(m2.getNodalConnectivity().isEqual(DataArrayInt([6,0,1,2,6,7,8,6,3,5,4,11,10,9,9,0,3,4,1,12,9,13,6,15,9,1,4,5,2,13,10,14,7,16,9,2,4,5,0,14,11,12,8,17])))
+        self.assertTrue(m2.getNodalConnectivityIndex().isEqual(DataArrayInt([0,7,14,24,34,44])))
+        self.assertTrue(d.isEqual(DataArrayInt([0,1,2,3,4])))
+        self.assertTrue(di.isEqual(DataArrayInt([0,5])))
+        self.assertTrue(rd.isEqual(DataArrayInt([0,0,0,0,0])))
+        self.assertTrue(rdi.isEqual(DataArrayInt([0,1,2,3,4,5])))
+        #
+        f2=MEDCouplingFieldDouble(ON_NODES)
+        f2.setMesh(m)
+        f2.setName("FieldOnPenta18Sub")
+        f2.setArray(DataArrayDouble(list(range(18))))
+        f2.checkConsistencyLight()
+        pass
+
+    def testSKLAReplaceDeletePacks(self):
+        index=DataArrayInt([0,3,5,6,6])
+        value=DataArrayInt([1,2,3, 2,3, 3  ])
+        sla=MEDCouplingSkyLineArray(index,value)
+        idx=DataArrayInt([0,3])
+        packs=[DataArrayInt([4,5]),DataArrayInt([6,7,8])]
+        sla.replaceSimplePacks(idx,packs)
+        self.assertTrue(sla.getIndexArray().isEqual(DataArrayInt([0,2,4,5,8])))
+        self.assertTrue(sla.getValuesArray().isEqual(DataArrayInt([4,5, 2,3, 3, 6,7,8])))
+        sla.deleteSimplePacks(idx)
+        self.assertTrue(sla.getIndexArray().isEqual(DataArrayInt([0,2,3])))
+        self.assertTrue(sla.getValuesArray().isEqual(DataArrayInt([2,3, 3])))
+        sla.deleteSimplePack(1)
+        self.assertTrue(sla.getIndexArray().isEqual(DataArrayInt([0,2])))
+        self.assertTrue(sla.getValuesArray().isEqual(DataArrayInt([2,3])))
+        pass
+
+    def testDADAsArcOfCircle(self):
+        d=DataArrayDouble([3.06915124862645,2.1464466094067824,2.85355345827285,2.3620444674400574,2.637955532559882,2.1464467447661937],3,2)
+        center,radius,ang=d.asArcOfCircle()
+        self.assertTrue((d-center).magnitude().isUniform(radius,1e-10))
+        self.assertAlmostEqual(ang,-4.712389294301196,12)
+        pass
+
+    def testDAMaxAbsValue(self):
+        d=DataArrayDouble([-2,3,1.2,-2.9])
+        a,b=d.getMaxAbsValue()
+        self.assertAlmostEqual(a,3.,13)
+        self.assertEqual(b,1)
+        a,b=(-d).getMaxAbsValue()
+        self.assertAlmostEqual(a,-3.,13)
+        self.assertEqual(b,1)
+        self.assertAlmostEqual((-d).getMaxAbsValueInArray(),-3.,13)
+        pass
+
+    def testDAIFindIdForEach1(self):
+        a1=DataArrayInt([17,27,2,10,-4,3,12,27,16])
+        b1=DataArrayInt([3,16,-4,27,17])
+        ret=a1.findIdForEach(b1)
+        self.assertTrue(ret.isEqual(DataArrayInt([5,8,4,7,0])))
+        self.assertTrue(a1[ret].isEqual(b1))
+        b2=DataArrayInt([3,16,22,27,17])
+        self.assertRaises(InterpKernelException,a1.findIdForEach,b2) # 22 not in a1 !
+        a1.rearrange(3)
+        self.assertRaises(InterpKernelException,a1.findIdForEach,b1) # a1 is not single component
+        pass
+    
+    @unittest.skipUnless(IsCXX11Compiled(),"requires C++11")
+    def testAttractSeg3MidPtsAroundNodes1(self):
+        """ Test of MEDCouplingUMesh.attractSeg3MidPtsAroundNodes methods """
+        ptsExpToBeModified=DataArrayInt([95,96,97,98,101,103,104,106,108,110])
+        eps=1e-12
+        a=2./3.
+        b=1./3.
+        coo=DataArrayDouble([10,0,0,10,10,0,10,0,3.+b,10,0,6.+a,10,10,3.+b,10,10,6.+a,10,3.+b,0,10,6.+a,0,3.+b,0,0,6.+a,0,0,3.+b,10,0,6.+a,10,0,10,3.+b,6.+a,10,6.+a,6.+a,10,3.+b,3.+b,10,6.+a,3.+b,3.+b,0,3.+b,3.+b,0,6.+a,6.+a,0,3.+b,6.+a,0,6.+a,6.+a,10,3.+b,6.+a,10,6.+a,3.+b,10,3.+b,3.+b,10,6.+a,3.+b,3.+b,0,6.+a,3.+b,0,3.+b,6.+a,0,6.+a,6.+a,0,3.+b,3.+b,6.+a,6.+a,3.+b,6.+a,3.+b,6.+a,6.+a,6.+a,6.+a,6.+a,3.+b,3.+b,3.+b,6.+a,3.+b,3.+b,3.+b,6.+a,3.+b,6.+a,6.+a,3.+b,10,0,1.+a,10,0,5.,10,10,1.+a,10,10,5.,10,1.+a,0,10,5.,0,10,8.+b,0,5.,0,0,8.+b,0,0,5.,10,0,8.+b,10,0,10,1.+a,6.+a,10,5.,6.+a,10,8.+b,6.+a,10,1.+a,3.+b,10,3.+b,5.,10,5.,3.+b,10,6.+a,5.,10,8.+b,3.+b,10,3.+b,1.+a,10,6.+a,1.+a,3.+b,0,1.+a,3.+b,0,5.,6.+a,0,1.+a,5.,0,3.+b,6.+a,0,5.,5.,0,6.+a,8.+b,0,3.+b,8.+b,0,6.+a,6.+a,10,1.+a,8.+b,10,3.+b,6.+a,10,5.,8.+b,10,6.+a,3.+b,10,1.+a,5.,10,3.+b,3.+b,10,5.,5.,10,6.+a,3.+b,1.+a,0,5.,3.+b,0,6.+a,1.+a,0,8.+b,3.+b,0,3.+b,5.,0,5.,6.+a,0,6.+a,5.,0,8.+b,6.+a,0,3.+b,8.+b,0,6.+a,8.+b,0,3.+b,1.+a,6.+a,6.+a,1.+a,6.+a,5.,3.+b,6.+a,8.+b,3.+b,6.+a,3.+b,5.,6.+a,6.+a,5.,6.+a,5.,6.+a,6.+a,8.+b,6.+a,6.+a,3.+b,8.+b,6.+a,6.+a,8.+b,6.+a,3.+b,3.+b,5,3.+b,1.+a,3.+b,6.+a,3.+b,5.,6.+a,1.+a,3.+b,5.,3.+b,3.+b,8.+b,3.+b,3.+b,3.+b,6.+a,5.,3.+b,5.,3.+b,6.+a,6.+a,5.,6.+a,5.,3.+b,5.,6.+a,3.+b,8.+b,6.+a,3.+b,3.+b,8.+b,3.+b,6.+a,8.+b,3.+b,3.+b,3.+b,1.+a,6.+a,3.+b,1.+a,3.+b,6.+a,1.+a,6.+a,6.+a,1.+a],111,3)
+        conn=DataArrayInt([30,17,28,32,16,19,29,33,18,83,93,94,58,84,95,96,61,62,85,97,60,30,19,29,33,18,3,12,14,2,84,95,96,61,47,51,50,37,64,86,98,63,30,28,30,34,32,29,31,35,33,87,99,100,93,88,101,102,95,85,89,103,97,30,29,31,35,33,12,13,15,14,88,101,102,95,48,53,52,51,86,90,104,98,30,30,23,22,34,31,21,20,35,91,71,105,99,92,67,106,101,89,72,70,103,30,31,21,20,35,13,5,4,15,92,67,106,101,49,39,54,53,90,68,66,104,30,16,32,24,8,18,33,25,9,94,107,73,57,96,108,75,59,60,97,74,43,30,18,33,25,9,2,14,6,0,96,108,75,59,50,55,40,36,63,98,76,44,30,32,34,26,24,33,35,27,25,100,109,77,107,102,110,79,108,97,103,78,74,30,33,35,27,25,14,15,7,6,102,110,79,108,52,56,41,55,98,104,80,76,30,34,22,10,26,35,20,11,27,105,69,81,109,106,65,82,110,103,70,45,78,30,35,20,11,27,15,4,1,7,106,65,82,110,54,38,42,56,104,66,46,80])
+        connI=DataArrayInt([0,21,42,63,84,105,126,147,168,189,210,231,252])
+        m=MEDCouplingUMesh("mesh",3)
+        m.setConnectivity(conn,connI,True)
+        m.setCoords(coo.deepCopy())# deep copy coo because next line is going to modify it, if it works normaly
+        m.attractSeg3MidPtsAroundNodes(0.1,DataArrayInt([33,35])) # ze call is here !
+        self.assertTrue(not m.getCoords().isEqual(coo,eps)) # some points have had their position changed...
+        ptsExpNotToBeModified=ptsExpToBeModified.buildComplement(len(coo))
+        self.assertTrue(m.getCoords()[ptsExpNotToBeModified].isEqual(coo[ptsExpNotToBeModified],eps))
+        self.assertTrue((m.getCoords()[ptsExpToBeModified]-coo[ptsExpToBeModified]).magnitude().isUniform(4./3.,1e-12))
+        ptsPosExp=DataArrayDouble([6.+a,3.+b,3.+a,6.+a,3.,3.+b,6.+b,3.+b,3.+b,7.,3.+b,3.+b,6.+a,6.+a,3.+a,6.+b,6.+a,3.+b,7.,6.+a,3.+b,6.+a,7.,3.+b,6.+a,3.+b,3.,6.+a,6.+a,3.],10,3)
+        self.assertTrue(m.getCoords()[ptsExpToBeModified].isEqual(ptsPosExp,1e-12))
+        pass
+    
     pass
 
 if __name__ == '__main__':
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingCommon.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingCommon.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingCommon.i	2018-04-19 17:04:36.733222643 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingCommon.i	2018-04-19 17:25:17.277788264 +0200
@@ -1,4 +1,4 @@
-// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+// Copyright (C) 2017  CEA/DEN, EDF R&D
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
@@ -16,9 +16,7 @@
 //
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
-// Author : Anthony Geay (CEA/DEN)
-
-%module MEDCoupling
+// Author : Anthony Geay (EDF R&D)
 
 #ifdef WITH_DOCSTRINGS
 %include MEDCoupling_doc.i
@@ -147,6 +145,18 @@
 //$$$$$$$$$$$$$$$$$$
 
 ////////////////////
+%typemap(out) MEDCoupling::MEDCouplingField*
+{
+  $result=convertField($1,$owner);
+}
+
+%typemap(out) MEDCouplingField*
+{
+  $result=convertField($1,$owner);
+}
+//$$$$$$$$$$$$$$$$$$
+
+////////////////////
 %typemap(out) MEDCoupling::MEDCouplingMultiFields*
 {
   $result=convertMultiFields($1,$owner);
@@ -188,6 +198,7 @@
 %newobject MEDCoupling::MEDCouplingFieldDouble::MergeFields;
 %newobject MEDCoupling::MEDCouplingFieldDouble::MeldFields;
 %newobject MEDCoupling::MEDCouplingFieldDouble::convertToIntField;
+%newobject MEDCoupling::MEDCouplingFieldDouble::convertToFloatField;
 %newobject MEDCoupling::MEDCouplingFieldDouble::doublyContractedProduct;
 %newobject MEDCoupling::MEDCouplingFieldDouble::determinant;
 %newobject MEDCoupling::MEDCouplingFieldDouble::eigenValues;
@@ -448,6 +459,8 @@
 %feature("unref") MEDCouplingFieldDiscretizationGaussNE "$this->decrRef();"
 %feature("unref") MEDCouplingFieldDiscretizationKriging "$this->decrRef();"
 %feature("unref") MEDCouplingFieldDouble "$this->decrRef();"
+%feature("unref") MEDCouplingFieldFloat "$this->decrRef();"
+%feature("unref") MEDCouplingFieldInt "$this->decrRef();"
 %feature("unref") MEDCouplingMultiFields "$this->decrRef();"
 %feature("unref") MEDCouplingFieldTemplate "$this->decrRef();"
 %feature("unref") MEDCouplingMultiFields "$this->decrRef();"
@@ -951,12 +964,12 @@
           return self->checkTypeConsistencyAndContig(code,idsPerType);
         }
 
-        PyObject *splitProfilePerType(const DataArrayInt *profile) const throw(INTERP_KERNEL::Exception)
+        PyObject *splitProfilePerType(const DataArrayInt *profile, bool smartPflKiller=true) const throw(INTERP_KERNEL::Exception)
         {
           std::vector<int> code;
           std::vector<DataArrayInt *> idsInPflPerType;
           std::vector<DataArrayInt *> idsPerType;
-          self->splitProfilePerType(profile,code,idsInPflPerType,idsPerType);
+          self->splitProfilePerType(profile,code,idsInPflPerType,idsPerType,smartPflKiller);
           PyObject *ret=PyTuple_New(3);
           //
           if(code.size()%3!=0)
@@ -1070,14 +1083,6 @@
            self->resizeForUnserialization(tinyInfo,a1,a2,littleStrings);
          }
          
-         PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-         {// put an empty dict in input to say to __new__ to call __init__...
-           PyObject *ret(PyTuple_New(1));
-           PyObject *ret0(PyDict_New());
-           PyTuple_SetItem(ret,0,ret0);
-           return ret;
-         }
-         
          PyObject *__getstate__() const throw(INTERP_KERNEL::Exception)
          {
            PyObject *ret0(MEDCoupling_MEDCouplingMesh_getTinySerializationInformation(self));
@@ -1221,6 +1226,9 @@
     
     void deletePack(const int i, const int j) throw(INTERP_KERNEL::Exception);
     
+    void deleteSimplePack(const int i) throw(INTERP_KERNEL::Exception);
+    void deleteSimplePacks(const DataArrayInt* idx) throw(INTERP_KERNEL::Exception);
+    
     %extend 
     {
       MEDCouplingSkyLineArray() throw(INTERP_KERNEL::Exception)
@@ -1304,6 +1312,13 @@
           self->replaceSimplePack(idx, vpack.data(), vpack.data()+vpack.size());
         }
         
+      void replaceSimplePacks(const DataArrayInt* idx, PyObject *listePacks) throw(INTERP_KERNEL::Exception)
+        {
+          std::vector<const DataArrayInt*> packs;
+          convertFromPyObjVectorOfObj<const MEDCoupling::DataArrayInt*>(listePacks,SWIGTYPE_p_MEDCoupling__DataArrayInt,"DataArrayInt",packs);
+          self->replaceSimplePacks(idx, packs);
+        }
+        
       void replacePack(const int superIdx, const int idx, PyObject *pack) throw(INTERP_KERNEL::Exception)
         {
           std::vector<int> vpack;
@@ -1497,8 +1512,8 @@
                DataArrayDoubleTuple *aa,*aa2;
                std::vector<double> bb,bb2;
                int sw;
-               const char msg[]="Python wrap of MEDCouplingPointSet::findNodesOnLine : 1st paramater for point.";
-               const char msg2[]="Python wrap of MEDCouplingPointSet::findNodesOnLine : 2nd paramater for vector.";
+               const char msg[]="Python wrap of MEDCouplingPointSet::findNodesOnLine : 1st parameter for point.";
+               const char msg2[]="Python wrap of MEDCouplingPointSet::findNodesOnLine : 2nd parameter for vector.";
                const double *p=convertObjToPossibleCpp5_Safe(pt,sw,val,a,aa,bb,msg,1,spaceDim,true);
                const double *v=convertObjToPossibleCpp5_Safe(vec,sw,val2,a2,aa2,bb2,msg2,1,spaceDim,true);
                std::vector<int> nodes;
@@ -1516,8 +1531,8 @@
                DataArrayDoubleTuple *aa,*aa2;
                std::vector<double> bb,bb2;
                int sw;
-               const char msg[]="Python wrap of MEDCouplingPointSet::findNodesOnPlane : 1st paramater for point.";
-               const char msg2[]="Python wrap of MEDCouplingPointSet::findNodesOnPlane : 2nd paramater for vector.";
+               const char msg[]="Python wrap of MEDCouplingPointSet::findNodesOnPlane : 1st parameter for point.";
+               const char msg2[]="Python wrap of MEDCouplingPointSet::findNodesOnPlane : 2nd parameter for vector.";
                const double *p=convertObjToPossibleCpp5_Safe(pt,sw,val,a,aa,bb,msg,1,spaceDim,true);
                const double *v=convertObjToPossibleCpp5_Safe(vec,sw,val2,a2,aa2,bb2,msg2,1,spaceDim,true);
                std::vector<int> nodes;
@@ -1994,12 +2009,6 @@
         return MEDCouplingUMesh::New(meshName,meshDim);
       }
 
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDCouplingUMesh");
-      }
-
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -2380,6 +2389,14 @@
           }
       }
 
+      void attractSeg3MidPtsAroundNodes(double ratio, PyObject *nodeIds) throw(INTERP_KERNEL::Exception)
+      {
+        int szArr,sw,iTypppArr;
+        std::vector<int> stdvecTyyppArr;
+        const int *nodeIdsPtr(convertIntStarLikePyObjToCppIntStar(nodeIds,sw,szArr,iTypppArr,stdvecTyyppArr));
+        self->attractSeg3MidPtsAroundNodes(ratio,nodeIdsPtr,nodeIdsPtr+szArr);
+      }
+
       PyObject *getLevArrPerCellTypes(PyObject *li) const throw(INTERP_KERNEL::Exception)
       {
         int sz;
@@ -2924,8 +2941,8 @@
         DataArrayDoubleTuple *aa,*aa2;
         std::vector<double> bb,bb2;
         int sw;
-        const char msg[]="Python wrap of MEDCouplingUMesh::buildSlice3D : 1st paramater for origin.";
-        const char msg2[]="Python wrap of MEDCouplingUMesh::buildSlice3D : 2nd paramater for vector.";
+        const char msg[]="Python wrap of MEDCouplingUMesh::buildSlice3D : 1st parameter for origin.";
+        const char msg2[]="Python wrap of MEDCouplingUMesh::buildSlice3D : 2nd parameter for vector.";
         const double *orig=convertObjToPossibleCpp5_Safe(origin,sw,val,a,aa,bb,msg,1,spaceDim,true);
         const double *vect=convertObjToPossibleCpp5_Safe(vec,sw,val2,a2,aa2,bb2,msg2,1,spaceDim,true);
         //
@@ -2947,8 +2964,8 @@
         DataArrayDoubleTuple *aa,*aa2;
         std::vector<double> bb,bb2;
         int sw;
-        const char msg[]="Python wrap of MEDCouplingUMesh::buildSlice3DSurf : 1st paramater for origin.";
-        const char msg2[]="Python wrap of MEDCouplingUMesh::buildSlice3DSurf : 2nd paramater for vector.";
+        const char msg[]="Python wrap of MEDCouplingUMesh::buildSlice3DSurf : 1st parameter for origin.";
+        const char msg2[]="Python wrap of MEDCouplingUMesh::buildSlice3DSurf : 2nd parameter for vector.";
         const double *orig=convertObjToPossibleCpp5_Safe(origin,sw,val,a,aa,bb,msg,1,spaceDim,true);
         const double *vect=convertObjToPossibleCpp5_Safe(vec,sw,val2,a2,aa2,bb2,msg2,1,spaceDim,true);
         //
@@ -2967,8 +2984,8 @@
         DataArrayDoubleTuple *aa,*aa2;
         std::vector<double> bb,bb2;
         int sw;
-        const char msg[]="Python wrap of MEDCouplingUMesh::clipSingle3DCellByPlane : 1st paramater for origin.";
-        const char msg2[]="Python wrap of MEDCouplingUMesh::clipSingle3DCellByPlane : 2nd paramater for vector.";
+        const char msg[]="Python wrap of MEDCouplingUMesh::clipSingle3DCellByPlane : 1st parameter for origin.";
+        const char msg2[]="Python wrap of MEDCouplingUMesh::clipSingle3DCellByPlane : 2nd parameter for vector.";
         const double *orig=convertObjToPossibleCpp5_Safe(origin,sw,val,a,aa,bb,msg,1,3,true);
         const double *vect=convertObjToPossibleCpp5_Safe(vec,sw,val2,a2,aa2,bb2,msg2,1,3,true);
         MCAuto<MEDCouplingUMesh> ret(self->clipSingle3DCellByPlane(orig,vect,eps));
@@ -2985,8 +3002,8 @@
         DataArrayDoubleTuple *aa,*aa2;
         std::vector<double> bb,bb2;
         int sw;
-        const char msg[]="Python wrap of MEDCouplingUMesh::getCellIdsCrossingPlane : 1st paramater for origin.";
-        const char msg2[]="Python wrap of MEDCouplingUMesh::getCellIdsCrossingPlane : 2nd paramater for vector.";
+        const char msg[]="Python wrap of MEDCouplingUMesh::getCellIdsCrossingPlane : 1st parameter for origin.";
+        const char msg2[]="Python wrap of MEDCouplingUMesh::getCellIdsCrossingPlane : 2nd parameter for vector.";
         const double *orig=convertObjToPossibleCpp5_Safe(origin,sw,val,a,aa,bb,msg,1,spaceDim,true);
         const double *vect=convertObjToPossibleCpp5_Safe(vec,sw,val2,a2,aa2,bb2,msg2,1,spaceDim,true);
         return self->getCellIdsCrossingPlane(orig,vect,eps);
@@ -3058,11 +3075,6 @@
       {
         return MEDCouplingMappedExtrudedMesh::New();
       }
-
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDCouplingMappedExtrudedMesh");
-      }
       
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
@@ -3168,11 +3180,6 @@
         return MEDCoupling1SGTUMesh::New(m);
       }
 
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDCoupling1SGTUMesh");
-      }
-
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -3240,11 +3247,6 @@
         return MEDCoupling1DGTUMesh::New(m);
       }
 
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDCoupling1DGTUMesh");
-      }
-
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -3589,11 +3591,6 @@
       {
         return MEDCouplingCMesh::New(meshName);
       }
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDCouplingCMesh");
-      }
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -3633,10 +3630,6 @@
       {
         return MEDCouplingCurveLinearMesh::New(meshName);
       }
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDCouplingCurveLinearMesh");
-      }
       std::string __str__() const throw(INTERP_KERNEL::Exception) 
       {
         return self->simpleRepr();
@@ -3714,11 +3707,6 @@
         return MEDCoupling_MEDCouplingIMesh_New__SWIG_1(meshName,spaceDim,nodeStrct,origin,dxyz);
       }
 
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDCouplingIMesh");
-      }
-
       void setNodeStruct(PyObject *nodeStrct) throw(INTERP_KERNEL::Exception)
       {
         int sw,sz,val0;
@@ -3810,8 +3798,6 @@
   public:
     virtual void checkConsistencyLight() const throw(INTERP_KERNEL::Exception);
     virtual bool areCompatibleForMerge(const MEDCouplingField *other) const throw(INTERP_KERNEL::Exception);
-    virtual bool isEqual(const MEDCouplingField *other, double meshPrec, double valsPrec) const throw(INTERP_KERNEL::Exception);
-    virtual bool isEqualWithoutConsideringStr(const MEDCouplingField *other, double meshPrec, double valsPrec) const throw(INTERP_KERNEL::Exception);
     virtual void copyTinyStringsFrom(const MEDCouplingField *other) throw(INTERP_KERNEL::Exception);
     void setMesh(const MEDCoupling::MEDCouplingMesh *mesh) throw(INTERP_KERNEL::Exception);
     void setName(const char *name) throw(INTERP_KERNEL::Exception);
@@ -3857,18 +3843,6 @@
         return convertIntArrToPyList3(ret);
       }
 
-      PyObject *isEqualIfNotWhy(const MEDCouplingField *other, double meshPrec, double valsPrec) const throw(INTERP_KERNEL::Exception)
-      {
-        std::string ret1;
-        bool ret0=self->isEqualIfNotWhy(other,meshPrec,valsPrec,ret1);
-        PyObject *ret=PyTuple_New(2);
-        PyObject *ret0Py=ret0?Py_True:Py_False;
-        Py_XINCREF(ret0Py);
-        PyTuple_SetItem(ret,0,ret0Py);
-        PyTuple_SetItem(ret,1,PyString_FromString(ret1.c_str()));
-        return ret;
-      }
-
       PyObject *buildSubMeshData(PyObject *li) const throw(INTERP_KERNEL::Exception)
       {
         DataArrayInt *ret1=0;
@@ -3971,6 +3945,8 @@
     static MEDCouplingFieldTemplate *New(TypeOfField type);
     std::string simpleRepr() const throw(INTERP_KERNEL::Exception);
     std::string advancedRepr() const throw(INTERP_KERNEL::Exception);
+    bool isEqual(const MEDCouplingFieldTemplate *other, double meshPrec) const throw(INTERP_KERNEL::Exception);
+    bool isEqualWithoutConsideringStr(const MEDCouplingFieldTemplate *other, double meshPrec) const throw(INTERP_KERNEL::Exception);
     %extend
        {
          MEDCouplingFieldTemplate(const MEDCouplingFieldDouble& f) throw(INTERP_KERNEL::Exception)
@@ -4004,16 +3980,45 @@
            self->reprQuickOverview(oss);
            return oss.str();
          }
+
+         PyObject *isEqualIfNotWhy(const MEDCouplingFieldTemplate *other, double meshPrec) const throw(INTERP_KERNEL::Exception)
+         {
+           std::string ret1;
+           bool ret0=self->isEqualIfNotWhy(other,meshPrec,ret1);
+           PyObject *ret=PyTuple_New(2);
+           PyObject *ret0Py=ret0?Py_True:Py_False;
+           Py_XINCREF(ret0Py);
+           PyTuple_SetItem(ret,0,ret0Py);
+           PyTuple_SetItem(ret,1,PyString_FromString(ret1.c_str()));
+           return ret;
+         }
        }
   };
+
+  template<class T>
+ class MEDCouplingFieldT : public MEDCoupling::MEDCouplingField
+  {
+  public:
+    TypeOfTimeDiscretization getTimeDiscretization() const throw(INTERP_KERNEL::Exception);
+  protected:
+    MEDCouplingFieldT();
+    ~MEDCouplingFieldT();
+  };
+
+  %template(MEDCouplingFieldTdouble) MEDCoupling::MEDCouplingFieldT<double>;
+  %template(MEDCouplingFieldTfloat) MEDCoupling::MEDCouplingFieldT<float>;
+  %template(MEDCouplingFieldTint) MEDCoupling::MEDCouplingFieldT<int>;
   
   class MEDCouplingFieldInt;
+  class MEDCouplingFieldFloat;
   
-  class MEDCouplingFieldDouble : public MEDCoupling::MEDCouplingField
+  class MEDCouplingFieldDouble : public MEDCouplingFieldT<double>
   {
   public:
     static MEDCouplingFieldDouble *New(TypeOfField type, TypeOfTimeDiscretization td=ONE_TIME);
     static MEDCouplingFieldDouble *New(const MEDCouplingFieldTemplate& ft, TypeOfTimeDiscretization td=ONE_TIME);
+    bool isEqual(const MEDCouplingFieldDouble *other, double meshPrec, double valsPrec) const throw(INTERP_KERNEL::Exception);
+    bool isEqualWithoutConsideringStr(const MEDCouplingFieldDouble *other, double meshPrec, double valsPrec) const throw(INTERP_KERNEL::Exception);
     void setTimeUnit(const std::string& unit);
     std::string getTimeUnit() const;
     void synchronizeTimeWithSupport() throw(INTERP_KERNEL::Exception);
@@ -4023,13 +4028,13 @@
     std::string advancedRepr() const throw(INTERP_KERNEL::Exception);
     std::string  writeVTK(const std::string& fileName, bool isBinary=true) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldInt *convertToIntField() const throw(INTERP_KERNEL::Exception);
+    MEDCouplingFieldFloat *convertToFloatField() const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldDouble *clone(bool recDeepCpy) const;
     MEDCouplingFieldDouble *cloneWithMesh(bool recDeepCpy) const;
     MEDCouplingFieldDouble *deepCopy() const;
     MEDCouplingFieldDouble *buildNewTimeReprFromThis(TypeOfTimeDiscretization td, bool deepCopy) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldDouble *nodeToCellDiscretization() const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldDouble *cellToNodeDiscretization() const throw(INTERP_KERNEL::Exception);
-    TypeOfTimeDiscretization getTimeDiscretization() const throw(INTERP_KERNEL::Exception);
     double getIJ(int tupleId, int compoId) const throw(INTERP_KERNEL::Exception);
     double getIJK(int cellId, int nodeIdInCell, int compoId) const throw(INTERP_KERNEL::Exception);
     void synchronizeTimeWithMesh() throw(INTERP_KERNEL::Exception);
@@ -4130,6 +4135,18 @@
         self->reprQuickOverview(oss);
         return oss.str();
       }
+
+      PyObject *isEqualIfNotWhy(const MEDCouplingFieldDouble *other, double meshPrec, double valsPrec) const throw(INTERP_KERNEL::Exception)
+      {
+        std::string ret1;
+        bool ret0=self->isEqualIfNotWhy(other,meshPrec,valsPrec,ret1);
+        PyObject *ret=PyTuple_New(2);
+        PyObject *ret0Py=ret0?Py_True:Py_False;
+        Py_XINCREF(ret0Py);
+        PyTuple_SetItem(ret,0,ret0Py);
+        PyTuple_SetItem(ret,1,PyString_FromString(ret1.c_str()));
+        return ret;
+      }
       
       MEDCouplingFieldDouble *voronoize(double eps) const throw(INTERP_KERNEL::Exception)
       {
@@ -4426,8 +4443,8 @@
         std::vector<double> bb,bb2;
         int sw;
         int spaceDim=3;
-        const char msg[]="Python wrap of MEDCouplingFieldDouble::extractSlice3D : 1st paramater for origin.";
-        const char msg2[]="Python wrap of MEDCouplingFieldDouble::extractSlice3D : 2nd paramater for vector.";
+        const char msg[]="Python wrap of MEDCouplingFieldDouble::extractSlice3D : 1st parameter for origin.";
+        const char msg2[]="Python wrap of MEDCouplingFieldDouble::extractSlice3D : 2nd parameter for vector.";
         const double *orig=convertObjToPossibleCpp5_Safe(origin,sw,val,a,aa,bb,msg,1,spaceDim,true);
         const double *vect=convertObjToPossibleCpp5_Safe(vec,sw,val2,a2,aa2,bb2,msg2,1,spaceDim,true);
         //
@@ -5028,16 +5045,6 @@
         return field_serialize<double>(self);
       }
 
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInputGeneral<SinglePyObjExpectToBeAListOfSz2>(cls,args,"MEDCouplingFieldDouble");
-      }
-
-      PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-      {// put an empty dict in input to say to __new__ to call __init__...
-        return field__getnewargs__<MEDCouplingFieldDouble>(self);
-      }
-
       PyObject *__getstate__() const throw(INTERP_KERNEL::Exception)
       {
         return field__getstate__<MEDCouplingFieldDouble>(self,MEDCoupling_MEDCouplingFieldDouble_getTinySerializationInformation,MEDCoupling_MEDCouplingFieldDouble_serialize);
@@ -5207,11 +5214,13 @@
        }
   };
 
-  class MEDCouplingFieldInt : public MEDCouplingField
+  class MEDCouplingFieldInt : public MEDCouplingFieldT<int>
   {
   public:
     static MEDCouplingFieldInt *New(TypeOfField type, TypeOfTimeDiscretization td=ONE_TIME);
     static MEDCouplingFieldInt *New(const MEDCouplingFieldTemplate& ft, TypeOfTimeDiscretization td=ONE_TIME);
+    bool isEqual(const MEDCouplingFieldInt *other, double meshPrec, int valsPrec) const throw(INTERP_KERNEL::Exception);
+    bool isEqualWithoutConsideringStr(const MEDCouplingFieldInt *other, double meshPrec, int valsPrec) const throw(INTERP_KERNEL::Exception);
     void setTimeUnit(const std::string& unit) throw(INTERP_KERNEL::Exception);
     std::string getTimeUnit() const throw(INTERP_KERNEL::Exception);
     void setTime(double val, int iteration, int order) throw(INTERP_KERNEL::Exception);
@@ -5232,6 +5241,18 @@
         return MEDCouplingFieldInt::New(ft,td);
       }
 
+      PyObject *isEqualIfNotWhy(const MEDCouplingFieldInt *other, double meshPrec, int valsPrec) const throw(INTERP_KERNEL::Exception)
+      {
+        std::string ret1;
+        bool ret0=self->isEqualIfNotWhy(other,meshPrec,valsPrec,ret1);
+        PyObject *ret=PyTuple_New(2);
+        PyObject *ret0Py=ret0?Py_True:Py_False;
+        Py_XINCREF(ret0Py);
+        PyTuple_SetItem(ret,0,ret0Py);
+        PyTuple_SetItem(ret,1,PyString_FromString(ret1.c_str()));
+        return ret;
+      }
+      
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -5283,16 +5304,6 @@
         return field_serialize<int>(self);
       }
 
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInputGeneral<SinglePyObjExpectToBeAListOfSz2>(cls,args,"MEDCouplingFieldInt");
-      }
-
-      PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-      {// put an empty dict in input to say to __new__ to call __init__...
-        return field__getnewargs__<MEDCouplingFieldInt>(self);
-      }
-
       PyObject *__getstate__() const throw(INTERP_KERNEL::Exception)
       {
         return field__getstate__<MEDCouplingFieldInt>(self,MEDCoupling_MEDCouplingFieldInt_getTinySerializationInformation,MEDCoupling_MEDCouplingFieldInt_serialize);
@@ -5305,11 +5316,13 @@
     }
   };
 
-  class MEDCouplingFieldFloat : public MEDCouplingField
+  class MEDCouplingFieldFloat : public MEDCouplingFieldT<float>
   {
   public:
     static MEDCouplingFieldFloat *New(TypeOfField type, TypeOfTimeDiscretization td=ONE_TIME);
     static MEDCouplingFieldFloat *New(const MEDCouplingFieldTemplate& ft, TypeOfTimeDiscretization td=ONE_TIME);
+    bool isEqual(const MEDCouplingFieldFloat *other, double meshPrec, float valsPrec) const throw(INTERP_KERNEL::Exception);
+    bool isEqualWithoutConsideringStr(const MEDCouplingFieldFloat *other, double meshPrec, float valsPrec) const throw(INTERP_KERNEL::Exception);
     void setTimeUnit(const std::string& unit) throw(INTERP_KERNEL::Exception);
     std::string getTimeUnit() const throw(INTERP_KERNEL::Exception);
     void setTime(double val, int iteration, int order) throw(INTERP_KERNEL::Exception);
@@ -5330,6 +5343,18 @@
         return MEDCouplingFieldFloat::New(ft,td);
       }
 
+      PyObject *isEqualIfNotWhy(const MEDCouplingFieldFloat *other, double meshPrec, float valsPrec) const throw(INTERP_KERNEL::Exception)
+      {
+        std::string ret1;
+        bool ret0=self->isEqualIfNotWhy(other,meshPrec,valsPrec,ret1);
+        PyObject *ret=PyTuple_New(2);
+        PyObject *ret0Py=ret0?Py_True:Py_False;
+        Py_XINCREF(ret0Py);
+        PyTuple_SetItem(ret,0,ret0Py);
+        PyTuple_SetItem(ret,1,PyString_FromString(ret1.c_str()));
+        return ret;
+      }
+
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -5380,16 +5405,6 @@
       {
         return field_serialize<float>(self);
       }
-        
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInputGeneral<SinglePyObjExpectToBeAListOfSz2>(cls,args,"MEDCouplingFieldFloat");
-      }
-      
-      PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-      {// put an empty dict in input to say to __new__ to call __init__...
-        return field__getnewargs__<MEDCouplingFieldFloat>(self);
-      }
       
       PyObject *__getstate__() const throw(INTERP_KERNEL::Exception)
       {
@@ -6000,6 +6015,35 @@
 }
 
 %pythoncode %{
+def MEDCouplingUMeshReduce(self):
+    return MEDCouplingStdReduceFunct,(MEDCouplingUMesh,((),(self.__getstate__()),))
+def MEDCouplingCMeshReduce(self):
+    return MEDCouplingStdReduceFunct,(MEDCouplingCMesh,((),(self.__getstate__()),))
+def MEDCouplingIMeshReduce(self):
+    return MEDCouplingStdReduceFunct,(MEDCouplingIMesh,((),(self.__getstate__()),))
+def MEDCouplingMappedExtrudedMeshReduce(self):
+    return MEDCouplingStdReduceFunct,(MEDCouplingMappedExtrudedMesh,((),(self.__getstate__()),))
+def MEDCouplingCurveLinearMeshReduce(self):
+    return MEDCouplingStdReduceFunct,(MEDCouplingCurveLinearMesh,((),(self.__getstate__()),))
+def MEDCoupling1SGTUMeshReduce(self):
+    return MEDCouplingStdReduceFunct,(MEDCoupling1SGTUMesh,((),(self.__getstate__()),))
+def MEDCoupling1DGTUMeshReduce(self):
+    return MEDCouplingStdReduceFunct,(MEDCoupling1DGTUMesh,((),(self.__getstate__()),))
+def MEDCouplingFieldDoubleReduce(self):
+    self.checkConsistencyLight()
+    d=(self.getTypeOfField(),self.getTimeDiscretization())
+    return MEDCouplingStdReduceFunct,(MEDCouplingFieldDouble,(d,(self.__getstate__()),))
+def MEDCouplingFieldIntReduce(self):
+    self.checkConsistencyLight()
+    d=(self.getTypeOfField(),self.getTimeDiscretization())
+    return MEDCouplingStdReduceFunct,(MEDCouplingFieldInt,(d,(self.__getstate__()),))
+def MEDCouplingFieldFloatReduce(self):
+    self.checkConsistencyLight()
+    d=(self.getTypeOfField(),self.getTimeDiscretization())
+    return MEDCouplingStdReduceFunct,(MEDCouplingFieldFloat,(d,(self.__getstate__()),))
+%}
+
+%pythoncode %{
 import os
 __filename=os.environ.get('PYTHONSTARTUP')
 if __filename and os.path.isfile(__filename):
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingDataArrayTraits.hxx MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingDataArrayTraits.hxx
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingDataArrayTraits.hxx	2018-04-19 17:04:36.733222643 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingDataArrayTraits.hxx	2018-04-19 17:25:17.286788442 +0200
@@ -37,7 +37,7 @@
 #ifdef WITH_NUMPY
 // specific DataArray deallocator callback. This deallocator is used both in the constructor of DataArray and in the toNumPyArr
 // method. This dellocator uses weakref to determine if the linked numArr is still alive or not. If alive the ownership is given to it.
-// if no more alive the "standart" DataArray deallocator is called.
+// if no more alive the "standard" DataArray deallocator is called.
 void numarrdeal(void *pt, void *wron)
 {
   void **wronc=(void **)wron;
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingDataArrayTypemaps.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingDataArrayTypemaps.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingDataArrayTypemaps.i	2018-04-19 17:04:36.733222643 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingDataArrayTypemaps.i	2018-04-19 17:25:17.255787829 +0200
@@ -1,4 +1,4 @@
-// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+// Copyright (C) 2007-2017  CEA/DEN, EDF R&D
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
@@ -50,7 +50,7 @@
 }
 
 /*!
- * This method is an extention of PySlice_GetIndices but less
+ * This method is an extension of PySlice_GetIndices but less
  * open than PySlice_GetIndicesEx that accepts too many situations.
  */
 void GetIndicesOfSlice(PyObject *slice, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, const char *msgInCaseOfFailure)
@@ -236,27 +236,27 @@
 
     /*
      * Don't allow infinite chains of views, always set the base
-     * to the first owner of the data.  
-     * That is, either the first object which isn't an array, 
+     * to the first owner of the data.
+     * That is, either the first object which isn't an array,
      * or the first object which owns its own data.
      */
 
     while (PyArray_Check(obj) && (PyObject *)arr != obj) {
         PyArrayObject *obj_arr = (PyArrayObject *)obj;
         PyObject *tmp;
- 
+
 
         /* If this array owns its own data, stop collapsing */
-        if (PyArray_CHKFLAGS(obj_arr, MED_NUMPY_OWNDATA )) { 
+        if (PyArray_CHKFLAGS(obj_arr, MED_NUMPY_OWNDATA )) {
             break;
-        }   
+        }
 
         tmp = PyArray_BASE(obj_arr);
         /* If there's no base, stop collapsing */
         if (tmp == NULL) {
             break;
         }
-        /* Stop the collapse new base when the would not be of the same 
+        /* Stop the collapse new base when the would not be of the same
          * type (i.e. different subclass).
          */
         if (Py_TYPE(tmp) != Py_TYPE(arr)) {
@@ -293,7 +293,7 @@
   MEDCoupling::MemArray<T>& mem=self->accessToMemArray();
   if(nbComp==0)
     {
-      std::ostringstream oss; oss << MCDataStr << "::toNumPyArray : number of components of this is 0 ! Should be > 0 !"; 
+      std::ostringstream oss; oss << MCDataStr << "::toNumPyArray : number of components of this is 0 ! Should be > 0 !";
       throw INTERP_KERNEL::Exception(oss.str().c_str());
     }
   int nbDims=nbComp==1?1:2;
@@ -489,7 +489,7 @@
       if(msg)
         oss << msg;
       else
-        oss << "PyWrap convertPyObjectToStr : expect a sting like py object !";
+        oss << "PyWrap convertPyObjectToStr : expect a string like py object !";
       throw INTERP_KERNEL::Exception(oss.str());
     }
   return ret;
@@ -1394,7 +1394,7 @@
     }
   status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayIntTuple,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       daIntTuple=reinterpret_cast< MEDCoupling::DataArrayIntTuple * >(argp);
       sw=4;
       return ;
@@ -1474,7 +1474,7 @@
     }
   status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayIntTuple,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       MEDCoupling::DataArrayIntTuple *daIntTuple=reinterpret_cast< MEDCoupling::DataArrayIntTuple * >(argp);
       sw=4; sz=daIntTuple->getNumberOfCompo();
       return daIntTuple->getConstPointer();
@@ -1690,14 +1690,14 @@
   void *argp;
   int status=SWIG_ConvertPtr(value,&argp,ti_da,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       d=reinterpret_cast< typename MEDCoupling::Traits<T>::ArrayType * >(argp);
       sw=2;
       return ;
     }
   status=SWIG_ConvertPtr(value,&argp,ti_tuple,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       e=reinterpret_cast< typename MEDCoupling::Traits<T>::ArrayTuple * >(argp);
       sw=3;
       return ;
@@ -1719,6 +1719,19 @@
 }
 
 /*!
+ * if value int -> cpp val sw=1
+ * if value double -> cpp val sw=1
+ * if value DataArrayDouble -> cpp DataArrayDouble sw=2
+ * if value DataArrayDoubleTuple -> cpp DataArrayDoubleTuple sw=3
+ * if value list[int,double] -> cpp std::vector<double> sw=4
+ * if value tuple[int,double] -> cpp std::vector<double> sw=4
+ */
+static void convertFloatStarLikePyObjToCpp_2(PyObject *value, int& sw, float& val, MEDCoupling::DataArrayFloat *&d, MEDCoupling::DataArrayFloatTuple *&e, std::vector<float>& f)
+{
+  convertFPStarLikePyObjToCpp_2<float>(value,sw,val,d,e,f,SWIGTYPE_p_MEDCoupling__DataArrayFloat,SWIGTYPE_p_MEDCoupling__DataArrayFloatTuple);
+}
+
+/*!
  * if python int -> cpp int sw=1
  * if python list[int] -> cpp vector<int> sw=2
  * if python tuple[int] -> cpp vector<int> sw=2
@@ -2068,7 +2081,7 @@
       sw=1;
       if(nbTuplesExpected*nbCompExpected!=1)
         {
-          std::ostringstream oss; oss << msg << "dimension expected to be " << nbTuplesExpected*nbCompExpected << " , and your data in input has dimension one (single PyFloat) !"; 
+          std::ostringstream oss; oss << msg << "dimension expected to be " << nbTuplesExpected*nbCompExpected << " , and your data in input has dimension one (single PyFloat) !";
           throw INTERP_KERNEL::Exception(oss.str().c_str());
         }
       return &val;
@@ -2079,7 +2092,7 @@
       sw=1;
       if(nbTuplesExpected*nbCompExpected!=1)
         {
-          std::ostringstream oss; oss << msg << "dimension expected to be " << nbTuplesExpected*nbCompExpected << " , and your data in input has dimension one (single PyInt) !"; 
+          std::ostringstream oss; oss << msg << "dimension expected to be " << nbTuplesExpected*nbCompExpected << " , and your data in input has dimension one (single PyInt) !";
           throw INTERP_KERNEL::Exception(oss.str().c_str());
         }
       return &val;
@@ -2099,7 +2112,7 @@
   void *argp;
   int status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayDouble,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       d=reinterpret_cast< MEDCoupling::DataArrayDouble * >(argp);
       sw=2;
       if(d)
@@ -2135,7 +2148,7 @@
     }
   status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayDoubleTuple,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       e=reinterpret_cast< MEDCoupling::DataArrayDoubleTuple * >(argp);
       sw=3;
       if(e->getNumberOfCompo()==nbCompExpected)
@@ -2144,7 +2157,7 @@
             return e->getConstPointer();
           else
             {
-              std::ostringstream oss; oss << msg << "nb of tuples expected to be " << nbTuplesExpected << " , and input DataArrayDoubleTuple has always one tuple by contruction !";
+              std::ostringstream oss; oss << msg << "nb of tuples expected to be " << nbTuplesExpected << " , and input DataArrayDoubleTuple has always one tuple by construction !";
               throw INTERP_KERNEL::Exception(oss.str().c_str());
             }
         }
@@ -2175,7 +2188,7 @@
       sw=1;
       if(nbCompExpected!=1)
         {
-          std::ostringstream oss; oss << msg << "dimension expected to be " << nbCompExpected << " , and your data in input has dimension one (single PyFloat) !"; 
+          std::ostringstream oss; oss << msg << "dimension expected to be " << nbCompExpected << " , and your data in input has dimension one (single PyFloat) !";
           throw INTERP_KERNEL::Exception(oss.str().c_str());
         }
       nbTuples=1;
@@ -2187,7 +2200,7 @@
       sw=1;
       if(nbCompExpected!=1)
         {
-          std::ostringstream oss; oss << msg << "dimension expected to be " << nbCompExpected << " , and your data in input has dimension one (single PyInt) !"; 
+          std::ostringstream oss; oss << msg << "dimension expected to be " << nbCompExpected << " , and your data in input has dimension one (single PyInt) !";
           throw INTERP_KERNEL::Exception(oss.str().c_str());
         }
       nbTuples=1;
@@ -2213,7 +2226,7 @@
       sw=4;
       if(size%nbCompExpected!=0)
         {
-          std::ostringstream oss; oss << msg << "dimension expected to be a multiple of " << nbCompExpected << " , and your data in input has dimension " << f.size() << " !"; 
+          std::ostringstream oss; oss << msg << "dimension expected to be a multiple of " << nbCompExpected << " , and your data in input has dimension " << f.size() << " !";
           throw INTERP_KERNEL::Exception(oss.str().c_str());
         }
       nbTuples=size/nbCompExpected;
@@ -2239,7 +2252,7 @@
       sw=4;
       if(size%nbCompExpected!=0)
         {
-          std::ostringstream oss; oss << msg << "dimension expected to be a multiple of " << nbCompExpected << " , and your data in input has dimension " << f.size() << " !"; 
+          std::ostringstream oss; oss << msg << "dimension expected to be a multiple of " << nbCompExpected << " , and your data in input has dimension " << f.size() << " !";
           throw INTERP_KERNEL::Exception(oss.str().c_str());
         }
       nbTuples=size/nbCompExpected;
@@ -2248,7 +2261,7 @@
   void *argp;
   int status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayDouble,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       d=reinterpret_cast< MEDCoupling::DataArrayDouble * >(argp);
       sw=2;
       if(d)
@@ -2277,7 +2290,7 @@
     }
   status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayDoubleTuple,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       e=reinterpret_cast< MEDCoupling::DataArrayDoubleTuple * >(argp);
       sw=3;
       if(e)
@@ -2380,7 +2393,7 @@
   void *argp;
   int status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayDouble,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       d=reinterpret_cast< MEDCoupling::DataArrayDouble * >(argp);
       sw=2;
       if(d)
@@ -2409,7 +2422,7 @@
     }
   status=SWIG_ConvertPtr(value,&argp,SWIGTYPE_p_MEDCoupling__DataArrayDoubleTuple,0|0);
   if(SWIG_IsOK(status))
-    {  
+    {
       e=reinterpret_cast< MEDCoupling::DataArrayDoubleTuple * >(argp);
       sw=3;
       if(e)
@@ -2456,114 +2469,6 @@
   return reinterpret_cast< MEDCoupling::DataArray * >(aBasePtrVS);
 }
 
-static PyObject *NewMethWrapCallInitOnlyIfEmptyDictInInput(PyObject *cls, PyObject *args, const char *clsName)
-{
-  if(!PyTuple_Check(args))
-    {
-      std::ostringstream oss; oss << clsName << ".__new__ : the args in input is expected to be a tuple !";
-      throw INTERP_KERNEL::Exception(oss.str().c_str());
-    }
-  PyObject *builtinsd(PyEval_GetBuiltins());//borrowed
-  PyObject *obj(PyDict_GetItemString(builtinsd,"object"));//borrowed
-  PyObject *selfMeth(PyObject_GetAttrString(obj,"__new__"));
-  //
-  PyObject *tmp0(PyTuple_New(1));
-  PyTuple_SetItem(tmp0,0,cls); Py_XINCREF(cls);
-  PyObject *instance(PyObject_CallObject(selfMeth,tmp0));
-  Py_DECREF(tmp0);
-  Py_DECREF(selfMeth);
-  if(PyTuple_Size(args)==2 && PyDict_Check(PyTuple_GetItem(args,1)) && PyDict_Size(PyTuple_GetItem(args,1))==0 )
-    {// NOT general case. only true if in unpickeling context ! call __init__. Because for all other cases, __init__ is called right after __new__ !
-      PyObject *initMeth(PyObject_GetAttrString(instance,"__init__"));
-      PyObject *tmp3(PyTuple_New(0));
-      PyObject *tmp2(PyObject_CallObject(initMeth,tmp3));
-      Py_XDECREF(tmp2);
-      Py_DECREF(tmp3);
-      Py_DECREF(initMeth);
-    }
-  return instance;
-}
-
-template<class T>
-static PyObject *NewMethWrapCallInitOnlyIfDictWithSingleEltInInputGeneral(PyObject *cls, PyObject *args, const char *clsName)
-{
-  if(!PyTuple_Check(args))
-    {
-      std::ostringstream oss; oss << clsName << ".__new__ : the args in input is expected to be a tuple !";
-      throw INTERP_KERNEL::Exception(oss.str().c_str());
-    }
-  PyObject *builtinsd(PyEval_GetBuiltins());//borrowed
-  PyObject *obj(PyDict_GetItemString(builtinsd,"object"));//borrowed
-  PyObject *selfMeth(PyObject_GetAttrString(obj,"__new__"));
-  //
-  PyObject *tmp0(PyTuple_New(1));
-  PyTuple_SetItem(tmp0,0,cls); Py_XINCREF(cls);
-  PyObject *instance(PyObject_CallObject(selfMeth,tmp0));
-  Py_DECREF(tmp0);
-  Py_DECREF(selfMeth);
-  if(PyTuple_Size(args)==2 && PyDict_Check(PyTuple_GetItem(args,1)) && PyDict_Size(PyTuple_GetItem(args,1))==1 )
-    {// NOT general case. only true if in unpickeling context ! call __init__. Because for all other cases, __init__ is called right after __new__ !
-      PyObject *initMeth(PyObject_GetAttrString(instance,"__init__"));
-      PyObject *zeNumpyRepr(0);
-      {
-        PyObject *tmp1(PyInt_FromLong(0));
-       zeNumpyRepr=PyDict_GetItem(PyTuple_GetItem(args,1),tmp1);//borrowed
-        Py_DECREF(tmp1);
-      }
-      if(!zeNumpyRepr)
-        {
-          std::ostringstream oss; oss << clsName << ".__new__ : the args in input is expected to be a tuple !";
-          throw INTERP_KERNEL::Exception(oss.str().c_str());
-        }
-      T tt;
-      {
-        PyObject *tmp3(0);
-        try
-          {
-            tmp3=tt(zeNumpyRepr);
-          }
-        catch(INTERP_KERNEL::Exception& e)
-          {
-            std::ostringstream oss; oss << clsName << ".__new__ : Invalid type in input " << " : " << e.what();
-            throw INTERP_KERNEL::Exception(oss.str());
-          }
-        {
-          PyObject *tmp2(PyObject_CallObject(initMeth,tmp3));
-          Py_XDECREF(tmp2);
-        }
-        Py_DECREF(tmp3);
-      }
-      Py_DECREF(initMeth);
-    }
-  return instance;
-}
-
-struct SinglePyObjToBePutInATuple
-{
-  PyObject *operator()(PyObject *zeNumpyRepr)
-  {
-    PyObject *tmp3(PyTuple_New(1));
-    PyTuple_SetItem(tmp3,0,zeNumpyRepr); Py_XINCREF(zeNumpyRepr);
-    return tmp3;
-  }
-};
-
-struct SinglePyObjExpectToBeAListOfSz2
-{
-  PyObject *operator()(PyObject *uniqueElt)
-  {
-    if(!PyTuple_Check(uniqueElt) || PyTuple_Size(uniqueElt)!=2)
-      throw INTERP_KERNEL::Exception("Not a tuple of size 2 !");
-    Py_XINCREF(uniqueElt);
-    return uniqueElt;
-  }
-};
-
-static PyObject *NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(PyObject *cls, PyObject *args, const char *clsName)
-{
-  return NewMethWrapCallInitOnlyIfDictWithSingleEltInInputGeneral<SinglePyObjToBePutInATuple>(cls,args,clsName);
-}
-
 static PyObject *convertPartDefinition(MEDCoupling::PartDefinition *pd, int owner)
 {
   PyObject *ret=0;
@@ -3127,6 +3032,83 @@
     }
 }
 
+bool isCSRMatrix(PyObject *m)
+{
+#if defined(WITH_NUMPY) && defined(WITH_SCIPY)
+  PyObject* pdict(PyDict_New());
+  PyDict_SetItemString(pdict, "__builtins__", PyEval_GetBuiltins());
+  PyObject *tmp(PyRun_String("from scipy.sparse import csr_matrix", Py_single_input, pdict, pdict));
+  if(!tmp)
+    throw INTERP_KERNEL::Exception("Problem during loading csr_matrix in scipy.sparse ! Is Scipy module available in present ?");
+  PyObject *csrMatrixCls=PyDict_GetItemString(pdict,"csr_matrix");
+  if(!csrMatrixCls)
+    throw INTERP_KERNEL::Exception("csr_matrix not found in scipy.sparse ! Is Scipy module available in present ?");
+  bool ret(PyObject_IsInstance(m,csrMatrixCls));
+  Py_DECREF(pdict); Py_XDECREF(tmp);
+  return ret;
+#else
+  return false;
+#endif
+}
+
+void convertCSR_MCDataToVectMapIntDouble(const MEDCoupling::DataArrayInt *indptrPtr, const MEDCoupling::DataArrayInt *indicesPtr, const MEDCoupling::DataArrayDouble *dataPtr, std::vector<std::map<int,double> >& mCpp)
+{
+#if __cplusplus >= 201103L
+  auto nbOfRows(indptrPtr->getNumberOfTuples()-1);
+  if(nbOfRows<0)
+    throw INTERP_KERNEL::Exception("pywrap of MEDCouplingRemapper::setMatrix : input CSR matrix looks bad regarding indptr array !");
+  mCpp.resize(nbOfRows);
+  auto indPtrCPtr(indptrPtr->begin());
+  auto indicesCPtr(indicesPtr->begin());
+  auto dataCPtr(dataPtr->begin());
+  for(auto i=0;i<nbOfRows;i++)
+    {
+      auto& line(mCpp[i]);
+      for(auto j=indPtrCPtr[i];j<indPtrCPtr[i+1];j++)
+        {
+          line[indicesCPtr[j]]=dataCPtr[j];
+        }
+    }
+#else
+  throw INTERP_KERNEL::Exception("Breaking news : 10% off for C++11 compiler :)");
+#endif
+}
+
+void convertToVectMapIntDouble(PyObject *pyobj, std::vector<std::map<int,double> >& mCpp)
+{
+  if(!PyList_Check(pyobj))
+    throw INTERP_KERNEL::Exception("convertToVectMapIntDouble : input is not a python list !");
+  mCpp.clear();
+  Py_ssize_t sz(PyList_Size(pyobj));
+  mCpp.resize(sz);
+  for(Py_ssize_t i=0;i<sz;i++)
+    {
+      PyObject *elt(PyList_GetItem(pyobj,i));
+      if(!PyDict_Check(elt))
+        {
+          std::ostringstream oss; oss << "convertToVectMapIntDouble : at pos # " << i << " of pylist a dict is exepect !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      PyObject *key, *value;
+      Py_ssize_t pos(0);
+      std::map<int,double>& mapCpp(mCpp[i]);
+      while(PyDict_Next(elt,&pos,&key,&value))
+        {
+          if(!PyInt_Check(key))
+            {
+              std::ostringstream oss; oss << "convertToVectMapIntDouble : at pos # " << i << " of pylist the dict contains at pos " << pos << " a key not mappable to pyint !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+          if(!PyFloat_Check(value))
+            {
+              std::ostringstream oss; oss << "convertToVectMapIntDouble : at pos # " << i << " of pylist the dict contains at pos " << pos << " the value not mappable to pyfloat !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+          mapCpp[(int)PyInt_AS_LONG(key)]=PyFloat_AS_DOUBLE(value);
+        }
+    }
+}
+
 template<class T>
 PyObject *DataArrayT_imul__internal(PyObject *trueSelf, PyObject *obj, typename MEDCoupling::Traits<T>::ArrayType *self, swig_type_info *ti_da, swig_type_info *ti_tuple)
 {
@@ -3257,7 +3239,7 @@
       throw INTERP_KERNEL::Exception(msg);
     }
 }
-  
+
 template<class T>
 PyObject *DataArrayT_isub__internal(PyObject *trueSelf, PyObject *obj, typename MEDCoupling::Traits<T>::ArrayType *self, swig_type_info *ti_da, swig_type_info *ti_tuple)
 {
@@ -3324,9 +3306,11 @@
 swig_type_info *SWIGTITraits<float>::TI_TUPLE=NULL;//unfortunately SWIGTYPE_p_MEDCoupling__DataArrayFloat is null when called here ! Postpone initialization at inlined initializeMe()
 swig_type_info *SWIGTITraits<int>::TI_TUPLE=NULL;//unfortunately SWIGTYPE_p_MEDCoupling__DataArrayFloat is null when called here ! Postpone initialization at inlined initializeMe()
 
+#ifdef WITH_NUMPY
 PyTypeObject *NPYTraits<double>::NPYFunc=&PyCallBackDataArrayDouble_RefType;
 
 PyTypeObject *NPYTraits<float>::NPYFunc=&PyCallBackDataArrayFloat_RefType;
+#endif
 
 template<class T>
 typename MEDCoupling::Traits<T>::ArrayType *DataArrayT__setitem__(typename MEDCoupling::Traits<T>::ArrayType *self, PyObject *obj, PyObject *value)
@@ -3364,4 +3348,37 @@
   return DataArrayT_isub__internal<T>(trueSelf,obj,self,SWIGTITraits<T>::TI,SWIGTITraits<T>::TI_TUPLE);
 }
 
+template<class T>
+typename MEDCoupling::Traits<T>::ArrayType *DataArrayFPT_rmul(typename MEDCoupling::Traits<T>::ArrayType *self, PyObject *obj)
+{
+  const char msg[]="Unexpected situation in __rmul__ !";
+  T val;
+  typename MEDCoupling::Traits<T>::ArrayType *a;
+  typename MEDCoupling::Traits<T>::ArrayTuple *aa;
+  std::vector<T> bb;
+  int sw;
+  convertFPStarLikePyObjToCpp_2<T>(obj,sw,val,a,aa,bb,SWIGTITraits<T>::TI,SWIGTITraits<T>::TI_TUPLE);
+  switch(sw)
+    {
+    case 1:
+      {
+        typename MEDCoupling::MCAuto<typename MEDCoupling::Traits<T>::ArrayType> ret(self->deepCopy());
+        ret->applyLin(val,0.);
+        return ret.retn();
+      }
+    case 3:
+      {
+        typename MEDCoupling::MCAuto<typename MEDCoupling::Traits<T>::ArrayType> aaa(aa->buildDA(1,self->getNumberOfComponents()));
+        return MEDCoupling::Traits<T>::ArrayType::Multiply(self,aaa);
+      }
+    case 4:
+      {
+        typename MEDCoupling::MCAuto<typename MEDCoupling::Traits<T>::ArrayType> aaa(MEDCoupling::Traits<T>::ArrayType::New()); aaa->useArray(&bb[0],false,MEDCoupling::CPP_DEALLOC,1,(int)bb.size());
+        return MEDCoupling::Traits<T>::ArrayType::Multiply(self,aaa);
+      }
+    default:
+      throw INTERP_KERNEL::Exception(msg);
+    }
+}
+
 #endif
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyc MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyc
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyc	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyc	2018-04-19 17:25:17.266788047 +0200
@@ -0,0 +1,271 @@
+
+;Zc           @   s!   d  d l  Td d d     YZ d S(   i(   t   *t   MEDCouplingDataForTestc           B   s~  e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
+ d	   Z d
+   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e	  Z	 e  e
+  Z
+ e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z e  e  Z RS(   c         C   sZ  d d d d d d d d d d d d d d d d d d g } d d d d d d d d d	 d d
+ d d d d d d	 d g } t  j   } | j d  | j d	  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   t j   } | j	 | d d  | j
+ |  | S(   Ng333333ӿg?gffffff?i    i   i   i   i   i   i   i   i   i
+   i   i   i	   (   t   MEDCouplingUMesht   Newt   setMeshDimensiont   allocateCellst   insertNextCellt
+   NORM_QUAD4t	   NORM_TRI3t   finishInsertingCellst   DataArrayDoublet	   setValuest	   setCoords(   t   clst   targetCoordst
+   targetConnt
+   targetMesht   myCoords(    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DTargetMesh_1   s    <<
+c         C   s   d d d d d d d d g } d d d d d d g } t  j d d  } | j d  | j t d | d d ! | j t d | d d ! | j   t j   } | j | d	 d  | j |  | S(
+   Ng333333ӿgffffff?i    i   i   i   s   my name of mesh 2Di   i   (	   R   R   R   R   R   R	   R
+   R   R   (   R   t   sourceCoordst
+   sourceConnt
+   sourceMeshR   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DSourceMesh_1)   s    
+c      Q   C   s\  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gQ } d d d d d d	 d
+ d d d d d d	 d d d
+ d d d d d d
+ d d d d d d d
+ d d d d d	 d
+ d d d d d d	 d d d
+ d d d d d d
+ d d d d d d d
+ d d d d d d d g@ } t  j   } | j d  | j d  x: t d  D], } | j t d | d | d | d ! qW| j   t j   } | j	 | d d  | j
+ |  | S(    Ng        g      I@g      i@i    i   i   i   i	   i
+   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   (   R   R   R   R   t   rangeR   t
+   NORM_HEXA8R	   R
+   R   R   (   R   R   R   R   t   iR   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build3DTargetMesh_16   s     QQW`f&
+c      0   C   s  d d d d d d d d d d d d d d d d d d d d d d d d d d d g } d d d d d d	 d d
+ d d d d d d d d d d d	 d d d d d d d d d	 d d d d d d d d d	 d d d
+ d d d	 d d d d d
+ g0 } t  j   } | j d  | j d  | j t d | d	 d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   t j   } | j | d d  | j	 |  | S(   Ng        g      i@g      Y@i   i   i   i   i   i    i   i   i   i   i   i   i   i   i    i$   i(   i,   i0   i	   (
+   R   R   R   R   R   t   NORM_TETRA4R	   R
+   R   R   (   t   selfR   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build3DSourceMesh_1H   s.    -*
+c         C   su  d d d d d d d d d d d d d d d d d d d d d d d d d d d g } d d d	 d
+ d
+ d	 d d	 d d d d d	 d d d d d	 g } t  j   } | j d  | j d  | j t d	 | d d	 ! | j t d | d	 d ! | j t d | d d ! | j t d	 | d d ! | j t d	 | d d ! | j   t j   } | j	 | d d  | j
+ |  | S(   Ng333333ӿg      ?g?g      ?gffffff?g      ?i    i   i   i   i   i   i   i   i   i
+   i   i   i	   (   R   R   R   R   R   R   R   R	   R
+   R   R   (   R   R   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build3DSurfTargetMesh_1b   s    W<
+c      b  C   s	  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g } d d d	 d
+ d d d d d	 d d d d d d d	 d d d d d d d d d d d d d d d d d d d d d d d d d d	 d d d d d d d d d d	 d d d
+ d d d d d d d d d d d d d d  d d d d	 d d d d d	 d d	 d d d d d d d d d d d d d d d d  d! d d d  d d d! d d d d d d d! d d" d# d d d$ d% d d d d d d& d' d( d) d d d d d d d d d( d* d d d d* d+ d d d d d, d+ d d d d- d, d d d d. d- d d d d( d. d d( d* d+ d, d- d. d d d d d( d* d/ d) d d d d d+ d0 d1 d* d d! d d d d d d d' d( d d d d( d. d d d d. d- d d d d- d, d d d d! d2 d, d d! d d' d2 d d' d( d. d- d, d2 d d$ d% d d, d3 d4 d+ d& d' d( d) d5 d6 d7 d8 d( d. d- d, d+ d* d d( d7 d9 d* d d* d9 d: d+ d d+ d, d; d: d d, d- d< d; d d- d. d= d< d d. d( d7 d= d d7 d9 d: d; d< d= d( d* d/ d) d7 d9 d> d8 d+ d0 d1 d* d: d? d@ d9 d' d2 d, d- d. d( d d' d6 d7 d( d d( d7 d= d. d d. d= d< d- d d- d< d; d, d d, d2 dA d; d d2 d' d6 dA d d6 d7 d= d< d; dA d, d3 d4 d+ d; dB dC d: gb} d d" d# d d d  d d d d	 d d d d d	 d d d
+ d	 d d d d d d d d	 d
+ g } t  j   } | j d
+  | j d  | j t d  | d d  ! | j t d+ | d  d9 ! | j t d  | d9 dC ! | j t d  | dC dD ! | j t d+ | dD dE ! | j t d  | dE dF ! | j t d  | dF dG ! | j t d+ | dG dH ! | j t d  | dH dI ! | j t d  | dI dJ ! | j t d+ | dJ dK ! | j t d  | dK dL ! | j t d  | dL dM ! | j t d+ | dM dN ! | j t d  | dN dO ! | j t d  | dO dP ! | j t d+ | dP dQ ! | j t d  | dQ dR ! | j   t j   } | j	 | dS d
+  | j
+ |  t  j   } | j d  | j d  | j t d | d d ! | j t d | d d ! | j t d | d d# ! | j t d | d# d ! | j t d | d d ! | j t d | d d ! | j   | j
+ |  | | f S(T   Ng        g      ?g      ?g      ?g       @g      @i    i   i   i   i   i   i   i   i   i   i   i   i   ii   i   i   i   i   i   i   i
+   i	   i   i   i   i   i   i   i   i   i   i)   i   i!   i$   i+   i%   i"   i    i#   i(   i'   i&   i*   i,   i-   i8   i.   i0   i3   i:   i4   i1   i/   i2   i7   i6   i5   i9   i;   iC   in   iv   i~   i   i   i   i   i   i   i  i'  i/  iZ  ib  i<   (   R   R   R   R   R   R   t   NORM_POLYHEDR	   R
+   R   R   R   t   NORM_POLYGON(   R   t   coordst   connt   conn2t   retR   t   mesh2D(    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build3DExtrudedUMesh_1s   st    Z-Z-Z-Z3000Z
+
+c         C   s   d d d d g } d d d d d d g } t  j   } | j d  | j d  | j t d | d d ! | j t d | d d	 ! | j t d | d	 d
+ ! | j   t j   } | j | d	 d  | j	 |  | S(   Ng        g333333?g      ?g      ?i    i   i   i   i   i   (
+   R   R   R   R   R   t	   NORM_SEG2R	   R
+   R   R   (   R   R!   R"   t   meshR   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildCU1DMesh_U   s    
+c      $   C   s  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g$ } d d d d d d	 d
+ d d d d d d d d d d d	 g } t  j   } | j d
+  | j d  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   t j   } | j	 | d d
+  | j
+ |  | S(   Ng333333ӿg?gffffff?i    i	   i   i   i   i   i   i
+   i   i   i   i   i   i   i   i   i   (   R   R   R   R   R   R   R   R	   R
+   R   R   (   R   R   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DTargetMeshMergeNode_1   s    r<
+c      ]   C   s  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g] } d d d d d d	 d
+ d d d d d d	 d d d
+ d d d d d d
+ d d d d d d d
+ d d d d d	 d
+ d d d d d d	 d d d
+ d d d d d d
+ d d d d d d d
+ d d d d d d  d g@ } t  j   } | j d  | j d  x: t d  D], } | j t d | d | d | d! ! qW| j   t j   } | j	 | d" d  | j
+ |  | S(#   Ng        g      I@g      i@i    i   i   i   i	   i
+   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   (   R   R   R   R   R   R   R   R	   R
+   R   R   (   R   R   R   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build3DTargetMeshMergeNode_1   s     QQ{`f&
+c         C   s  d d d d d d d d d d d d d d d d d d d d d d d d d d g } d d d d d d d	 d d
+ d	 d d d d d d d
+ d d d d d d d g } t  j   } | j d  | j d	  | j d  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   t	 j   } | j
+ | d d	  | j |  | S(   Ng333333ӿg?gffffff?g333333?i    i   i   i   i   i   i   i   i   i	   i   i
+   i   t   mergei   i   i   i   i   (   R   R   t   setNameR   R   R   R   R   R	   R
+   R   R   (   R   R   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DTargetMeshMerged_1   s(    66
+c         C   s  d d d d d d d d d d d d d d d d d d g } d d d d d d d d d d d	 d d d
+ d d
+ d d d d d	 d d d	 g } t  j   } | j d  | j d  | j t d | d d ! | j t d | d d
+ ! | j t d | d
+ d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   t j   } | j | d d  | j	 |  | S(   Ng333333ӿg?gffffff?i    i   i   i   i   i   i   i   i   i	   i   i   i   i   i   (
+   R   R   R   R   R   R   R	   R
+   R   R   (   R   R   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DTargetMesh_2  s$    <N
+c         C   s   t  j d d  } | j d  d d d d d d d d g } x: t d  D], } | j t d | d | d | d ! qJ W| j   t j d d d	 d
+ d g d d  } | j |  | S(   Nt   1DSourceMeshi   i   i    i   i   g333333?gffffff?g?g      ?gQ?i   (	   R   R   R   R   R   R'   R	   R
+   R   (   R   R$   R"   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build1DSourceMesh_2  s    &
+$c      
+   C   s	  t  j d d  } | j d  d d d d d d d d	 d
+ d g
+ } | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   d d d d d d d d d d g
+ } t j   } | j | d d  | j	 |  | S(   Nt   1DMesh_3i   i   i    i   i   i   i   i   i	   i   i
+   g      ?g      ?g?g      @gףp=
+@g?gffffff?g=
+ףp=@(
+   R   R   R   R   t	   NORM_SEG3R'   R	   R
+   R   R   (   R   R$   R"   R!   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build1DTargetMesh_3'  s    $
+$c         C   s'  t  j d d  } | j d  d d d d d d d d	 d
+ d g
+ } | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   d d d d d d d d d d d d d d d d d d d d g } t j   } | j | d d  | j	 |  | S(   Nt   2DCurveMesh_3i   i   i    i   i   i   i   i   i	   i   i
+   g      ?g      ?g?g      @gףp=
+@g?gffffff?g=
+ףp=@(
+   R   R   R   R   R3   R'   R	   R
+   R   R   (   R   R$   R"   R!   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DCurveTargetMesh_36  s    $
+Bc      4   C   sQ  t  j d d  } | j d  d d d d d d d d d d d d d d d d	 d
+ d d d d d d	 d d d d d d d d d d d d d d d d d d d d
+ d	 d d d d d d d d	 g4 } | j t d | d d ! | j t d | d d
+ ! | j t d | d
+ d ! | j t d	 | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d	 | d d ! | j t d | d d ! | j	   d d d d d d d d d d d d d d d d d d d d d d g } t
+ j   } | j | d d  | j |  | j   | S(   Nt   2DMesh_3i   i
+   i    i   i   i   i   i   i   i   i	   i   i   i   i   i!   i&   i,   i4   g        g      ?g      ?g       @g      ?g      ?i   (   R   R   R   R   R   R   R    t	   NORM_TRI6t
+   NORM_QUAD8R	   R
+   R   R   t   checkConsistencyLight(   R   R$   R"   R!   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DTargetMesh_3E  s(    
+H
+c         C   s`  d d d d d d d d d d d d d d d d d d d d g } d d d d d d d d d	 d
+ d d d d d d d	 d g } t  j   } | j d
+  | j d  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j   t j   } | j	 | d d
+  | j
+ |  | S(   Ng333333ӿg?gffffff?i    i   i   i   i   i   i   i   i   i	   i
+   i   i   (   R   R   R   R   R   R   R   R	   R
+   R   R   (   R   R   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DTargetMesh_4[  s    B<
+c      	   C   s  t  j   } | j d  t  j   } | j d  d d d d d g } d d	 d
+ d d d d d d g	 } d d d d d d d d d g	 } d d d d d g } d d  d! d" d# g } t j   } | j | d$ d%  t j   }	 |	 j | d& d%  t j   }
+ |
+ j | d& d%  t j   } | j | d$ d%  t j   } | j | d$ d%  | j d'  |	 j d(  |
+ j d)  | j d*  | j d+  | j d, d-  |	 j d, d.  |
+ j d, d/  | j d, d0  | j d, d1  t j t t	  } | j
+ |  | j |  | j d d$ d2  | j d3  t j t t  } | j
+ |  | j |	 |
+ g  | j d4 d5 d6  | j d7 d& d8  | j d9  t j t t  } | j
+ |  | j |  | j d7 d: d;  | j d< d= d>  | j d?  t j t t	  } | j
+ |  | j |  | j d@ dA dB  | j dC  t j t t  } | j
+ |  | j |  | j dD  t j | | | | | g  } | S(E   Nt   m1t   m2gffffffg      g       g      g      g        g      ?g       @g      @g      @g?g?g333333?g?g     @e@g     `e@g     e@g     e@g     e@g33333Ce@gfffffFe@gIe@gLe@g      @g      @g      @g       @g      "@g      .@g      0@g      1@g      2@g      3@i   i   i	   t   d0t   d1t   d1_1t   d2t   d4i    t   c1t   c6t   c9t   c5t   c7i   t   f0gffffff?i   i   g333333?i
+   t   f1i   i   g      ?i   i   t   f2g333333?i   i   t   f3t   f4(   R   R   R-   R
+   R   R   t   setInfoOnComponentt   MEDCouplingFieldDoublet   ON_CELLSt   ONE_TIMEt   setMesht   setArrayt   setTimet   ON_NODESt   LINEAR_TIMEt	   setArrayst   setStartTimet
+   setEndTimet   CONST_ON_TIME_INTERVALt   NO_TIMEt   MEDCouplingMultiFields(   R   R=   R>   t   vals0t   vals1t   vals1_1t   vals2t   vals4R?   R@   RA   RB   RC   RI   RJ   RK   RL   RM   R$   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildMultiFields_1l  sr    !!    c         C   so  t  j   } | j d  t  j   } | j d  d d d d d g } d d	 d
+ d d g } d d d d d g } d d d d d g } d d d d d g } t j   } | j | d d  t j   }	 |	 j | d d  t j   }
+ |
+ j | d d  t j   } | j | d d  t j   } | j | d d  | j d  |	 j d  |
+ j d   | j d!  | j d"  | j d# d$  |	 j d# d%  |
+ j d# d&  | j d# d'  | j d# d(  t j t t	  } | j
+ |  | j |  | j d) d d*  | j d+  t j t t  } | j
+ |  | j |	 |
+ g  | j d, d- d.  | j d/ d0 d1  | j d2  t j t t  } | j
+ |  | j |  | j d/ d3 d4  | j d5 d6 d7  | j d8  t j t t	  } | j
+ |  | j |  | j d9 d: d;  | j d<  t j t t  } | j
+ |  | j |  | j d=  | | | | | g S(>   NR=   R>   gffffffg      g       g      g      g        g      ?g       @g      @g      @g     @e@g     `e@g     e@g     e@g     e@g      @g      @g      @g       @g      "@g      .@g      0@g      1@g      2@g      3@i   i   R?   R@   RA   RB   RC   i    RD   RE   RF   RG   RH   g?i   RI   gffffff?i   i   g333333?i	   i
+   RJ   i   i   g      ?i   i   RK   g333333?i   i   RL   RM   (   R   R   R-   R
+   R   R   RN   RO   RP   RQ   RR   RS   RT   RV   RW   RX   RY   RZ   R[   (   R   R=   R>   R]   R^   R_   R`   Ra   R?   R@   RA   RB   RC   RI   RJ   RK   RL   RM   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildMultiFields_2  sp        c         C   s   t  j d d  } t j   } d d d d d g } | j d  | j t d | d d ! | j t d | d d ! | j   | j	 |  | S(   Nt   Multi1DMeshi   i    i   i   i   (
+   R   R   R   t   buildCoordsForMultiTypes_1R   R   R'   R3   R	   R   (   R   R(   t   cooR"   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build1DMultiTypes_1  s    
+c         C   s   t  j d d  } t j   } d d d d d d d d d d	 d
+ d d d	 d
+ d d d d d d g } | j d  | j t d | d	 d ! | j t d | d d
+ ! | j t d | d
+ d ! | j t	 d | d d ! | j
+   | j |  | S(   Nt   Multi2DMeshi   i   i   i   i   i   i   i    i	   i
+   i   i   i   i   i   i   (   R   R   R   Re   R   R   R   R8   R   R9   R	   R   (   R   R(   Rf   R"   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build2DMultiTypes_1  s    E
+c      Q   C   s  t  j d d  } t j   } d d d d d d d d d d d	 d
+ d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d d d d d' d( d) d* d d d d d' d( d) d* d d d d d+ d, d- d. d/ d0 d1 d2 gQ } | j d3  | j t d4 | d d4 ! | j t d | d4 d ! | j t d5 | d d ! | j t	 d | d d ! | j t
+ d6 | d d! ! | j t d | d! d0 ! | j t d3 | d0 d7 ! | j t d | d7 d8 ! | j   | j |  | S(9   Nt   Multi3DMeshi   i    i   i   i   i   i   i   i   i   i   i   i
+   i	   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   i)   i*   i+   i,   i-   i.   i/   i0   i1   i2   i3   i4   i5   i6   i7   i   i   i   i   i=   iQ   (   R   R   R   Re   R   R   R   t   NORM_TETRA10t
+   NORM_PYRA5t   NORM_PYRA13t   NORM_PENTA6t   NORM_PENTA15R   t   NORM_HEXA20R	   R   (   R   R(   Rf   R"   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   build3DMultiTypes_1  s,    '-B
+c         C   sQ  t  j   } d d d d d d d d d d d d d d d d d d d d d d d d d	 d d d d	 d d	 d	 d d	 d d d d d d d	 d d	 d d d d d d d d d
+ d
+ d d d
+ d
+ d d
+ d d d d d d d d d d d d d d d
+ d d d d d
+ d d d
+ d
+ d d d
+ d d d d d d
+ d d d d d d d d d
+ d d
+ d d d d d d d d d d d d d d d d d d d d d d d
+ d d
+ d
+ d
+ d d
+ d d d	 d d	 d	 d	 d	 d	 d	 d d	 d d d	 d d	 d	 d	 d d	 d d d	 d d d d d	 d d	 d	 d d	 d d g } | j | d d  | j d d  | j d d  | j d d  | S(   Ng        g      ?g      ?g       @g      @g      @g      ?g      @g      @g      @g?g?g333333@i8   i   i    s   X (cm)i   s   Y (cm)i   s   Z (cm)(   R
+   R   R   RN   (   R   R!   t   data(    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyRe   	  s       c      Q   C   sU  t  j d d  } t j   } d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gQ } | j | d d  d d d d	 d
+ d d d d	 d d d d d d d d d d d d d d d	 d d d d d	 d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d g@ } | j d  x: t d  D], } | j t d | d | d | d ! q
+W| j   | j	 |  | S(!   Nt	   Hexa8Onlyi   g        g      ?g      ?i   i   i   i   i    i	   i
+   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   (
+   R   R   R
+   R   R   R   R   R   R	   R   (   R   R(   Rf   R!   R"   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildHexa8Mesh_1  s&    &
+c      J   C   s  t  j d d  } t  j d d  } d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d	 d d d	 d d d	 d d d	 d d d
+ d d d
+ d d d
+ d d d
+ d d d g9 } d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gJ } t j   } | j | d d  | j |  | j |  | j d  x: t d  D], } | j t d | d | d | d ! qW| j t	 d | d d ! | j t	 d | d d  ! | j t
+ d | d  d! ! | j t
+ d | d! d" ! | j   d d d d d d d d d d d d d d d d d d d d g } | j d  x: t d  D], } | j t d | d | d | d ! q
+W| j t d | d d ! | j t d | d d# ! | j   | | g S($   Ns
+   Pointe.medi   i   g        g      ?g       @g       g      g      @g      @g      @i    i   i   i   i   i   i   i	   i   i   i   i   i   i
+   i   i   i   i   i0   i5   i:   iB   iJ   i   (   R   R   R
+   R   R   R   R   R   R   Rl   R   R	   R   R   (   R   R(   t   mesh2R!   R"   Rf   R   R#   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildPointe_1'  s4    &
+B&
+c         C   s_  t  d d d d d d d d d d d	 d
+ d d d d d d d d d d d d d d d d d
+ d	 d d d d d d d d d d d d d d
+ d d d d d d d d d d d d d  d d! d" d# d d$ d% d& d d' d( d) d* d+ d, d- d. d/ d0 d1 d d2 d d3 d d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA dB dC dD dE dF d dG dH dI dJ dK dL dM dN dO d dP d	 dQ d dR dS dT dU dV dW dX d dY dZ d[ d\ d] d^ d_ d` da db dc dd de df dg dh di dj dk dl dm dn g do dp  } | j dq dr g  t ds dp  } | j dt  | j du  | j d1 dv dv  | j |  | j   dw dx dy g dw dy dz g dx d{ dy g d{ d| dy g d{ d} d~ g d{ d~ d| g dz dy d g dy d d g dy d| d g dy d d g d| d~ d g d~ d d g d d d d g d dp d d g dp d d d g d d dx dw g d d d{ dx g d d d} d{ g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d g d d d d d d d d g d d d d d d d d g d d d d d d d d g d d d d d d d d g d d d d d d d d g d d d d d d d d g g$ } x+ t d dz  D] } | j	 t
+ | |  qWx+ t dz d  D] } | j	 t | |  qWx+ t d d  D] } | j	 t | |  q(Wx+ t d d  D] } | j	 t | |  qVWt j t  } | j d  | j t  | j |  | j t t d dz   d d d d d d g d d g d g  | j t t dz d   d1 d1 d d1 d d d1 d g d d d d d d d d g d d d d g  | j t t d d   d d d d d d d d d d d d g d d d d d d g d d d g  | j t t d d   d1 d1 d d1 d d d1 d d d1 d d d d d1 d g d d d d d d d d d d d d d d d d d d g d d d d d d d d d g	  t |  S(   Ng      ?g        gFUUUUU?g?gH2k?gh}?gB^4?goS?gu?g~h?g       @g72k?gh}?gd}+?g\.?g;f?g;f?g;f?g;f?g    0<g    j<g泼g棼g       guggFUUUUUgH2kg72kgd}+gB^4gFUUUUUg(ges?g      g,O5egnF(Х?ggc2>gHpvݒ?gc1w*,gxb?geP,gi^?glvglv?g)fgh9;?g      g\.g;fgw~'g\
+X2D?g\ϗbgi<?gg<O-?g\ϗbgi<?giMPcgP55JK?g4Lg4L?g%	ga6N?gڡ
+gϠŽ?g?"fg?"f?g;fg@jM)g8`7?g NgA{F,"?g)fgh9;?gDʞg*ت?gh}g~hgoSgesg(?gi^geP,?gHpvݒܿgc2>?gh}ؿgxbgc1w*,?ga6Ng%	?gh9;g)f?g\
+X2DԿgw~'?gnF(Хпg,O5e?gi<ȿg\ϗb?g><gFUUUUU?gg      ?gSg?gh9;g)f?gi<ؿg\ϗb?iI   i   s   X [INCONNUE]s   Y [INCONNUE]t   MA1s   CREE PAR CODE_ASTERs   SANS UNITESii   i   i   i   i	   i   i
+   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i)   i3   i   i   i*   i   i   i+   i   i   i#   i&   i   i    i,   i4   i!   i2   i-   i5   i'   i"   i.   i   i/   i6   i$   i0   i(   i%   i1   i8   i7   i>   i:   iG   i9   i?   i;   i=   i@   i<   iA   iD   iH   iB   iE   iC   iF   t   CH1RBgUUUUUU?g      ?g3Eyg3Ey?gUUUUUU?gUUUUUU?gDr?~gDr?~?gE?gX<ݚ?gH?(   R
+   t   setInfoOnComponentsR   t   setDescriptiont   setTimeUnitRT   R   R   R   R   R   R   R8   R9   RO   R   t   ON_GAUSS_PTR-   t	   setNaturet   IntensiveMaximumRR   t   setGaussLocalizationOnCellst   listt   MEDCouplingFieldTemplate(   R   Rf   t   mR"   R   t   fff(    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildFieldOnGauss_1E  sB       
+    @adc        C   s  t  d d d d d d d d d d d	 d d
+ d d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ d0 d1 d2 d3 d d4 d5 d6 d d7 d8 d9 d d: d; d< d d= d> d? d@ dA dB dC dD dE dF dG dH dI dJ dK dL dM dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ d] d^ d_ d` da db dc dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz d{ d| d} d~ d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d ddddddddd	d
+dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKd dLd dMd dNd dOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndod dpdqdrdsdtdudvdwdxd/ dydq dzd+ d{do d|ds d}d~ddddddddddddddddddddddddddddddddddddddgdd } | j ddg  t dd } | j d | j d | j dodd | j |  | j d dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg dddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddg ddddddg ddddddg ddddddg ddddddg ddddddg ddddddg ddddddg ddddddg dddddd g dddddd g ddddddg ddddddg ddddd	d
+g dddddd
+g dddddd	g ddddddg ddddddg ddddddg ddddddg ddddddg ddddddg ddddddg ddddddg dddd d!dg ddd"dd#d$g d"d%dd&d'd$g ddd"dd(d#g dd)d"d*d+d(g ddd,dd-d.g d,d)dd/d*d.g ddd,d!d0d-g dd1d,d2d3d0g d%d"d4d&d5d6g d4d7d%d8d9d6g d"d)d4d+d:d5g d)d;d4d<d=d:g d)d,d>d/d?d@g d>d;d)dAd<d@g d,d1d>d3dBd?g d1dCd>dDdEdBg d7d4dFdGd8dHdIdJg d4d;dKdFd=dLdMdHg d;d>dNdKdAdOdPdLg d>dCdQdNdEdRdSdOg dGdFdTdUdIdVdWdXg dFdKdYdTdMdZd[dVg dKdNd\dYdPd]d^dZg dNdQd_d\dSd`dad]g dUdTdbdcdWdddedfg dTdYdgdbd[dhdiddg dYd\djdgd^dkdldhg d\d_dmdjdadndodkg dcdbdpdqdedrdsdtg dbdgdudpdidvdwdrg dgdjdxdudldydzdvg djdmd{dxdod|d}dyg dqdpdddsd~ddg dpdudddwddd~g dudxdddzdddg dxd{ddd}dddg gx } x+ t dd D] } | j	 t
+ | |  q#Wx+ t dd; D] } | j	 t | |  qQWx+ t d;dF D] } | j	 t | |  qWx+ t dFd[ D] } | j	 t | |  qWt j t  } | j d | j t  | j |  | j t t dd  d d d d d d g ddg dg  | j t t dd;  dodod dod d dod g ddddddddg d d d d g  | j t t d;dF  d d d d d d dd ddd dg ddddddg dddg  | j t t dFd[  dodod dod d dod d dod d d d dod g ddddddddd ddd d ddd d d g dddddddddg	  t |  S(  Ng      ?g        gg?g?g      ?g      ?g ?gwvyL?g      ?g       @g>%?gbOL2?gkg?gwZ?gۮ94?g;9f?g΂k+?g"tb?gx>%?gbOL2?g y?g'K?g_?g'`?gK7I?g݊+x9?g#?g?gy?gK?g?g8?gk8?gPc?g?g?gj3?g?glƟ%XJ?g?g@?g'mOA?g}P$t?gtb?g[6l?gDݑ{0?gY<݈?gr?gFlYe?g&mOA?g}P$t?g      ?g;C+?gj?g      ?gPJ?g'Pq?g      ?gғc?gX ~LY?g      ?g8c?gࢊA?gxiw?gk?g
+?gvr?g06??g.Oʞ~?g,I:?ggY(?gH#?gl??gNv?g0>c~S?gzoH?g#p?gX?gB?6J?g?g4|xN%?gv/LE?g?gt?gm3?gW#iل?g>?gZ>?gCmTa?gyO?gub+P?gS?g#%?gǯ0?gg]i?gu?g?gRag?g*ņU?g288$N}?gҋ?g
+l?gUد ?gv?go]v?g}aFL?ges?gTv	}?gpL+?g,H?g.N?gJY~6?gwI|Z?g%ި?g4nt?g6Y~6?goI|Z?gm4>s?g?gLc?gѢA?g`l~?gO4}?g3W?gNYY?gNݬ?gq M?g_XC?gM](?gOv?g>c~S?gG?gf	?gR?ghi?gpe?gU|F?g?glt?gW#iل?g>?gbLHxU?g2CLv?g;>?gp?gv"ҋ?gMQ
+?go 3?g:;tu?gRag?g*ņU?gr?gt??gb(56z?gv
+9?g=˧L?g$X.?g^#'?gDz2b?g?H?g.N?gs?g Ql?g>v?g<?gdЅ?gB?gߴ:F?geY?g.s?gڄ(5?gg?gݙ?gЕ?gE@le?g"iֲ?gv/=?g&o?gr?g#K*?g]?gml?g41E?gFa?g/Н7?g.ĳ?g2}e?gy?glX?gEfE,+?gk:+?g3?g▄i?gu@͹?gЎ?g&?g)q#?gF-?gTT?gO8o?g8&?gca>?gEc90?gwA}?g2x?gE^?g!?g?gy?gS|"^?g ?g\?g>Z?gzP?g6?gD+.?go,= ?g
+(?g;F?gs?gJXb?gBBehl?gΆ?g6:?gOM)?g2CdY?gHvOq?g8_R?ge?gÂ-ZK?gsM?gY_q=?g?5Kg+?gmQ?g_.<?g?gX?g$?g
+Wi+?g<!?gz^i?g?g$d#=?gB;?gA?g@?g_0?g߼VW?ghr	?gX?g&?ge'?g"*?gHK=?gYi?gɾ3?g▄i?gO8o?g$&?g?gy?gD+.?g,= ?g厢SM?gČ?gU.2X?gu?gc:?gV/n?g^rB ?gzУ?gR@O	?gA?g&b?gjcW5?gu?ghIG?gj3Cm?g8/?gXzY?g,.?gߝ_u8?ga[\
+?ghq?g?6?g?z?g$W&c?gC]1M?g;?gQ\?g|٭?g^l?g?g( ?g6=?g
+,Qw?ga?gBXW?gÇp#?gj?gIvwT?g𣮒|?gb
+?g0r~^X?g\?gF\s9?ggWj?gʡx?gte3'?gyzO?gt?g*-RB?goM?gm9N?gz=?g~MY?g)?gn?g8kAm?gR
+-0?gt?g"-RB?gUrB ?gzУ?gt3Cm?gJ/?g?z?g$W&c?g6=?g
+,Qw?gX
+?g(r~^X?g       g      g      g      gʶ8i}igWbvml?gM|g!^?g$gfRQ?g9ragT?gB˗y}g?gdg1\?g}1@g0,s*?gk.g j?g/cg
+wp׮m?gi3{go?g g(C$?glIgL?g.Mgr0:?gI:$gdĪOs?gCg_V$?gN 
+g؏=M?g      g¶8i}igWbvml?gU˗y}g?g/cgwp׮m?g8Mgs0:?gFlYeg4ntg[6lgwI|ZgoI|Zg!g;?gtWg9K?gg??gУDg_MZE?g!ڿg;?gu62ܿgN!
+.?g1ٿg&$HH?gTeտg?b?g@bѿgWT|?gu62̿gN!
+.?gXޱgax?gEqaEg$)?gA.ͪgCA?g>uUgbcw?gXޡgjx?gzSg?gp/$?gII?g?gJ}|	?gT#o[?gbhA?g?gzSg?g_/$?i   i   s   X [INCONNUE]s   Y [INCONNUE]t   MA2s   CREE PAR CODE_ASTERs   SANS UNITESii    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i>   iY   i   i   i?   i   i   i@   i	   i   i$   i   i   i   iA   iZ   i    i   i!   iB   i   i"   i'   i   iC   i[   i   i#   iD   iE   i   i%   i*   i
+   iF   i\   i&   iG   i   i(   i-   i   iH   i]   i   i)   iI   iJ   i   i+   i0   i   iK   i^   i,   iL   i   i.   i3   i   iM   i_   i   i/   iN   iO   i   i1   i6   i   iP   i`   i2   iQ   i   i4   i9   i   iR   ia   i;   i5   iS   iT   i<   i7   iU   i   iV   ib   i8   iW   i=   i:   iX   id   ic   i   is   i   ie   i   it   if   i   iu   i   i   iv   ih   ig   i   iw   i   ii   i   ix   ij   i   iy   i   i   iz   il   ik   i   i{   i   im   i   i|   in   i   i}   i   i   i~   ip   io   i   i   i   iq   i   i   ir   i   i   i   i   i   i   i   i   i   i   i   i   i   i   t   CH2RBgUUUUUU?g      ?g3Eyg3Ey?gUUUUUU?gUUUUUU?gDr?~gDr?~?gE?gX<ݚ?gH?(   R
+   Ry   R   Rz   R{   RT   R   R   R   R   R   R   R8   R9   RO   R   R|   R-   R}   R~   RR   R   R   R   (   R   Rf   R   R"   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildFieldOnGauss_2b  sV         9          ~  @adc      L   C   s  t  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gK d d  } | j d d	 d
+ g  t d d  } | j d  | j d  | j d d d  | j |  | j d  d d d d g d d d d d g d d d d d d g d d d d d d g d d d  d d d g d d d d! d" d# g d d$ d d d d% d d g d d& d! d d  d' d" d g g } | j t	 | d  | j t
+ | d  x+ t d$ d  D] } | j t | |  qHW| j t | d  | j t | d%  t j t  } | j d(  | j t  | j |  | j d g d d d d d d d d d d d d g d) d) d) g d* g  | j d g d d d d d d d d d d d d d d d g d d d+ d d d+ d, d d+ d d, d+ d d d- g d. d. d. d. d. g  | j d$ d d d g d d d d d d d d d d d d d d d d d d g d/ d d d/ d d d/ d d d0 d d d0 d d d0 d d g d* d* d* d* d* d* g  | j d d% g d d d d d d d d d d d d d d d d d d d d d d d d g d/ d/ d/ d/ d/ d0 d/ d0 d/ d/ d0 d0 d0 d/ d/ d0 d/ d0 d0 d0 d/ d0 d0 d0 g d d d d d d d d g  t |  S(1   Ng        g      ?g       @g      @g      ?i   i   s   X [INCONNUE]s   Y [INCONNUE]s   Z [INCONNUE]Rw   s   CREE PAR CODE_ASTERs   SANS UNITESg      ii    i
+   i   i   i   i   i   i   i   i   i   i   i	   i   i   i   i   i   i   i   i   i   i   i   t   CH13g      ?gUUUUUU?gF@?g      g#zd?g?g3Eyg3Ey?(   R
+   Ry   R   Rz   R{   RT   R   R   R   R   Rl   R   Rn   R   RO   R   R|   R-   R}   R~   RR   R   R   (   R   Rf   R   R"   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildFieldOnGauss_3  s2        Ic      L   C   s  t  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gK d d  } | j d	 d
+ d g  t d d  } | j d  | j d  | j d d d  | j |  | j d  d d d d g d d d d d g d d d d d d g d d d d d d g d d  d! d d d g d d d d" d# d$ g d d% d d d d& d d g d d' d" d d! d( d# d g g } | j t	 | d  | j t
+ | d  x+ t d% d  D] } | j t | |  qHW| j t | d  | j t | d&  t j t  } | j d)  | j t  | j |  | j d g d d d d d d d d d d d d g d* d* d* g d+ g  | j d g d d d d d d d d d d d d d d d g d d d, d d d, d- d d, d d- d, d d d. g d/ d/ d/ d/ d/ g  | j d% d d d g d d d d d d d d d d d d d d d d d d g d0 d d d0 d d d0 d d d1 d d d1 d d d1 d d g d+ d+ d+ d+ d+ d+ g  | j d d& g d d d d d d d d d d d d d d d d d d d d d d d d g d0 d0 d0 d0 d0 d1 d0 d1 d0 d0 d1 d1 d1 d0 d0 d1 d0 d1 d1 d1 d0 d1 d1 d1 g d d d d d d d d g  t |  S(2   Ng        g       @g      ?g      ?g      @g      @i   i   s   X [INCONNUE]s   Y [INCONNUE]s   Z [INCONNUE]R   s   CREE PAR CODE_ASTERs   SANS UNITESg      ii    i
+   i   i   i   i   i   i   i   i   i   i   i	   i   i   i   i   i   i   i   i   i   i   i   t   CH23g      ?gUUUUUU?gF@?g      g#zd?g?g3Eyg3Ey?(   R
+   Ry   R   Rz   R{   RT   R   R   R   R   Rl   R   Rn   R   RO   R   R|   R-   R}   R~   RR   R   R   (   R   Rf   R   R"   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildFieldOnGauss_4  s2        Ic      	   C   s1  d d l  m } d d l m } g  t d  D] } | | | | d  ^ q- } | d j | d j | d j | d j | d j | d j | d j | d j g } t t d	   }	 t j	 d
+ d  }
+ |
+ j
+ d  t j	 | t |  d d  } | | | f 7} |
+ j |  |
+ j t |	  |
+ j   |
+ S(   Ni(   t   rect(   t   pii   g      @i   i   i   i   t   circlei   (   t   cmathR   t   mathR   R   t   realt   imagR   R   R   R   R
+   t   lenR   R   t   NORM_QPOLYGR	   (   R   t   center_Xt   center_Yt   radiusR   R   R   t   cR!   t   connect   baseMesht
+   meshCoords(    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildCircle  s    0(.
+c         C   s%  d d l  m } d d l m } g  t d  D] } | | | | d  ^ q- } g  } x5 t d  D]' } | j | | j | | j g  qc Wd d d d	 d
+ d d d g }	 t j	 d d  }
+ |
+ j
+ d	  t j	 | t |  d d  } | | | f 7} |
+ j |  |
+ j t |	  |
+ j   |
+ S(   Ni(   R   (   R   i   g      @i   i   i   i   i   i   i   i    R   (   R   R   R   R   R   t   extendR   R   R   R   R   R
+   R   R   R   R   R	   (   R   R   R   R   R   R   R   R   R!   R   R   R   (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   buildCircle2  s    0%
+(!   t   __name__t
+   __module__R   R   R   R   R   R&   R)   R*   R+   R.   R/   R1   R4   R6   R;   R<   Rb   Rc   Rg   Ri   Rq   Re   Rt   Rv   R   R   R   R   R   R   t   classmethod(    (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyR      sz   						H											7	6													N(    (   t   MEDCouplingR   (    (    (    s}   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDCoupling_Swig/MEDCouplingDataForTest.pyt   <module>   s   
+
\ Pas de fin de ligne à la fin du fichier
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingExamplesTest.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingExamplesTest.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingExamplesTest.py	2018-04-19 17:04:36.734222663 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingExamplesTest.py	2018-04-19 17:25:17.260787928 +0200
@@ -2220,7 +2220,7 @@
         fieldOnCells.setName("MyTensorFieldOnCellNoTime")
         fieldOnCells.setMesh(mesh)
         array=DataArrayDouble()
-        array.alloc(fieldOnCells.getMesh().getNumberOfCells(),9) # Implicitely fieldOnCells will be a 9 components field.
+        array.alloc(fieldOnCells.getMesh().getNumberOfCells(),9) # Implicitly fieldOnCells will be a 9 components field.
         array.fillWithValue(7.)
         fieldOnCells.setArray(array)
         # fieldOnCells is now usable
@@ -2252,7 +2252,7 @@
         fieldOnNodes.setName("MyScalarFieldOnNodeNoTime")
         fieldOnNodes.setMesh(mesh)
         array=DataArrayDouble()
-        array.alloc(fieldOnNodes.getMesh().getNumberOfNodes(),1) # Implicitely fieldOnNodes will be a 1 component field.
+        array.alloc(fieldOnNodes.getMesh().getNumberOfNodes(),1) # Implicitly fieldOnNodes will be a 1 component field.
         array.fillWithValue(7.)
         fieldOnNodes.setArray(array)
         # fieldOnNodes is now usable
@@ -2272,7 +2272,7 @@
         fieldOnCells.setTime(4.22,2,-1) # Time attached is 4.22 ms, iteration id is 2 and order id (or sub iteration id) is -1
         fieldOnCells.setMesh(mesh)
         array=DataArrayDouble()
-        array.alloc(fieldOnCells.getMesh().getNumberOfCells(),2) # Implicitely fieldOnCells will be a 2 components field.
+        array.alloc(fieldOnCells.getMesh().getNumberOfCells(),2) # Implicitly fieldOnCells will be a 2 components field.
         array.fillWithValue(7.)
         fieldOnCells.setArray(array)
         # fieldOnCells is now usable
@@ -2293,7 +2293,7 @@
         fieldOnNodes.setEndTime(6.44,4,-1)# fieldOnNodes is defined in interval [4.22 ms,6.44 ms]
         fieldOnNodes.setMesh(mesh)
         array=DataArrayDouble()
-        array.alloc(fieldOnNodes.getMesh().getNumberOfNodes(),3) # Implicitely fieldOnNodes will be a 3 components field.
+        array.alloc(fieldOnNodes.getMesh().getNumberOfNodes(),3) # Implicitly fieldOnNodes will be a 3 components field.
         array.fillWithValue(7.)
         fieldOnNodes.setArray(array)
         # fieldOnNodes is now usable
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingFinalize.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingFinalize.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingFinalize.i	2018-04-19 17:04:36.735222683 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingFinalize.i	2018-04-19 17:25:17.278788284 +0200
@@ -19,7 +19,8 @@
 
 %pythoncode %{
 InterpKernelException.__reduce__=INTERPKERNELExceptionReduce
-DataArrayDouble.__new__=classmethod(MEDCouplingDataArrayDoublenew)
+
+DataArrayDouble.__reduce__=MEDCouplingDataArrayDoubleReduce
 DataArrayDouble.__iadd__=MEDCouplingDataArrayDoubleIadd
 DataArrayDouble.__isub__=MEDCouplingDataArrayDoubleIsub
 DataArrayDouble.__imul__=MEDCouplingDataArrayDoubleImul
@@ -32,7 +33,7 @@
 DataArrayDouble.__ifloordiv__=MEDCouplingDataArrayDoubleIdiv
 DataArrayDouble.__rfloordiv__=DataArrayDouble.__rdiv__
 
-DataArrayInt.__new__=classmethod(MEDCouplingDataArrayIntnew)
+DataArrayInt.__reduce__=MEDCouplingDataArrayIntReduce
 DataArrayInt.__iadd__=MEDCouplingDataArrayIntIadd
 DataArrayInt.__isub__=MEDCouplingDataArrayIntIsub
 DataArrayInt.__imul__=MEDCouplingDataArrayIntImul
@@ -46,9 +47,9 @@
 DataArrayInt.__ifloordiv__=MEDCouplingDataArrayIntIdiv
 DataArrayInt.__rfloordiv__=DataArrayInt.__rdiv__
 
-DataArrayByte.__new__=classmethod(MEDCouplingDataArrayBytenew)
-
-DataArrayFloat.__new__=classmethod(MEDCouplingDataArrayFloatnew)
+DataArrayByte.__reduce__=MEDCouplingDataArrayByteReduce
+  
+DataArrayFloat.__reduce__=MEDCouplingDataArrayFloatReduce
 DataArrayFloat.__iadd__=MEDCouplingDataArrayFloatIadd
 DataArrayFloat.__isub__=MEDCouplingDataArrayFloatIsub
 DataArrayFloat.__imul__=MEDCouplingDataArrayFloatImul
@@ -56,7 +57,7 @@
 DataArrayFloat.__itruediv__=MEDCouplingDataArrayFloatIdiv
 DataArrayFloat.__ifloordiv__=MEDCouplingDataArrayFloatIdiv
 
-MEDCouplingFieldDouble.__new__=classmethod(MEDCouplingFieldDoublenew)
+MEDCouplingFieldDouble.__reduce__=MEDCouplingFieldDoubleReduce
 MEDCouplingFieldDouble.__iadd__=MEDCouplingFieldDoubleIadd
 MEDCouplingFieldDouble.__isub__=MEDCouplingFieldDoubleIsub
 MEDCouplingFieldDouble.__imul__=MEDCouplingFieldDoubleImul
@@ -69,9 +70,9 @@
 MEDCouplingFieldDouble.__rfloordiv__=MEDCouplingFieldDouble.__rdiv__
 MEDCouplingFieldDouble.__ifloordiv__=MEDCouplingFieldDoubleIdiv
 
-MEDCouplingFieldInt.__new__=classmethod(MEDCouplingFieldIntnew)
+MEDCouplingFieldInt.__reduce__=MEDCouplingFieldIntReduce
   
-MEDCouplingFieldFloat.__new__=classmethod(MEDCouplingFieldFloatnew)
+MEDCouplingFieldFloat.__reduce__=MEDCouplingFieldFloatReduce
 
 DataArrayDoubleTuple.__iadd__=MEDCouplingDataArrayDoubleTupleIadd
 DataArrayDoubleTuple.__isub__=MEDCouplingDataArrayDoubleTupleIsub
@@ -88,16 +89,16 @@
 DataArrayIntTuple.__ifloordiv__=MEDCouplingDataArrayIntTupleIdiv
 DataArrayIntTuple.__imod__=MEDCouplingDataArrayIntTupleImod
 
-DenseMatrix.__iadd__=ParaMEDMEMDenseMatrixIadd
-DenseMatrix.__isub__=ParaMEDMEMDenseMatrixIsub
+DenseMatrix.__iadd__=MEDCouplingDenseMatrixIadd
+DenseMatrix.__isub__=MEDCouplingDenseMatrixIsub
 
-MEDCouplingUMesh.__new__=classmethod(MEDCouplingUMeshnew)
-MEDCoupling1DGTUMesh.__new__=classmethod(MEDCoupling1DGTUMeshnew)
-MEDCoupling1SGTUMesh.__new__=classmethod(MEDCoupling1SGTUMeshnew)
-MEDCouplingCurveLinearMesh.__new__=classmethod(MEDCouplingCurveLinearMeshnew)
-MEDCouplingCMesh.__new__=classmethod(MEDCouplingCMeshnew)
-MEDCouplingIMesh.__new__=classmethod(MEDCouplingIMeshnew)
-MEDCouplingMappedExtrudedMesh.__new__=classmethod(MEDCouplingExtrudedMeshnew)
+MEDCouplingUMesh.__reduce__=MEDCouplingUMeshReduce
+MEDCoupling1DGTUMesh.__reduce__=MEDCoupling1DGTUMeshReduce
+MEDCoupling1SGTUMesh.__reduce__=MEDCoupling1SGTUMeshReduce
+MEDCouplingCurveLinearMesh.__reduce__=MEDCouplingCurveLinearMeshReduce
+MEDCouplingCMesh.__reduce__=MEDCouplingCMeshReduce
+MEDCouplingIMesh.__reduce__=MEDCouplingIMeshReduce
+MEDCouplingMappedExtrudedMesh.__reduce__=MEDCouplingMappedExtrudedMeshReduce
 
 DataArrayAsciiCharIterator.__next__ = DataArrayAsciiCharIterator.next
 DataArrayIntIterator.__next__ = DataArrayIntIterator.next
@@ -106,7 +107,20 @@
 MEDCouplingUMeshCellByTypeIterator.__next__ = MEDCouplingUMeshCellByTypeIterator.next
 
 del INTERPKERNELExceptionReduce
-del MEDCouplingDataArrayDoublenew
+del MEDCouplingDataArrayDoubleReduce
+del MEDCouplingDataArrayFloatReduce
+del MEDCouplingDataArrayIntReduce
+del MEDCouplingDataArrayByteReduce
+del MEDCouplingUMeshReduce
+del MEDCouplingCMeshReduce
+del MEDCouplingIMeshReduce
+del MEDCouplingMappedExtrudedMeshReduce
+del MEDCouplingCurveLinearMeshReduce
+del MEDCoupling1SGTUMeshReduce
+del MEDCoupling1DGTUMeshReduce
+del MEDCouplingFieldDoubleReduce
+del MEDCouplingFieldFloatReduce
+del MEDCouplingFieldIntReduce
 del MEDCouplingDataArrayDoubleIadd
 del MEDCouplingDataArrayDoubleIsub
 del MEDCouplingDataArrayDoubleImul
@@ -116,14 +130,11 @@
 del MEDCouplingFieldDoubleImul
 del MEDCouplingFieldDoubleIdiv
 del MEDCouplingFieldDoubleIpow
-del MEDCouplingDataArrayIntnew
 del MEDCouplingDataArrayIntIadd
 del MEDCouplingDataArrayIntIsub
 del MEDCouplingDataArrayIntImul
 del MEDCouplingDataArrayIntIdiv
 del MEDCouplingDataArrayIntImod
-del MEDCouplingDataArrayBytenew
-del MEDCouplingDataArrayFloatnew
 del MEDCouplingDataArrayFloatIadd
 del MEDCouplingDataArrayFloatIsub
 del MEDCouplingDataArrayFloatImul
@@ -137,14 +148,6 @@
 del MEDCouplingDataArrayIntTupleImul
 del MEDCouplingDataArrayIntTupleIdiv
 del MEDCouplingDataArrayIntTupleImod
-del ParaMEDMEMDenseMatrixIadd
-del ParaMEDMEMDenseMatrixIsub
-del MEDCouplingUMeshnew
-del MEDCoupling1DGTUMeshnew
-del MEDCoupling1SGTUMeshnew
-del MEDCouplingCurveLinearMeshnew
-del MEDCouplingCMeshnew
-del MEDCouplingIMeshnew
-del MEDCouplingExtrudedMeshnew
-del MEDCouplingFieldDoublenew
+del MEDCouplingDenseMatrixIadd
+del MEDCouplingDenseMatrixIsub
 %}
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCoupling.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCoupling.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCoupling.i	2018-04-19 17:04:36.728222543 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCoupling.i	2018-04-19 17:25:17.280788323 +0200
@@ -17,12 +17,11 @@
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
 
+%module MEDCoupling
+
 %include "MEDCouplingCommon.i"
 
 %pythoncode %{
-def MEDCouplingDataArrayDoublenew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.DataArrayDouble____new___(cls,args)
 def MEDCouplingDataArrayDoubleIadd(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DataArrayDouble____iadd___(self, self, *args)
@@ -38,9 +37,6 @@
 def MEDCouplingDataArrayDoubleIpow(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DataArrayDouble____ipow___(self, self, *args)
-def MEDCouplingFieldDoublenew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingFieldDouble____new___(cls,args)
 def MEDCouplingFieldDoubleIadd(self,*args):
     import _MEDCoupling
     return _MEDCoupling.MEDCouplingFieldDouble____iadd___(self, self, *args)
@@ -56,15 +52,6 @@
 def MEDCouplingFieldDoubleIpow(self,*args):
     import _MEDCoupling
     return _MEDCoupling.MEDCouplingFieldDouble____ipow___(self, self, *args)
-def MEDCouplingFieldIntnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingFieldInt____new___(cls,args)
-def MEDCouplingFieldFloatnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingFieldFloat____new___(cls,args)
-def MEDCouplingDataArrayIntnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.DataArrayInt____new___(cls,args)
 def MEDCouplingDataArrayIntIadd(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DataArrayInt____iadd___(self, self, *args)
@@ -83,12 +70,6 @@
 def MEDCouplingDataArrayIntIpow(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DataArrayInt____ipow___(self, self, *args)
-def MEDCouplingDataArrayBytenew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.DataArrayByte____new___(cls,args)
-def MEDCouplingDataArrayFloatnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.DataArrayFloat____new___(cls,args)
 def MEDCouplingDataArrayFloatIadd(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DataArrayFloat____iadd___(self, self, *args)
@@ -128,33 +109,12 @@
 def MEDCouplingDataArrayIntTupleImod(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DataArrayIntTuple____imod___(self, self, *args)
-def ParaMEDMEMDenseMatrixIadd(self,*args):
+def MEDCouplingDenseMatrixIadd(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DenseMatrix____iadd___(self, self, *args)
-def ParaMEDMEMDenseMatrixIsub(self,*args):
+def MEDCouplingDenseMatrixIsub(self,*args):
     import _MEDCoupling
     return _MEDCoupling.DenseMatrix____isub___(self, self, *args)
-def MEDCouplingUMeshnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingUMesh____new___(cls,args)
-def MEDCoupling1DGTUMeshnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCoupling1DGTUMesh____new___(cls,args)
-def MEDCoupling1SGTUMeshnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCoupling1SGTUMesh____new___(cls,args)
-def MEDCouplingCurveLinearMeshnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingCurveLinearMesh____new___(cls,args)
-def MEDCouplingCMeshnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingCMesh____new___(cls,args)
-def MEDCouplingIMeshnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingIMesh____new___(cls,args)
-def MEDCouplingExtrudedMeshnew(cls,*args):
-    import _MEDCoupling
-    return _MEDCoupling.MEDCouplingMappedExtrudedMesh____new___(cls,args)
 %}
 
 %include "MEDCouplingFinalize.i"
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingIntersectTest.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingIntersectTest.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingIntersectTest.py	2018-04-19 17:04:36.735222683 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingIntersectTest.py	2018-04-19 17:25:17.284788402 +0200
@@ -312,6 +312,56 @@
         self.assertTrue(f.getArray().isEqual(valuesExpected,1e-12))
         pass
 
+    def testIntersect2DMeshes7(self):
+        """ Quadratic precision values were improperly reset before testing colinearities """
+        eps = 1.0e-08
+        mesh1 = MEDCouplingUMesh('assemblyGrid_Pij', 2)
+        coo = DataArrayDouble([(10.80630000000000,10.80630000000000),(9.48750000000000,10.80630000000000),(10.75250000000000,10.80630000000000),(9.48750000000000,9.48750000000000),(10.75250000000000,9.48750000000000),(10.80630000000000,9.48750000000000),(9.48750000000000,10.75250000000000),(10.75250000000000,10.75250000000000),(10.80630000000000,10.75250000000000)])
+        mesh1.setCoords(coo)
+        c = DataArrayInt([5, 4, 3, 6, 7, 5, 5, 4, 7, 8, 5, 1, 2, 7, 6, 5, 2, 0, 8, 7])
+        cI = DataArrayInt([0, 5, 10, 15, 20])
+        mesh1.setConnectivity(c, cI)
+        mesh2 = MEDCouplingUMesh('merge', 2)
+        coo = DataArrayDouble([(9.48750000000001,9.48750000000001),(10.75249999999975,9.48749999999955),(10.12000000000001,9.48750000000001),(10.80629999999976,9.48749999999955),(8.22250000000029,10.75250000000028),(9.48749999999961,10.75249999999971),(8.85500000000029,10.75250000000028),(9.48750000000001,10.12000000000001),(10.75249999999338,10.75249999999338),(10.41000000000001,10.12000000000001),(10.32506096654411,10.32506096654411),(10.12000000000001,10.41000000000001),(9.91493903345591,10.32506096654411),(9.83000000000001,10.12000000000001),(9.91493903345591,9.91493903345591),(10.12000000000001,9.83000000000001),(10.32506096654411,9.91493903345591),(10.11999999999961,10.75249999999971),(10.75249999999975,10.11999999999958),(10.49000000000001,10.12000000000001),(10.38162950903903,10.38162950903903),(10.12000000000001,10.49000000000001),(9.85837049096099,10.38162950903903),(9.75000000000001,10.12000000000001),(9.85837049096099,9.85837049096099),(10.12000000000001,9.75000000000001),(10.38162950903903,9.85837049096099),(9.88665476220845,10.35334523779157),(9.88665476220845,9.88665476220845),(9.67293524548050,9.67293524548050),(9.67293524548050,10.56706475451952),(10.80629999999339,10.75249999999338),(8.22250000000029,10.80630000000028),(9.48749999999961,10.80629999999971),(10.75249999999338,10.80629999999339),(10.80629999999339,10.80629999999339),(10.77939999999976,9.48749999999955),(10.77939999999339,10.75249999999338),(10.80629999999976,10.11999999999958),(8.22250000000029,10.77940000000028),(8.85500000000029,10.80630000000028),(9.48749999999961,10.77939999999971),(10.11999999999961,10.80629999999971),(10.75249999999338,10.77939999999339),(10.77939999999339,10.80629999999339),(10.80629999999339,10.77939999999339)])
+        mesh2.setCoords(coo)
+        c = DataArrayInt([32, 4, 32, 33, 5, 39, 40, 41, 6, 32, 5, 33, 34, 8, 41, 42, 43, 17, 32, 8, 34, 35, 31, 43, 44, 45, 37, 32, 14, 12, 10, 16, 13, 11, 9, 15, 32, 22, 12, 14, 24, 27, 13, 28, 23, 32, 24, 0, 5, 22, 29, 7, 30, 23, 32, 24, 14, 16, 10, 12, 22, 20, 26, 28, 15, 9, 11, 27, 21, 19, 25, 32, 22, 5, 8, 1, 0, 24, 26, 20, 30, 17, 18, 2, 29, 25, 19, 21, 32, 1, 8, 31, 3, 18, 37, 38, 36])
+        cI = DataArrayInt([0, 9, 18, 27, 36, 45, 54, 71, 88, 97])
+        mesh2.setConnectivity(c, cI)
+        result, mapResToInit, mapResToRef = MEDCouplingUMesh.Intersect2DMeshes(mesh1, mesh2, eps)
+        result.zipCoords()
+        exp_coo = [9.48750000000001, 9.48750000000001, 10.75249999999975, 9.48749999999955, 10.80629999999976, 9.48749999999955, 9.48749999999961, 10.75249999999971, 10.75249999999338, 10.75249999999338, 10.32506096654411, 10.32506096654411, 9.91493903345591, 10.32506096654411, 9.91493903345591, 9.91493903345591, 10.32506096654411, 9.91493903345591, 10.38162950903903, 10.38162950903903, 9.85837049096099, 10.38162950903903, 9.85837049096099, 9.85837049096099, 10.38162950903903, 9.85837049096099, 10.80629999999339, 10.75249999999338, 9.48749999999961, 10.80629999999971, 10.75249999999338, 10.80629999999339, 10.80629999999339, 10.80629999999339, 9.830000000000023, 10.120000000000008, 10.120000000000008, 10.410000000000004, 10.41000000000001, 10.120000000000008, 10.120000000000008, 9.830000000000013, 9.886654762208451, 10.353345237791569, 9.830000000000023, 10.120000000000008, 9.886654762208451, 9.886654762208451, 9.750000000000005, 10.12000000000001, 9.487499999999809, 10.11999999999986, 9.6729352454803, 10.56706475451937, 9.750000000000005, 10.12000000000001, 9.672935245480499, 9.672935245480499, 9.886654762208451, 9.886654762208451, 10.120000000000008, 9.830000000000013, 10.41000000000001, 10.120000000000008, 10.120000000000008, 10.410000000000004, 9.886654762208451, 10.353345237791569, 10.120000000000013, 10.490000000000004, 10.489999999999988, 10.120000000000013, 10.120000000000017, 9.750000000000021, 10.119999999996494, 10.752499999996544, 10.752499999996566, 10.119999999996466, 10.11999999999988, 9.48749999999978, 9.672935245480499, 9.672935245480499, 10.120000000000017, 9.750000000000021, 10.489999999999988, 10.120000000000013, 10.120000000000013, 10.490000000000004, 9.6729352454803, 10.56706475451937]
+        e1 = [0, 0, 0, 0, 0, 1, 2, 3]
+        e2 = [3, 4, 5, 6, 7, 8, 1, 2]
+        valuesExpected=DataArrayDouble(exp_coo, len(exp_coo)//2, 2)
+        self.assertTrue(result.getCoords().isEqual(valuesExpected,1e-12))
+        self.assertEqual(e1, mapResToInit.getValues())
+        self.assertEqual(e2, mapResToRef.getValues())
+
+    def testIntersect2DMeshes8(self):
+        """ Quadratic precision values were improperly reset before testing colinearities 
+        This was also impacting the mapping computation. """
+        eps = 1.0e-8
+        mesh1 = MEDCouplingUMesh('assemblyGrid_Pij', 2)
+        coo = DataArrayDouble([(10.80630000000000,-10.80630000000000),(9.48750000000000,-10.80630000000000),(10.75250000000000,-10.80630000000000),(9.48750000000000,-10.75250000000000),(10.75250000000000,-10.75250000000000),(10.80630000000000,-10.75250000000000),(9.48750000000000,-9.48750000000000),(10.75250000000000,-9.48750000000000),(10.80630000000000,-9.48750000000000)])
+        mesh1.setCoords(coo)
+        c = DataArrayInt([5, 2, 1, 3, 4, 5, 0, 2, 4, 5, 5, 4, 3, 6, 7, 5, 5, 4, 7, 8])
+        cI = DataArrayInt([0, 5, 10, 15, 20])
+        mesh1.setConnectivity(c, cI)
+        mesh2 = MEDCouplingUMesh('merge', 2)
+        coo = DataArrayDouble([(9.48749999999998,-10.75249999999999),(9.48750000000018,-10.80629999999998),(10.75250000000047,-10.75250000000063),(10.75249999999318,-10.80629999999318),(10.80630000000048,-10.75250000000063),(10.80629999999318,-10.80629999999318),(9.48750000000001,-9.48750000000001),(9.48749999999998,-10.11999999999999),(10.75249999999975,-9.48750000000004),(10.40999999999999,-10.11999999999999),(10.32506096654408,-9.91493903345589),(10.11999999999999,-9.82999999999999),(9.91493903345589,-9.91493903345589),(9.82999999999998,-10.11999999999999),(9.91493903345589,-10.32506096654409),(10.11999999999999,-10.40999999999999),(10.32506096654408,-10.32506096654409),(10.12000000000001,-9.48750000000001),(10.75250000000047,-10.12000000000058),(10.12000000000018,-10.75249999999998),(9.70121951672794,-10.53878048327204),(9.70121951672794,-9.70121951672794),(10.80629999999976,-9.48750000000004),(9.48750000000018,-10.77939999999998),(10.75249999999318,-10.77939999999318),(10.12000000000018,-10.80629999999998),(10.77940000000048,-10.75250000000063),(10.80629999999318,-10.77939999999318),(10.77939999999318,-10.80629999999318),(10.77939999999976,-9.48750000000004),(10.80630000000048,-10.12000000000058)])
+        mesh2.setCoords(coo)
+        c = DataArrayInt([32, 1, 0, 2, 3, 23, 19, 24, 25, 32, 3, 2, 4, 5, 24, 26, 27, 28, 32, 16, 14, 12, 10, 15, 13, 11, 9, 32, 0, 6, 12, 14, 7, 21, 13, 20, 32, 6, 8, 2, 0, 14, 16, 10, 12, 17, 18, 19, 20, 15, 9, 11, 21, 32, 2, 8, 22, 4, 18, 29, 30, 26])
+        cI = DataArrayInt([0, 9, 18, 27, 36, 53, 62])
+        mesh2.setConnectivity(c, cI)
+        result, mapResToInit, mapResToRef = MEDCouplingUMesh.Intersect2DMeshes(mesh1, mesh2, eps)
+        result.zipCoords()
+        exp_coo = [9.48749999999998, -10.75249999999999, 9.48750000000018, -10.80629999999998, 10.75250000000047, -10.75250000000063, 10.75249999999318, -10.80629999999318, 10.80630000000048, -10.75250000000063, 10.80629999999318, -10.80629999999318, 9.48750000000001, -9.48750000000001, 10.75249999999975, -9.48750000000004, 10.32506096654408, -9.91493903345589, 9.91493903345589, -9.91493903345589, 9.91493903345589, -10.32506096654409, 10.32506096654408, -10.32506096654409, 10.80629999999976, -9.48750000000004, 10.119999999999989, -10.409999999999961, 9.829999999999997, -10.11999999999999, 10.119999999999983, -9.830000000000005, 10.409999999999968, -10.119999999999987, 9.487499999999994, -10.120000000000001, 9.70121951672795, -9.70121951672795, 9.829999999999997, -10.11999999999999, 9.701219516727935, -10.53878048327204, 10.11999999999988, -9.487500000000026, 10.752500000000111, -10.120000000000335, 10.120000000000225, -10.75250000000031, 9.701219516727935, -10.53878048327204, 10.119999999999989, -10.409999999999961, 10.409999999999968, -10.119999999999987, 10.119999999999983, -9.830000000000005, 9.70121951672795, -9.70121951672795]
+        e1 = [0, 1, 2, 2, 2, 3]
+        e2 = [0, 1, 2, 3, 4, 5]
+        valuesExpected=DataArrayDouble(exp_coo, len(exp_coo)//2, 2)
+        self.assertTrue(result.getCoords().isEqual(valuesExpected,1e-10))
+        self.assertEqual(e1, mapResToInit.getValues())
+        self.assertEqual(e2, mapResToRef.getValues())
 
     def testSwig2Intersect2DMeshesQuadra1(self):
         import cmath
@@ -377,7 +427,7 @@
         m1.finishInsertingCells()
 
         m2 = MEDCouplingDataForTest.buildCircle(0.25, 0.2, 0.4)
-        # Was looping indefinitly:
+        # Was looping indefinitely:
         m_intersec, resToM1, resToM2 = MEDCouplingUMesh.Intersect2DMeshes(m1, m2, eps)
         m_intersec.zipCoords()
         coo_tgt = DataArrayDouble([-0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.03284271247461901, 0.4828427124746191,
@@ -388,7 +438,7 @@
         connI_tgt = [0, 9, 22]
         res1_tgt  = [0, 0]
         res2_tgt = [0, -1]
-        self.assert_(coo_tgt.isEqualWithoutConsideringStr(m_intersec.getCoords(), 1e-12))
+        self.assertTrue(coo_tgt.isEqualWithoutConsideringStr(m_intersec.getCoords(), 1e-12))
         self.assertEqual(conn_tgt, m_intersec.getNodalConnectivity().getValues())
         self.assertEqual(connI_tgt, m_intersec.getNodalConnectivityIndex().getValues())
         self.assertEqual(res1_tgt, resToM1.getValues())
@@ -819,6 +869,29 @@
         self.assertTrue(d.isEqual(DataArrayInt([(-1,-1),(1,2),(3,0),(3,4),(-1,-1)])))
         pass
 
+    def testSwig2Intersect2DMeshWith1DLine17(self):
+        """ Single colinear intersection - a deltaShiftIndex() was improperly tested. """
+        eps = 1.0e-12
+        mesh = MEDCouplingUMesh('dummy_layer', 2)
+        coo = DataArrayDouble([(-0.5,-0.5),(-0.5,0.5),(0.5,0.5),(0.5,-0.5),(-0.25,-0.25),(-0.25,0.25),(0.25,0.25),(0.25,-0.25)])
+        mesh.setCoords(coo)
+        c = DataArrayInt([5, 4, 5, 6, 7, 5, 0, 1, 5, 4, 5, 1, 2, 3, 0, 4, 7, 6, 5])
+        cI = DataArrayInt([0, 5, 10, 19])
+        mesh.setConnectivity(c, cI)
+        m_line = MEDCouplingUMesh('segment', 1)
+        coo = DataArrayDouble([(-0.5,0.5),(-0.25,0.25)])
+        m_line.setCoords(coo)
+        c = DataArrayInt([1, 0, 1])
+        cI = DataArrayInt([0, 3])
+        m_line.setConnectivity(c, cI)
+        a, b, c, d = MEDCouplingUMesh.Intersect2DMeshWith1DLine(mesh, m_line, eps)
+        self.assertEqual(mesh.getNodalConnectivity().getValues(),a.getNodalConnectivity().getValues())
+        self.assertEqual(mesh.getNodalConnectivityIndex().getValues(),a.getNodalConnectivityIndex().getValues())
+        self.assertEqual([1,1,5],b.getNodalConnectivity().getValues())
+        self.assertEqual(m_line.getNodalConnectivityIndex().getValues(),b.getNodalConnectivityIndex().getValues())
+        self.assertTrue([0,1,2], c.getValues())
+        self.assertEqual([2,1], d.getValues())
+
     def testSwig2Conformize2D1(self):
         eps = 1.0e-8
         coo = [0.,-0.5,0.,0.,0.5,0.,0.5,-0.5,0.25,
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingMemArray.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingMemArray.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingMemArray.i	2018-04-19 17:04:36.736222703 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingMemArray.i	2018-04-19 17:25:17.290788521 +0200
@@ -73,6 +73,7 @@
 %newobject MEDCoupling::DataArrayFloat::iterator;
 %newobject MEDCoupling::DataArrayFloat::__iter__;
 %newobject MEDCoupling::DataArrayFloat::Meld;
+%newobject MEDCoupling::DataArrayFloat::__rmul__;
 %newobject MEDCoupling::DataArrayInt::New;
 %newobject MEDCoupling::DataArrayInt::__iter__;
 %newobject MEDCoupling::DataArrayInt::performCopyOrIncrRef;
@@ -92,6 +93,7 @@
 %newobject MEDCoupling::DataArrayInt::findIdsEqualList;
 %newobject MEDCoupling::DataArrayInt::findIdsNotEqualList;
 %newobject MEDCoupling::DataArrayInt::findIdsEqualTuple;
+%newobject MEDCoupling::DataArrayInt::findIdForEach;
 %newobject MEDCoupling::DataArrayInt::sumPerTuple;
 %newobject MEDCoupling::DataArrayInt::negate;
 %newobject MEDCoupling::DataArrayInt::computeAbs;
@@ -745,6 +747,18 @@
         int nbOfComp(self->getNumberOfComponents()),nbOfTuples(self->getNumberOfTuples());
         return convertDblArrToPyListOfTuple<float>(vals,nbOfComp,nbOfTuples);
       }
+
+      PyObject *isEqualIfNotWhy(const DataArrayFloat& other, float prec) const throw(INTERP_KERNEL::Exception)
+      {
+        std::string ret1;
+        bool ret0=self->isEqualIfNotWhy(other,prec,ret1);
+        PyObject *ret=PyTuple_New(2);
+        PyObject *ret0Py=ret0?Py_True:Py_False;
+        Py_XINCREF(ret0Py);
+        PyTuple_SetItem(ret,0,ret0Py);
+        PyTuple_SetItem(ret,1,PyString_FromString(ret1.c_str()));
+        return ret;
+      }
       
       PyObject *__getitem__(PyObject *obj) throw(INTERP_KERNEL::Exception)
       {
@@ -771,6 +785,11 @@
         return DataArrayT_imul<float>(trueSelf,obj,self);
       }
 
+      DataArrayFloat *__rmul__(PyObject *obj) throw(INTERP_KERNEL::Exception)
+      {
+        return DataArrayFPT_rmul<float>(self,obj);
+      }
+
       PyObject *___idiv___(PyObject *trueSelf, PyObject *obj) throw(INTERP_KERNEL::Exception)
       {
         return DataArrayT_idiv<float>(trueSelf,obj,self);
@@ -782,31 +801,6 @@
         return ToNumPyArray<DataArrayFloat,float>(self,NPY_FLOAT,"DataArrayFloat");
       }
 #endif
-
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"DataArrayFloat");
-      }
-      
-      PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-      {
-#ifdef WITH_NUMPY
-        if(!self->isAllocated())
-          throw INTERP_KERNEL::Exception("PyWrap of DataArrayFloat.__getnewargs__ : self is not allocated !");
-        PyObject *ret(PyTuple_New(1));
-        PyObject *ret0(PyDict_New());
-        PyObject *numpyArryObj(MEDCoupling_DataArrayFloat_toNumPyArray(self));
-        {// create a dict to discriminite in __new__ if __init__ should be called. Not beautiful but not idea ...
-          PyObject *tmp1(PyInt_FromLong(0));
-          PyDict_SetItem(ret0,tmp1,numpyArryObj); Py_DECREF(tmp1); Py_DECREF(numpyArryObj);
-          PyTuple_SetItem(ret,0,ret0);
-        }
-        return ret;
-#else
-        throw INTERP_KERNEL::Exception("PyWrap of DataArrayByte.__getnewargs__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !");
-#endif
-      }
     }
   };
 
@@ -923,9 +917,8 @@
     void checkNoNullValues() const throw(INTERP_KERNEL::Exception);
     DataArrayDouble *computeBBoxPerTuple(double epsilon=0.0) const throw(INTERP_KERNEL::Exception);
     void recenterForMaxPrecision(double eps) throw(INTERP_KERNEL::Exception);
-    double getMaxValue(int& tupleId) const throw(INTERP_KERNEL::Exception);
     double getMaxValueInArray() const throw(INTERP_KERNEL::Exception);
-    double getMinValue(int& tupleId) const throw(INTERP_KERNEL::Exception);
+    double getMaxAbsValueInArray() const throw(INTERP_KERNEL::Exception);
     double getMinValueInArray() const throw(INTERP_KERNEL::Exception);
     int count(double value, double eps) const throw(INTERP_KERNEL::Exception);
     double getAverageValue() const throw(INTERP_KERNEL::Exception);
@@ -1052,6 +1045,22 @@
           }
       }
 
+      PyObject *asArcOfCircle() const throw(INTERP_KERNEL::Exception)
+      {
+        double center[2],radius,ang;
+        self->asArcOfCircle(center,radius,ang);
+        PyObject *ret(PyTuple_New(3));
+        {
+          PyObject *ret0(PyList_New(2));
+          PyList_SetItem(ret0,0,PyFloat_FromDouble(center[0]));
+          PyList_SetItem(ret0,1,PyFloat_FromDouble(center[1]));
+          PyTuple_SetItem(ret,0,ret0);
+        }
+        PyTuple_SetItem(ret,1,PyFloat_FromDouble(radius));
+        PyTuple_SetItem(ret,2,PyFloat_FromDouble(ang));        
+        return ret;
+      }
+
       DataArrayDoubleIterator *__iter__() throw(INTERP_KERNEL::Exception)
       {
         return self->iterator();
@@ -1284,6 +1293,16 @@
         return ret;
       }
 
+	  PyObject *getMaxAbsValue() const throw(INTERP_KERNEL::Exception)
+      {
+        std::size_t tmp;
+        double r1=self->getMaxAbsValue(tmp);
+        PyObject *ret=PyTuple_New(2);
+        PyTuple_SetItem(ret,0,PyFloat_FromDouble(r1));
+        PyTuple_SetItem(ret,1,PyInt_FromLong(tmp));
+        return ret;
+      }
+
       PyObject *getMaxValue2() const throw(INTERP_KERNEL::Exception)
       {
         DataArrayInt *tmp;
@@ -1689,34 +1708,7 @@
 
       DataArrayDouble *__rmul__(PyObject *obj) throw(INTERP_KERNEL::Exception)
       {
-        const char msg[]="Unexpected situation in __rmul__ !";
-        double val;
-        DataArrayDouble *a;
-        DataArrayDoubleTuple *aa;
-        std::vector<double> bb;
-        int sw;
-        convertDoubleStarLikePyObjToCpp_2(obj,sw,val,a,aa,bb);
-        switch(sw)
-          {
-          case 1:
-            {
-              MCAuto<DataArrayDouble> ret=self->deepCopy();
-              ret->applyLin(val,0.);
-              return ret.retn();
-            }
-          case 3:
-            {
-              MCAuto<DataArrayDouble> aaa=aa->buildDADouble(1,self->getNumberOfComponents());
-              return DataArrayDouble::Multiply(self,aaa);
-            }
-          case 4:
-            {
-              MCAuto<DataArrayDouble> aaa=DataArrayDouble::New(); aaa->useArray(&bb[0],false,CPP_DEALLOC,1,(int)bb.size());
-              return DataArrayDouble::Multiply(self,aaa);
-            }
-          default:
-            throw INTERP_KERNEL::Exception(msg);
-          }
+        return DataArrayFPT_rmul<double>(self,obj);
       }
 
       PyObject *___imul___(PyObject *trueSelf, PyObject *obj) throw(INTERP_KERNEL::Exception)
@@ -1947,31 +1939,6 @@
         PyTuple_SetItem(ret,1,SWIG_NewPointerObj(SWIG_as_voidptr(ret1),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
         return ret;
       }
-
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"DataArrayDouble");
-      }
-
-      PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-      {
-#ifdef WITH_NUMPY
-        if(!self->isAllocated())
-          throw INTERP_KERNEL::Exception("PyWrap of DataArrayDouble.__getnewargs__ : self is not allocated !");
-        PyObject *ret(PyTuple_New(1));
-        PyObject *ret0(PyDict_New());
-        PyObject *numpyArryObj(MEDCoupling_DataArrayDouble_toNumPyArray(self));
-        {// create a dict to discriminite in __new__ if __init__ should be called. Not beautiful but not idea ...
-          PyObject *tmp1(PyInt_FromLong(0));
-          PyDict_SetItem(ret0,tmp1,numpyArryObj); Py_DECREF(tmp1); Py_DECREF(numpyArryObj);
-          PyTuple_SetItem(ret,0,ret0);
-        }
-        return ret;
-#else
-        throw INTERP_KERNEL::Exception("PyWrap of DataArrayDouble.__getnewargs__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !");
-#endif
-      }
     }
   };
 
@@ -2356,9 +2323,8 @@
     bool presenceOfValue(const std::vector<int>& vals) const throw(INTERP_KERNEL::Exception);
     int count(int value) const throw(INTERP_KERNEL::Exception);
     int accumulate(int compId) const throw(INTERP_KERNEL::Exception);
-    int getMaxValue(int& tupleId) const throw(INTERP_KERNEL::Exception);
     int getMaxValueInArray() const throw(INTERP_KERNEL::Exception);
-    int getMinValue(int& tupleId) const throw(INTERP_KERNEL::Exception);
+    int getMaxAbsValueInArray() const throw(INTERP_KERNEL::Exception);
     int getMinValueInArray() const throw(INTERP_KERNEL::Exception);
     void abs() throw(INTERP_KERNEL::Exception);
     DataArrayInt *computeAbs() const throw(INTERP_KERNEL::Exception);
@@ -2577,6 +2543,15 @@
         return self->findIdsEqualTuple(bg,bg+sz);
       }
 
+      DataArrayInt *findIdForEach(PyObject *vals) const throw(INTERP_KERNEL::Exception)
+      {
+        int sw,sz,val;
+        std::vector<int> val2;
+        const int *bg(convertIntStarLikePyObjToCppIntStar(vals,sw,sz,val,val2));
+        MCAuto<DataArrayInt> ret(self->findIdForEach(bg,bg+sz));
+        return ret.retn();
+      }
+
       PyObject *splitInBalancedSlices(int nbOfSlices) const throw(INTERP_KERNEL::Exception)
       {
         std::vector< std::pair<int,int> > slcs(self->splitInBalancedSlices(nbOfSlices));
@@ -3005,6 +2980,16 @@
         PyTuple_SetItem(ret,1,PyInt_FromLong(tmp));
         return ret;
       }
+    
+      PyObject *getMaxAbsValue(std::size_t& tupleId) const throw(INTERP_KERNEL::Exception)
+      {
+      	std::size_t tmp;
+        int r1=self->getMaxAbsValue(tmp);
+        PyObject *ret=PyTuple_New(2);
+        PyTuple_SetItem(ret,0,PyInt_FromLong(r1));
+        PyTuple_SetItem(ret,1,PyInt_FromLong(tmp));
+        return ret;
+      }
 
       PyObject *getMinValue() const throw(INTERP_KERNEL::Exception)
       {
@@ -4305,31 +4290,6 @@
         PyTuple_SetItem(pyRet,1,ret1Py);
         return pyRet;
       }
-      
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"DataArrayInt");
-      }
-      
-      PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-      {
-#ifdef WITH_NUMPY
-        if(!self->isAllocated())
-          throw INTERP_KERNEL::Exception("PyWrap of DataArrayInt.__getnewargs__ : self is not allocated !");
-        PyObject *ret(PyTuple_New(1));
-        PyObject *ret0(PyDict_New());
-        PyObject *numpyArryObj(MEDCoupling_DataArrayInt_toNumPyArray(self));
-        {// create a dict to discriminite in __new__ if __init__ should be called. Not beautiful but not idea ...
-          PyObject *tmp1(PyInt_FromLong(0));
-          PyDict_SetItem(ret0,tmp1,numpyArryObj); Py_DECREF(tmp1); Py_DECREF(numpyArryObj);
-          PyTuple_SetItem(ret,0,ret0);
-        }
-        return ret;
-#else
-        throw INTERP_KERNEL::Exception("PyWrap of DataArrayInt.__getnewargs__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !");
-#endif
-      }
     }
   };
 
@@ -5096,31 +5056,6 @@
       }
 #endif
 
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"DataArrayByte");
-      }
-
-      PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-      {
-#ifdef WITH_NUMPY
-        if(!self->isAllocated())
-          throw INTERP_KERNEL::Exception("PyWrap of DataArrayByte.__getnewargs__ : self is not allocated !");
-        PyObject *ret(PyTuple_New(1));
-        PyObject *ret0(PyDict_New());
-        PyObject *numpyArryObj(MEDCoupling_DataArrayByte_toNumPyArray(self));
-        {// create a dict to discriminite in __new__ if __init__ should be called. Not beautiful but not idea ...
-          PyObject *tmp1(PyInt_FromLong(0));
-          PyDict_SetItem(ret0,tmp1,numpyArryObj); Py_DECREF(tmp1); Py_DECREF(numpyArryObj);
-          PyTuple_SetItem(ret,0,ret0);
-        }
-        return ret;
-#else
-        throw INTERP_KERNEL::Exception("PyWrap of DataArrayByte.__getnewargs__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !");
-#endif
-      }
-
       DataArrayByte *__setitem__(PyObject *obj, PyObject *value) throw(INTERP_KERNEL::Exception)
       {
         self->checkAllocated();
@@ -5984,3 +5919,32 @@
     }
   };
 }
+
+%pythoncode %{
+def MEDCouplingStdReduceFunct(cls,params):
+    a,b=params
+    ret=object.__new__(cls)
+    ret.__init__(*a)
+    ret.__setstate__(b)
+    return ret
+
+def MEDCouplingDataArrayDoubleReduce(self):
+    if not MEDCouplingHasNumPyBindings():
+      raise InterpKernelException("PyWrap of DataArrayDouble.__reduce__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !")
+    return MEDCouplingStdReduceFunct,(DataArrayDouble,((self.toNumPyArray(),),(self.__getstate__()),))
+
+def MEDCouplingDataArrayIntReduce(self):
+    if not MEDCouplingHasNumPyBindings():
+      raise InterpKernelException("PyWrap of DataArrayInt.__reduce__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !")
+    return MEDCouplingStdReduceFunct,(DataArrayInt,((self.toNumPyArray(),),(self.__getstate__()),))
+
+def MEDCouplingDataArrayByteReduce(self):
+    if not MEDCouplingHasNumPyBindings():
+      raise InterpKernelException("PyWrap of DataArrayByte.__reduce__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !")
+    return MEDCouplingStdReduceFunct,(DataArrayByte,((self.toNumPyArray(),),(self.__getstate__()),))
+
+def MEDCouplingDataArrayFloatReduce(self):
+    if not MEDCouplingHasNumPyBindings():
+      raise InterpKernelException("PyWrap of DataArrayFloat.__reduce__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !")
+    return MEDCouplingStdReduceFunct,(DataArrayFloat,((self.toNumPyArray(),),(self.__getstate__()),))
+%}
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingNumPyTest.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingNumPyTest.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingNumPyTest.py	2018-04-19 17:04:36.736222703 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingNumPyTest.py	2018-04-19 17:25:17.292788561 +0200
@@ -386,7 +386,7 @@
     def test19(self):
         sz=20
         a=array(0,dtype=int32)
-        a.resize(sz/2,2)
+        a.resize(sz//2,2)
         a[:]=4
         self.assertEqual(getrefcount(a),2)
         d=DataArrayInt(a)
@@ -405,7 +405,7 @@
     def test20(self):
         sz=20
         a=array(0,dtype=float64)
-        a.resize(sz/2,2)
+        a.resize(sz//2,2)
         a[:]=4
         self.assertEqual(getrefcount(a),2)
         d=DataArrayDouble(a)
@@ -422,7 +422,7 @@
 
     @unittest.skipUnless(MEDCouplingHasNumPyBindings(),"requires numpy")
     def test21(self):
-        #tests that only DataArray*(npArray) contructor is available
+        #tests that only DataArray*(npArray) constructor is available
         a=array(0,dtype=int32)
         a.resize(20)
         DataArrayInt(a)
@@ -918,7 +918,7 @@
         """Same as test20 with float32"""
         sz=20
         a=array(0,dtype=float32)
-        a.resize(sz/2,2)
+        a.resize(sz//2,2)
         a[:]=4
         self.assertEqual(getrefcount(a),2)
         d=DataArrayFloat(a)
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingPickleTest.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingPickleTest.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingPickleTest.py	2018-04-19 17:04:36.736222703 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingPickleTest.py	2018-04-19 17:25:17.282788363 +0200
@@ -84,7 +84,7 @@
 
     @unittest.skipUnless(MEDCouplingHasNumPyBindings(),"requires numpy")
     def test4(self):
-        """ Idem test3 except that here serialization/deserialization is done explicitely."""
+        """ Idem test3 except that here serialization/deserialization is done explicitly."""
         arr=DataArrayDouble(10) ; arr.iota()
         m=MEDCouplingCMesh() ; m.setCoords(arr,arr,arr)
         m=m.buildUnstructured()
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRefCountObject.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRefCountObject.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRefCountObject.i	2018-04-19 17:04:36.736222703 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRefCountObject.i	2018-04-19 17:25:17.297788659 +0200
@@ -62,7 +62,8 @@
   int MEDCouplingSizeOfVoidStar();
   bool MEDCouplingByteOrder();
   const char *MEDCouplingByteOrderStr();
-
+  bool IsCXX11Compiled();
+  
   class BigMemoryObject
   {
   public:
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRemapperCommon.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRemapperCommon.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRemapperCommon.i	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRemapperCommon.i	2018-04-19 17:25:17.285788422 +0200
@@ -0,0 +1,123 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+
+#define MEDCOUPLING_EXPORT
+#define INTERPKERNEL_EXPORT
+#define MEDCOUPLINGREMAPPER_EXPORT
+
+%newobject MEDCoupling::MEDCouplingRemapper::transferField;
+%newobject MEDCoupling::MEDCouplingRemapper::reverseTransferField;
+
+%{
+#include "MEDCouplingRemapper.hxx"
+%}
+
+%include "InterpolationOptions.hxx"
+
+namespace MEDCoupling
+{
+  typedef enum
+    {
+      IK_ONLY_PREFERED = 0,
+      NOT_IK_ONLY_PREFERED = 1,
+      IK_ONLY_FORCED = 2,
+      NOT_IK_ONLY_FORCED =3
+    } InterpolationMatrixPolicy;
+
+  class MEDCouplingRemapper : public TimeLabel, public INTERP_KERNEL::InterpolationOptions
+    {
+    private:
+      void updateTime() const;
+    public:
+      MEDCouplingRemapper();
+      ~MEDCouplingRemapper();
+      int prepare(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method) throw(INTERP_KERNEL::Exception);
+      int prepareEx(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target) throw(INTERP_KERNEL::Exception);
+      void transfer(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField, double dftValue) throw(INTERP_KERNEL::Exception);
+      void partialTransfer(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField) throw(INTERP_KERNEL::Exception);
+      void reverseTransfer(MEDCouplingFieldDouble *srcField, const MEDCouplingFieldDouble *targetField, double dftValue) throw(INTERP_KERNEL::Exception);
+      MEDCouplingFieldDouble *transferField(const MEDCouplingFieldDouble *srcField, double dftValue) throw(INTERP_KERNEL::Exception);
+      MEDCouplingFieldDouble *reverseTransferField(const MEDCouplingFieldDouble *targetField, double dftValue) throw(INTERP_KERNEL::Exception);
+      bool setOptionInt(const std::string& key, int value) throw(INTERP_KERNEL::Exception);
+      bool setOptionDouble(const std::string& key, double value) throw(INTERP_KERNEL::Exception);
+      bool setOptionString(const std::string& key, const std::string& value) throw(INTERP_KERNEL::Exception);
+      int getInterpolationMatrixPolicy() const throw(INTERP_KERNEL::Exception);
+      void setInterpolationMatrixPolicy(int newInterpMatPol) throw(INTERP_KERNEL::Exception);
+      //
+      int nullifiedTinyCoeffInCrudeMatrixAbs(double maxValAbs) throw(INTERP_KERNEL::Exception);
+      int nullifiedTinyCoeffInCrudeMatrix(double scaleFactor) throw(INTERP_KERNEL::Exception);
+      double getMaxValueInCrudeMatrix() const throw(INTERP_KERNEL::Exception);
+      int getNumberOfColsOfMatrix() const throw(INTERP_KERNEL::Exception);
+      static std::string BuildMethodFrom(const std::string& meth1, const std::string& meth2) throw(INTERP_KERNEL::Exception);
+      %extend
+         {
+           PyObject *getCrudeMatrix() const throw(INTERP_KERNEL::Exception)
+           {
+             const std::vector<std::map<int,double> >& m=self->getCrudeMatrix();
+             std::size_t sz=m.size();
+             PyObject *ret=PyList_New(sz);
+             for(std::size_t i=0;i<sz;i++)
+               {
+                 const std::map<int,double>& row=m[i];
+                 PyObject *ret0=PyDict_New();
+                 for(std::map<int,double>::const_iterator it=row.begin();it!=row.end();it++)
+                   PyDict_SetItem(ret0,PyInt_FromLong((*it).first),PyFloat_FromDouble((*it).second));
+                 PyList_SetItem(ret,i,ret0);
+               }
+             return ret;
+           }
+#if defined(WITH_NUMPY) && defined(WITH_SCIPY)
+           PyObject *getCrudeCSRMatrix() const throw(INTERP_KERNEL::Exception)
+           {
+             return ToCSRMatrix(self->getCrudeMatrix(),self->getNumberOfColsOfMatrix());
+           }
+#endif
+           void setCrudeMatrix(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method, PyObject *m) throw(INTERP_KERNEL::Exception)
+           {
+             std::vector<std::map<int,double> > mCpp;
+             if(isCSRMatrix(m))
+               {
+#if defined(WITH_NUMPY) && defined(WITH_SCIPY)
+                 PyObject *indptr(PyObject_GetAttrString(m,"indptr"));
+                 PyObject *indices(PyObject_GetAttrString(m,"indices"));
+                 PyObject *data(PyObject_GetAttrString(m,"data"));
+                 MCAuto<DataArrayInt> indptrPtr(MEDCoupling_DataArrayInt_New__SWIG_1(indptr,NULL,NULL));
+                 MCAuto<DataArrayInt> indicesPtr(MEDCoupling_DataArrayInt_New__SWIG_1(indices,NULL,NULL));
+                 MCAuto<DataArrayDouble> dataPtr(MEDCoupling_DataArrayDouble_New__SWIG_1(data,NULL,NULL));
+                 convertCSR_MCDataToVectMapIntDouble(indptrPtr,indicesPtr,dataPtr,mCpp);
+                 Py_XDECREF(data); Py_XDECREF(indptr); Py_XDECREF(indices);
+#else
+                 throw INTERP_KERNEL::Exception("pywrap of MEDCouplingRemapper::setCrudeMatrix : unexpected situation regarding numpy/scipy !");
+#endif
+               }
+             else
+               convertToVectMapIntDouble(m,mCpp);
+             self->setCrudeMatrix(srcMesh,targetMesh,method,mCpp);
+           }
+
+           void setCrudeMatrixEx(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target, PyObject *m) throw(INTERP_KERNEL::Exception)
+           {
+             std::vector<std::map<int,double> > mCpp;
+             convertToVectMapIntDouble(m,mCpp);
+             self->setCrudeMatrixEx(src,target,mCpp);
+           }
+         }
+    };
+}
+
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRemapper.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRemapper.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRemapper.i	2018-04-19 17:04:36.736222703 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRemapper.i	2018-04-19 17:25:17.298788679 +0200
@@ -19,93 +19,11 @@
 
 %module MEDCouplingRemapper
 
-#define MEDCOUPLING_EXPORT
-#define INTERPKERNEL_EXPORT
-#define MEDCOUPLINGREMAPPER_EXPORT
-
-%{
-#include "MEDCouplingMemArray.hxx"
-#include "MEDCouplingUMesh.hxx"
-#include "MEDCouplingField.hxx"
-#include "MEDCouplingFieldDouble.hxx"
-#include "MEDCouplingRemapper.hxx"
-
-using namespace MEDCoupling;
-using namespace INTERP_KERNEL;
-%}
-
-%newobject MEDCoupling::MEDCouplingRemapper::transferField;
-%newobject MEDCoupling::MEDCouplingRemapper::reverseTransferField;
-
 %include "MEDCouplingCommon.i"
-%include "InterpolationOptions.hxx"
 
-namespace MEDCoupling
-{
-  typedef enum
-    {
-      IK_ONLY_PREFERED = 0,
-      NOT_IK_ONLY_PREFERED = 1,
-      IK_ONLY_FORCED = 2,
-      NOT_IK_ONLY_FORCED =3
-    } InterpolationMatrixPolicy;
-
-  class MEDCouplingRemapper : public TimeLabel, public INTERP_KERNEL::InterpolationOptions
-    {
-    private:
-      void updateTime() const;
-    public:
-      MEDCouplingRemapper();
-      ~MEDCouplingRemapper();
-      int prepare(const MEDCouplingMesh *srcMesh, const MEDCouplingMesh *targetMesh, const std::string& method) throw(INTERP_KERNEL::Exception);
-      int prepareEx(const MEDCouplingFieldTemplate *src, const MEDCouplingFieldTemplate *target) throw(INTERP_KERNEL::Exception);
-      void transfer(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField, double dftValue) throw(INTERP_KERNEL::Exception);
-      void partialTransfer(const MEDCouplingFieldDouble *srcField, MEDCouplingFieldDouble *targetField) throw(INTERP_KERNEL::Exception);
-      void reverseTransfer(MEDCouplingFieldDouble *srcField, const MEDCouplingFieldDouble *targetField, double dftValue) throw(INTERP_KERNEL::Exception);
-      MEDCouplingFieldDouble *transferField(const MEDCouplingFieldDouble *srcField, double dftValue) throw(INTERP_KERNEL::Exception);
-      MEDCouplingFieldDouble *reverseTransferField(const MEDCouplingFieldDouble *targetField, double dftValue) throw(INTERP_KERNEL::Exception);
-      bool setOptionInt(const std::string& key, int value) throw(INTERP_KERNEL::Exception);
-      bool setOptionDouble(const std::string& key, double value) throw(INTERP_KERNEL::Exception);
-      bool setOptionString(const std::string& key, const std::string& value) throw(INTERP_KERNEL::Exception);
-      int getInterpolationMatrixPolicy() const throw(INTERP_KERNEL::Exception);
-      void setInterpolationMatrixPolicy(int newInterpMatPol) throw(INTERP_KERNEL::Exception);
-      //
-      int nullifiedTinyCoeffInCrudeMatrixAbs(double maxValAbs) throw(INTERP_KERNEL::Exception);
-      int nullifiedTinyCoeffInCrudeMatrix(double scaleFactor) throw(INTERP_KERNEL::Exception);
-      double getMaxValueInCrudeMatrix() const throw(INTERP_KERNEL::Exception);
-      int getNumberOfColsOfMatrix() const throw(INTERP_KERNEL::Exception);
-      static std::string BuildMethodFrom(const std::string& meth1, const std::string& meth2) throw(INTERP_KERNEL::Exception);
-      %extend
-         {
-           PyObject *getCrudeMatrix() const throw(INTERP_KERNEL::Exception)
-           {
-             const std::vector<std::map<int,double> >& m=self->getCrudeMatrix();
-             std::size_t sz=m.size();
-             PyObject *ret=PyList_New(sz);
-             for(std::size_t i=0;i<sz;i++)
-               {
-                 const std::map<int,double>& row=m[i];
-                 PyObject *ret0=PyDict_New();
-                 for(std::map<int,double>::const_iterator it=row.begin();it!=row.end();it++)
-                   PyDict_SetItem(ret0,PyInt_FromLong((*it).first),PyFloat_FromDouble((*it).second));
-                 PyList_SetItem(ret,i,ret0);
-               }
-             return ret;
-           }
-#if defined(WITH_NUMPY) && defined(WITH_SCIPY)
-           PyObject *getCrudeCSRMatrix() const throw(INTERP_KERNEL::Exception)
-           {
-             return ToCSRMatrix(self->getCrudeMatrix(),self->getNumberOfColsOfMatrix());
-           }
-#endif
-         }
-    };
-}
+%include "MEDCouplingRemapperCommon.i"
 
 %pythoncode %{
-def MEDCouplingDataArrayDoublenew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.DataArrayDouble____new___(cls,args)
 def MEDCouplingDataArrayDoubleIadd(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DataArrayDouble____iadd___(self, self, *args)
@@ -121,9 +39,6 @@
 def MEDCouplingDataArrayDoubleIpow(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DataArrayDouble____ipow___(self, self, *args)
-def MEDCouplingFieldDoublenew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingFieldDouble____new___(cls,args)
 def MEDCouplingFieldDoubleIadd(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.MEDCouplingFieldDouble____iadd___(self, self, *args)
@@ -139,18 +54,6 @@
 def MEDCouplingFieldDoubleIpow(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.MEDCouplingFieldDouble____ipow___(self, self, *args)
-def MEDCouplingFieldIntnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingFieldInt____new___(cls,args)
-def MEDCouplingFieldFloatnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingFieldFloat____new___(cls,args)
-def MEDCouplingDataArrayBytenew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.DataArrayByte____new___(cls,args)
-def MEDCouplingDataArrayFloatnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.DataArrayFloat____new___(cls,args)
 def MEDCouplingDataArrayFloatIadd(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DataArrayFloat____iadd___(self, self, *args)
@@ -163,9 +66,6 @@
 def MEDCouplingDataArrayFloatIdiv(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DataArrayFloat____idiv___(self, self, *args)
-def MEDCouplingDataArrayIntnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.DataArrayInt____new___(cls,args)
 def MEDCouplingDataArrayIntIadd(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DataArrayInt____iadd___(self, self, *args)
@@ -211,33 +111,12 @@
 def MEDCouplingDataArrayIntTupleImod(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DataArrayIntTuple____imod___(self, self, *args)
-def ParaMEDMEMDenseMatrixIadd(self,*args):
+def MEDCouplingDenseMatrixIadd(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DenseMatrix____iadd___(self, self, *args)
-def ParaMEDMEMDenseMatrixIsub(self,*args):
+def MEDCouplingDenseMatrixIsub(self,*args):
     import _MEDCouplingRemapper
     return _MEDCouplingRemapper.DenseMatrix____isub___(self, self, *args)
-def MEDCouplingUMeshnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingUMesh____new___(cls,args)
-def MEDCoupling1DGTUMeshnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCoupling1DGTUMesh____new___(cls,args)
-def MEDCoupling1SGTUMeshnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCoupling1SGTUMesh____new___(cls,args)
-def MEDCouplingCurveLinearMeshnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingCurveLinearMesh____new___(cls,args)
-def MEDCouplingCMeshnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingCMesh____new___(cls,args)
-def MEDCouplingIMeshnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingIMesh____new___(cls,args)
-def MEDCouplingExtrudedMeshnew(cls,*args):
-    import _MEDCouplingRemapper
-    return _MEDCouplingRemapper.MEDCouplingMappedExtrudedMesh____new___(cls,args)
 %}
 
 %include "MEDCouplingFinalize.i"
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRemapperTest.py MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRemapperTest.py
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingRemapperTest.py	2018-04-19 17:04:36.737222723 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingRemapperTest.py	2018-04-19 17:25:17.258787888 +0200
@@ -1108,7 +1108,7 @@
         pass
 
     def testP0P0WithHEXGP12(self):
-        """ Test that HEXGP12 are correclty remapped (elements with polygonal faces were not properly handled) """
+        """ Test that HEXGP12 are correctly remapped (elements with polygonal faces were not properly handled) """
         # From Astrid, two disjoint hexagonal prisms:
         coo1 = [-4.991193077144312, 8.644999999999998, 0.0, -9.982386154288623, 6.112246755425186e-16, 0.0, -4.991193077144315, -8.644999999999998, 0.0, 4.991193077144309, -8.645000000000005, 0.0, 9.982386154288626, 1.1651321638577316e-15, 0.0, 4.991193077144314, 8.645, 0.0, -4.991193077144312, 8.644999999999998, 7.561799999999991, -9.982386154288623, 6.112246755425186e-16, 7.561799999999991, -4.991193077144315, -8.644999999999998, 7.561799999999991, 4.991193077144309, -8.645000000000005, 7.561799999999991, 9.982386154288626, 1.1651321638577316e-15, 7.561799999999991, 4.991193077144314, 8.645, 7.561799999999991]
         coo2 = [-4.991193077144313, -8.645, 0.0, -9.982386154288626, -1.3992140779350848e-15, 0.0, -19.964772308577256, 0.0, 0.0, -24.95596538572157, -8.644999999999998, 0.0, -19.96477230857726, -17.289999999999996, 0.0, -9.982386154288626, -17.289999999999996, 0.0, -4.991193077144313, -8.645, 5.041200000000004, -9.982386154288626, -1.3992140779350848e-15, 5.041200000000004, -19.964772308577256, 0.0, 5.041200000000004, -24.95596538572157, -8.644999999999998, 5.041200000000004, -19.96477230857726, -17.289999999999996, 5.041200000000004, -9.982386154288626, -17.289999999999996, 5.041200000000004]
@@ -1155,6 +1155,130 @@
         self.assertEqual(1, len(rmp.getCrudeMatrix()[0]))
         pass
 
+    @unittest.skipUnless(MEDCouplingHasNumPyBindings() and MEDCouplingHasSciPyBindings() and IsCXX11Compiled(),"requires numpy AND scipy AND C++11")
+    def testP1P1PL3DSpaceFrom1DTo0D(self):
+        from scipy.sparse import csr_matrix
+        from numpy import array
+
+        def generateTrg(eps):
+            trgArr=DataArrayDouble([(0.5,0.5,0.5),(0.2,0.2,0.2),(0.9,0.9,0.9),(0.7+eps*sqrt(3),0.7-eps*sqrt(3),0.7)])
+            trg=MEDCouplingUMesh("trg",0) ; trg.setCoords(trgArr)
+            trg.allocateCells()
+            RenumTrg=[2,3,0,1]
+            for rt in RenumTrg:
+                trg.insertNextCell(NORM_POINT1,[rt])
+            return trg
+
+        srcArr=DataArrayDouble([(0.,0.,1.),(0.,0.,0.),(1.,1.,1.)])
+        src=MEDCouplingUMesh("src",1) ; src.setCoords(srcArr)
+        src.allocateCells()
+        src.insertNextCell(NORM_SEG2,[1,2])
+        #
+        trg=generateTrg(1e-7)# trg point 3 of trg cell 1 is NOT closer enough to source edge #1 -> not intercepted
+        #
+        rem=MEDCouplingRemapper()
+        rem.setIntersectionType(PointLocator)
+        self.assertEqual(rem.prepare(src,trg,"P1P1"),1)
+        mat=rem.getCrudeCSRMatrix()
+        row=array([2,2, 0,0, 1,1]) # here no ref to point 3 !
+        col=array([1,2, 1,2, 1,2])
+        data=array([0.1,0.9, 0.5,0.5, 0.8,0.2])
+        mExp=csr_matrix((data,(row,col)),shape=(4,3))
+        delta=abs(mExp-mat)
+        self.assertAlmostEqual(delta.sum(),0.,14)
+        #
+        trg=generateTrg(1e-14) # trg point 3 of trg cell 1 is closer enough to source edge #1 -> intercepted
+        rem=MEDCouplingRemapper()
+        rem.setIntersectionType(PointLocator)
+        self.assertEqual(rem.prepare(src,trg,"P1P1"),1)
+        mat=rem.getCrudeCSRMatrix()
+        row=array([2,2, 3,3, 0,0, 1,1]) # here ref to target point 3 
+        col=array([1,2, 1,2, 1,2, 1,2])
+        data=array([0.1,0.9, 0.3,0.7, 0.5,0.5, 0.8,0.2])
+        mExp2=csr_matrix((data,(row,col)),shape=(4,3))
+        delta2=abs(mExp2-mat)
+        self.assertAlmostEqual(delta2.sum(),0.,14)
+        pass
+
+    def testSetMatrix1(self):
+        """ Remapper has now setCrudeMatrix method to reload matrix to skip prepare phase """
+        cooS=DataArrayDouble([1,1, 7,1, 7,2, 1,2],4,2)
+        cooT=DataArrayDouble([0,0, 3,0, 3,3, 0,3, 6,0, 12,0, 12,3, 6,3],8,2)
+        ms=MEDCouplingUMesh("source",2) ; ms.allocateCells(1) ; ms.insertNextCell(NORM_QUAD4,[0,1,2,3]) ; ms.setCoords(cooS)
+        mt=MEDCouplingUMesh("target",2) ; mt.allocateCells(2) ; mt.insertNextCell(NORM_QUAD4,[0,1,2,3]) ; mt.insertNextCell(NORM_QUAD4,[4,5,6,7]) ; mt.setCoords(cooT)
+        rem=MEDCouplingRemapper()
+        self.assertEqual(rem.prepare(ms,mt,"P0P0"),1) # [{0: 2.0}, {0: 1.0}]
+        fs=MEDCouplingFieldDouble(ON_CELLS)
+        fs.setMesh(ms)
+        fs.setArray(DataArrayDouble([10]))
+        fs.checkConsistencyLight()
+        #
+        fs.setNature(ExtensiveConservation)
+        self.assertTrue(rem.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([20./3,10./3.]),1e-12))# sum is equal to 10. First value is twice than second value
+        #
+        fs.setNature(ExtensiveMaximum)
+        self.assertTrue(rem.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([20./6.,10./6.]),1e-12))#sum is equal to 5 (10/2. because only half part on input cell is intercepted by the target cells). First value is twice than second value
+        #
+        fs.setNature(IntensiveConservation)
+        self.assertTrue(rem.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([2./9.*10.,1./18.*10.]),1e-12))#
+        #
+        fs.setNature(IntensiveMaximum)
+        self.assertTrue(rem.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([10.,10.]),1e-12))#
+        ####
+        rem2=MEDCouplingRemapper()
+        rem2.setCrudeMatrix(ms,mt,"P0P0",rem.getCrudeMatrix())
+        fs.setNature(ExtensiveConservation)
+        self.assertTrue(rem2.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([20./3,10./3.]),1e-12))
+        #
+        fs.setNature(ExtensiveMaximum)
+        self.assertTrue(rem2.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([20./6.,10./6.]),1e-12))
+        #
+        fs.setNature(IntensiveConservation)
+        self.assertTrue(rem2.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([2./9.*10.,1./18.*10.]),1e-12))
+        #
+        fs.setNature(IntensiveMaximum)
+        self.assertTrue(rem2.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([10.,10.]),1e-12))
+        #
+        srcFt=MEDCouplingFieldTemplate.New(ON_CELLS);
+        trgFt=MEDCouplingFieldTemplate.New(ON_CELLS);
+        srcFt.setMesh(ms);
+        trgFt.setMesh(mt);
+        rem3=MEDCouplingRemapper()
+        rem3.setCrudeMatrixEx(srcFt,trgFt,rem.getCrudeMatrix())
+        fs.setNature(ExtensiveConservation)
+        self.assertTrue(rem3.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([20./3,10./3.]),1e-12))
+        pass
+
+    @unittest.skipUnless(MEDCouplingHasNumPyBindings() and MEDCouplingHasSciPyBindings(),"requires numpy AND scipy")
+    def testSetMatrix2(self):
+        """ Remapper has now setCrudeMatrix method to reload matrix to skip prepare phase. Same as testSetMatrix1 but with CSR scipy matrix """
+        arrx_s=DataArrayDouble(6) ; arrx_s.iota()
+        arry_s=DataArrayDouble(6) ; arry_s.iota()
+        ms=MEDCouplingCMesh() ; ms.setCoords(arrx_s,arry_s)
+        ms=ms.buildUnstructured()
+        #
+        arrx_t=DataArrayDouble([2.5,4.5,5.5])
+        arry_t=DataArrayDouble([2.5,3.5,5.5])
+        mt=MEDCouplingCMesh() ; mt.setCoords(arrx_t,arry_t)
+        mt=mt.buildUnstructured()
+        #
+        rem=MEDCouplingRemapper()
+        self.assertEqual(rem.prepare(ms,mt,"P0P0"),1)
+        #
+        fs=MEDCouplingFieldDouble(ON_CELLS)
+        fs.setMesh(ms)
+        arr=DataArrayDouble(25) ; arr.iota()
+        fs.setArray(arr)
+        fs.checkConsistencyLight()
+        #
+        fs.setNature(ExtensiveConservation)
+        self.assertTrue(rem.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([54.25,11.75,79.25,16.75]),1e-12))
+        mat=rem.getCrudeCSRMatrix()
+        rem2=MEDCouplingRemapper()
+        rem2.setCrudeMatrix(ms,mt,"P0P0",mat)
+        self.assertTrue(rem2.transferField(fs,1e300).getArray().isEqual(DataArrayDouble([54.25,11.75,79.25,16.75]),1e-12))
+        pass
+        
     def checkMatrix(self,mat1,mat2,nbCols,eps):
         self.assertEqual(len(mat1),len(mat2))
         for i in range(len(mat1)):
diff -Naur MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingTypemaps.i MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingTypemaps.i
--- MEDCOUPLING_old/src/MEDCoupling_Swig/MEDCouplingTypemaps.i	2018-04-19 17:04:36.737222723 +0200
+++ MEDCOUPLING_new/src/MEDCoupling_Swig/MEDCouplingTypemaps.i	2018-04-19 17:25:17.296788640 +0200
@@ -83,6 +83,25 @@
   return ret;
 }
 
+static PyObject *convertField(MEDCoupling::MEDCouplingField *f, int owner)
+{
+  PyObject *ret(NULL);
+  if(!f)
+    {
+      Py_XINCREF(Py_None);
+      return Py_None;
+    }
+  if(dynamic_cast<MEDCoupling::MEDCouplingFieldDouble *>(f))
+    ret=SWIG_NewPointerObj(reinterpret_cast<void*>(f),SWIGTYPE_p_MEDCoupling__MEDCouplingFieldDouble,owner);
+  if(dynamic_cast<MEDCoupling::MEDCouplingFieldInt *>(f))
+    ret=SWIG_NewPointerObj(reinterpret_cast<void*>(f),SWIGTYPE_p_MEDCoupling__MEDCouplingFieldInt,owner);
+  if(dynamic_cast<MEDCoupling::MEDCouplingFieldFloat *>(f))
+    ret=SWIG_NewPointerObj(reinterpret_cast<void*>(f),SWIGTYPE_p_MEDCoupling__MEDCouplingFieldFloat,owner);
+  if(!ret)
+    throw INTERP_KERNEL::Exception("Not recognized type of field on downcast !");
+  return ret;
+}
+
 static PyObject* convertMultiFields(MEDCoupling::MEDCouplingMultiFields *mfs, int owner)
 {
   PyObject *ret=0;
diff -Naur MEDCOUPLING_old/src/MEDLoader/CMakeLists.txt MEDCOUPLING_new/src/MEDLoader/CMakeLists.txt
--- MEDCOUPLING_old/src/MEDLoader/CMakeLists.txt	2018-04-19 17:04:36.738222743 +0200
+++ MEDCOUPLING_new/src/MEDLoader/CMakeLists.txt	2018-04-19 17:25:17.745797515 +0200
@@ -63,6 +63,10 @@
   MEDFileBasis.cxx
   MEDFileMeshLL.cxx
   MEDFileField.cxx
+  MEDFileFieldInternal.cxx
+  MEDFileFieldGlobs.cxx
+  MEDFileField1TS.cxx
+  MEDFileFieldMultiTS.cxx
   MEDFileJoint.cxx
   MEDFileEquivalence.cxx
   MEDFileParameter.cxx
@@ -80,7 +84,7 @@
 
 ADD_LIBRARY(medloader ${medloader_SOURCES})
 SET_TARGET_PROPERTIES(medloader PROPERTIES COMPILE_FLAGS "")
-TARGET_LINK_LIBRARIES(medloader medcoupling ${MEDFILE_C_LIBRARIES} ${HDF5_LIBRARIES} ${MEDLOADER_XDR_LIBRARIES})
+TARGET_LINK_LIBRARIES(medloader medcouplingcpp ${MEDFILE_C_LIBRARIES} ${HDF5_LIBRARIES} ${MEDLOADER_XDR_LIBRARIES})
 INSTALL(TARGETS medloader EXPORT ${PROJECT_NAME}TargetGroup DESTINATION ${MEDCOUPLING_INSTALL_LIBS})
 
 FILE(GLOB medloader_HEADERS_HXX "${CMAKE_CURRENT_SOURCE_DIR}/*.hxx")
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileBlowStrEltUp.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileBlowStrEltUp.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileBlowStrEltUp.cxx	2018-04-19 17:04:36.738222743 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileBlowStrEltUp.cxx	2018-04-19 17:25:17.812798839 +0200
@@ -23,6 +23,7 @@
 #include "MEDFileFieldVisitor.hxx"
 #include "MEDCouplingPartDefinition.hxx"
 #include "MCAuto.txx"
+#include <numeric>
 
 using namespace MEDCoupling;
 
@@ -337,10 +338,13 @@
   void checkUniqueLoc(const std::string& loc) const;
   static MCAuto<DataArrayDouble> BuildMeshFromAngleVrille(INTERP_KERNEL::NormalizedCellType gt, const DataArrayDouble *angleDeVrille, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs);
   static MCAuto<DataArrayDouble> BuildMeshFromEpaisseur(INTERP_KERNEL::NormalizedCellType gt, const DataArrayDouble *thikness, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs);
+  static MCAuto<DataArrayDouble> BuildMeshPipeSEG3(const DataArrayDouble *angle, const DataArrayDouble *scale, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs);
   static MCAuto<MEDCouplingUMesh> BuildMeshCommon(INTERP_KERNEL::NormalizedCellType gt, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs, MCAuto<DataArrayDouble>& ptsForLoc);
   static MCAuto<DataArrayDouble> BuildMeshFromStructure(INTERP_KERNEL::NormalizedCellType gt, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs);
 public:
   static const char ANGLE_DE_VRILLE[];
+  static const char ANGLE[];
+  static const char SCALE[];
   static const char EPAISSEUR[];
 private:
   std::vector<std::string> _locs;
@@ -350,6 +354,10 @@
 
 const char LocInfo::ANGLE_DE_VRILLE[]="ANGLE DE VRILLE";
 
+const char LocInfo::ANGLE[]="ANGLE";
+
+const char LocInfo::SCALE[]="SCALE";
+
 const char LocInfo::EPAISSEUR[]="EPAISSEUR";
 
 LocInfo::LocInfo(const std::vector<FieldWalker2>& fw)
@@ -376,7 +384,7 @@
     }
 }
 
-MCAuto<MEDCouplingUMesh> LocInfo::BuildMeshCommon(INTERP_KERNEL::NormalizedCellType gt,const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs, MCAuto<DataArrayDouble>& ptsForLoc)
+MCAuto<MEDCouplingUMesh> LocInfo::BuildMeshCommon(INTERP_KERNEL::NormalizedCellType gt, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs, MCAuto<DataArrayDouble>& ptsForLoc)
 {
   MCAuto<DataArrayInt> conn(zeStr->getConn());
   conn=conn->deepCopy(); conn->rearrange(1);
@@ -453,6 +461,7 @@
 
 MCAuto<DataArrayDouble> LocInfo::BuildMeshFromEpaisseur(INTERP_KERNEL::NormalizedCellType gt, const DataArrayDouble *thikness, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs)
 {
+#if __cplusplus >= 201103L
   MCAuto<DataArrayDouble> ptsForLoc;
   MCAuto<MEDCouplingUMesh> geoMesh(BuildMeshCommon(gt,pfl,loc,zeStr,mesh,section,globs,ptsForLoc));
   int nbSecPts(section->getNumberOfNodes()),nbCells(geoMesh->getNumberOfCells()),nbg(loc.getGaussWeights().size());
@@ -460,7 +469,6 @@
   if(!pfl.empty())
     {
       const DataArrayInt *pflArr(globs->getProfile(pfl));
-      geoMesh=geoMesh->buildPartOfMySelf(pflArr->begin(),pflArr->end(),true);
       zeThikness=thikness->selectByTupleIdSafe(pflArr->begin(),pflArr->end());
     }
   else
@@ -476,11 +484,14 @@
   std::vector< MCAuto<DataArrayDouble> > arrs(nbCells*nbg);
   for(int j=0;j<nbCells;j++)
     {
-      double thck(zeThikness->getIJ(j,0));
-      MCAuto<DataArrayDouble> fact(DataArrayDouble::New()); fact->alloc(1,nbCompo);
+      double thck(zeThikness->getIJ(j,0)),eccentricity(zeThikness->getIJ(j,1));
+      MCAuto<DataArrayDouble> fact(DataArrayDouble::New()),fact2(DataArrayDouble::New()); fact->alloc(1,nbCompo); fact2->alloc(1,nbCompo);
       std::copy(orthoArr->begin()+j*nbCompo,orthoArr->begin()+(j+1)*nbCompo,fact->getPointer());
-      std::transform(fact->begin(),fact->end(),fact->getPointer(),std::bind2nd(std::multiplies<double>(),thck/2.));
+      std::copy(orthoArr->begin()+j*nbCompo,orthoArr->begin()+(j+1)*nbCompo,fact2->getPointer());
+      std::for_each(fact2->rwBegin(),fact2->rwEnd(),[eccentricity](double& val){ val*=eccentricity; });
+      std::transform(fact->begin(),fact->end(),fact->getPointer(),[thck](const double& val){ return val*thck/2.; });
       MCAuto<DataArrayDouble> p(DataArrayDouble::Multiply(secPts,fact));
+      p=DataArrayDouble::Add(p,fact2);
       for(int l=0;l<nbg;l++)
         {
           MCAuto<DataArrayDouble> p2(p->deepCopy());
@@ -492,24 +503,131 @@
   std::vector<const DataArrayDouble *> arrs2(VecAutoToVecOfCstPt(arrs));
   MCAuto<DataArrayDouble> resu(DataArrayDouble::Aggregate(arrs2));
   return resu;
+#else
+  throw INTERP_KERNEL::Exception("Broken news : 10% off for C++11 compiler :)");
+#endif
+}
+
+MCAuto<DataArrayDouble> LocInfo::BuildMeshPipeSEG3(const DataArrayDouble *angle, const DataArrayDouble *scale, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs)
+{
+#if __cplusplus >= 201103L
+  static const char MSG1[]="BuildMeshPipeSEG3 : not recognized pattern ! Send mail to anthony.geay@edf.fr with corresponding MED file !";
+  MCAuto<DataArrayDouble> ptsForLoc;
+  MCAuto<MEDCouplingUMesh> geoMesh(BuildMeshCommon(INTERP_KERNEL::NORM_SEG3,pfl,loc,zeStr,mesh,section,globs,ptsForLoc));
+  int nbSecPts(section->getNumberOfNodes()),nbCells(geoMesh->getNumberOfCells()),nbg(loc.getGaussWeights().size());
+  MCConstAuto<DataArrayDouble> zeAngle,zeScale;
+  if(!pfl.empty())
+    {
+      const DataArrayInt *pflArr(globs->getProfile(pfl));
+      zeAngle=angle->selectByTupleIdSafe(pflArr->begin(),pflArr->end());
+      zeScale=scale->selectByTupleIdSafe(pflArr->begin(),pflArr->end());
+    }
+  else
+    {
+      zeAngle.takeRef(angle);
+      zeScale.takeRef(scale);
+    }
+  if(zeAngle->getNumberOfComponents()!=3 || zeScale->getNumberOfComponents()!=2 || nbg!=3)
+    throw INTERP_KERNEL::Exception(MSG1);
+  MCAuto<MEDCouplingFieldDouble> dir;
+  {
+    MCAuto<MEDCouplingUMesh> geoMesh2(geoMesh->deepCopy());
+    geoMesh2->convertQuadraticCellsToLinear();
+    dir=geoMesh2->buildDirectionVectorField();
+  }
+  MCAuto<DataArrayDouble> rot(dir->getArray()->fromCartToSpher());
+  int nbCompo(ptsForLoc->getNumberOfComponents());
+  MCAuto<DataArrayDouble> secPts(section->getCoords()->changeNbOfComponents(nbCompo,0.));
+  {
+    const int TAB[3]={2,0,1};
+    std::vector<int> v(TAB,TAB+3);
+    secPts=secPts->keepSelectedComponents(v);
+  }
+  const double CENTER[3]={0.,0.,0.},AX0[3]={0.,0.,1.};
+  double AX1[3]; AX1[2]=0.;
+  std::vector< MCAuto<DataArrayDouble> > arrs(nbCells*nbg);
+  for(int j=0;j<nbCells;j++)
+    {
+      constexpr int DIM=3;
+      MCAuto<DataArrayDouble> p(secPts->deepCopy());
+      double ang0(rot->getIJ(j,2));
+      double rmin(zeScale->getIJ(j,0)),rmax(zeScale->getIJ(j,1));
+      {
+        auto pt(p->rwBegin());
+        for(int i=0;i<nbSecPts;i++)
+          {
+            auto nrm(sqrt(std::accumulate(pt,pt+DIM,0.,[](double sum, double v) { return sum+v*v; } )));
+            auto sca((rmin+2.*(nrm-0.5)*(rmax-rmin))/nrm);
+            std::for_each(pt,pt+3,[sca](double& val) { val*=sca; } );
+            std::advance(pt,DIM);
+          }
+      }
+      DataArrayDouble::Rotate3DAlg(CENTER,AX0,ang0,nbSecPts,p->begin(),p->getPointer());
+      AX1[0]=-sin(ang0); AX1[1]=cos(ang0);// rot Oy around OZ
+      double ang1(M_PI/2.-rot->getIJ(j,1));
+      DataArrayDouble::Rotate3DAlg(CENTER,AX1,-ang1,nbSecPts,p->begin(),p->getPointer());
+      for(int l=0;l<3;l++)
+        {
+          MCAuto<DataArrayDouble> p3(p->deepCopy());
+          DataArrayDouble::Rotate3DAlg(CENTER,dir->getArray()->begin()+j*3,zeAngle->getIJ(j,l),nbSecPts,p3->begin(),p3->getPointer());
+          MCAuto<DataArrayDouble> p2(p3->deepCopy());
+          for(int k=0;k<nbCompo;k++)
+            p2->applyLin(1.,ptsForLoc->getIJ(j*nbg+l,k),k);
+          arrs[j*nbg+l]=p2;
+        }
+    }
+  std::vector<const DataArrayDouble *> arrs2(VecAutoToVecOfCstPt(arrs));
+  MCAuto<DataArrayDouble> resu(DataArrayDouble::Aggregate(arrs2));
+  return resu;
+#else
+  throw INTERP_KERNEL::Exception("Broken news : 10% off for C++11 compiler :)");
+#endif
 }
 
 MCAuto<DataArrayDouble> LocInfo::BuildMeshFromStructure(INTERP_KERNEL::NormalizedCellType gt, const std::string& pfl, const MEDFileFieldLoc& loc, const MEDFileEltStruct4Mesh *zeStr, const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileFieldGlobsReal *globs)
 {
   static const char MSG1[]="BuildMeshFromStructure : not recognized pattern ! Send mail to anthony.geay@edf.fr with corresponding MED file !";
   const std::vector< MCAuto<DataArray> >& vars(zeStr->getVars());
-  if(vars.size()!=1)
-    throw INTERP_KERNEL::Exception(MSG1);
-  MCAuto<DataArray> zeArr(vars[0]);
-  if(zeArr.isNull())
-    throw INTERP_KERNEL::Exception(MSG1);
-  MCAuto<DataArrayDouble> zeArr2(DynamicCast<DataArray,DataArrayDouble>(zeArr));
-  if(zeArr2.isNull())
-    throw INTERP_KERNEL::Exception(MSG1);
-  if(zeArr2->getName()==ANGLE_DE_VRILLE)
-    return BuildMeshFromAngleVrille(gt,zeArr2,pfl,loc,zeStr,mesh,section,globs);
-  if(zeArr2->getName()==EPAISSEUR)
-    return BuildMeshFromEpaisseur(gt,zeArr2,pfl,loc,zeStr,mesh,section,globs);
+  if(vars.size()==1)
+    {
+      MCAuto<DataArray> zeArr(vars[0]);
+      if(zeArr.isNull())
+        throw INTERP_KERNEL::Exception(MSG1);
+      MCAuto<DataArrayDouble> zeArr2(DynamicCast<DataArray,DataArrayDouble>(zeArr));
+      if(zeArr2.isNull())
+        throw INTERP_KERNEL::Exception(MSG1);
+      if(zeArr2->getName()==ANGLE_DE_VRILLE || zeArr2->getName()==ANGLE)
+        return BuildMeshFromAngleVrille(gt,zeArr2,pfl,loc,zeStr,mesh,section,globs);
+      if(zeArr2->getName()==EPAISSEUR || zeArr2->getName()==SCALE)
+        return BuildMeshFromEpaisseur(gt,zeArr2,pfl,loc,zeStr,mesh,section,globs);
+    }
+  if(vars.size()==2)
+    {
+      MCAuto<DataArray> zeArr0(vars[0]),zeArr1(vars[1]);
+      if(zeArr0.isNull() || zeArr1.isNull())
+        throw INTERP_KERNEL::Exception(MSG1);
+      MCAuto<DataArrayDouble> zeArr00(DynamicCastSafe<DataArray,DataArrayDouble>(zeArr0)),zeArr11(DynamicCastSafe<DataArray,DataArrayDouble>(zeArr1));
+      switch(gt)
+      {
+        case INTERP_KERNEL::NORM_SEG3:
+          {
+            MCAuto<DataArrayDouble> angle,scale;
+            if(zeArr00->getName()==ANGLE)
+              angle=zeArr00;
+            if(zeArr00->getName()==SCALE)
+              scale=zeArr00;
+            if(zeArr11->getName()==ANGLE)
+              angle=zeArr11;
+            if(zeArr11->getName()==SCALE)
+              scale=zeArr11;
+            if(angle.isNull() || scale.isNull())
+              throw INTERP_KERNEL::Exception(MSG1);
+            return BuildMeshPipeSEG3(angle,scale,pfl,loc,zeStr,mesh,section,globs);
+          }
+        default:
+          throw INTERP_KERNEL::Exception(MSG1);
+      }
+    }
   throw INTERP_KERNEL::Exception(MSG1);
 }
 
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileField1TS.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileField1TS.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileField1TS.cxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileField1TS.cxx	2018-04-19 17:25:17.799798582 +0200
@@ -0,0 +1,2630 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#include "MEDFileField1TS.hxx"
+#include "MEDFileFieldVisitor.hxx"
+#include "MEDFileSafeCaller.txx"
+#include "MEDLoaderBase.hxx"
+#include "MEDFileField.txx"
+
+#include "MEDCouplingFieldTemplate.hxx"
+#include "MEDCouplingFieldDouble.hxx"
+
+using namespace MEDCoupling;
+
+extern INTERP_KERNEL::NormalizedCellType typmai2[MED_N_CELL_FIXED_GEO];
+
+template class MEDCoupling::MEDFileField1TSTemplateWithoutSDA<int>;
+template class MEDCoupling::MEDFileField1TSTemplateWithoutSDA<float>;
+template class MEDCoupling::MEDFileField1TSTemplateWithoutSDA<double>;
+template class MEDCoupling::MEDFileField1TSNDTemplateWithoutSDA<int>;
+template class MEDCoupling::MEDFileField1TSNDTemplateWithoutSDA<float>;
+template class MEDCoupling::MEDFileTemplateField1TS<int>;
+template class MEDCoupling::MEDFileTemplateField1TS<float>;
+template class MEDCoupling::MEDFileTemplateField1TS<double>;
+template class MEDCoupling::MEDFileNDTemplateField1TS<int>;
+template class MEDCoupling::MEDFileNDTemplateField1TS<float>;
+
+const char MEDFileField1TSWithoutSDA::TYPE_STR[]="FLOAT64";
+const char MEDFileIntField1TSWithoutSDA::TYPE_STR[]="INT32";
+const char MEDFileFloatField1TSWithoutSDA::TYPE_STR[]="FLOAT32";
+
+//= MEDFileAnyTypeField1TSWithoutSDA
+
+void MEDFileAnyTypeField1TSWithoutSDA::deepCpyLeavesFrom(const MEDFileAnyTypeField1TSWithoutSDA& other)
+{
+  _field_per_mesh.resize(other._field_per_mesh.size());
+  std::size_t i=0;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=other._field_per_mesh.begin();it!=other._field_per_mesh.end();it++,i++)
+    {
+      if((const MEDFileFieldPerMesh *)*it)
+        _field_per_mesh[i]=(*it)->deepCopy(this);
+    }
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::accept(MEDFileFieldVisitor& visitor) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      {
+        visitor.newMeshEntry(*it);
+        (*it)->accept(visitor);
+        visitor.endMeshEntry(*it);
+      }
+}
+
+/*!
+ * Prints a string describing \a this field into a stream. This string is outputted 
+ * by \c print Python command.
+ *  \param [in] bkOffset - number of white spaces printed at the beginning of each line.
+ *  \param [in,out] oss - the out stream.
+ *  \param [in] f1tsId - the field index within a MED file. If \a f1tsId < 0, the tiny
+ *          info id printed, else, not.
+ */
+void MEDFileAnyTypeField1TSWithoutSDA::simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const
+{
+  std::string startOfLine(bkOffset,' ');
+  oss << startOfLine << "Field ";
+  if(bkOffset==0)
+    oss << "[Type=" << getTypeStr() << "] with name \"" << getName() << "\" ";
+  oss << "on one time Step ";
+  if(f1tsId>=0)
+    oss << "(" << f1tsId << ") ";
+  oss << "on iteration=" << _iteration << " order=" << _order << "." << std::endl;
+  oss << startOfLine << "Time attached is : " << _dt << " [" << _dt_unit << "]." << std::endl;
+  const DataArray *arr=getUndergroundDataArray();
+  if(arr)
+    {
+      const std::vector<std::string> &comps=arr->getInfoOnComponents();
+      if(f1tsId<0)
+        {
+          oss << startOfLine << "Field has " << comps.size() << " components with the following infos :" << std::endl;
+          for(std::vector<std::string>::const_iterator it=comps.begin();it!=comps.end();it++)
+            oss << startOfLine << "  -  \"" << (*it) << "\"" << std::endl;
+        }
+      if(arr->isAllocated())
+        {
+          oss << startOfLine << "Whole field contains " << arr->getNumberOfTuples() << " tuples." << std::endl;
+        }
+      else
+        oss << startOfLine << "The array of the current field has not allocated yet !" << std::endl;
+    }
+  else
+    {
+      oss << startOfLine << "Field infos are empty ! Not defined yet !" << std::endl;
+    }
+  oss << startOfLine << "----------------------" << std::endl;
+  if(!_field_per_mesh.empty())
+    {
+      int i=0;
+      for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it2=_field_per_mesh.begin();it2!=_field_per_mesh.end();it2++,i++)
+        {
+          const MEDFileFieldPerMesh *cur=(*it2);
+          if(cur)
+            cur->simpleRepr(bkOffset,oss,i);
+          else
+            oss << startOfLine << "Field per mesh #" << i << " is not defined !" << std::endl;
+        }
+    }
+  else
+    {
+      oss << startOfLine << "Field is not defined on any meshes !" << std::endl;
+    }
+  oss << startOfLine << "----------------------" << std::endl;
+}
+
+std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > MEDFileAnyTypeField1TSWithoutSDA::splitComponents() const
+{
+  const DataArray *arr(getUndergroundDataArray());
+  if(!arr)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::splitComponents : no array defined !");
+  int nbOfCompo=arr->getNumberOfComponents();
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret(nbOfCompo);
+  for(int i=0;i<nbOfCompo;i++)
+    {
+      ret[i]=deepCopy();
+      std::vector<int> v(1,i);
+      MCAuto<DataArray> arr2=arr->keepSelectedComponents(v);
+      ret[i]->setArray(arr2);
+    }
+  return ret;
+}
+
+MEDFileAnyTypeField1TSWithoutSDA::MEDFileAnyTypeField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order):MEDFileFieldNameScope(fieldName,meshName),_iteration(iteration),_order(order),_csit(csit),_nb_of_tuples_to_be_allocated(-2)
+{
+}
+
+MEDFileAnyTypeField1TSWithoutSDA::MEDFileAnyTypeField1TSWithoutSDA():_iteration(-1),_order(-1),_dt(0.),_csit(-1),_nb_of_tuples_to_be_allocated(-1)
+{
+}
+
+/*!
+ * Returns the maximal dimension of supporting elements. Returns -2 if \a this is
+ * empty. Returns -1 if this in on nodes.
+ *  \return int - the dimension of \a this.
+ */
+int MEDFileAnyTypeField1TSWithoutSDA::getDimension() const
+{
+  int ret=-2;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    (*it)->getDimension(ret);
+  return ret;
+}
+
+bool MEDFileAnyTypeField1TSWithoutSDA::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
+{
+  bool ret=false;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      MEDFileFieldPerMesh *cur(*it);
+      if(cur)
+        ret=cur->changeMeshNames(modifTab) || ret;
+    }
+  return ret;
+}
+
+/*!
+ * Returns the number of iteration of the state of underlying mesh.
+ *  \return int - the iteration number.
+ *  \throw If \c _field_per_mesh.empty()
+ */
+int MEDFileAnyTypeField1TSWithoutSDA::getMeshIteration() const
+{
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::getMeshIteration : No field set !");
+  return _field_per_mesh[0]->getMeshIteration();
+}
+
+/*!
+ * Returns the order number of iteration of the state of underlying mesh.
+ *  \return int - the order number.
+ *  \throw If \c _field_per_mesh.empty()
+ */
+int MEDFileAnyTypeField1TSWithoutSDA::getMeshOrder() const
+{
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::getMeshOrder : No field set !");
+  return _field_per_mesh[0]->getMeshOrder();
+}
+
+/*!
+ * Checks if \a this field is tagged by a given iteration number and a given
+ * iteration order number.
+ *  \param [in] iteration - the iteration number of interest.
+ *  \param [in] order - the iteration order number of interest.
+ *  \return bool - \c true if \a this->getIteration() == \a iteration && 
+ *          \a this->getOrder() == \a order.
+ */
+bool MEDFileAnyTypeField1TSWithoutSDA::isDealingTS(int iteration, int order) const
+{
+  return iteration==_iteration && order==_order;
+}
+
+/*!
+ * Returns number of iteration and order number of iteration when
+ * \a this field has been calculated.
+ *  \return std::pair<int,int> - a pair of the iteration number and the iteration
+ *          order number.
+ */
+std::pair<int,int> MEDFileAnyTypeField1TSWithoutSDA::getDtIt() const
+{
+  std::pair<int,int> p;
+  fillIteration(p);
+  return p;
+}
+
+/*!
+ * Returns number of iteration and order number of iteration when
+ * \a this field has been calculated.
+ *  \param [in,out] p - a pair returning the iteration number and the iteration
+ *          order number.
+ */
+void MEDFileAnyTypeField1TSWithoutSDA::fillIteration(std::pair<int,int>& p) const
+{
+  p.first=_iteration;
+  p.second=_order;
+}
+
+/*!
+ * Returns all types of spatial discretization of \a this field.
+ *  \param [in,out] types - a sequence of types of \a this field.
+ */
+void MEDFileAnyTypeField1TSWithoutSDA::fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const
+{
+  std::set<TypeOfField> types2;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      (*it)->fillTypesOfFieldAvailable(types2);
+    }
+  std::back_insert_iterator< std::vector<TypeOfField> > bi(types);
+  std::copy(types2.begin(),types2.end(),bi);
+}
+
+/*!
+ * Returns all types of spatial discretization of \a this field.
+ *  \return std::vector<TypeOfField> - a sequence of types of spatial discretization
+ *          of \a this field.
+ */
+std::vector<TypeOfField> MEDFileAnyTypeField1TSWithoutSDA::getTypesOfFieldAvailable() const
+{
+  std::vector<TypeOfField> ret;
+  fillTypesOfFieldAvailable(ret);
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getPflsReallyUsed2() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getPflsReallyUsed();
+      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
+        if(ret2.find(*it2)==ret2.end())
+          {
+            ret.push_back(*it2);
+            ret2.insert(*it2);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getLocsReallyUsed2() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getLocsReallyUsed();
+      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
+        if(ret2.find(*it2)==ret2.end())
+          {
+            ret.push_back(*it2);
+            ret2.insert(*it2);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getPflsReallyUsedMulti2() const
+{
+  std::vector<std::string> ret;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getPflsReallyUsedMulti();
+      ret.insert(ret.end(),tmp.begin(),tmp.end());
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getLocsReallyUsedMulti2() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getLocsReallyUsedMulti();
+      ret.insert(ret.end(),tmp.begin(),tmp.end());
+    }
+  return ret;
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    (*it)->changePflsRefsNamesGen(mapOfModif);
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    (*it)->changeLocsRefsNamesGen(mapOfModif);
+}
+
+/*!
+ * Returns all attributes of parts of \a this field lying on a given mesh.
+ * Each part differs from other ones by a type of supporting mesh entity. The _i_-th
+ * item of every of returned sequences refers to the _i_-th part of \a this field.
+ * Thus all sequences returned by this method are of the same length equal to number
+ * of different types of supporting entities.<br>
+ * A field part can include sub-parts with several different spatial discretizations,
+ * \ref MEDCoupling::ON_CELLS "ON_CELLS" and \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT"
+ * for example. Hence, some of the returned sequences contains nested sequences, and an item
+ * of a nested sequence corresponds to a type of spatial discretization.<br>
+ * This method allows for iteration over MEDFile DataStructure without any overhead.
+ *  \param [in] mname - a name of a mesh of interest. It can be \c NULL, which is valid
+ *          for the case with only one underlying mesh. (Actually, the number of meshes is
+ *          not checked if \a mname == \c NULL).
+ *  \param [in,out] types - a sequence of types of underlying mesh entities. A type per
+ *          a field part is returned. 
+ *  \param [in,out] typesF - a sequence of sequences of types of spatial discretizations.
+ *          This sequence is of the same length as \a types. 
+ *  \param [in,out] pfls - a sequence returning a profile name per each type of spatial
+ *          discretization. A profile name can be empty.
+ *          Length of this and of nested sequences is the same as that of \a typesF.
+ *  \param [in,out] locs - a sequence returning a localization name per each type of spatial
+ *          discretization. A localization name can be empty.
+ *          Length of this and of nested sequences is the same as that of \a typesF.
+ *  \return std::vector< std::vector< std::pair<int,int> > > - a sequence holding a range
+ *          of ids of tuples within the data array, per each type of spatial
+ *          discretization within one mesh entity type. 
+ *          Length of this and of nested sequences is the same as that of \a typesF.
+ *  \throw If no field is lying on \a mname.
+ */
+std::vector< std::vector< std::pair<int,int> > > MEDFileAnyTypeField1TSWithoutSDA::getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldSplitedByType : This is empty !");
+  return _field_per_mesh[0]->getFieldSplitedByType(types,typesF,pfls,locs);
+}
+
+/*!
+ * Returns dimensions of mesh elements \a this field lies on. The returned value is a
+ * maximal absolute dimension and values returned via the out parameter \a levs are 
+ * dimensions relative to the maximal absolute dimension. <br>
+ * This method is designed for MEDFileField1TS instances that have a discretization
+ * \ref MEDCoupling::ON_CELLS "ON_CELLS", 
+ * \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT", 
+ * \ref MEDCoupling::ON_GAUSS_NE "ON_GAUSS_NE".
+ * Only these 3 discretizations will be taken into account here. If \a this is
+ * \ref MEDCoupling::ON_NODES "ON_NODES", -1 is returned and \a levs are empty.<br>
+ * This method is useful to make the link between the dimension of the underlying mesh
+ * and the levels of \a this, because it is possible that the highest dimension of \a this
+ * field is not equal to the dimension of the underlying mesh.
+ * 
+ * Let's consider the following case:
+ * - mesh \a m1 has a meshDimension 3 and has non empty levels [0,-1,-2] with elements
+ * TETRA4, HEXA8, TRI3 and SEG2.
+ * - field \a f1 lies on \a m1 and is defined on 3D and 1D elements TETRA4 and SEG2.
+ * - field \a f2 lies on \a m1 and is defined on 2D and 1D elements TRI3 and SEG2.
+ *
+ * In this case \a f1->getNonEmptyLevels() returns (3,[0,-2]) and \a
+ * f2->getNonEmptyLevels() returns (2,[0,-1]). <br>
+ * The returned values can be used for example to retrieve a MEDCouplingFieldDouble lying
+ * on elements of a certain relative level by calling getFieldAtLevel(). \a meshDimRelToMax
+ * parameter of getFieldAtLevel() is computed basing on the returned values as this:
+ * <em> meshDimRelToMax = absDim - meshDim + relativeLev </em>.
+ * For example<br>
+ * to retrieve the highest level of
+ * \a f1: <em>f1->getFieldAtLevel( ON_CELLS, 3-3+0 ); // absDim - meshDim + relativeLev</em><br> 
+ * to retrieve the lowest level of \a f1: <em>f1->getFieldAtLevel( ON_CELLS, 3-3+(-2) );</em><br>
+ * to retrieve the highest level of \a f2: <em>f2->getFieldAtLevel( ON_CELLS, 2-3+0 );</em><br>
+ * to retrieve the lowest level of \a f2: <em>f2->getFieldAtLevel( ON_CELLS, 2-3+(-1) )</em>.
+ *  \param [in] mname - a name of a mesh of interest. It can be \c NULL, which is valid
+ *          for the case with only one underlying mesh. (Actually, the number of meshes is
+ *          not checked if \a mname == \c NULL).
+ *  \param [in,out] levs - a sequence returning the dimensions relative to the maximal
+ *          absolute one. They are in decreasing order. This sequence is cleared before
+ *          filling it in.
+ *  \return int - the maximal absolute dimension of elements \a this fields lies on.
+ *  \throw If no field is lying on \a mname.
+ */
+int MEDFileAnyTypeField1TSWithoutSDA::getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const
+{
+  levs.clear();
+  std::vector<INTERP_KERNEL::NormalizedCellType> types;
+  std::vector< std::vector<TypeOfField> > typesF;
+  std::vector< std::vector<std::string> > pfls, locs;
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getNonEmptyLevels : This is empty !");
+  _field_per_mesh[0]->getFieldSplitedByType(types,typesF,pfls,locs);
+  if(types.empty())
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getNonEmptyLevels : 'this' is empty !");
+  std::set<INTERP_KERNEL::NormalizedCellType> st(types.begin(),types.end());
+  if(st.size()==1 && (*st.begin())==INTERP_KERNEL::NORM_ERROR)
+    return -1;
+  st.erase(INTERP_KERNEL::NORM_ERROR);
+  std::set<int> ret1;
+  for(std::set<INTERP_KERNEL::NormalizedCellType>::const_iterator it=st.begin();it!=st.end();it++)
+    {
+      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(*it);
+      ret1.insert((int)cm.getDimension());
+    }
+  int ret=*std::max_element(ret1.begin(),ret1.end());
+  std::copy(ret1.rbegin(),ret1.rend(),std::back_insert_iterator<std::vector<int> >(levs));
+  std::transform(levs.begin(),levs.end(),levs.begin(),std::bind2nd(std::plus<int>(),-ret));
+  return ret;
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::convertMedBallIntoClassic()
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it<_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      (*it)->convertMedBallIntoClassic();
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl)
+{
+  if(!pfl)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : null pfl !");
+  std::string name(pfl->getName());
+  pfl->checkAllocated();
+  if(pfl->getNumberOfComponents()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : non mono compo array !");
+  if(name.empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : empty pfl name !");
+  if(_field_per_mesh.size()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : only single mesh supported !");
+  MCAuto<MEDFileFieldPerMesh> fpm(_field_per_mesh[0]);
+  if(fpm.isNull())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : only single not null mesh supported !");
+  MEDFileFieldPerMeshPerTypePerDisc *disc(fpm->getLeafGivenTypeAndLocId(ct,0));
+  if(disc->getType()!=tof)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : error !");
+  int s(disc->getStart()),e(disc->getEnd()),nt(pfl->getNumberOfTuples());
+  DataArray *arr(getUndergroundDataArray());
+  int nt2(arr->getNumberOfTuples()),delta((e-s)-nt);
+  if(delta<0)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : internal error !");
+  MCAuto<DataArray> arr0(arr->selectByTupleIdSafeSlice(0,s,1)),arr1(arr->selectByTupleIdSafeSlice(s,e,1)),arr2(arr->selectByTupleIdSafeSlice(e,nt2,1));
+  MCAuto<DataArray> arr11(arr1->selectByTupleIdSafe(pfl->begin(),pfl->end()));
+  MCAuto<DataArray> arrOut(arr->buildNewEmptyInstance());
+  arrOut->alloc(nt2-delta,arr->getNumberOfComponents());
+  arrOut->copyStringInfoFrom(*arr);
+  arrOut->setContigPartOfSelectedValuesSlice(0,arr0,0,s,1);
+  arrOut->setContigPartOfSelectedValuesSlice(s,arr11,0,nt,1);
+  arrOut->setContigPartOfSelectedValuesSlice(e-delta,arr2,0,nt2-e,1);
+  setArray(arrOut);
+  disc->setEnd(e-delta);
+  disc->setProfile(name);
+}
+
+/*!
+ * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
+ * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
+ * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
+ *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
+ */
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId)
+{
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId : This is empty !");
+  return _field_per_mesh[0]->getLeafGivenTypeAndLocId(typ,locId);
+}
+
+/*!
+ * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
+ * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
+ * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
+ *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
+ */
+const MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const
+{
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId : This is empty !");
+  return _field_per_mesh[0]->getLeafGivenTypeAndLocId(typ,locId);
+}
+
+/*!
+ * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
+ */
+int MEDFileAnyTypeField1TSWithoutSDA::getMeshIdFromMeshName(const std::string& mName) const
+{
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getMeshIdFromMeshName : No field set !");
+  if(mName.empty())
+    return 0;
+  std::string mName2(mName);
+  int ret=0;
+  std::vector<std::string> msg;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++,ret++)
+    if(mName2==(*it)->getMeshName())
+      return ret;
+    else
+      msg.push_back((*it)->getMeshName());
+  std::ostringstream oss; oss << "MEDFileField1TSWithoutSDA::getMeshIdFromMeshName : No such mesh \"" << mName2 << "\" as underlying mesh of field \"" << getName() << "\" !\n";
+  oss << "Possible meshes are : ";
+  for(std::vector<std::string>::const_iterator it2=msg.begin();it2!=msg.end();it2++)
+    oss << "\"" << (*it2) << "\" ";
+  throw INTERP_KERNEL::Exception(oss.str());
+}
+
+int MEDFileAnyTypeField1TSWithoutSDA::addNewEntryIfNecessary(const MEDCouplingMesh *mesh)
+{
+  if(!mesh)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::addNewEntryIfNecessary : input mesh is NULL !");
+  std::string tmp(mesh->getName());
+  if(tmp.empty())
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::addNewEntryIfNecessary : empty mesh name ! unsupported by MED file !");
+  setMeshName(tmp);
+  std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();
+  int i=0;
+  for(;it!=_field_per_mesh.end();it++,i++)
+    {
+      if((*it)->getMeshName()==tmp)
+        return i;
+    }
+  int sz=_field_per_mesh.size();
+  _field_per_mesh.resize(sz+1);
+  _field_per_mesh[sz]=MEDFileFieldPerMesh::New(this,mesh);
+  return sz;
+}
+
+bool MEDFileAnyTypeField1TSWithoutSDA::renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N,
+                                                                   MEDFileFieldGlobsReal& glob)
+{
+  bool ret=false;
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      MEDFileFieldPerMesh *fpm(*it);
+      if(fpm)
+        ret=fpm->renumberEntitiesLyingOnMesh(meshName,oldCode,newCode,renumO2N,glob) || ret;
+    }
+  return ret;
+}
+
+/*!
+ * This method splits \a this into several sub-parts so that each sub parts have exactly one spatial discretization. This method implements the minimal
+ * splitting that leads to single spatial discretization of this.
+ *
+ * \sa splitMultiDiscrPerGeoTypes
+ */
+std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > MEDFileAnyTypeField1TSWithoutSDA::splitDiscretizations() const
+{
+  std::vector<INTERP_KERNEL::NormalizedCellType> types;
+  std::vector< std::vector<TypeOfField> > typesF;
+  std::vector< std::vector<std::string> > pfls,locs;
+  std::vector< std::vector<std::pair<int,int> > > bgEnd(getFieldSplitedByType(getMeshName().c_str(),types,typesF,pfls,locs));
+  std::set<TypeOfField> allEnt;
+  for(std::vector< std::vector<TypeOfField> >::const_iterator it1=typesF.begin();it1!=typesF.end();it1++)
+    for(std::vector<TypeOfField>::const_iterator it2=(*it1).begin();it2!=(*it1).end();it2++)
+      allEnt.insert(*it2);
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret(allEnt.size());
+  std::set<TypeOfField>::const_iterator it3(allEnt.begin());
+  for(std::size_t i=0;i<allEnt.size();i++,it3++)
+    {
+      std::vector< std::pair<int,int> > its;
+      ret[i]=shallowCpy();
+      int newLgth(ret[i]->keepOnlySpatialDiscretization(*it3,its));
+      ret[i]->updateData(newLgth,its);
+    }
+  return ret;
+}
+
+/*!
+ * This method performs a sub splitting as splitDiscretizations does but finer. This is the finest spliting level that can be done.
+ * This method implements the minimal splitting so that each returned elements are mono Gauss discretization per geometric type.
+ *
+ * \sa splitDiscretizations
+ */
+std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > MEDFileAnyTypeField1TSWithoutSDA::splitMultiDiscrPerGeoTypes() const
+{
+  std::vector<INTERP_KERNEL::NormalizedCellType> types;
+  std::vector< std::vector<TypeOfField> > typesF;
+  std::vector< std::vector<std::string> > pfls,locs;
+  std::vector< std::vector<std::pair<int,int> > > bgEnd(getFieldSplitedByType(getMeshName().c_str(),types,typesF,pfls,locs));
+  std::set<TypeOfField> allEnt;
+  std::size_t nbOfMDPGT(0),ii(0);
+  for(std::vector< std::vector<TypeOfField> >::const_iterator it1=typesF.begin();it1!=typesF.end();it1++,ii++)
+    {
+      nbOfMDPGT=std::max(nbOfMDPGT,locs[ii].size());
+      for(std::vector<TypeOfField>::const_iterator it2=(*it1).begin();it2!=(*it1).end();it2++)
+        allEnt.insert(*it2);
+    }
+  if(allEnt.size()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::splitMultiDiscrPerGeoTypes : this field is expected to be defined only on one spatial discretization !");
+  if(nbOfMDPGT==0)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::splitMultiDiscrPerGeoTypes : empty field !");
+  if(nbOfMDPGT==1)
+    {
+      std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret0(1);
+      ret0[0]=const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(this); this->incrRef();
+      return ret0;
+    }
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret(nbOfMDPGT);
+  for(std::size_t i=0;i<nbOfMDPGT;i++)
+    {
+      std::vector< std::pair<int,int> > its;
+      ret[i]=shallowCpy();
+      int newLgth(ret[i]->keepOnlyGaussDiscretization(i,its));
+      ret[i]->updateData(newLgth,its);
+    }
+  return ret;
+}
+
+int MEDFileAnyTypeField1TSWithoutSDA::keepOnlySpatialDiscretization(TypeOfField tof, std::vector< std::pair<int,int> >& its)
+{
+  int globalCounter(0);
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    (*it)->keepOnlySpatialDiscretization(tof,globalCounter,its);
+  return globalCounter;
+}
+
+int MEDFileAnyTypeField1TSWithoutSDA::keepOnlyGaussDiscretization(std::size_t idOfDisc, std::vector< std::pair<int,int> >& its)
+{
+  int globalCounter(0);
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    (*it)->keepOnlyGaussDiscretization(idOfDisc,globalCounter,its);
+  return globalCounter;
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::updateData(int newLgth, const std::vector< std::pair<int,int> >& oldStartStops)
+{
+  if(_nb_of_tuples_to_be_allocated>=0)
+    {
+      _nb_of_tuples_to_be_allocated=newLgth;
+      const DataArray *oldArr(getUndergroundDataArray());
+      if(oldArr)
+        {
+          MCAuto<DataArray> newArr(createNewEmptyDataArrayInstance());
+          newArr->setInfoAndChangeNbOfCompo(oldArr->getInfoOnComponents());
+          setArray(newArr);
+          _nb_of_tuples_to_be_allocated=newLgth;//force the _nb_of_tuples_to_be_allocated because setArray has been used specialy
+        }
+      return ;
+    }
+  if(_nb_of_tuples_to_be_allocated==-1)
+    return ;
+  if(_nb_of_tuples_to_be_allocated==-2 || _nb_of_tuples_to_be_allocated==-3)
+    {
+      const DataArray *oldArr(getUndergroundDataArray());
+      if(!oldArr || !oldArr->isAllocated())
+        throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::updateData : internal error 1 !");
+      MCAuto<DataArray> newArr(createNewEmptyDataArrayInstance());
+      newArr->alloc(newLgth,getNumberOfComponents());
+      if(oldArr)
+        newArr->copyStringInfoFrom(*oldArr);
+      int pos=0;
+      for(std::vector< std::pair<int,int> >::const_iterator it=oldStartStops.begin();it!=oldStartStops.end();it++)
+        {
+          if((*it).second<(*it).first)
+            throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::updateData : the range in the leaves was invalid !");
+          newArr->setContigPartOfSelectedValuesSlice(pos,oldArr,(*it).first,(*it).second,1);
+          pos+=(*it).second-(*it).first;
+        }
+      setArray(newArr);
+      return ;
+    }
+  throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::updateData : internal error 2 !");
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::writeLL(med_idt fid, const MEDFileWritable& opts, const MEDFileFieldNameScope& nasc) const
+{
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::writeLL : empty field !");
+  if(_field_per_mesh.size()>1)
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::writeLL : In MED3.0 mode in writing mode only ONE underlying mesh supported !");
+  _field_per_mesh[0]->copyOptionsFrom(opts);
+  _field_per_mesh[0]->writeLL(fid,nasc);
+}
+
+/*!
+ * MED file does not support ' ' at the end of the field name. This method corrects the possibly invalid input \a nonCorrectFieldName to a correct one by right stripping input.
+ */
+std::string MEDFileAnyTypeField1TSWithoutSDA::FieldNameToMEDFileConvention(const std::string& nonCorrectFieldName)
+{
+  std::string::size_type pos0(nonCorrectFieldName.find_last_not_of(' '));
+  if(pos0==std::string::npos)
+    return nonCorrectFieldName;
+  if(pos0+1==nonCorrectFieldName.length())
+    return nonCorrectFieldName;
+  return nonCorrectFieldName.substr(0,pos0+1);
+}
+
+/*!
+ * This methods returns true is the allocation has been needed leading to a modification of state in \a this->_nb_of_tuples_to_be_allocated.
+ * If false is returned the memory allocation is not required.
+ */
+bool MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile()
+{
+  if(_nb_of_tuples_to_be_allocated>=0)
+    {
+      getOrCreateAndGetArray()->alloc(_nb_of_tuples_to_be_allocated,getNumberOfComponents());
+      _nb_of_tuples_to_be_allocated=-2;
+      return true;
+    }
+  if(_nb_of_tuples_to_be_allocated==-2 || _nb_of_tuples_to_be_allocated==-3)
+    return false;
+  if(_nb_of_tuples_to_be_allocated==-1)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile : trying to read from a file an empty instance ! Need to prepare the structure before !");
+  if(_nb_of_tuples_to_be_allocated<-3)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile : internal error !");
+  throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile : internal error !");
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::loadOnlyStructureOfDataRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  med_int numdt,numit;
+  med_float dt;
+  med_int meshnumdt,meshnumit;
+  MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,nasc.getName().c_str(),_csit,&numdt,&numit,&_dt));
+  {
+    med_bool localMesh;
+    med_int nmesh;
+    INTERP_KERNEL::AutoPtr<char> meshName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+    MEDFILESAFECALLERRD0(MEDfield23ComputingStepMeshInfo,(fid,nasc.getName().c_str(),_csit,&numdt,&numit,&dt,&nmesh,meshName,&localMesh,&meshnumdt,&meshnumit)); // to check with Adrien for legacy MED files
+  }
+  //MEDFILESAFECALLERRD0(MEDfieldComputingStepMeshInfo,(fid,nasc.getName().c_str(),_csit,&numdt,&numit,&_dt,&meshnumdt,&meshnumit));
+  if(_iteration!=numdt || _order!=numit)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::loadBigArraysRecursively : unexpected exception internal error !");
+  _field_per_mesh.resize(1);
+  //
+  MEDFileMesh *mm(0);
+  if(ms)
+    {
+      mm=ms->getMeshWithName(getMeshName());
+    }
+  //
+  _field_per_mesh[0]=MEDFileFieldPerMesh::NewOnRead(fid,this,0,meshnumdt,meshnumit,nasc,mm,entities);
+  _nb_of_tuples_to_be_allocated=0;
+  _field_per_mesh[0]->loadOnlyStructureOfDataRecursively(fid,_nb_of_tuples_to_be_allocated,nasc);
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
+{
+  allocIfNecessaryTheArrayToReceiveDataFromFile();
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    (*it)->loadBigArraysRecursively(fid,nasc);
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc)
+{
+  if(allocIfNecessaryTheArrayToReceiveDataFromFile())
+    for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+      (*it)->loadBigArraysRecursively(fid,nasc);
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::loadStructureAndBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  loadOnlyStructureOfDataRecursively(fid,nasc,ms,entities);
+  loadBigArraysRecursively(fid,nasc);
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::unloadArrays()
+{
+  DataArray *thisArr(getUndergroundDataArray());
+  if(thisArr && thisArr->isAllocated())
+    {
+      _nb_of_tuples_to_be_allocated=thisArr->getNumberOfTuples();
+      thisArr->desallocate();
+    }
+}
+
+std::size_t MEDFileAnyTypeField1TSWithoutSDA::getHeapMemorySizeWithoutChildren() const
+{
+  return _mesh_name.capacity()+_dt_unit.capacity()+_field_per_mesh.capacity()*sizeof(MCAuto< MEDFileFieldPerMesh >);
+}
+
+std::vector<const BigMemoryObject *> MEDFileAnyTypeField1TSWithoutSDA::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret;
+  if(getUndergroundDataArray())
+    ret.push_back(getUndergroundDataArray());
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    ret.push_back((const MEDFileFieldPerMesh *)*it);
+  return ret;
+}
+
+/*!
+ * Adds a MEDCouplingFieldDouble to \a this. The underlying mesh of the given field is
+ * checked if its elements are sorted suitable for writing to MED file ("STB" stands for
+ * "Sort By Type"), if not, an exception is thrown. 
+ *  \param [in] field - the field to add to \a this. The array of field \a field is ignored
+ *  \param [in] arr - the array of values.
+ *  \param [in,out] glob - the global data where profiles and localization present in
+ *          \a field, if any, are added.
+ *  \throw If the name of \a field is empty.
+ *  \throw If the data array of \a field is not set.
+ *  \throw If \a this->_arr is already allocated but has different number of components
+ *         than \a field.
+ *  \throw If the underlying mesh of \a field has no name.
+ *  \throw If elements in the mesh are not in the order suitable for writing to the MED file.
+ */
+void MEDFileAnyTypeField1TSWithoutSDA::setFieldNoProfileSBT(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  const MEDCouplingMesh *mesh(field->getMesh());
+  //
+  TypeOfField type(field->getTypeOfField());
+  std::vector<DataArrayInt *> dummy;
+  if(mesh)
+    setMeshName(mesh->getName());
+  int start(copyTinyInfoFrom(th,field,arr));
+  int pos(addNewEntryIfNecessary(mesh));
+  if(type!=ON_NODES)
+    {
+      std::vector<int> code=MEDFileField1TSWithoutSDA::CheckSBTMesh(mesh);
+      _field_per_mesh[pos]->assignFieldNoProfileNoRenum(start,code,field,arr,glob,nasc);
+    }
+  else
+    _field_per_mesh[pos]->assignNodeFieldNoProfile(start,field,arr,glob);
+}
+
+/*!
+ * Adds a MEDCouplingFieldDouble to \a this. Specified entities of a given dimension
+ * of a given mesh are used as the support of the given field (a real support is not used). 
+ * Elements of the given mesh must be sorted suitable for writing to MED file. 
+ * Order of underlying mesh entities of the given field specified by \a profile parameter
+ * is not prescribed; this method permutes field values to have them sorted by element
+ * type as required for writing to MED file. A new profile is added only if no equal
+ * profile is missing. 
+ *  \param [in] field - the field to add to \a this. The field double values are ignored.
+ *  \param [in] arrOfVals - the values of the field \a field used.
+ *  \param [in] mesh - the supporting mesh of \a field.
+ *  \param [in] meshDimRelToMax - a relative dimension of mesh entities \a field lies on.
+ *  \param [in] profile - ids of mesh entities on which corresponding field values lie.
+ *  \param [in,out] glob - the global data where profiles and localization present in
+ *          \a field, if any, are added.
+ *  \param [in] nasc - the name scope used to assign names. Depends on the caller on the top call stack
+ *  \param [in] smartPflKiller - specifies if this method tries at most to avoid profiles
+ *  \throw If either \a field or \a mesh or \a profile has an empty name.
+ *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in \a mesh.
+ *  \throw If the data array of \a field is not set.
+ *  \throw If \a this->_arr is already allocated but has different number of components
+ *         than \a field.
+ *  \throw If elements in \a mesh are not in the order suitable for writing to the MED file.
+ *  \sa setFieldNoProfileSBT()
+ */
+void MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arrOfVals, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc, bool smartPflKiller)
+{
+  if(!field)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : input field is null !");
+  if(!arrOfVals || !arrOfVals->isAllocated())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : input array is null or not allocated !");
+  TypeOfField type=field->getTypeOfField();
+  std::vector<DataArrayInt *> idsInPflPerType;
+  std::vector<DataArrayInt *> idsPerType;
+  std::vector<int> code,code2;
+  MCAuto<MEDCouplingMesh> m(mesh->getMeshAtLevel(meshDimRelToMax));
+  if(type!=ON_NODES)
+    {
+      m->splitProfilePerType(profile,code,idsInPflPerType,idsPerType,smartPflKiller);
+      std::vector< MCAuto<DataArrayInt> > idsInPflPerType2(idsInPflPerType.size()); std::copy(idsInPflPerType.begin(),idsInPflPerType.end(),idsInPflPerType2.begin());
+      std::vector< MCAuto<DataArrayInt> > idsPerType2(idsPerType.size()); std::copy(idsPerType.begin(),idsPerType.end(),idsPerType2.begin()); 
+      std::vector<const DataArrayInt *> idsPerType3(idsPerType.size()); std::copy(idsPerType.begin(),idsPerType.end(),idsPerType3.begin());
+      // start of check
+      MCAuto<MEDCouplingFieldTemplate> field2=field->clone(false);
+      int nbOfTuplesExp=field2->getNumberOfTuplesExpectedRegardingCode(code,idsPerType3);
+      if(nbOfTuplesExp!=arrOfVals->getNumberOfTuples())
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : The array is expected to have " << nbOfTuplesExp << " tuples ! It has " << arrOfVals->getNumberOfTuples() << " !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      // end of check
+      int start(copyTinyInfoFrom(th,field,arrOfVals));
+      code2=m->getDistributionOfTypes();
+      //
+      int pos=addNewEntryIfNecessary(m);
+      _field_per_mesh[pos]->assignFieldProfile(start,profile,code,code2,idsInPflPerType,idsPerType,field,arrOfVals,m,glob,nasc);
+    }
+  else
+    {
+      if(!profile || !profile->isAllocated() || profile->getNumberOfComponents()!=1)
+        throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : input profile is null, not allocated or with number of components != 1 !");
+      std::vector<int> v(3); v[0]=-1; v[1]=profile->getNumberOfTuples(); v[2]=0;
+      std::vector<const DataArrayInt *> idsPerType3(1); idsPerType3[0]=profile;
+      int nbOfTuplesExp=field->getNumberOfTuplesExpectedRegardingCode(v,idsPerType3);
+      if(nbOfTuplesExp!=arrOfVals->getNumberOfTuples())
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : For node field, the array is expected to have " << nbOfTuplesExp << " tuples ! It has " << arrOfVals->getNumberOfTuples() << " !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      int start(copyTinyInfoFrom(th,field,arrOfVals));
+      int pos(addNewEntryIfNecessary(m));
+      _field_per_mesh[pos]->assignNodeFieldProfile(start,profile,field,arrOfVals,glob,nasc);
+    }
+}
+
+/*!
+ * \param [in] newNbOfTuples - The new nb of tuples to be allocated.
+ */
+void MEDFileAnyTypeField1TSWithoutSDA::allocNotFromFile(int newNbOfTuples)
+{
+  if(_nb_of_tuples_to_be_allocated>=0)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocNotFromFile : the object is expected to be appended to a data coming from a file but not loaded ! Load before appending data !");
+  DataArray *arr(getOrCreateAndGetArray());
+  arr->alloc(newNbOfTuples,arr->getNumberOfComponents());
+  _nb_of_tuples_to_be_allocated=-3;
+}
+
+/*!
+ * Copies tiny info and allocates \a this->_arr instance of DataArrayDouble to
+ * append data of a given MEDCouplingFieldDouble. So that the size of \a this->_arr becomes
+ * larger by the size of \a field. Returns an id of the first not filled
+ * tuple of \a this->_arr.
+ *  \param [in] field - the field to copy the info on components and the name from.
+ *  \return int - the id of first not initialized tuple of \a this->_arr.
+ *  \throw If the name of \a field is empty.
+ *  \throw If the data array of \a field is not set.
+ *  \throw If \a this->_arr is already allocated but has different number of components
+ *         than \a field.
+ */
+int MEDFileAnyTypeField1TSWithoutSDA::copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr)
+{
+  if(!field)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::copyTinyInfoFrom : input field is NULL !");
+  std::string name(field->getName());
+  setName(name.c_str());
+  if(field->getMesh())
+    setMeshName(field->getMesh()->getName());
+  setDtUnit(th->getTimeUnit());
+  if(name.empty())
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::copyTinyInfoFrom : unsupported fields with no name in MED file !");
+  if(!arr)
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::copyTinyInfoFrom : no array set !");
+  if(!arr->isAllocated())
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::copyTinyInfoFrom : array is not allocated !");
+  _dt=th->getTime(_iteration,_order);
+  getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(arr->getInfoOnComponents());
+  if(!getOrCreateAndGetArray()->isAllocated())
+    {
+      allocNotFromFile(arr->getNumberOfTuples());
+      return 0;
+    }
+  else
+    {
+      int oldNbOfTuples=getOrCreateAndGetArray()->getNumberOfTuples();
+      int newNbOfTuples=oldNbOfTuples+arr->getNumberOfTuples();
+      getOrCreateAndGetArray()->reAlloc(newNbOfTuples);
+      _nb_of_tuples_to_be_allocated=-3;
+      return oldNbOfTuples;
+    }
+}
+
+/*!
+ * Returns number of components in \a this field
+ *  \return int - the number of components.
+ */
+int MEDFileAnyTypeField1TSWithoutSDA::getNumberOfComponents() const
+{
+  return getOrCreateAndGetArray()->getNumberOfComponents();
+}
+
+/*!
+ * Change info on components in \a this.
+ * \throw If size of \a infos is not equal to the number of components already in \a this.
+ */
+void MEDFileAnyTypeField1TSWithoutSDA::setInfo(const std::vector<std::string>& infos)
+{
+  DataArray *arr=getOrCreateAndGetArray();
+  arr->setInfoOnComponents(infos);//will throw an exception if number of components mismatches
+}
+
+/*!
+ * Returns info on components of \a this field.
+ *  \return const std::vector<std::string>& - a sequence of strings each being an
+ *          information on _i_-th component.
+ */
+const std::vector<std::string>& MEDFileAnyTypeField1TSWithoutSDA::getInfo() const
+{
+  const DataArray *arr=getOrCreateAndGetArray();
+  return arr->getInfoOnComponents();
+}
+
+/*!
+ * Returns a mutable info on components of \a this field.
+ *  \return std::vector<std::string>& - a sequence of strings each being an
+ *          information on _i_-th component.
+ */
+std::vector<std::string>& MEDFileAnyTypeField1TSWithoutSDA::getInfo()
+{
+  DataArray *arr=getOrCreateAndGetArray();
+  return arr->getInfoOnComponents();
+}
+
+bool MEDFileAnyTypeField1TSWithoutSDA::presenceOfMultiDiscPerGeoType() const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    {
+      const MEDFileFieldPerMesh *fpm(*it);
+      if(!fpm)
+        continue;
+      if(fpm->presenceOfMultiDiscPerGeoType())
+        return true;
+    }
+  return false;
+}
+
+bool MEDFileAnyTypeField1TSWithoutSDA::presenceOfStructureElements() const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      if((*it)->presenceOfStructureElements())
+        return true;
+  return false;
+}
+
+bool MEDFileAnyTypeField1TSWithoutSDA::onlyStructureElements() const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      if(!(*it)->onlyStructureElements())
+        return false;
+  return true;
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::killStructureElements()
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      (*it)->killStructureElements();
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::keepOnlyStructureElements()
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      (*it)->keepOnlyStructureElements();
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::keepOnlyOnSE(const std::string& seName)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      (*it)->keepOnlyOnSE(seName);
+}
+
+void MEDFileAnyTypeField1TSWithoutSDA::getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
+    if((*it).isNotNull())
+      (*it)->getMeshSENames(ps);
+}
+
+MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh(const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  static const char MSG0[]="MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the field is too complex to be able to be extracted with  \"field\" method ! Call getFieldOnMeshAtLevel method instead to deal with complexity !";
+  if(_field_per_mesh.empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the field is empty ! Nothing to extract !");
+  if(_field_per_mesh.size()>1)
+    throw INTERP_KERNEL::Exception(MSG0);
+  if(_field_per_mesh[0].isNull())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the field is inconsistent !");
+  const MEDFileFieldPerMesh *pm(_field_per_mesh[0]);
+  std::set<TypeOfField> types;
+  pm->fillTypesOfFieldAvailable(types);
+  if(types.size()!=1)
+    throw INTERP_KERNEL::Exception(MSG0);
+  TypeOfField type(*types.begin());
+  int meshDimRelToMax(0);
+  if(type==ON_NODES)
+    meshDimRelToMax=0;
+  else
+    {
+      int myDim(std::numeric_limits<int>::max());
+      bool isUnique(pm->isUniqueLevel(myDim));
+      if(!isUnique)
+        throw INTERP_KERNEL::Exception(MSG0);
+      meshDimRelToMax=myDim-mesh->getMeshDimension();
+      if(meshDimRelToMax>0)
+        throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the mesh attached to field is not compatible with the field !");
+    }
+  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,meshDimRelToMax,0/*renumPol*/,glob,mesh,arrOut,nasc);
+}
+
+/*!
+ * Returns a new MEDCouplingFieldDouble of given type lying on a given support.
+ *  \param [in] type - a spatial discretization of the new field.
+ *  \param [in] meshDimRelToMax - a relative dimension of the supporting mesh entities.
+ *  \param [in] mName - a name of the supporting mesh.
+ *  \param [in] renumPol - specifies how to permute values of the result field according to
+ *          the optional numbers of cells and nodes, if any. The valid values are
+ *          - 0 - do not permute.
+ *          - 1 - permute cells.
+ *          - 2 - permute nodes.
+ *          - 3 - permute cells and nodes.
+ *
+ *  \param [in] glob - the global data storing profiles and localization.
+ *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
+ *          caller is to delete this field using decrRef() as it is no more needed. 
+ *  \throw If the MED file is not readable.
+ *  \throw If there is no mesh named \a mName in the MED file.
+ *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in the mesh.
+ *  \throw If no field of \a this is lying on the mesh \a mName.
+ *  \throw If no field values of the given \a type or given \a meshDimRelToMax are available.
+ */
+MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldAtLevel(TypeOfField type, int meshDimRelToMax, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  MCAuto<MEDFileMesh> mm;
+  if(mName.empty())
+    mm=MEDFileMesh::New(glob->getFileName(),getMeshName().c_str(),getMeshIteration(),getMeshOrder());
+  else
+    mm=MEDFileMesh::New(glob->getFileName(),mName,getMeshIteration(),getMeshOrder());
+  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,meshDimRelToMax,renumPol,glob,mm,arrOut,nasc);
+}
+
+/*!
+ * Returns a new MEDCouplingFieldDouble of given type lying on a given support.
+ *  \param [in] type - a spatial discretization of the new field.
+ *  \param [in] meshDimRelToMax - a relative dimension of the supporting mesh entities.
+ *  \param [in] renumPol - specifies how to permute values of the result field according to
+ *          the optional numbers of cells and nodes, if any. The valid values are
+ *          - 0 - do not permute.
+ *          - 1 - permute cells.
+ *          - 2 - permute nodes.
+ *          - 3 - permute cells and nodes.
+ *
+ *  \param [in] glob - the global data storing profiles and localization.
+ *  \param [in] mesh - the supporting mesh.
+ *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
+ *          caller is to delete this field using decrRef() as it is no more needed. 
+ *  \throw If the MED file is not readable.
+ *  \throw If no field of \a this is lying on \a mesh.
+ *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in the mesh.
+ *  \throw If no field values of the given \a type or given \a meshDimRelToMax are available.
+ */
+MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  MCAuto<MEDCouplingMesh> m(mesh->getMeshAtLevel(meshDimRelToMax,false));
+  const DataArrayInt *d(mesh->getNumberFieldAtLevel(meshDimRelToMax)),*e(mesh->getNumberFieldAtLevel(1));
+  if(meshDimRelToMax==1)
+    (static_cast<MEDCouplingUMesh *>((MEDCouplingMesh *)m))->setMeshDimension(0);
+  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,renumPol,glob,m,d,e,arrOut,nasc);
+}
+
+/*!
+ * Returns a new MEDCouplingFieldDouble of a given type lying on the top level cells of a
+ * given mesh. 
+ *  \param [in] type - a spatial discretization of the new field.
+ *  \param [in] mName - a name of the supporting mesh.
+ *  \param [in] renumPol - specifies how to permute values of the result field according to
+ *          the optional numbers of cells and nodes, if any. The valid values are
+ *          - 0 - do not permute.
+ *          - 1 - permute cells.
+ *          - 2 - permute nodes.
+ *          - 3 - permute cells and nodes.
+ *
+ *  \param [in] glob - the global data storing profiles and localization.
+ *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
+ *          caller is to delete this field using decrRef() as it is no more needed. 
+ *  \throw If the MED file is not readable.
+ *  \throw If there is no mesh named \a mName in the MED file.
+ *  \throw If there are no mesh entities in the mesh.
+ *  \throw If no field values of the given \a type are available.
+ */
+MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldAtTopLevel(TypeOfField type, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  MCAuto<MEDFileMesh> mm;
+  if(mName.empty())
+    mm=MEDFileMesh::New(glob->getFileName(),getMeshName().c_str(),getMeshIteration(),getMeshOrder());
+  else
+    mm=MEDFileMesh::New(glob->getFileName(),mName,getMeshIteration(),getMeshOrder());
+  int absDim=getDimension();
+  int meshDimRelToMax=absDim-mm->getMeshDimension();
+  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,meshDimRelToMax,renumPol,glob,mm,arrOut,nasc);
+}
+
+/*!
+ * Returns a new MEDCouplingFieldDouble of given type lying on a given support.
+ *  \param [in] type - a spatial discretization of the new field.
+ *  \param [in] renumPol - specifies how to permute values of the result field according to
+ *          the optional numbers of cells and nodes, if any. The valid values are
+ *          - 0 - do not permute.
+ *          - 1 - permute cells.
+ *          - 2 - permute nodes.
+ *          - 3 - permute cells and nodes.
+ *
+ *  \param [in] glob - the global data storing profiles and localization.
+ *  \param [in] mesh - the supporting mesh.
+ *  \param [in] cellRenum - the cell numbers array used for permutation of the result
+ *         field according to \a renumPol.
+ *  \param [in] nodeRenum - the node numbers array used for permutation of the result
+ *         field according to \a renumPol.
+ *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
+ *          caller is to delete this field using decrRef() as it is no more needed. 
+ *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in the mesh.
+ *  \throw If no field of \a this is lying on \a mesh.
+ *  \throw If no field values of the given \a type or given \a meshDimRelToMax are available.
+ */
+MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(TypeOfField type, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, const DataArrayInt *cellRenum, const DataArrayInt *nodeRenum, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  static const char msg1[]="MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : request for a renumbered field following mesh numbering whereas it is a profile field !";
+  bool isPfl=false;
+  MCAuto<MEDCouplingFieldDouble> ret=_field_per_mesh[0]->getFieldOnMeshAtLevel(type,glob,mesh,isPfl,arrOut,nasc);
+  switch(renumPol)
+  {
+    case 0:
+      {
+        //no need to test _field_per_mesh.empty() because geMeshName has already done it
+        return ret.retn();
+      }
+    case 3:
+    case 1:
+      {
+        if(isPfl)
+          throw INTERP_KERNEL::Exception(msg1);
+        //no need to test _field_per_mesh.empty() because geMeshName has already done it
+        if(cellRenum)
+          {
+            if((int)cellRenum->getNbOfElems()!=mesh->getNumberOfCells())
+              {
+                std::ostringstream oss; oss << "MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : Request of simple renumbering but it seems that underlying mesh \"" << mesh->getName() << "\" of requested field ";
+                oss << "\"" << getName() << "\" has partial renumbering (some geotype has no renumber) !";
+                throw INTERP_KERNEL::Exception(oss.str());
+              }
+            MEDCouplingFieldDiscretization *disc=ret->getDiscretization();
+            if(!disc) throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel : internal error, no discretization on field !");
+            std::vector<DataArray *> arrOut2(1,arrOut);
+            // 2 following lines replace ret->renumberCells(cellRenum->getConstPointer()) if not DataArrayDouble
+            disc->renumberArraysForCell(ret->getMesh(),arrOut2,cellRenum->getConstPointer(),true);
+            (const_cast<MEDCouplingMesh*>(ret->getMesh()))->renumberCells(cellRenum->getConstPointer(),true);
+          }
+        if(renumPol==1)
+          return ret.retn();
+      }
+    case 2:
+      {
+        //no need to test _field_per_mesh.empty() because geMeshName has already done it
+        if(isPfl)
+          throw INTERP_KERNEL::Exception(msg1);
+        if(nodeRenum)
+          {
+            if((int)nodeRenum->getNbOfElems()!=mesh->getNumberOfNodes())
+              {
+                std::ostringstream oss; oss << "MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : Request of simple renumbering but it seems that underlying mesh \"" << mesh->getName() << "\" of requested field ";
+                oss << "\"" << nasc.getName() << "\" not defined on all nodes !";
+                throw INTERP_KERNEL::Exception(oss.str());
+              }
+            MCAuto<DataArrayInt> nodeRenumSafe=nodeRenum->checkAndPreparePermutation();
+            if(!dynamic_cast<DataArrayDouble *>((DataArray *)arrOut))
+              throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : node renumbering not implemented for not double DataArrays !");
+            ret->renumberNodes(nodeRenumSafe->getConstPointer());
+          }
+        return ret.retn();
+      }
+    default:
+      throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : unsupported renum policy ! Dealing with policy 0 1 2 and 3 !");
+  }
+}
+
+/*!
+ * Returns values and a profile of the field of a given type lying on a given support.
+ *  \param [in] type - a spatial discretization of the field.
+ *  \param [in] meshDimRelToMax - a relative dimension of the supporting mesh entities.
+ *  \param [in] mesh - the supporting mesh.
+ *  \param [out] pfl - a new instance of DataArrayInt holding ids of mesh entities the
+ *          field of interest lies on. If the field lies on all entities of the given
+ *          dimension, all ids in \a pfl are zero. The caller is to delete this array
+ *          using decrRef() as it is no more needed.  
+ *  \param [in] glob - the global data storing profiles and localization.
+ *  \return DataArrayDouble * - a new instance of DataArrayDouble holding values of the
+ *          field. The caller is to delete this array using decrRef() as it is no more needed.
+ *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in \a mesh.
+ *  \throw If no field of \a this is lying on \a mesh.
+ *  \throw If no field values of the given \a type are available.
+ */
+DataArray *MEDFileAnyTypeField1TSWithoutSDA::getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const
+{
+  MCAuto<MEDCouplingMesh> m(mesh->getMeshAtLevel(meshDimRelToMax));
+  MCAuto<DataArray> ret=_field_per_mesh[0]->getFieldOnMeshAtLevelWithPfl(type,m,pfl,glob,nasc);
+  ret->setName(nasc.getName().c_str());
+  return ret.retn();
+}
+
+//= MEDFileField1TSWithoutSDA
+
+/*!
+ * Throws if a given value is not a valid (non-extended) relative dimension.
+ *  \param [in] meshDimRelToMax - the relative dimension value.
+ *  \throw If \a meshDimRelToMax > 0.
+ */
+void MEDFileField1TSWithoutSDA::CheckMeshDimRel(int meshDimRelToMax)
+{
+  if(meshDimRelToMax>0)
+    throw INTERP_KERNEL::Exception("CheckMeshDimRel : This is a meshDimRel not a meshDimRelExt ! So value should be <=0 !");
+}
+
+/*!
+ * Checks if elements of a given mesh are in the order suitable for writing 
+ * to the MED file. If this is not so, an exception is thrown. In a case of success, returns a
+ * vector describing types of elements and their number.
+ *  \param [in] mesh - the mesh to check.
+ *  \return std::vector<int> - a vector holding for each element type (1) item of
+ *          INTERP_KERNEL::NormalizedCellType, (2) number of elements, (3) -1. 
+ *          These values are in full-interlace mode.
+ *  \throw If elements in \a mesh are not in the order suitable for writing to the MED file.
+ */
+std::vector<int> MEDFileField1TSWithoutSDA::CheckSBTMesh(const MEDCouplingMesh *mesh)
+{
+  if(!mesh)
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::CheckSBTMesh : input mesh is NULL !");
+  std::set<INTERP_KERNEL::NormalizedCellType> geoTypes=mesh->getAllGeoTypes();
+  int nbOfTypes=geoTypes.size();
+  std::vector<int> code(3*nbOfTypes);
+  MCAuto<DataArrayInt> arr1=DataArrayInt::New();
+  arr1->alloc(nbOfTypes,1);
+  int *arrPtr=arr1->getPointer();
+  std::set<INTERP_KERNEL::NormalizedCellType>::const_iterator it=geoTypes.begin();
+  for(int i=0;i<nbOfTypes;i++,it++)
+    arrPtr[i]=std::distance(typmai2,std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,*it));
+  MCAuto<DataArrayInt> arr2=arr1->checkAndPreparePermutation();
+  const int *arrPtr2=arr2->getConstPointer();
+  int i=0;
+  for(it=geoTypes.begin();it!=geoTypes.end();it++,i++)
+    {
+      int pos=arrPtr2[i];
+      int nbCells=mesh->getNumberOfCellsWithType(*it);
+      code[3*pos]=(int)(*it);
+      code[3*pos+1]=nbCells;
+      code[3*pos+2]=-1;//no profiles
+    }
+  std::vector<const DataArrayInt *> idsPerType;//no profiles
+  DataArrayInt *da=mesh->checkTypeConsistencyAndContig(code,idsPerType);
+  if(da)
+    {
+      da->decrRef();
+      throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::CheckSBTMesh : underlying mesh is not sorted by type as MED file expects !");
+    }
+  return code;
+}
+
+MEDFileField1TSWithoutSDA *MEDFileField1TSWithoutSDA::New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos)
+{
+  return new MEDFileField1TSWithoutSDA(fieldName,meshName,csit,iteration,order,infos);
+}
+
+/*!
+ * Returns all attributes and values of parts of \a this field lying on a given mesh.
+ * Each part differs from other ones by a type of supporting mesh entity. The _i_-th
+ * item of every of returned sequences refers to the _i_-th part of \a this field.
+ * Thus all sequences returned by this method are of the same length equal to number
+ * of different types of supporting entities.<br>
+ * A field part can include sub-parts with several different spatial discretizations,
+ * \ref MEDCoupling::ON_CELLS "ON_CELLS" and \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT"
+ * for example. Hence, some of the returned sequences contains nested sequences, and an item
+ * of a nested sequence corresponds to a type of spatial discretization.<br>
+ * This method allows for iteration over MEDFile DataStructure with a reduced overhead.
+ * The overhead is due to selecting values into new instances of DataArrayDouble.
+ *  \param [in] mname - a name of a mesh of interest. It can be \c NULL, which is valid
+ *          for the case with only one underlying mesh. (Actually, the number of meshes is
+ *          not checked if \a mname == \c NULL).
+ *  \param [in,out] types - a sequence of types of underlying mesh entities. A type per
+ *          a field part is returned. 
+ *  \param [in,out] typesF - a sequence of sequences of types of spatial discretizations.
+ *          A field part can include sub-parts with several different spatial discretizations,
+ *          \ref MEDCoupling::ON_CELLS "ON_CELLS" and 
+ *          \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT" for example.
+ *          This sequence is of the same length as \a types. 
+ *  \param [in,out] pfls - a sequence returning a profile name per each type of spatial
+ *          discretization. A profile name can be empty.
+ *          Length of this and of nested sequences is the same as that of \a typesF.
+ *  \param [in,out] locs - a sequence returning a localization name per each type of spatial
+ *          discretization. A localization name can be empty.
+ *          Length of this and of nested sequences is the same as that of \a typesF.
+ *  \return std::vector< std::vector<DataArrayDouble *> > - a sequence holding arrays of values
+ *          per each type of spatial discretization within one mesh entity type.
+ *          The caller is to delete each DataArrayDouble using decrRef() as it is no more needed.
+ *          Length of this and of nested sequences is the same as that of \a typesF.
+ *  \throw If no field is lying on \a mname.
+ */
+std::vector< std::vector<DataArrayDouble *> > MEDFileField1TSWithoutSDA::getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  if(mname.empty())
+    if(_field_per_mesh.empty())
+      throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldSplitedByType : This is empty !");
+  std::vector< std::vector< std::pair<int,int> > > ret0=_field_per_mesh[0]->getFieldSplitedByType(types,typesF,pfls,locs);
+  int nbOfRet=ret0.size();
+  std::vector< std::vector<DataArrayDouble *> > ret(nbOfRet);
+  for(int i=0;i<nbOfRet;i++)
+    {
+      const std::vector< std::pair<int,int> >& p=ret0[i];
+      int nbOfRet1=p.size();
+      ret[i].resize(nbOfRet1);
+      for(int j=0;j<nbOfRet1;j++)
+        {
+          DataArrayDouble *tmp=_arr->selectByTupleIdSafeSlice(p[j].first,p[j].second,1);
+          ret[i][j]=tmp;
+        }
+    }
+  return ret;
+}
+
+const char *MEDFileField1TSWithoutSDA::getTypeStr() const
+{
+  return TYPE_STR;
+}
+
+MEDFileIntField1TSWithoutSDA *MEDFileField1TSWithoutSDA::convertToInt() const
+{
+  MCAuto<MEDFileIntField1TSWithoutSDA> ret(new MEDFileIntField1TSWithoutSDA);
+  ret->MEDFileAnyTypeField1TSWithoutSDA::operator =(*this);
+  ret->deepCpyLeavesFrom(*this);
+  const DataArrayDouble *arr(_arr);
+  if(arr)
+    {
+      MCAuto<DataArrayInt> arr2(arr->convertToIntArr());
+      ret->setArray(arr2);
+    }
+  return ret.retn();
+}
+
+/*!
+ * Returns a pointer to the underground DataArrayDouble instance and a
+ * sequence describing parameters of a support of each part of \a this field. The
+ * caller should not decrRef() the returned DataArrayDouble. This method allows for a
+ * direct access to the field values. This method is intended for the field lying on one
+ * mesh only.
+ *  \param [in,out] entries - the sequence describing parameters of a support of each
+ *         part of \a this field. Each item of this sequence consists of two parts. The
+ *         first part describes a type of mesh entity and an id of discretization of a
+ *         current field part. The second part describes a range of values [begin,end)
+ *         within the returned array relating to the current field part.
+ *  \return DataArrayDouble * - the pointer to the field values array.
+ *  \throw If the number of underlying meshes is not equal to 1.
+ *  \throw If no field values are available.
+ *  \sa getUndergroundDataArray()
+ */
+DataArray *MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  return getUndergroundDataArrayTemplateExt(entries);
+}
+
+MEDFileField1TSWithoutSDA::MEDFileField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos):MEDFileField1TSTemplateWithoutSDA<double>(fieldName,meshName,csit,iteration,order)
+{
+  DataArrayDouble *arr(getOrCreateAndGetArrayTemplate());
+  arr->setInfoAndChangeNbOfCompo(infos);
+}
+
+MEDFileField1TSWithoutSDA::MEDFileField1TSWithoutSDA():MEDFileField1TSTemplateWithoutSDA<double>()
+{
+}
+
+MEDFileField1TSWithoutSDA *MEDFileField1TSWithoutSDA::shallowCpy() const
+{
+  MCAuto<MEDFileField1TSWithoutSDA> ret(new MEDFileField1TSWithoutSDA(*this));
+  ret->deepCpyLeavesFrom(*this);
+  return ret.retn();
+}
+
+MEDFileField1TSWithoutSDA *MEDFileField1TSWithoutSDA::deepCopy() const
+{
+  MCAuto<MEDFileField1TSWithoutSDA> ret(shallowCpy());
+  if(_arr.isNotNull())
+    ret->_arr=_arr->deepCopy();
+  return ret.retn();
+}
+
+//= MEDFileIntField1TSWithoutSDA
+
+MEDFileIntField1TSWithoutSDA *MEDFileIntField1TSWithoutSDA::New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos)
+{
+  return new MEDFileIntField1TSWithoutSDA(fieldName,meshName,csit,iteration,order,infos);
+}
+
+MEDFileIntField1TSWithoutSDA::MEDFileIntField1TSWithoutSDA()
+{
+}
+
+MEDFileIntField1TSWithoutSDA::MEDFileIntField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order,
+                                                           const std::vector<std::string>& infos):MEDFileField1TSNDTemplateWithoutSDA<int>(fieldName,meshName,csit,iteration,order,infos)
+{
+  DataArrayInt *arr(getOrCreateAndGetArrayTemplate());
+  arr->setInfoAndChangeNbOfCompo(infos);
+}
+
+const char *MEDFileIntField1TSWithoutSDA::getTypeStr() const
+{
+  return TYPE_STR;
+}
+
+/*!
+ * Returns a pointer to the underground DataArrayInt instance and a
+ * sequence describing parameters of a support of each part of \a this field. The
+ * caller should not decrRef() the returned DataArrayInt. This method allows for a
+ * direct access to the field values. This method is intended for the field lying on one
+ * mesh only.
+ *  \param [in,out] entries - the sequence describing parameters of a support of each
+ *         part of \a this field. Each item of this sequence consists of two parts. The
+ *         first part describes a type of mesh entity and an id of discretization of a
+ *         current field part. The second part describes a range of values [begin,end)
+ *         within the returned array relating to the current field part.
+ *  \return DataArrayInt * - the pointer to the field values array.
+ *  \throw If the number of underlying meshes is not equal to 1.
+ *  \throw If no field values are available.
+ *  \sa getUndergroundDataArray()
+ */
+DataArray *MEDFileIntField1TSWithoutSDA::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  return getUndergroundDataArrayIntExt(entries);
+}
+
+/*!
+ * Returns a pointer to the underground DataArrayInt instance and a
+ * sequence describing parameters of a support of each part of \a this field. The
+ * caller should not decrRef() the returned DataArrayInt. This method allows for a
+ * direct access to the field values. This method is intended for the field lying on one
+ * mesh only.
+ *  \param [in,out] entries - the sequence describing parameters of a support of each
+ *         part of \a this field. Each item of this sequence consists of two parts. The
+ *         first part describes a type of mesh entity and an id of discretization of a
+ *         current field part. The second part describes a range of values [begin,end)
+ *         within the returned array relating to the current field part.
+ *  \return DataArrayInt * - the pointer to the field values array.
+ *  \throw If the number of underlying meshes is not equal to 1.
+ *  \throw If no field values are available.
+ *  \sa getUndergroundDataArray()
+ */
+DataArrayInt *MEDFileIntField1TSWithoutSDA::getUndergroundDataArrayIntExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  if(_field_per_mesh.size()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : field lies on several meshes, this method has no sense !");
+  if(_field_per_mesh[0]==0)
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : no field specified !");
+  _field_per_mesh[0]->getUndergroundDataArrayExt(entries);
+  return getUndergroundDataArrayTemplate();
+}
+
+MEDFileIntField1TSWithoutSDA *MEDFileIntField1TSWithoutSDA::shallowCpy() const
+{
+  MCAuto<MEDFileIntField1TSWithoutSDA> ret(new MEDFileIntField1TSWithoutSDA(*this));
+  ret->deepCpyLeavesFrom(*this);
+  return ret.retn();
+}
+
+MEDFileIntField1TSWithoutSDA *MEDFileIntField1TSWithoutSDA::deepCopy() const
+{
+  MCAuto<MEDFileIntField1TSWithoutSDA> ret(shallowCpy());
+  if(_arr.isNotNull())
+    ret->_arr=_arr->deepCopy();
+  return ret.retn();
+}
+
+//= MEDFileFloatField1TSWithoutSDA
+
+MEDFileFloatField1TSWithoutSDA *MEDFileFloatField1TSWithoutSDA::New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos)
+{
+  return new MEDFileFloatField1TSWithoutSDA(fieldName,meshName,csit,iteration,order,infos);
+}
+
+MEDFileFloatField1TSWithoutSDA::MEDFileFloatField1TSWithoutSDA()
+{
+}
+
+MEDFileFloatField1TSWithoutSDA::MEDFileFloatField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order,
+                                                               const std::vector<std::string>& infos):MEDFileField1TSNDTemplateWithoutSDA<float>(fieldName,meshName,csit,iteration,order,infos)
+{
+  DataArrayFloat *arr(getOrCreateAndGetArrayTemplate());
+  arr->setInfoAndChangeNbOfCompo(infos);
+}
+
+const char *MEDFileFloatField1TSWithoutSDA::getTypeStr() const
+{
+  return TYPE_STR;
+}
+
+/*!
+ * Returns a pointer to the underground DataArrayFloat instance and a
+ * sequence describing parameters of a support of each part of \a this field. The
+ * caller should not decrRef() the returned DataArrayFloat. This method allows for a
+ * direct access to the field values. This method is intended for the field lying on one
+ * mesh only.
+ *  \param [in,out] entries - the sequence describing parameters of a support of each
+ *         part of \a this field. Each item of this sequence consists of two parts. The
+ *         first part describes a type of mesh entity and an id of discretization of a
+ *         current field part. The second part describes a range of values [begin,end)
+ *         within the returned array relating to the current field part.
+ *  \return DataArrayFloat * - the pointer to the field values array.
+ *  \throw If the number of underlying meshes is not equal to 1.
+ *  \throw If no field values are available.
+ *  \sa getUndergroundDataArray()
+ */
+DataArray *MEDFileFloatField1TSWithoutSDA::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  return getUndergroundDataArrayFloatExt(entries);
+}
+
+/*!
+ * Returns a pointer to the underground DataArrayFloat instance and a
+ * sequence describing parameters of a support of each part of \a this field. The
+ * caller should not decrRef() the returned DataArrayFloat. This method allows for a
+ * direct access to the field values. This method is intended for the field lying on one
+ * mesh only.
+ *  \param [in,out] entries - the sequence describing parameters of a support of each
+ *         part of \a this field. Each item of this sequence consists of two parts. The
+ *         first part describes a type of mesh entity and an id of discretization of a
+ *         current field part. The second part describes a range of values [begin,end)
+ *         within the returned array relating to the current field part.
+ *  \return DataArrayFloat * - the pointer to the field values array.
+ *  \throw If the number of underlying meshes is not equal to 1.
+ *  \throw If no field values are available.
+ *  \sa getUndergroundDataArray()
+ */
+DataArrayFloat *MEDFileFloatField1TSWithoutSDA::getUndergroundDataArrayFloatExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  if(_field_per_mesh.size()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : field lies on several meshes, this method has no sense !");
+  if(_field_per_mesh[0]==0)
+    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : no field specified !");
+  _field_per_mesh[0]->getUndergroundDataArrayExt(entries);
+  return getUndergroundDataArrayTemplate();
+}
+
+MEDFileFloatField1TSWithoutSDA *MEDFileFloatField1TSWithoutSDA::shallowCpy() const
+{
+  MCAuto<MEDFileFloatField1TSWithoutSDA> ret(new MEDFileFloatField1TSWithoutSDA(*this));
+  ret->deepCpyLeavesFrom(*this);
+  return ret.retn();
+}
+
+MEDFileFloatField1TSWithoutSDA *MEDFileFloatField1TSWithoutSDA::deepCopy() const
+{
+  MCAuto<MEDFileFloatField1TSWithoutSDA> ret(shallowCpy());
+  if(_arr.isNotNull())
+    ret->_arr=_arr->deepCopy();
+  return ret.retn();
+}
+
+//= MEDFileAnyTypeField1TS
+
+MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS()
+{
+}
+
+MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  med_field_type typcha;
+  //
+  std::vector<std::string> infos;
+  std::string dtunit,fieldName,meshName;
+  LocateField2(fid,0,true,fieldName,typcha,infos,dtunit,meshName);
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ret;
+  switch(typcha)
+  {
+    case MED_FLOAT64:
+      {
+        ret=MEDFileField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+        break;
+      }
+    case MED_INT32:
+      {
+        ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+        break;
+      }
+    case MED_FLOAT32:
+      {
+        ret=MEDFileFloatField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+        break;
+      }
+    case MED_INT:
+      {
+        if(sizeof(med_int)==sizeof(int))
+          {
+            ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+            break;
+          }
+      }
+    default:
+      {
+        std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::BuildContentFrom(fid) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of the first field is not in [MED_FLOAT64, MED_INT32] !";
+        throw INTERP_KERNEL::Exception(oss.str());
+      }
+  }
+  ret->setDtUnit(dtunit.c_str());
+  ret->getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(infos);
+  //
+  med_int numdt,numit;
+  med_float dt;
+  MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,fieldName.c_str(),1,&numdt,&numit,&dt));
+  ret->setTime(numdt,numit,dt);
+  ret->_csit=1;
+  if(loadAll)
+    ret->loadStructureAndBigArraysRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
+  else
+    ret->loadOnlyStructureOfDataRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
+  return ret.retn();
+}
+
+MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+try:MEDFileFieldGlobsReal(fid)
+{
+  _content=BuildContentFrom(fid,loadAll,ms,entities);
+  loadGlobals(fid);
+}
+catch(INTERP_KERNEL::Exception& e)
+{
+    throw e;
+}
+
+MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  med_field_type typcha;
+  std::vector<std::string> infos;
+  std::string dtunit,meshName;
+  int nbSteps(0);
+  {
+    int iii=-1;
+    nbSteps=LocateField(fid,fieldName,iii,typcha,infos,dtunit,meshName);
+  }
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ret;
+  switch(typcha)
+  {
+    case MED_FLOAT64:
+      {
+        ret=MEDFileField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+        break;
+      }
+    case MED_INT32:
+      {
+        ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+        break;
+      }
+    case MED_FLOAT32:
+      {
+        ret=MEDFileFloatField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+        break;
+      }
+    case MED_INT:
+      {
+        if(sizeof(med_int)==sizeof(int))
+          {
+            ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
+            break;
+          }
+      }
+    default:
+      {
+        std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::BuildContentFrom(fid,fieldName) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
+        throw INTERP_KERNEL::Exception(oss.str());
+      }
+  }
+  ret->setMeshName(meshName);
+  ret->setDtUnit(dtunit.c_str());
+  ret->getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(infos);
+  //
+  if(nbSteps<1)
+    {
+      std::ostringstream oss; oss << "MEDFileField1TS(fid,fieldName) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but there is no time steps on it !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  //
+  med_int numdt,numit;
+  med_float dt;
+  MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,fieldName.c_str(),1,&numdt,&numit,&dt));
+  ret->setTime(numdt,numit,dt);
+  ret->_csit=1;
+  if(loadAll)
+    ret->loadStructureAndBigArraysRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
+  else
+    ret->loadOnlyStructureOfDataRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
+  return ret.retn();
+}
+
+MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+try:MEDFileFieldGlobsReal(fid)
+{
+  _content=BuildContentFrom(fid,fieldName,loadAll,ms,entities);
+  loadGlobals(fid);
+}
+catch(INTERP_KERNEL::Exception& e)
+{
+    throw e;
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c)
+{
+  if(!c)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::BuildNewInstanceFromContent : empty content in input : unable to build a new instance !");
+  if(dynamic_cast<const MEDFileField1TSWithoutSDA *>(c))
+    {
+      MCAuto<MEDFileField1TS> ret(MEDFileField1TS::New());
+      ret->_content=c; c->incrRef();
+      return ret.retn();
+    }
+  if(dynamic_cast<const MEDFileIntField1TSWithoutSDA *>(c))
+    {
+      MCAuto<MEDFileIntField1TS> ret(MEDFileIntField1TS::New());
+      ret->_content=c; c->incrRef();
+      return ret.retn();
+    }
+  if(dynamic_cast<const MEDFileFloatField1TSWithoutSDA *>(c))
+    {
+      MCAuto<MEDFileFloatField1TS> ret(MEDFileFloatField1TS::New());
+      ret->_content=c; c->incrRef();
+      return ret.retn();
+    }
+  throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::BuildNewInstanceFromContent : internal error ! a content of type different from FLOAT64 FLOAT32 and INT32 has been built but not intercepted !");
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c, med_idt fid)
+{
+  MEDFileAnyTypeField1TS *ret(BuildNewInstanceFromContent(c));
+  ret->setFileName(FileNameFromFID(fid));
+  return ret;
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(const std::string& fileName, bool loadAll)
+{
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
+  return New(fid,loadAll);
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(med_idt fid, bool loadAll)
+{
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,loadAll,0,0));
+  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
+  ret->loadGlobals(fid);
+  return ret.retn();
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(const std::string& fileName, const std::string& fieldName, bool loadAll)
+{
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
+  return New(fid,fieldName,loadAll);
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(med_idt fid, const std::string& fieldName, bool loadAll)
+{
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,fieldName,loadAll,0,0));
+  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
+  ret->loadGlobals(fid);
+  return ret.retn();
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll)
+{
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
+  return New(fid,fieldName,iteration,order,loadAll);
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll)
+{
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,fieldName,iteration,order,loadAll,0,0));
+  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
+  ret->loadGlobals(fid);
+  return ret.retn();
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::NewAdv(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities)
+{
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
+  return NewAdv(fid,fieldName,iteration,order,loadAll,entities);
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::NewAdv(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities)
+{
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,fieldName,iteration,order,loadAll,0,entities));
+  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
+  ret->loadGlobals(fid);
+  return ret.retn();
+}
+
+MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::BuildContentFrom(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  med_field_type typcha;
+  std::vector<std::string> infos;
+  std::string dtunit,meshName;
+  int iii(-1);
+  int nbOfStep2(LocateField(fid,fieldName,iii,typcha,infos,dtunit,meshName));
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ret;
+  switch(typcha)
+  {
+    case MED_FLOAT64:
+      {
+        ret=MEDFileField1TSWithoutSDA::New(fieldName,meshName,-1,iteration,order,std::vector<std::string>());
+        break;
+      }
+    case MED_INT32:
+      {
+        ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,iteration,order,std::vector<std::string>());
+        break;
+      }
+    case MED_FLOAT32:
+      {
+        ret=MEDFileFloatField1TSWithoutSDA::New(fieldName,meshName,-1,iteration,order,std::vector<std::string>());
+        break;
+      }
+    case MED_INT:
+      {
+        if(sizeof(med_int)==sizeof(int))
+          {
+            ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,iteration,order,std::vector<std::string>());
+            break;
+          }
+      }
+    default:
+      {
+        std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::BuildContentFrom(fid,fieldName,iteration,order) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
+        throw INTERP_KERNEL::Exception(oss.str());
+      }
+  }
+  ret->setDtUnit(dtunit.c_str());
+  ret->getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(infos);
+  //
+  bool found=false;
+  std::vector< std::pair<int,int> > dtits(nbOfStep2);
+  for(int i=0;i<nbOfStep2 && !found;i++)
+    {
+      med_int numdt,numit;
+      med_float dt;
+      MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,fieldName.c_str(),i+1,&numdt,&numit,&dt));
+      if(numdt==iteration && numit==order)
+        {
+          found=true;
+          ret->_csit=i+1;
+        }
+      else
+        dtits[i]=std::pair<int,int>(numdt,numit);
+    }
+  if(!found)
+    {
+      std::ostringstream oss; oss << "No such iteration (" << iteration << "," << order << ") in existing field '" << fieldName << "' in file '" << FileNameFromFID(fid) << "' ! Available iterations are : ";
+      for(std::vector< std::pair<int,int> >::const_iterator iter=dtits.begin();iter!=dtits.end();iter++)
+        oss << "(" << (*iter).first << "," << (*iter).second << "), ";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  if(loadAll)
+    ret->loadStructureAndBigArraysRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
+  else
+    ret->loadOnlyStructureOfDataRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
+  return ret.retn();
+}
+
+MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+try:MEDFileFieldGlobsReal(fid)
+{
+  _content=BuildContentFrom(fid,fieldName,iteration,order,loadAll,ms,entities);
+  loadGlobals(fid);
+}
+catch(INTERP_KERNEL::Exception& e)
+{
+    throw e;
+}
+
+/*!
+ * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
+ * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
+ *
+ * \warning this is a shallow copy constructor
+ */
+MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(const MEDFileAnyTypeField1TSWithoutSDA& other, bool shallowCopyOfContent)
+{
+  if(!shallowCopyOfContent)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *otherPtr(&other);
+      otherPtr->incrRef();
+      _content=const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(otherPtr);
+    }
+  else
+    {
+      _content=other.shallowCpy();
+    }
+}
+
+int MEDFileAnyTypeField1TS::LocateField2(med_idt fid, int fieldIdCFormat, bool checkFieldId, std::string& fieldName, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName)
+{
+  if(checkFieldId)
+    {
+      int nbFields=MEDnField(fid);
+      if(fieldIdCFormat>=nbFields)
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::LocateField2(fileName) : in file \'" << FileNameFromFID(fid) << "\' number of fields is " << nbFields << " ! Trying to request for id " << fieldIdCFormat << " !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  int ncomp(MEDfieldnComponent(fid,fieldIdCFormat+1));
+  INTERP_KERNEL::AutoPtr<char> comp(MEDLoaderBase::buildEmptyString(ncomp*MED_SNAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> unit(MEDLoaderBase::buildEmptyString(ncomp*MED_SNAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> dtunit(MEDLoaderBase::buildEmptyString(MED_LNAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> nomcha(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> nomMaa(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  med_bool localMesh;
+  int nbOfStep;
+  MEDFILESAFECALLERRD0(MEDfieldInfo,(fid,fieldIdCFormat+1,nomcha,nomMaa,&localMesh,&typcha,comp,unit,dtunit,&nbOfStep));
+  fieldName=MEDLoaderBase::buildStringFromFortran(nomcha,MED_NAME_SIZE);
+  dtunitOut=MEDLoaderBase::buildStringFromFortran(dtunit,MED_LNAME_SIZE);
+  meshName=MEDLoaderBase::buildStringFromFortran(nomMaa,MED_NAME_SIZE);
+  infos.clear(); infos.resize(ncomp);
+  for(int j=0;j<ncomp;j++)
+    infos[j]=MEDLoaderBase::buildUnionUnit((char *)comp+j*MED_SNAME_SIZE,MED_SNAME_SIZE,(char *)unit+j*MED_SNAME_SIZE,MED_SNAME_SIZE);
+  return nbOfStep;
+}
+
+/*!
+ * This method throws an INTERP_KERNEL::Exception if \a fieldName field is not in file pointed by \a fid and with name \a fileName.
+ * 
+ * \param [out]
+ * \return in case of success the number of time steps available for the field with name \a fieldName.
+ */
+int MEDFileAnyTypeField1TS::LocateField(med_idt fid, const std::string& fieldName, int& posCFormat, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName)
+{
+  int nbFields=MEDnField(fid);
+  bool found=false;
+  std::vector<std::string> fns(nbFields);
+  int nbOfStep2(-1);
+  for(int i=0;i<nbFields && !found;i++)
+    {
+      std::string tmp,tmp2;
+      nbOfStep2=LocateField2(fid,i,false,tmp,typcha,infos,dtunitOut,tmp2);
+      fns[i]=tmp;
+      found=(tmp==fieldName);
+      if(found)
+        {
+          posCFormat=i;
+          meshName=tmp2;
+        }
+    }
+  if(!found)
+    {
+      std::ostringstream oss; oss << "No such field '" << fieldName << "' in file '" << FileNameFromFID(fid) << "' ! Available fields are : ";
+      for(std::vector<std::string>::const_iterator it=fns.begin();it!=fns.end();it++)
+        oss << "\"" << *it << "\" ";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  return nbOfStep2;
+}
+
+/*!
+ * This method as MEDFileField1TSW::setLocNameOnLeaf, is dedicated for advanced user that a want a very fine control on their data structure
+ * without overhead. This method can be called only regarding information returned by MEDFileField1TSWithoutSDA::getFieldSplitedByType or MEDFileField1TSWithoutSDA::getFieldSplitedByType2.
+ * This method changes the attribute (here it's profile name) of the leaf datastructure (MEDFileFieldPerMeshPerTypePerDisc instance).
+ * It is the responsibility of the caller to invoke MEDFileFieldGlobs::appendProfile or MEDFileFieldGlobs::getProfile
+ * to keep a valid instance.
+ * If \b this do not have any leaf that correspond to the request of the input parameter (\b mName, \b typ, \b locId) an INTERP_KERNEL::Exception will be thrown.
+ * If \b newPflName profile name does not already exist the profile with old name will be renamed with name \b newPflName.
+ * If \b newPflName already exists and that \b forceRenameOnGlob is false (the default) an INTERP_KERNEL::Exception will be thrown to avoid big confusion. In this case the called should rename before the profile name with name \b newPflName.
+ *
+ * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
+ * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
+ * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
+ *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
+ * \param [in] newLocName is the new localization name.
+ * \param [in] forceRenameOnGlob specifies the behaviour in case of profile \b newPflName already exists. If true, the renaming is done without check. It can lead to major bug.
+ *             If false, an exception will be thrown to force user to change previously the name of the profile with name \b newPflName
+ */
+void MEDFileAnyTypeField1TS::setProfileNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newPflName, bool forceRenameOnGlob)
+{
+  MEDFileFieldPerMeshPerTypePerDisc *disc=getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
+  std::string oldPflName=disc->getProfile();
+  std::vector<std::string> vv=getPflsReallyUsedMulti();
+  int nbOfOcc=std::count(vv.begin(),vv.end(),oldPflName);
+  if(forceRenameOnGlob || (!existsPfl(newPflName) && nbOfOcc==1))
+    {
+      disc->setProfile(newPflName);
+      DataArrayInt *pfl=getProfile(oldPflName.c_str());
+      pfl->setName(newPflName);
+    }
+  else
+    {
+      std::ostringstream oss; oss << "MEDFileField1TS::setProfileNameOnLeaf : Profile \"" << newPflName << "\" already exists or referenced more than one !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+}
+
+/*!
+ * This method as MEDFileField1TSW::setProfileNameOnLeaf, is dedicated for advanced user that a want a very fine control on their data structure
+ * without overhead. This method can be called only regarding information returned by MEDFileField1TSWithoutSDA::getFieldSplitedByType or MEDFileField1TSWithoutSDA::getFieldSplitedByType2.
+ * This method changes the attribute (here it's localization name) of the leaf datastructure (MEDFileFieldPerMeshPerTypePerDisc instance).
+ * It is the responsibility of the caller to invoke MEDFileFieldGlobs::appendProfile or MEDFileFieldGlobs::getProfile
+ * to keep a valid instance.
+ * If \b this do not have any leaf that correspond to the request of the input parameter (\b mName, \b typ, \b locId) an INTERP_KERNEL::Exception will be thrown.
+ * This method is an extension of MEDFileField1TSWithoutSDA::setProfileNameOnLeafExt method because it performs a modification of global info.
+ * If \b newLocName profile name does not already exist the localization with old name will be renamed with name \b newLocName.
+ * If \b newLocName already exists an INTERP_KERNEL::Exception will be thrown to avoid big confusion. In this case the called should rename before the profile name with name \b newLocName.
+ *
+ * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
+ * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
+ * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
+ *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
+ * \param [in] newLocName is the new localization name.
+ * \param [in] forceRenameOnGlob specifies the behaviour in case of profile \b newLocName already exists. If true, the renaming is done without check. It can lead to major bug.
+ *             If false, an exception will be thrown to force user to change previously the name of the profile with name \b newLocName
+ */
+void MEDFileAnyTypeField1TS::setLocNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newLocName, bool forceRenameOnGlob)
+{
+  MEDFileFieldPerMeshPerTypePerDisc *disc=getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
+  std::string oldLocName=disc->getLocalization();
+  std::vector<std::string> vv=getLocsReallyUsedMulti();
+  int nbOfOcc=std::count(vv.begin(),vv.end(),oldLocName);
+  if(forceRenameOnGlob || (!existsLoc(newLocName) && nbOfOcc==1))
+    {
+      disc->setLocalization(newLocName);
+      MEDFileFieldLoc& loc=getLocalization(oldLocName.c_str());
+      loc.setName(newLocName);
+    }
+  else
+    {
+      std::ostringstream oss; oss << "MEDFileField1TS::setLocNameOnLeaf : Localization \"" << newLocName << "\" already exists or referenced more than one !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+}
+
+MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::contentNotNullBase()
+{
+  MEDFileAnyTypeField1TSWithoutSDA *ret=_content;
+  if(!ret)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS : content is expected to be not null !");
+  return ret;
+}
+
+const MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::contentNotNullBase() const
+{
+  const MEDFileAnyTypeField1TSWithoutSDA *ret=_content;
+  if(!ret)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS : const content is expected to be not null !");
+  return ret;
+}
+
+/*!
+ * This method alloc the arrays and load potentially huge arrays contained in this field.
+ * This method should be called when a MEDFileAnyTypeField1TS::New constructor has been with false as the last parameter.
+ * This method can be also called to refresh or reinit values from a file.
+ * 
+ * \throw If the fileName is not set or points to a non readable MED file.
+ * \sa MEDFileAnyTypeField1TS::loadArraysIfNecessary
+ */
+void MEDFileAnyTypeField1TS::loadArrays()
+{
+  if(getFileName().empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::loadArrays : the structure does not come from a file !");
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
+  contentNotNullBase()->loadBigArraysRecursively(fid,*contentNotNullBase());
+}
+
+/*!
+ * This method behaves as MEDFileAnyTypeField1TS::loadArrays does, the first call, if \a this was built using a file without loading big arrays.
+ * But once data loaded once, this method does nothing. Contrary to MEDFileAnyTypeField1TS::loadArrays and MEDFileAnyTypeField1TS::unloadArrays
+ * this method does not throw if \a this does not come from file read.
+ * 
+ * \sa MEDFileAnyTypeField1TS::loadArrays, MEDFileAnyTypeField1TS::unloadArrays
+ */
+void MEDFileAnyTypeField1TS::loadArraysIfNecessary()
+{
+  if(!getFileName().empty())
+    {
+      MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
+      contentNotNullBase()->loadBigArraysRecursivelyIfNecessary(fid,*contentNotNullBase());
+    }
+}
+
+/*!
+ * This method releases potentially big data arrays and so returns to the same heap memory than status loaded with 'loadAll' parameter set to false.
+ * \b WARNING, this method does release arrays even if \a this does not come from a load of a MED file.
+ * So this method can lead to a loss of data. If you want to unload arrays safely call MEDFileAnyTypeField1TS::unloadArraysWithoutDataLoss instead.
+ * 
+ * \sa MEDFileAnyTypeField1TS::loadArrays, MEDFileAnyTypeField1TS::loadArraysIfNecessary, MEDFileAnyTypeField1TS::unloadArraysWithoutDataLoss
+ */
+void MEDFileAnyTypeField1TS::unloadArrays()
+{
+  contentNotNullBase()->unloadArrays();
+}
+
+/*!
+ * This method potentially releases big data arrays if \a this is coming from a file. If \a this has been built from scratch this method will have no effect.
+ * This method is the symmetrical method of MEDFileAnyTypeField1TS::loadArraysIfNecessary.
+ * This method is useful to reduce \b safely amount of heap memory necessary for \a this by using MED file as database.
+ * 
+ * \sa MEDFileAnyTypeField1TS::loadArraysIfNecessary
+ */
+void MEDFileAnyTypeField1TS::unloadArraysWithoutDataLoss()
+{
+  if(!getFileName().empty())
+    contentNotNullBase()->unloadArrays();
+}
+
+void MEDFileAnyTypeField1TS::writeLL(med_idt fid) const
+{
+  int nbComp(getNumberOfComponents());
+  INTERP_KERNEL::AutoPtr<char> comp(MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> unit(MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE));
+  for(int i=0;i<nbComp;i++)
+    {
+      std::string info=getInfo()[i];
+      std::string c,u;
+      MEDLoaderBase::splitIntoNameAndUnit(info,c,u);
+      MEDLoaderBase::safeStrCpy2(c.c_str(),MED_SNAME_SIZE,comp+i*MED_SNAME_SIZE,_too_long_str);
+      MEDLoaderBase::safeStrCpy2(u.c_str(),MED_SNAME_SIZE,unit+i*MED_SNAME_SIZE,_too_long_str);
+    }
+  if(getName().empty())
+    throw INTERP_KERNEL::Exception("MEDFileField1TS::write : MED file does not accept field with empty name !");
+  MEDFILESAFECALLERWR0(MEDfieldCr,(fid,getName().c_str(),getMEDFileFieldType(),nbComp,comp,unit,getDtUnit().c_str(),getMeshName().c_str()));
+  writeGlobals(fid,*this);
+  contentNotNullBase()->writeLL(fid,*this,*contentNotNullBase());
+}
+
+std::size_t MEDFileAnyTypeField1TS::getHeapMemorySizeWithoutChildren() const
+{
+  return MEDFileFieldGlobsReal::getHeapMemorySizeWithoutChildren();
+}
+
+std::vector<const BigMemoryObject *> MEDFileAnyTypeField1TS::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret(MEDFileFieldGlobsReal::getDirectChildrenWithNull());
+  ret.push_back((const MEDFileAnyTypeField1TSWithoutSDA *)_content);
+  return ret;
+}
+
+/*!
+ * Returns a string describing \a this field. This string is outputted 
+ * by \c print Python command.
+ */
+std::string MEDFileAnyTypeField1TS::simpleRepr() const
+{
+  std::ostringstream oss;
+  contentNotNullBase()->simpleRepr(0,oss,-1);
+  simpleReprGlobs(oss);
+  return oss.str();
+}
+
+/*!
+ * This method returns all profiles whose name is non empty used.
+ * \b WARNING If profile is used several times it will be reported \b only \b once.
+ * To get non empty name profiles as time as they appear in \b this call MEDFileField1TS::getPflsReallyUsedMulti instead.
+ */
+std::vector<std::string> MEDFileAnyTypeField1TS::getPflsReallyUsed() const
+{
+  return contentNotNullBase()->getPflsReallyUsed2();
+}
+
+/*!
+ * This method returns all localizations whose name is non empty used.
+ * \b WARNING If localization is used several times it will be reported \b only \b once.
+ */
+std::vector<std::string> MEDFileAnyTypeField1TS::getLocsReallyUsed() const
+{
+  return contentNotNullBase()->getLocsReallyUsed2();
+}
+
+/*!
+ * This method returns all profiles whose name is non empty used.
+ * \b WARNING contrary to MEDFileField1TS::getPflsReallyUsed, if profile is used several times it will be reported as time as it appears.
+ */
+std::vector<std::string> MEDFileAnyTypeField1TS::getPflsReallyUsedMulti() const
+{
+  return contentNotNullBase()->getPflsReallyUsedMulti2();
+}
+
+/*!
+ * This method returns all localizations whose name is non empty used.
+ * \b WARNING contrary to MEDFileField1TS::getLocsReallyUsed if localization is used several times it will be reported as time as it appears.
+ */
+std::vector<std::string> MEDFileAnyTypeField1TS::getLocsReallyUsedMulti() const
+{
+  return contentNotNullBase()->getLocsReallyUsedMulti2();
+}
+
+void MEDFileAnyTypeField1TS::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  contentNotNullBase()->changePflsRefsNamesGen2(mapOfModif);
+}
+
+void MEDFileAnyTypeField1TS::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  contentNotNullBase()->changeLocsRefsNamesGen2(mapOfModif);
+}
+
+int MEDFileAnyTypeField1TS::getDimension() const
+{
+  return contentNotNullBase()->getDimension();
+}
+
+int MEDFileAnyTypeField1TS::getIteration() const
+{
+  return contentNotNullBase()->getIteration();
+}
+
+int MEDFileAnyTypeField1TS::getOrder() const
+{
+  return contentNotNullBase()->getOrder();
+}
+
+double MEDFileAnyTypeField1TS::getTime(int& iteration, int& order) const
+{
+  return contentNotNullBase()->getTime(iteration,order);
+}
+
+void MEDFileAnyTypeField1TS::setTime(int iteration, int order, double val)
+{
+  contentNotNullBase()->setTime(iteration,order,val);
+}
+
+std::string MEDFileAnyTypeField1TS::getName() const
+{
+  return contentNotNullBase()->getName();
+}
+
+void MEDFileAnyTypeField1TS::setName(const std::string& name)
+{
+  contentNotNullBase()->setName(name);
+}
+
+void MEDFileAnyTypeField1TS::simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const
+{
+  contentNotNullBase()->simpleRepr(bkOffset,oss,f1tsId);
+}
+
+std::string MEDFileAnyTypeField1TS::getDtUnit() const
+{
+  return contentNotNullBase()->getDtUnit();
+}
+
+void MEDFileAnyTypeField1TS::setDtUnit(const std::string& dtUnit)
+{
+  contentNotNullBase()->setDtUnit(dtUnit);
+}
+
+std::string MEDFileAnyTypeField1TS::getMeshName() const
+{
+  return contentNotNullBase()->getMeshName();
+}
+
+void MEDFileAnyTypeField1TS::setMeshName(const std::string& newMeshName)
+{
+  contentNotNullBase()->setMeshName(newMeshName);
+}
+
+bool MEDFileAnyTypeField1TS::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
+{
+  return contentNotNullBase()->changeMeshNames(modifTab);
+}
+
+int MEDFileAnyTypeField1TS::getMeshIteration() const
+{
+  return contentNotNullBase()->getMeshIteration();
+}
+
+int MEDFileAnyTypeField1TS::getMeshOrder() const
+{
+  return contentNotNullBase()->getMeshOrder();
+}
+
+int MEDFileAnyTypeField1TS::getNumberOfComponents() const
+{
+  return contentNotNullBase()->getNumberOfComponents();
+}
+
+bool MEDFileAnyTypeField1TS::isDealingTS(int iteration, int order) const
+{
+  return contentNotNullBase()->isDealingTS(iteration,order);
+}
+
+std::pair<int,int> MEDFileAnyTypeField1TS::getDtIt() const
+{
+  return contentNotNullBase()->getDtIt();
+}
+
+void MEDFileAnyTypeField1TS::fillIteration(std::pair<int,int>& p) const
+{
+  contentNotNullBase()->fillIteration(p);
+}
+
+void MEDFileAnyTypeField1TS::fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const
+{
+  contentNotNullBase()->fillTypesOfFieldAvailable(types);
+}
+
+void MEDFileAnyTypeField1TS::setInfo(const std::vector<std::string>& infos)
+{
+  contentNotNullBase()->setInfo(infos);
+}
+
+const std::vector<std::string>& MEDFileAnyTypeField1TS::getInfo() const
+{
+  return contentNotNullBase()->getInfo();
+}
+std::vector<std::string>& MEDFileAnyTypeField1TS::getInfo()
+{
+  return contentNotNullBase()->getInfo();
+}
+
+bool MEDFileAnyTypeField1TS::presenceOfMultiDiscPerGeoType() const
+{
+  return contentNotNullBase()->presenceOfMultiDiscPerGeoType();
+}
+
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TS::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId)
+{
+  return contentNotNullBase()->getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
+}
+
+const MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TS::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const
+{
+  return contentNotNullBase()->getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
+}
+
+int MEDFileAnyTypeField1TS::getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const
+{
+  return contentNotNullBase()->getNonEmptyLevels(mname,levs);
+}
+
+void MEDFileAnyTypeField1TS::convertMedBallIntoClassic()
+{
+  return contentNotNullBase()->convertMedBallIntoClassic();
+}
+
+void MEDFileAnyTypeField1TS::makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl)
+{
+  return contentNotNullBase()->makeReduction(ct,tof,pfl);
+}
+
+std::vector<TypeOfField> MEDFileAnyTypeField1TS::getTypesOfFieldAvailable() const
+{
+  return contentNotNullBase()->getTypesOfFieldAvailable();
+}
+
+std::vector< std::vector<std::pair<int,int> > > MEDFileAnyTypeField1TS::getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
+                                                                                              std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  return contentNotNullBase()->getFieldSplitedByType(mname,types,typesF,pfls,locs);
+}
+
+/*!
+ * This method returns as MEDFileAnyTypeField1TS new instances as number of components in \a this.
+ * The returned instances are deep copy of \a this except that for globals that are shared with those contained in \a this.
+ * ** WARNING ** do no forget to rename the output instances to avoid to write n-times in the same MED file field !
+ */
+std::vector< MCAuto< MEDFileAnyTypeField1TS > > MEDFileAnyTypeField1TS::splitComponents() const
+{
+  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
+  if(!content)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::splitComponents : no content in this ! Unable to split components !");
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > contentsSplit=content->splitComponents();
+  std::size_t sz(contentsSplit.size());
+  std::vector< MCAuto< MEDFileAnyTypeField1TS > > ret(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      ret[i]=shallowCpy();
+      ret[i]->_content=contentsSplit[i];
+    }
+  return ret;
+}
+
+/*!
+ * This method returns as MEDFileAnyTypeField1TS new instances as number of spatial discretizations in \a this.
+ * The returned instances are shallowed copied of \a this except that for globals that are shared with those contained in \a this.
+ */
+std::vector< MCAuto< MEDFileAnyTypeField1TS > > MEDFileAnyTypeField1TS::splitDiscretizations() const
+{
+  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
+  if(!content)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::splitDiscretizations : no content in this ! Unable to split discretization !");
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > contentsSplit(content->splitDiscretizations());
+  std::size_t sz(contentsSplit.size());
+  std::vector< MCAuto< MEDFileAnyTypeField1TS > > ret(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      ret[i]=shallowCpy();
+      ret[i]->_content=contentsSplit[i];
+    }
+  return ret;
+}
+
+/*!
+ * This method returns as MEDFileAnyTypeField1TS new instances as number of maximal number of discretization in \a this.
+ * The returned instances are shallowed copied of \a this except that for globals that are shared with those contained in \a this.
+ */
+std::vector< MCAuto< MEDFileAnyTypeField1TS > > MEDFileAnyTypeField1TS::splitMultiDiscrPerGeoTypes() const
+{
+  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
+  if(!content)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::splitMultiDiscrPerGeoTypes : no content in this ! Unable to split discretization !");
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > contentsSplit(content->splitMultiDiscrPerGeoTypes());
+  std::size_t sz(contentsSplit.size());
+  std::vector< MCAuto< MEDFileAnyTypeField1TS > > ret(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      ret[i]=shallowCpy();
+      ret[i]->_content=contentsSplit[i];
+    }
+  return ret;
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::deepCopy() const
+{
+  MCAuto<MEDFileAnyTypeField1TS> ret=shallowCpy();
+  if((const MEDFileAnyTypeField1TSWithoutSDA *)_content)
+    ret->_content=_content->deepCopy();
+  ret->deepCpyGlobs(*this);
+  return ret.retn();
+}
+
+int MEDFileAnyTypeField1TS::copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr)
+{
+  MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::New(*field));
+  return copyTinyInfoFrom(field->timeDiscrSafe(),ft,arr);
+}
+
+int MEDFileAnyTypeField1TS::copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr)
+{
+  return contentNotNullBase()->copyTinyInfoFrom(th,field,arr);
+}
+
+//= MEDFileField1TS
+
+/*!
+ * This method performs a copy with datatype modification ( float64->int32 ) of \a this. The globals information are copied
+ * following the given input policy.
+ *
+ * \param [in] isDeepCpyGlobs - a boolean that indicates the behaviour concerning globals (profiles and localizations)
+ *                            By default (true) the globals are deeply copied.
+ * \return MEDFileIntField1TS * - a new object that is the result of the conversion of \a this to int32 field.
+ */
+MEDFileIntField1TS *MEDFileField1TS::convertToInt(bool isDeepCpyGlobs) const
+{
+  MCAuto<MEDFileIntField1TS> ret;
+  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
+  if(content)
+    {
+      const MEDFileField1TSWithoutSDA *contc=dynamic_cast<const MEDFileField1TSWithoutSDA *>(content);
+      if(!contc)
+        throw INTERP_KERNEL::Exception("MEDFileField1TS::convertToInt : the content inside this is not FLOAT64 ! This is incoherent !");
+      MCAuto<MEDFileIntField1TSWithoutSDA> newc(contc->convertToInt());
+      ret=static_cast<MEDFileIntField1TS *>(MEDFileAnyTypeField1TS::BuildNewInstanceFromContent((MEDFileIntField1TSWithoutSDA *)newc));
+    }
+  else
+    ret=MEDFileIntField1TS::New();
+  if(isDeepCpyGlobs)
+    ret->deepCpyGlobs(*this);
+  else
+    ret->shallowCpyGlobs(*this);
+  return ret.retn();
+}
+
+MEDFileField1TS::MEDFileField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
+try:MEDFileTemplateField1TS<double>(fid,loadAll,ms)
+{
+}
+catch(INTERP_KERNEL::Exception& e)
+{ throw e; }
+
+MEDFileField1TS::MEDFileField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms)
+try:MEDFileTemplateField1TS<double>(fid,fieldName,loadAll,ms)
+{
+}
+catch(INTERP_KERNEL::Exception& e)
+{ throw e; }
+
+MEDFileField1TS::MEDFileField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms)
+try:MEDFileTemplateField1TS<double>(fid,fieldName,iteration,order,loadAll,ms)
+{
+}
+catch(INTERP_KERNEL::Exception& e)
+{ throw e; }
+
+/*!
+ * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
+ * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
+ *
+ * \warning this is a shallow copy constructor
+ */
+MEDFileField1TS::MEDFileField1TS(const MEDFileField1TSWithoutSDA& other, bool shallowCopyOfContent)
+try:MEDFileTemplateField1TS<double>(other,shallowCopyOfContent)
+{
+}
+catch(INTERP_KERNEL::Exception& e)
+{ throw e; }
+
+MEDFileField1TS *MEDFileField1TS::shallowCpy() const
+{
+  return new MEDFileField1TS(*this);
+}
+
+std::vector< std::vector<DataArrayDouble *> > MEDFileField1TS::getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
+                                                                                      std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  return contentNotNull()->getFieldSplitedByType2(mname,types,typesF,pfls,locs);
+}
+
+//= MEDFileIntField1TS
+
+MCAuto<MEDCouplingFieldDouble> MEDFileIntField1TS::ConvertFieldIntToFieldDouble(const MEDCouplingFieldInt *f)
+{
+  if(!f)
+    throw INTERP_KERNEL::Exception("MEDFileIntField1TS::ConvertFieldIntToFieldDouble : null input field !");
+  int t1,t2;
+  double t0(f->getTime(t1,t2));
+  std::string tu(f->getTimeUnit());
+  MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::New(*f));
+  MCAuto<MEDCouplingFieldDouble> ret(MEDCouplingFieldDouble::New(*ft));
+  ret->setTime(t0,t1,t2); ret->setTimeUnit(tu);
+  return ret;
+}
+
+//= MEDFileFloatField1TS
+
+//= MEDFileFloatField1TS
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileField1TS.hxx MEDCOUPLING_new/src/MEDLoader/MEDFileField1TS.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileField1TS.hxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileField1TS.hxx	2018-04-19 17:25:17.850799590 +0200
@@ -0,0 +1,467 @@
+// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#ifndef __MEDFILEFIELD1TS_HXX__
+#define __MEDFILEFIELD1TS_HXX__
+
+#include "MEDLoaderDefines.hxx"
+#include "MEDFileFieldGlobs.hxx"
+#include "MEDFileFieldInternal.hxx"
+#include "MEDLoaderTraits.hxx"
+
+#include "med.h"
+
+namespace MEDCoupling
+{
+  class TimeHolder;
+  class MEDFileMeshes;
+  
+  /*!
+   * SDA is for Shared Data Arrays such as profiles.
+   */
+  class MEDFileAnyTypeField1TSWithoutSDA : public RefCountObject, public MEDFileFieldNameScope
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA();
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order);
+    MEDLOADER_EXPORT int getIteration() const { return _iteration; }
+    MEDLOADER_EXPORT int getOrder() const { return _order; }
+    MEDLOADER_EXPORT double getTime(int& iteration, int& order) const { iteration=_iteration; order=_order; return _dt; }
+    MEDLOADER_EXPORT void setTime(int iteration, int order, double val) { _dt=val; _iteration=iteration; _order=order; }
+    MEDLOADER_EXPORT int getDimension() const;
+    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
+    MEDLOADER_EXPORT int getMeshIteration() const;
+    MEDLOADER_EXPORT int getMeshOrder() const;
+    MEDLOADER_EXPORT bool isDealingTS(int iteration, int order) const;
+    MEDLOADER_EXPORT std::pair<int,int> getDtIt() const;
+    MEDLOADER_EXPORT void fillIteration(std::pair<int,int>& p) const;
+    MEDLOADER_EXPORT void fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const;
+    MEDLOADER_EXPORT std::vector<TypeOfField> getTypesOfFieldAvailable() const;
+    //
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed2() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed2() const;
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti2() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti2() const;
+    MEDLOADER_EXPORT void changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    //
+    MEDLOADER_EXPORT int getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const;
+    MEDLOADER_EXPORT void convertMedBallIntoClassic();
+    MEDLOADER_EXPORT void makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl);
+    MEDLOADER_EXPORT std::vector< std::vector<std::pair<int,int> > > getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    //
+    MEDLOADER_EXPORT MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId);
+    MEDLOADER_EXPORT const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const;
+    MEDLOADER_EXPORT void deepCpyLeavesFrom(const MEDFileAnyTypeField1TSWithoutSDA& other);
+    MEDLOADER_EXPORT void accept(MEDFileFieldVisitor& visitor) const;
+  public:
+    MEDLOADER_EXPORT int getNumberOfComponents() const;
+    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
+    MEDLOADER_EXPORT std::vector<std::string>& getInfo();
+    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
+    MEDLOADER_EXPORT bool presenceOfStructureElements() const;
+    MEDLOADER_EXPORT bool onlyStructureElements() const;
+    MEDLOADER_EXPORT void killStructureElements();
+    MEDLOADER_EXPORT void keepOnlyStructureElements();
+    MEDLOADER_EXPORT void keepOnlyOnSE(const std::string& seName);
+    MEDLOADER_EXPORT void getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const;
+    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& infos);
+    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
+    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDLOADER_EXPORT int copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr);
+    MEDLOADER_EXPORT void setFieldNoProfileSBT(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    MEDLOADER_EXPORT void setFieldProfile(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arrOfVals, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc, bool smartPflKiller=true);
+    MEDLOADER_EXPORT virtual void simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TSWithoutSDA *deepCopy() const = 0;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TSWithoutSDA *shallowCpy() const = 0;
+    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > splitComponents() const;
+    MEDLOADER_EXPORT virtual const char *getTypeStr() const = 0;
+    MEDLOADER_EXPORT virtual DataArray *getUndergroundDataArray() const = 0;
+    MEDLOADER_EXPORT virtual DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const = 0;
+    MEDLOADER_EXPORT virtual void setArray(DataArray *arr) = 0;
+    MEDLOADER_EXPORT virtual DataArray *createNewEmptyDataArrayInstance() const = 0;
+    MEDLOADER_EXPORT virtual DataArray *getOrCreateAndGetArray() = 0;
+    MEDLOADER_EXPORT virtual const DataArray *getOrCreateAndGetArray() const = 0;
+  public:
+    MEDLOADER_EXPORT MEDCouplingFieldDouble *fieldOnMesh(const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const;
+    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldAtLevel(TypeOfField type, int meshDimRelToMax, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldOnMeshAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldAtTopLevel(TypeOfField type, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldOnMeshAtLevel(TypeOfField type, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, const DataArrayInt *cellRenum, const DataArrayInt *nodeRenum, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    DataArray *getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const;
+  public:
+    MEDLOADER_EXPORT bool renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N, MEDFileFieldGlobsReal& glob);
+    MEDLOADER_EXPORT std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > splitDiscretizations() const;
+    MEDLOADER_EXPORT std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > splitMultiDiscrPerGeoTypes() const;
+    MEDLOADER_EXPORT int keepOnlySpatialDiscretization(TypeOfField tof, std::vector< std::pair<int,int> >& its);
+    MEDLOADER_EXPORT int keepOnlyGaussDiscretization(std::size_t idOfDisc, std::vector< std::pair<int,int> >& its);
+  public:
+    MEDLOADER_EXPORT void allocNotFromFile(int newNbOfTuples);
+    MEDLOADER_EXPORT bool allocIfNecessaryTheArrayToReceiveDataFromFile();
+    MEDLOADER_EXPORT void loadOnlyStructureOfDataRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
+    MEDLOADER_EXPORT void loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc);
+    MEDLOADER_EXPORT void loadStructureAndBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT void unloadArrays();
+    MEDLOADER_EXPORT void writeLL(med_idt fid, const MEDFileWritable& opts, const MEDFileFieldNameScope& nasc) const;
+    MEDLOADER_EXPORT static std::string FieldNameToMEDFileConvention(const std::string& nonCorrectFieldName);
+  protected:
+    int getMeshIdFromMeshName(const std::string& mName) const;
+    int addNewEntryIfNecessary(const MEDCouplingMesh *mesh);
+    void updateData(int newLgth, const std::vector< std::pair<int,int> >& oldStartStops);
+  protected:
+    std::vector< MCAuto< MEDFileFieldPerMesh > > _field_per_mesh;
+    int _iteration;
+    int _order;
+    double _dt;
+  public:
+    //! only useable on reading
+    mutable int _csit;
+    // -3 means allocated and build from scratch
+    // -2 means allocated and read from a file
+    // -1 means not allocated and build from scratch
+    // >=0 means not allocated and read from a file
+    mutable int _nb_of_tuples_to_be_allocated;
+  };
+
+  class MEDFileIntField1TSWithoutSDA;
+
+  template<class T>
+  class MEDFileField1TSTemplateWithoutSDA : public MEDFileAnyTypeField1TSWithoutSDA
+  {
+  protected:
+    MEDFileField1TSTemplateWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order):MEDFileAnyTypeField1TSWithoutSDA(fieldName,meshName,csit,iteration,order) { }
+    MEDFileField1TSTemplateWithoutSDA() { }
+  public:
+    MEDLOADER_EXPORT void setArray(DataArray *arr);
+    MEDLOADER_EXPORT DataArray *createNewEmptyDataArrayInstance() const;
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getOrCreateAndGetArrayTemplate();
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType const *getOrCreateAndGetArrayTemplate() const;
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayTemplate() const;
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayTemplateExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDLOADER_EXPORT DataArray *getOrCreateAndGetArray();
+    MEDLOADER_EXPORT const DataArray *getOrCreateAndGetArray() const;
+    MEDLOADER_EXPORT DataArray *getUndergroundDataArray() const;
+    MEDLOADER_EXPORT void aggregate(const typename std::vector< typename MLFieldTraits<T>::F1TSWSDAType const * >& f1tss, const std::vector< std::vector< std::pair<int,int> > >& dts);
+    MEDLOADER_EXPORT void copyTimeInfoFrom(const typename Traits<T>::FieldType *mcf);
+  protected:
+    MCAuto< typename Traits<T>::ArrayType > _arr;
+  };
+
+  /*!
+   * SDA is for Shared Data Arrays such as profiles.
+   */
+  class MEDFileField1TSWithoutSDA : public MEDFileField1TSTemplateWithoutSDA<double>
+  {
+  public:
+    MEDLOADER_EXPORT const char *getTypeStr() const;
+    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    MEDLOADER_EXPORT static void CheckMeshDimRel(int meshDimRelToMax);
+    MEDLOADER_EXPORT static std::vector<int> CheckSBTMesh(const MEDCouplingMesh *mesh);
+    MEDLOADER_EXPORT static MEDFileField1TSWithoutSDA *New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
+  public:
+    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA();
+    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
+    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA *shallowCpy() const;
+    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA *deepCopy() const;
+    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA *convertToInt() const;
+  public:
+    static const char TYPE_STR[];
+  };
+
+  template<class T>
+  class MEDFileField1TSNDTemplateWithoutSDA : public MEDFileField1TSTemplateWithoutSDA<T>
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA *convertToDouble() const;
+  protected:
+    MEDFileField1TSNDTemplateWithoutSDA() { }
+    MEDFileField1TSNDTemplateWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos):MEDFileField1TSTemplateWithoutSDA<T>(fieldName,meshName,csit,iteration,order) { }
+  };
+  
+  /*!
+   * SDA is for Shared Data Arrays such as profiles.
+   */
+  class MEDFileIntField1TSWithoutSDA : public MEDFileField1TSNDTemplateWithoutSDA<int>
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA();
+    MEDLOADER_EXPORT static MEDFileIntField1TSWithoutSDA *New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
+    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA *deepCopy() const;
+    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA *shallowCpy() const;
+    MEDLOADER_EXPORT const char *getTypeStr() const;
+    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDLOADER_EXPORT DataArrayInt *getUndergroundDataArrayIntExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+  protected:
+    MEDFileIntField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
+  public:
+    MEDLOADER_EXPORT static const char TYPE_STR[];
+  };
+
+  /*!
+   * SDA is for Shared Data Arrays such as profiles.
+   */
+  class MEDFileFloatField1TSWithoutSDA : public MEDFileField1TSNDTemplateWithoutSDA<float>
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileFloatField1TSWithoutSDA();
+    MEDLOADER_EXPORT static MEDFileFloatField1TSWithoutSDA *New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
+    MEDLOADER_EXPORT MEDFileFloatField1TSWithoutSDA *deepCopy() const;
+    MEDLOADER_EXPORT MEDFileFloatField1TSWithoutSDA *shallowCpy() const;
+    MEDLOADER_EXPORT const char *getTypeStr() const;
+    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDLOADER_EXPORT DataArrayFloat *getUndergroundDataArrayFloatExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+  protected:
+    MEDFileFloatField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
+  public:
+    MEDLOADER_EXPORT static const char TYPE_STR[];
+  };
+
+  /*!
+   * User class.
+   */
+  class MEDFileAnyTypeField1TS : public RefCountObject, public MEDFileWritableStandAlone, public MEDFileFieldGlobsReal
+  {
+  protected:
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS();
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(const MEDFileAnyTypeField1TSWithoutSDA& other, bool shallowCopyOfContent);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c, med_idt fid);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TSWithoutSDA *BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TSWithoutSDA *BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TSWithoutSDA *BuildContentFrom(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT void writeLL(med_idt fid) const;
+    // direct forwarding to MEDFileAnyTypeField1TSWithoutSDA instance _content
+  public:
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(const std::string& fileName, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(med_idt fid, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *NewAdv(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *NewAdv(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT int getDimension() const;
+    MEDLOADER_EXPORT int getIteration() const;
+    MEDLOADER_EXPORT int getOrder() const;
+    MEDLOADER_EXPORT double getTime(int& iteration, int& order) const;
+    MEDLOADER_EXPORT void setTime(int iteration, int order, double val);
+    MEDLOADER_EXPORT std::string getName() const;
+    MEDLOADER_EXPORT void setName(const std::string& name);
+    MEDLOADER_EXPORT std::string simpleRepr() const;
+    MEDLOADER_EXPORT void simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const;
+    MEDLOADER_EXPORT std::string getDtUnit() const;
+    MEDLOADER_EXPORT void setDtUnit(const std::string& dtUnit);
+    MEDLOADER_EXPORT std::string getMeshName() const;
+    MEDLOADER_EXPORT void setMeshName(const std::string& newMeshName);
+    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
+    MEDLOADER_EXPORT int getMeshIteration() const;
+    MEDLOADER_EXPORT int getMeshOrder() const;
+    MEDLOADER_EXPORT int getNumberOfComponents() const;
+    MEDLOADER_EXPORT bool isDealingTS(int iteration, int order) const;
+    MEDLOADER_EXPORT std::pair<int,int> getDtIt() const;
+    MEDLOADER_EXPORT void fillIteration(std::pair<int,int>& p) const;
+    MEDLOADER_EXPORT void fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const;
+    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& infos);
+    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
+    MEDLOADER_EXPORT std::vector<std::string>& getInfo();
+    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
+    MEDLOADER_EXPORT std::vector<TypeOfField> getTypesOfFieldAvailable() const;
+    MEDLOADER_EXPORT std::vector< std::vector<std::pair<int,int> > > getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
+        std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    MEDLOADER_EXPORT MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId);
+    MEDLOADER_EXPORT const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const;
+    MEDLOADER_EXPORT int getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const;
+    MEDLOADER_EXPORT void convertMedBallIntoClassic();
+    MEDLOADER_EXPORT void makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl);
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const = 0;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TS *shallowCpy() const = 0;
+  public:
+    MEDLOADER_EXPORT void loadArrays();
+    MEDLOADER_EXPORT void loadArraysIfNecessary();
+    MEDLOADER_EXPORT void unloadArrays();
+    MEDLOADER_EXPORT void unloadArraysWithoutDataLoss();
+    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeField1TS > > splitComponents() const;
+    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeField1TS > > splitDiscretizations() const;
+    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeField1TS > > splitMultiDiscrPerGeoTypes() const;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *deepCopy() const;
+    MEDLOADER_EXPORT int copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr);
+    MEDLOADER_EXPORT int copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr);
+  public:
+    //! underground method see MEDFileField1TSWithoutSDA::setProfileNameOnLeaf
+    MEDLOADER_EXPORT void setProfileNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newPflName, bool forceRenameOnGlob=false);
+    //! underground method see MEDFileField1TSWithoutSDA::setLocNameOnLeaf
+    MEDLOADER_EXPORT void setLocNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newLocName, bool forceRenameOnGlob=false);
+    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
+    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed() const;
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti() const;
+    MEDLOADER_EXPORT void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+  public:
+    MEDLOADER_EXPORT static int LocateField2(med_idt fid, int fieldIdCFormat, bool checkFieldId, std::string& fieldName, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName);
+    MEDLOADER_EXPORT static int LocateField(med_idt fid, const std::string& fieldName, int& posCFormat, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName);
+  public:
+    MEDLOADER_EXPORT virtual med_field_type getMEDFileFieldType() const = 0;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA *contentNotNullBase();
+    MEDLOADER_EXPORT const MEDFileAnyTypeField1TSWithoutSDA *contentNotNullBase() const;
+  protected:
+    MCAuto<MEDFileAnyTypeField1TSWithoutSDA> _content;
+  };
+
+  class MEDFileIntField1TS;
+
+  template<class T>
+  class MEDFileTemplateField1TS : public MEDFileAnyTypeField1TS
+  {
+  public:
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New();
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const std::string& fileName, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(med_idt fid, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(DataArrayByte *db) { return BuildFromMemoryChunk<typename MLFieldTraits<T>::F1TSType>(db); }
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const typename MLFieldTraits<T>::F1TSWSDAType& other, bool shallowCopyOfContent);
+  public:
+    MEDLOADER_EXPORT static typename Traits<T>::ArrayType *ReturnSafelyTypedDataArray(MCAuto<DataArray>& arr);
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl) const;
+    MEDLOADER_EXPORT void setArray(DataArray *arr);
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArray() const;
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDLOADER_EXPORT static MCAuto<typename Traits<T>::FieldType> SetDataArrayInField(MEDCouplingFieldDouble *f, MCAuto<DataArray>& arr);
+    MEDLOADER_EXPORT static MCAuto<MEDCouplingFieldDouble> ToFieldTemplateWithTime(const typename Traits<T>::FieldType *f);
+  public:
+    MEDLOADER_EXPORT void copyTimeInfoFrom(const typename Traits<T>::FieldType *mcf);
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *field(const MEDFileMesh *mesh) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtTopLevel(TypeOfField type, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, const MEDCouplingMesh *mesh, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevelOld(TypeOfField type, const std::string& mname, int meshDimRelToMax, int renumPol=0) const;
+    MEDLOADER_EXPORT void setFieldNoProfileSBT(const typename Traits<T>::FieldType *field);
+    MEDLOADER_EXPORT void setFieldProfile(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile);
+    MEDLOADER_EXPORT void setFieldProfileFlatly(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile);
+    MEDLOADER_EXPORT typename MLFieldTraits<T>::F1TSType *extractPartImpl(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const { return this->extractPartImpl(extractDef,mm); }
+  protected:
+    ~MEDFileTemplateField1TS() { }
+    MEDFileTemplateField1TS();
+    MEDFileTemplateField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileAnyTypeField1TS(fid,loadAll,ms) { }
+    MEDFileTemplateField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileAnyTypeField1TS(fid,fieldName,loadAll,ms) { }
+    MEDFileTemplateField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileAnyTypeField1TS(fid,fieldName,iteration,order,loadAll,ms) { }
+    MEDFileTemplateField1TS(const typename MLFieldTraits<T>::F1TSWSDAType& other, bool shallowCopyOfContent):MEDFileAnyTypeField1TS(other,shallowCopyOfContent) { }
+    const typename MLFieldTraits<T>::F1TSWSDAType *contentNotNull() const;
+    typename MLFieldTraits<T>::F1TSWSDAType *contentNotNull();
+    void setFieldProfileGeneral(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, bool smartPflKiller);
+  };
+
+  /*!
+   * User class.
+   */
+  class MEDFileField1TS : public MEDFileTemplateField1TS<double>
+  {
+    friend class MEDFileTemplateField1TS<double>;
+  public:
+    MEDLOADER_EXPORT MEDFileIntField1TS *convertToInt(bool isDeepCpyGlobs=true) const;
+  public:
+    MEDLOADER_EXPORT MEDFileField1TS *shallowCpy() const;
+    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
+                                                                                          std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+  public:
+  private:
+    med_field_type getMEDFileFieldType() const { return MED_FLOAT64; }
+  private:
+    ~MEDFileField1TS() { }
+    MEDFileField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
+    MEDFileField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms);
+    MEDFileField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms);
+    MEDFileField1TS(const MEDFileField1TSWithoutSDA& other, bool shallowCopyOfContent);
+    MEDFileField1TS() { }
+  };
+
+  template<class T>
+  class MEDFileNDTemplateField1TS : public MEDFileTemplateField1TS<T>
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileField1TS *convertToDouble(bool isDeepCpyGlobs=true) const;
+  protected:
+    ~MEDFileNDTemplateField1TS() { }
+    MEDFileNDTemplateField1TS() { }
+    MEDFileNDTemplateField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateField1TS<T>(fid,loadAll,ms) { }
+    MEDFileNDTemplateField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateField1TS<T>(fid,fieldName,loadAll,ms) { }
+    MEDFileNDTemplateField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateField1TS<T>(fid,fieldName,iteration,order,loadAll,ms) { }
+    MEDFileNDTemplateField1TS(const typename MLFieldTraits<T>::F1TSWSDAType& other, bool shallowCopyOfContent):MEDFileTemplateField1TS<T>(other,shallowCopyOfContent) { }
+  };
+
+  class MEDFileIntField1TS : public MEDFileNDTemplateField1TS<int>
+  {
+    friend class MEDFileTemplateField1TS<int>;
+  public:
+    MEDLOADER_EXPORT MEDFileIntField1TS *shallowCpy() const { return new MEDFileIntField1TS(*this); }
+  public:
+    MEDLOADER_EXPORT static MCAuto<MEDCouplingFieldDouble> ConvertFieldIntToFieldDouble(const MEDCouplingFieldInt *f);
+  private:
+    med_field_type getMEDFileFieldType() const { return MED_INT32; }
+  private:
+    ~MEDFileIntField1TS() { }
+    MEDFileIntField1TS() { }
+    MEDFileIntField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<int>(fid,loadAll,ms) { }
+    MEDFileIntField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<int>(fid,fieldName,loadAll,ms) { }
+    MEDFileIntField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<int>(fid,fieldName,iteration,order,loadAll,ms) { }
+    /*!
+     * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
+     * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
+     *
+     * \warning this is a shallow copy constructor
+     */
+    MEDFileIntField1TS(const MEDFileIntField1TSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateField1TS<int>(other,shallowCopyOfContent) { }
+  };
+
+  class MEDFileFloatField1TS : public MEDFileNDTemplateField1TS<float>
+  {
+    friend class MEDFileTemplateField1TS<float>;
+  private:
+    med_field_type getMEDFileFieldType() const { return MED_FLOAT32; }
+    MEDLOADER_EXPORT MEDFileFloatField1TS *shallowCpy() const { return new MEDFileFloatField1TS(*this); }
+  private:
+    ~MEDFileFloatField1TS() { }
+    MEDFileFloatField1TS() { }
+    MEDFileFloatField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<float>(fid,loadAll,ms) { }
+    MEDFileFloatField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<float>(fid,fieldName,loadAll,ms) { }
+    MEDFileFloatField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<float>(fid,fieldName,iteration,order,loadAll,ms) { }
+    /*!
+     * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
+     * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
+     *
+     * \warning this is a shallow copy constructor
+     */
+    MEDFileFloatField1TS(const MEDFileFloatField1TSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateField1TS<float>(other,shallowCopyOfContent) { }
+  };
+}
+
+#endif
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileField.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileField.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileField.cxx	2018-04-19 17:04:36.741222802 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileField.cxx	2018-04-19 17:25:17.826799116 +0200
@@ -18,7 +18,7 @@
 //
 // Author : Anthony Geay (EDF R&D)
 
-#include "MEDFileField.txx"
+#include "MEDFileField.hxx"
 #include "MEDFileMesh.hxx"
 #include "MEDLoaderBase.hxx"
 #include "MEDLoaderTraits.hxx"
@@ -35,8923 +35,12 @@
 #include <algorithm>
 #include <iterator>
 
-extern med_geometry_type typmai[MED_N_CELL_FIXED_GEO];
 extern INTERP_KERNEL::NormalizedCellType typmai2[MED_N_CELL_FIXED_GEO];
 extern med_geometry_type typmainoeud[1];
 extern med_geometry_type typmai3[34];
 
 using namespace MEDCoupling;
 
-template class MEDCoupling::MEDFileField1TSTemplateWithoutSDA<int>;
-template class MEDCoupling::MEDFileField1TSTemplateWithoutSDA<float>;
-template class MEDCoupling::MEDFileField1TSTemplateWithoutSDA<double>;
-template class MEDCoupling::MEDFileField1TSNDTemplateWithoutSDA<int>;
-template class MEDCoupling::MEDFileField1TSNDTemplateWithoutSDA<float>;
-template class MEDCoupling::MEDFileNDTemplateFieldMultiTSWithoutSDA<int>;
-template class MEDCoupling::MEDFileNDTemplateFieldMultiTSWithoutSDA<float>;
-template class MEDCoupling::MEDFileTemplateField1TS<int>;
-template class MEDCoupling::MEDFileTemplateField1TS<float>;
-template class MEDCoupling::MEDFileTemplateField1TS<double>;
-template class MEDCoupling::MEDFileNDTemplateField1TS<int>;
-template class MEDCoupling::MEDFileNDTemplateField1TS<float>;
-template class MEDCoupling::MEDFileTemplateFieldMultiTS<int>;
-template class MEDCoupling::MEDFileTemplateFieldMultiTS<float>;
-template class MEDCoupling::MEDFileTemplateFieldMultiTS<double>;
-template class MEDCoupling::MEDFileNDTemplateFieldMultiTS<int>;
-template class MEDCoupling::MEDFileNDTemplateFieldMultiTS<float>;
-
-const char MEDFileField1TSWithoutSDA::TYPE_STR[]="FLOAT64";
-const char MEDFileIntField1TSWithoutSDA::TYPE_STR[]="INT32";
-const char MEDFileFloatField1TSWithoutSDA::TYPE_STR[]="FLOAT32";
-
-MEDFileGTKeeper::~MEDFileGTKeeper()
-{
-}
-
-MEDFileGTKeeper *MEDFileGTKeeperSta::deepCopy() const
-{
-  return new MEDFileGTKeeperSta(_geo_type);
-}
-
-INTERP_KERNEL::NormalizedCellType MEDFileGTKeeperSta::getGeoType() const
-{
-  return _geo_type;
-}
-
-std::string MEDFileGTKeeperSta::getRepr() const
-{
-  return INTERP_KERNEL::CellModel::GetCellModel(_geo_type).getRepr();
-}
-
-bool MEDFileGTKeeperSta::isEqual(const MEDFileGTKeeper *other) const
-{
-  const MEDFileGTKeeperSta *otherC(dynamic_cast<const MEDFileGTKeeperSta *>(other));
-  if(!otherC)
-    return false;
-  return _geo_type==otherC->_geo_type;
-}
-
-MEDFileGTKeeperDyn::MEDFileGTKeeperDyn(const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileStructureElement *se):_mesh(mesh),_section(section),_se(se)
-{
-  if(mesh)
-    mesh->incrRef();
-  if(section)
-    section->incrRef();
-  if(se)
-    se->incrRef();
-  if(_mesh.isNull() || _section.isNull() || _se.isNull())
-    throw INTERP_KERNEL::Exception("MEDFileGTKeeperDyn constructor : null pointer not allowed !");
-}
-
-MEDFileGTKeeper *MEDFileGTKeeperDyn::deepCopy() const
-{
-  return new MEDFileGTKeeperDyn(_mesh,_section,_se);
-}
-
-INTERP_KERNEL::NormalizedCellType MEDFileGTKeeperDyn::getGeoType() const
-{
-  throw INTERP_KERNEL::Exception("MEDFileGTKeeperDyn::getGeoType : not valid !");
-}
-
-std::string MEDFileGTKeeperDyn::getRepr() const
-{
-  std::ostringstream oss;
-  oss << _se->getDynGT();
-  return oss.str();
-}
-
-bool MEDFileGTKeeperDyn::isEqual(const MEDFileGTKeeper *other) const
-{
-  const MEDFileGTKeeperDyn *otherC(dynamic_cast<const MEDFileGTKeeperDyn *>(other));
-  if(!otherC)
-    return false;
-  return this==otherC;
-}
-
-MEDFileFieldLoc *MEDFileFieldLoc::New(med_idt fid, const std::string& locName)
-{
-  return new MEDFileFieldLoc(fid,locName);
-}
-
-MEDFileFieldLoc *MEDFileFieldLoc::New(med_idt fid, int id, const MEDFileEntities *entities)
-{
-  return new MEDFileFieldLoc(fid,id,entities);
-}
-
-MEDFileFieldLoc *MEDFileFieldLoc::New(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w)
-{
-  return new MEDFileFieldLoc(locName,geoType,refCoo,gsCoo,w);
-}
-
-MEDFileFieldLoc::MEDFileFieldLoc(med_idt fid, const std::string& locName):_name(locName)
-{
-  med_geometry_type geotype;
-  med_geometry_type sectiongeotype;
-  int nsectionmeshcell;
-  INTERP_KERNEL::AutoPtr<char> geointerpname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> sectionmeshname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  MEDlocalizationInfoByName(fid,locName.c_str(),&geotype,&_dim,&_nb_gauss_pt,geointerpname,sectionmeshname,&nsectionmeshcell,&sectiongeotype);
-  _gt=new MEDFileGTKeeperSta((INTERP_KERNEL::NormalizedCellType)(std::distance(typmai3,std::find(typmai3,typmai3+34,geotype))));
-  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
-  _nb_node_per_cell=cm.getNumberOfNodes();
-  _ref_coo.resize(_dim*_nb_node_per_cell);
-  _gs_coo.resize(_dim*_nb_gauss_pt);
-  _w.resize(_nb_gauss_pt);
-  MEDlocalizationRd(fid,locName.c_str(),MED_FULL_INTERLACE,&_ref_coo[0],&_gs_coo[0],&_w[0]);
-}
-
-MEDFileFieldLoc::MEDFileFieldLoc(med_idt fid, int id, const MEDFileEntities *entities)
-{
-  med_geometry_type geotype;
-  med_geometry_type sectiongeotype;
-  int nsectionmeshcell;
-  INTERP_KERNEL::AutoPtr<char> locName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> geointerpname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> sectionmeshname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  MEDlocalizationInfo(fid,id+1,locName,&geotype,&_dim,&_nb_gauss_pt,geointerpname,sectionmeshname,&nsectionmeshcell,&sectiongeotype);
-  _name=locName;
-  std::string sectionName(MEDLoaderBase::buildStringFromFortran(sectionmeshname,MED_NAME_SIZE));
-  if(sectionName.empty())
-    {
-      _gt=new MEDFileGTKeeperSta((INTERP_KERNEL::NormalizedCellType)(std::distance(typmai3,std::find(typmai3,typmai3+34,geotype))));
-      const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
-      _nb_node_per_cell=cm.getNumberOfNodes();
-    }
-  else
-    {
-      const MEDFileAllStaticEntitiesPlusDyn *entities2(dynamic_cast<const MEDFileAllStaticEntitiesPlusDyn *>(entities));
-      if(!entities2)
-        {
-          std::ostringstream oss; oss << "MEDFileFieldLoc cstr : for loc \"" << _name << "\" presence of non static type ! Expect entities !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      const MEDFileStructureElement *se(entities2->getWithGT(geotype));
-      const MEDFileUMesh *um(entities2->getSupMeshWithName(se->getMeshName()));
-      const MEDFileUMesh *section(entities2->getSupMeshWithName(sectionName));
-      _gt=new MEDFileGTKeeperDyn(um,section,se);
-      {
-        int dummy;
-        MEDFILESAFECALLERWR0(MEDmeshGeotypeParameter,(fid,geotype,&dummy,&_nb_node_per_cell));
-      }
-    }
-  _ref_coo.resize(_dim*_nb_node_per_cell);
-  _gs_coo.resize(_dim*_nb_gauss_pt);
-  _w.resize(_nb_gauss_pt);
-  MEDlocalizationRd(fid,locName,MED_FULL_INTERLACE,&_ref_coo[0],&_gs_coo[0],&_w[0]);
-}
-
-MEDFileFieldLoc::MEDFileFieldLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType,
-                                 const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w):_name(locName),_gt(new MEDFileGTKeeperSta(geoType)),_ref_coo(refCoo),_gs_coo(gsCoo),_w(w)
-{
-  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
-  _dim=cm.getDimension();
-  _nb_node_per_cell=cm.getNumberOfNodes();
-  _nb_gauss_pt=_w.size();
-}
-
-
-MEDFileFieldLoc::MEDFileFieldLoc(const MEDFileFieldLoc& other):_dim(other._dim),_nb_gauss_pt(other._nb_gauss_pt),_gt(other._gt->deepCopy()),_nb_node_per_cell(other._nb_node_per_cell),_name(other._name),_ref_coo(other._ref_coo),_gs_coo(other._gs_coo),_w(other._w)
-{
-}
-
-MEDFileFieldLoc *MEDFileFieldLoc::deepCopy() const
-{
-  return new MEDFileFieldLoc(*this);
-}
-
-bool MEDFileFieldLoc::isOnStructureElement() const
-{
-  const MEDFileGTKeeper *gt(_gt);
-  if(!gt)
-    throw INTERP_KERNEL::Exception("MEDFileFieldLoc::isOnStructureElement : null pointer !");
-  const MEDFileGTKeeperDyn *gt2(dynamic_cast<const MEDFileGTKeeperDyn *>(gt));
-  return gt2!=NULL;
-}
-
-std::size_t MEDFileFieldLoc::getHeapMemorySizeWithoutChildren() const
-{
-  return (_ref_coo.capacity()+_gs_coo.capacity()+_w.capacity())*sizeof(double)+_name.capacity();
-}
-
-std::vector<const BigMemoryObject *> MEDFileFieldLoc::getDirectChildrenWithNull() const
-{
-  return std::vector<const BigMemoryObject *>();
-}
-
-void MEDFileFieldLoc::simpleRepr(std::ostream& oss) const
-{
-  static const char OFF7[]="\n    ";
-  oss << "\"" << _name << "\"" << OFF7;
-  oss << "GeoType=" << _gt->getRepr() << OFF7;
-  oss << "Dimension=" << _dim << OFF7;
-  oss << "Number of Gauss points=" << _nb_gauss_pt << OFF7;
-  oss << "Number of nodes per cell=" << _nb_node_per_cell << OFF7;
-  oss << "RefCoords="; std::copy(_ref_coo.begin(),_ref_coo.end(),std::ostream_iterator<double>(oss," ")); oss << OFF7;
-  oss << "Weights="; std::copy(_w.begin(),_w.end(),std::ostream_iterator<double>(oss," ")); oss << OFF7;
-  oss << "GaussPtsCoords="; std::copy(_gs_coo.begin(),_gs_coo.end(),std::ostream_iterator<double>(oss," ")); oss << std::endl;
-}
-
-void MEDFileFieldLoc::setName(const std::string& name)
-{
-  _name=name;
-}
-
-bool MEDFileFieldLoc::isEqual(const MEDFileFieldLoc& other, double eps) const
-{
-  if(_name!=other._name)
-    return false;
-  if(_dim!=other._dim)
-    return false;
-  if(_nb_gauss_pt!=other._nb_gauss_pt)
-    return false;
-  if(_nb_node_per_cell!=other._nb_node_per_cell)
-    return false;
-  if(!_gt->isEqual(other._gt))
-    return false;
-  if(!MEDCouplingGaussLocalization::AreAlmostEqual(_ref_coo,other._ref_coo,eps))
-    return false;
-  if(!MEDCouplingGaussLocalization::AreAlmostEqual(_gs_coo,other._gs_coo,eps))
-    return false;
-  if(!MEDCouplingGaussLocalization::AreAlmostEqual(_w,other._w,eps))
-    return false;
-
-  return true;
-}
-
-void MEDFileFieldLoc::writeLL(med_idt fid) const
-{
-  MEDlocalizationWr(fid,_name.c_str(),typmai3[(int)getGeoType()],_dim,&_ref_coo[0],MED_FULL_INTERLACE,_nb_gauss_pt,&_gs_coo[0],&_w[0],MED_NO_INTERPOLATION,MED_NO_MESH_SUPPORT);
-}
-
-std::string MEDFileFieldLoc::repr() const
-{
-  std::ostringstream oss; oss.precision(15);
-  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
-  oss << "Localization \"" << _name << "\" :\n" << "  - Geometric Type : " << cm.getRepr();
-  oss << "\n  - Dimension : " << _dim << "\n  - Number of gauss points : ";
-  oss << _nb_gauss_pt << "\n  - Number of nodes in cell : " << _nb_node_per_cell;
-  oss << "\n  - Ref coords are : ";
-  int sz=_ref_coo.size();
-  if(sz%_dim==0)
-    {
-      int nbOfTuples=sz/_dim;
-      for(int i=0;i<nbOfTuples;i++)
-        {
-          oss << "(";
-          for(int j=0;j<_dim;j++)
-            { oss << _ref_coo[i*_dim+j]; if(j!=_dim-1) oss << ", "; }
-          oss << ") ";
-        }
-    }
-  else
-    std::copy(_ref_coo.begin(),_ref_coo.end(),std::ostream_iterator<double>(oss," "));
-  oss << "\n  - Gauss coords in reference element : ";
-  sz=_gs_coo.size();
-  if(sz%_dim==0)
-    {
-      int nbOfTuples=sz/_dim;
-      for(int i=0;i<nbOfTuples;i++)
-        {
-          oss << "(";
-          for(int j=0;j<_dim;j++)
-            { oss << _gs_coo[i*_dim+j]; if(j!=_dim-1) oss << ", "; }
-          oss << ") ";
-        }
-    }
-  else
-    std::copy(_gs_coo.begin(),_gs_coo.end(),std::ostream_iterator<double>(oss," "));
-  oss << "\n  - Weights of Gauss coords are : "; std::copy(_w.begin(),_w.end(),std::ostream_iterator<double>(oss," "));
-  return oss.str();
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  _type=field->getTypeOfField();
-  _start=start;
-  switch(_type)
-  {
-    case ON_CELLS:
-      {
-        getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,offset,offset+nbOfCells,1);
-        _end=_start+nbOfCells;
-        _nval=nbOfCells;
-        break;
-      }
-    case ON_GAUSS_NE:
-      {
-        MCAuto<DataArrayInt> arr=field->getDiscretization()->getOffsetArr(field->getMesh());
-        const int *arrPtr=arr->getConstPointer();
-        getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,arrPtr[offset],arrPtr[offset+nbOfCells],1);
-        _end=_start+(arrPtr[offset+nbOfCells]-arrPtr[offset]);
-        _nval=nbOfCells;
-        break;
-      }
-    case ON_GAUSS_PT:
-      {
-        const MEDCouplingFieldDiscretization *disc(field->getDiscretization());
-        const MEDCouplingGaussLocalization& gsLoc(field->getGaussLocalization(_loc_id));
-        const MEDCouplingFieldDiscretizationGauss *disc2(dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(disc));
-        if(!disc2)
-          throw INTERP_KERNEL::Exception("assignFieldNoProfile : invalid call to this method ! Internal Error !");
-        const DataArrayInt *dai(disc2->getArrayOfDiscIds());
-        MCAuto<DataArrayInt> dai2(disc2->getOffsetArr(field->getMesh()));
-        const int *dai2Ptr(dai2->getConstPointer());
-        int nbi(gsLoc.getWeights().size());
-        MCAuto<DataArrayInt> da2(dai->selectByTupleIdSafeSlice(offset,offset+nbOfCells,1));
-        MCAuto<DataArrayInt> da3(da2->findIdsEqual(_loc_id));
-        const int *da3Ptr(da3->getConstPointer());
-        if(da3->getNumberOfTuples()!=nbOfCells)
-          {//profile : for gauss even in NoProfile !!!
-            std::ostringstream oss; oss << "Pfl_" << nasc.getName() << "_" << INTERP_KERNEL::CellModel::GetCellModel(getGeoType()).getRepr() << "_" << _loc_id;
-            _profile=oss.str();
-            da3->setName(_profile.c_str());
-            glob.appendProfile(da3);
-          }
-        MCAuto<DataArrayInt> da4(DataArrayInt::New());
-        _nval=da3->getNbOfElems();
-        da4->alloc(_nval*nbi,1);
-        int *da4Ptr(da4->getPointer());
-        for(int i=0;i<_nval;i++)
-          {
-            int ref=dai2Ptr[offset+da3Ptr[i]];
-            for(int j=0;j<nbi;j++)
-              *da4Ptr++=ref+j;
-          }
-        std::ostringstream oss2; oss2 << "Loc_" << nasc.getName() << "_" << INTERP_KERNEL::CellModel::GetCellModel(getGeoType()).getRepr() << "_" << _loc_id;
-        _localization=oss2.str();
-        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,da4);
-        _end=_start+_nval*nbi;
-        glob.appendLoc(_localization.c_str(),getGeoType(),gsLoc.getRefCoords(),gsLoc.getGaussCoords(),gsLoc.getWeights());
-        break;
-      }
-    default:
-      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::assignFieldNoProfile : not implemented yet for such discretization type of field !");
-  }
-  start=_end;
-}
-
-/*!
- * Leaf method of field with profile assignement. This method is the most general one. No optimization is done here.
- * \param [in] pflName input containing name of profile if any. 0 if no profile (except for GAUSS_PT where a no profile can hide a profile when splitted by loc_id).
- * \param [in] multiTypePfl is the end user profile specified in high level API
- * \param [in] idsInPfl is the selection into the \a multiTypePfl whole profile that corresponds to the current geometric type.
- * \param [in] locIds is the profile needed to be created for MED file format. It can be null if all cells of current geometric type are fetched in \a multiTypePfl.
- *             \b WARNING if not null the MED file profile can be subdivided again in case of Gauss points.
- * \param [in] mesh is the mesh coming from the MEDFileMesh instance in correspondance with the MEDFileField. The mesh inside the \a field is simply ignored.
- */
-void MEDFileFieldPerMeshPerTypePerDisc::assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arrr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  _profile.clear();
-  _type=field->getTypeOfField();
-  std::string pflName(multiTypePfl->getName());
-  std::ostringstream oss; oss << pflName;
-  if(_type!=ON_NODES)
-    {
-      if(!isPflAlone)
-        { const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType()); oss << "_" <<  cm.getRepr(); }
-    }
-  else
-    { oss << "_NODE"; }
-  if(locIds)
-    {
-      if(pflName.empty())
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::assignFieldProfile : existing profile with empty name !");
-      if(_type!=ON_GAUSS_PT)
-        {
-          locIds->setName(oss.str());
-          glob.appendProfile(locIds);
-          _profile=oss.str();
-        }
-    }
-  _start=start;
-  switch(_type)
-  {
-    case ON_NODES:
-      {
-        _nval=idsInPfl->getNumberOfTuples();
-        getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,0,arrr->getNumberOfTuples(),1);
-        _end=_start+_nval;
-        break;
-      }
-    case ON_CELLS:
-      {
-        _nval=idsInPfl->getNumberOfTuples();
-        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,idsInPfl);
-        _end=_start+_nval;
-        break;
-      }
-    case ON_GAUSS_NE:
-      {
-        MCAuto<DataArrayInt> arr=field->getDiscretization()->getOffsetArr(mesh);
-        MCAuto<DataArrayInt> arr2=arr->deltaShiftIndex();
-        MCAuto<DataArrayInt> arr3=arr2->selectByTupleId(multiTypePfl->begin(),multiTypePfl->end());
-        arr3->computeOffsetsFull();
-        MCAuto<DataArrayInt> tmp=idsInPfl->buildExplicitArrByRanges(arr3);
-        int trueNval=tmp->getNumberOfTuples();
-        _nval=idsInPfl->getNumberOfTuples();
-        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,tmp);
-        _end=_start+trueNval;
-        break;
-      }
-    case ON_GAUSS_PT:
-      {
-        const MEDCouplingFieldDiscretizationGauss *disc2=dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(field->getDiscretization());
-        if(!disc2)
-          throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : invalid call to this method ! Internal Error !");
-        const DataArrayInt *da1=disc2->getArrayOfDiscIds();
-        const MEDCouplingGaussLocalization& gsLoc=field->getGaussLocalization(_loc_id);
-        MCAuto<DataArrayInt> da2=da1->selectByTupleId(idsInPfl->begin(),idsInPfl->end());
-        MCAuto<DataArrayInt> da3=da2->findIdsEqual(_loc_id);
-        MCAuto<DataArrayInt> da4=idsInPfl->selectByTupleId(da3->begin(),da3->end());
-        //
-        MCAuto<MEDCouplingMesh> mesh2=mesh->buildPart(multiTypePfl->begin(),multiTypePfl->end());
-        MCAuto<DataArrayInt> arr=disc2->getOffsetArr(mesh2);
-        //
-        MCAuto<DataArrayInt> tmp=DataArrayInt::New();
-        int trueNval=0;
-        for(const int *pt=da4->begin();pt!=da4->end();pt++)
-          trueNval+=arr->getIJ(*pt+1,0)-arr->getIJ(*pt,0);
-        tmp->alloc(trueNval,1);
-        int *tmpPtr=tmp->getPointer();
-        for(const int *pt=da4->begin();pt!=da4->end();pt++)
-          for(int j=arr->getIJ(*pt,0);j<arr->getIJ(*pt+1,0);j++)
-            *tmpPtr++=j;
-        //
-        _nval=da4->getNumberOfTuples();
-        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,tmp);
-        _end=_start+trueNval;
-        oss << "_loc_" << _loc_id;
-        if(locIds)
-          {
-            MCAuto<DataArrayInt> da5=locIds->selectByTupleId(da3->begin(),da3->end());
-            da5->setName(oss.str());
-            glob.appendProfile(da5);
-            _profile=oss.str();
-          }
-        else
-          {
-            if(!da3->isIota(nbOfEltsInWholeMesh))
-              {
-                da3->setName(oss.str());
-                glob.appendProfile(da3);
-                _profile=oss.str();
-              }
-          }
-        std::ostringstream oss2; oss2 << "Loc_" << nasc.getName() << "_" << INTERP_KERNEL::CellModel::GetCellModel(getGeoType()).getRepr() << "_" << _loc_id;
-        _localization=oss2.str();
-        glob.appendLoc(_localization.c_str(),getGeoType(),gsLoc.getRefCoords(),gsLoc.getGaussCoords(),gsLoc.getWeights());
-        break;
-      }
-    default:
-      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::assignFieldProfile : not implemented yet for such discretization type of field !");
-  }
-  start=_end;
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob)
-{
-  _start=start;
-  _nval=arrr->getNumberOfTuples();
-  getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,0,_nval,1);
-  _end=_start+_nval;
-  start=_end;
-}
-
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const PartDefinition *pd)
-{
-  return new MEDFileFieldPerMeshPerTypePerDisc(fath,type,profileIt,pd);
-}
-
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::New(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int locId)
-{
-  return new MEDFileFieldPerMeshPerTypePerDisc(fath,type,locId,std::string());
-}
-
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::New(const MEDFileFieldPerMeshPerTypePerDisc& other)
-{
-  return new MEDFileFieldPerMeshPerTypePerDisc(other);
-}
-
-std::size_t MEDFileFieldPerMeshPerTypePerDisc::getHeapMemorySizeWithoutChildren() const
-{
-  return _profile.capacity()+_localization.capacity()+sizeof(MEDFileFieldPerMeshPerTypePerDisc);
-}
-
-std::vector<const BigMemoryObject *> MEDFileFieldPerMeshPerTypePerDisc::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret(1);
-  ret[0]=(const PartDefinition*)_pd;
-  return ret;
-}
-
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::deepCopy(MEDFileFieldPerMeshPerTypeCommon *father) const
-{
-  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> ret(new MEDFileFieldPerMeshPerTypePerDisc(*this));
-  ret->_father=father;
-  return ret.retn();
-}
-
-MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField atype, int profileIt, const PartDefinition *pd)
-try:_type(atype),_father(fath),_profile_it(profileIt),_pd(const_cast<PartDefinition *>(pd))
-{
-  if(pd)
-    pd->incrRef();
-}
-catch(INTERP_KERNEL::Exception& e)
-{
-    throw e;
-}
-
-MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int locId, const std::string& dummy):_type(type),_father(fath),_loc_id(locId)
-{
-}
-
-MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc(const MEDFileFieldPerMeshPerTypePerDisc& other):RefCountObject(other),_type(other._type),_father(0),_start(other._start),_end(other._end),_nval(other._nval),_profile(other._profile),_localization(other._localization),_loc_id(other._loc_id),_profile_it(other._profile_it),_pd(other._pd),_tmp_work1(other._tmp_work1)
-{
-}
-
-MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc():_type(ON_CELLS),_father(0),_start(-std::numeric_limits<int>::max()),_end(-std::numeric_limits<int>::max()),
-    _nval(-std::numeric_limits<int>::max()),_loc_id(-std::numeric_limits<int>::max())
-{
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile(med_idt fid, const std::string& fieldName, int nbOfCompo, int iteration, int order, med_entity_type menti, med_geometry_type mgeoti, unsigned char *startFeedingPtr)
-{
-  const PartDefinition *pd(_pd);
-  if(!pd)
-    {
-      INTERP_KERNEL::AutoPtr<char> locname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-      int nbi,tmp1;
-      med_int nbValsInFile(MEDfieldnValueWithProfileByName(fid,fieldName.c_str(),iteration,order,menti,mgeoti,_profile.c_str(),MED_COMPACT_PFLMODE,&tmp1,locname,&nbi));
-      if(_end-_start!=nbValsInFile*nbi)
-        {
-          std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile : The number of tuples to read is " << nbValsInFile << "*" << nbi <<  " (nb integration points) ! But in data structure it values " << _end-_start << " is expected !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      MEDFILESAFECALLERRD0(MEDfieldValueWithProfileRd,(fid,fieldName.c_str(),iteration,order,menti,mgeoti,MED_COMPACT_PFLMODE,_profile.c_str(),MED_FULL_INTERLACE,MED_ALL_CONSTITUENT,startFeedingPtr));
-    }
-  else
-    {
-      if(!_profile.empty())
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile : not implemented !");
-      INTERP_KERNEL::AutoPtr<char> pflname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE)),locname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-      int profilesize,nbi;
-      int overallNval(MEDfieldnValueWithProfile(fid,fieldName.c_str(),iteration,order,menti,mgeoti,_profile_it+1,MED_COMPACT_PFLMODE,pflname,&profilesize,locname,&nbi));
-      const SlicePartDefinition *spd(dynamic_cast<const SlicePartDefinition *>(pd));
-      if(spd)
-        {
-          int start,stop,step;
-          spd->getSlice(start,stop,step);
-          int nbOfEltsToLoad(DataArray::GetNumberOfItemGivenBES(start,stop,step,"MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile"));
-          med_filter filter=MED_FILTER_INIT;
-          MEDfilterBlockOfEntityCr(fid,/*nentity*/overallNval,/*nvaluesperentity*/nbi,/*nconstituentpervalue*/nbOfCompo,
-                                   MED_ALL_CONSTITUENT,MED_FULL_INTERLACE,MED_COMPACT_STMODE,MED_NO_PROFILE,
-                                   /*start*/start+1,/*stride*/step,/*count*/1,/*blocksize*/nbOfEltsToLoad,
-                                   /*lastblocksize=useless because count=1*/0,&filter);
-          MEDFILESAFECALLERRD0(MEDfieldValueAdvancedRd,(fid,fieldName.c_str(),iteration,order,menti,mgeoti,&filter,startFeedingPtr));
-          MEDfilterClose(&filter);
-          return ;
-        }
-      const DataArrayPartDefinition *dpd(dynamic_cast<const DataArrayPartDefinition *>(pd));
-      if(dpd)
-        {
-          dpd->checkConsistencyLight();
-          MCAuto<DataArrayInt> myIds(dpd->toDAI());
-          int a(myIds->getMinValueInArray()),b(myIds->getMaxValueInArray());
-          myIds=myIds->deepCopy();// WARNING deep copy here because _pd is modified by applyLin !!!
-          myIds->applyLin(1,-a);
-          int nbOfEltsToLoad(b-a+1);
-          med_filter filter=MED_FILTER_INIT;
-          {//TODO : manage int32 !
-            MCAuto<DataArrayDouble> tmp(DataArrayDouble::New());
-            tmp->alloc(nbOfEltsToLoad,nbOfCompo);
-            MEDfilterBlockOfEntityCr(fid,/*nentity*/overallNval,/*nvaluesperentity*/nbi,/*nconstituentpervalue*/nbOfCompo,
-                                     MED_ALL_CONSTITUENT,MED_FULL_INTERLACE,MED_COMPACT_STMODE,MED_NO_PROFILE,
-                                     /*start*/a+1,/*stride*/1,/*count*/1,/*blocksize*/nbOfEltsToLoad,
-                                     /*lastblocksize=useless because count=1*/0,&filter);
-            MEDFILESAFECALLERRD0(MEDfieldValueAdvancedRd,(fid,fieldName.c_str(),iteration,order,menti,mgeoti,&filter,reinterpret_cast<unsigned char *>(tmp->getPointer())));
-            MCAuto<DataArrayDouble> feeder(DataArrayDouble::New());
-            feeder->useExternalArrayWithRWAccess(reinterpret_cast<double *>(startFeedingPtr),_nval,nbOfCompo);
-            feeder->setContigPartOfSelectedValues(0,tmp,myIds);
-          }
-          MEDfilterClose(&filter);
-        }
-      else
-        throw INTERP_KERNEL::Exception("Not implemented yet for not slices!");
-    }
-}
-
-const MEDFileFieldPerMeshPerTypeCommon *MEDFileFieldPerMeshPerTypePerDisc::getFather() const
-{
-  return _father;
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::loadOnlyStructureOfDataRecursively(med_idt fid, int& start, const MEDFileFieldNameScope& nasc)
-{
-  INTERP_KERNEL::AutoPtr<char> locname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> pflname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  std::string fieldName(nasc.getName()),meshName(getMeshName());
-  int iteration(getIteration()),order(getOrder()),profilesize,nbi;
-  TypeOfField type(getType());
-  med_geometry_type mgeoti;
-  med_entity_type menti;
-  _father->entriesForMEDfile(type,mgeoti,menti);
-  int zeNVal(MEDfieldnValueWithProfile(fid,fieldName.c_str(),iteration,order,menti,mgeoti,_profile_it+1,MED_COMPACT_PFLMODE,pflname,&profilesize,locname,&nbi));
-  _profile=MEDLoaderBase::buildStringFromFortran(pflname,MED_NAME_SIZE);
-  _localization=MEDLoaderBase::buildStringFromFortran(locname,MED_NAME_SIZE);
-  const PartDefinition *pd(_pd);
-  if(!pd)
-    {
-      _nval=zeNVal;
-    }
-  else
-    {
-      if(!_profile.empty())
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::loadOnlyStructureOfDataRecursively : profiles are not managed yet with part of def !");
-      _nval=pd->getNumberOfElems();
-    }
-  _start=start;
-  _end=start+_nval*nbi;
-  start=_end;
-  if(type==ON_CELLS && !_localization.empty())
-    {
-      if(_localization!="MED_GAUSS_ELNO")//For compatibily with MED2.3
-        setType(ON_GAUSS_PT);
-      else
-        {
-          setType(ON_GAUSS_NE);
-          _localization.clear();
-        }
-    }
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::loadBigArray(med_idt fid, const MEDFileFieldNameScope& nasc)
-{
-  std::string fieldName(nasc.getName()),meshName(getMeshName());
-  int iteration(getIteration()),order(getOrder());
-  TypeOfField type(getType());
-  med_geometry_type mgeoti;
-  med_entity_type menti;
-  _father->entriesForMEDfile(type,mgeoti,menti);
-  if(_start>_end)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::loadBigArray : internal error in range !");
-  if(_start==_end)
-    return ;
-  DataArray *arr(getOrCreateAndGetArray());//arr is not null due to the spec of getOrCreateAndGetArray
-  if(_start<0 || _start>=arr->getNumberOfTuples())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypePerDisc::loadBigArray : Invalid start ("<< _start << ") regarding admissible range of allocated array [0," << arr->getNumberOfTuples() << ") !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  if(_end<0 || _end>arr->getNumberOfTuples())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypePerDisc::loadBigArray : Invalid start ("<< _start << ") regarding admissible range of allocated array [0," << arr->getNumberOfTuples() << "] !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  int nbOfCompo(arr->getNumberOfComponents());
-  DataArrayDouble *arrD(dynamic_cast<DataArrayDouble *>(arr));
-  if(arrD)
-    {
-      double *startFeeding(arrD->getPointer()+_start*nbOfCompo);
-      goReadZeValuesInFile(fid,fieldName,nbOfCompo,iteration,order,menti,mgeoti,reinterpret_cast<unsigned char*>(startFeeding));
-      return ;
-    }
-  DataArrayInt *arrI(dynamic_cast<DataArrayInt *>(arr));
-  if(arrI)
-    {
-      int *startFeeding(arrI->getPointer()+_start*nbOfCompo);
-      goReadZeValuesInFile(fid,fieldName,nbOfCompo,iteration,order,menti,mgeoti,reinterpret_cast<unsigned char*>(startFeeding));
-      return ;
-    }
-  throw INTERP_KERNEL::Exception("Error on array reading ! Unrecognized type of field ! Should be in FLOAT64 or INT32 !");
-}
-
-/*!
- * Set a \c this->_start **and** \c this->_end keeping the same delta between the two.
- */
-void MEDFileFieldPerMeshPerTypePerDisc::setNewStart(int newValueOfStart)
-{
-  int delta=_end-_start;
-  _start=newValueOfStart;
-  _end=_start+delta;
-}
-
-int MEDFileFieldPerMeshPerTypePerDisc::getIteration() const
-{
-  return _father->getIteration();
-}
-
-int MEDFileFieldPerMeshPerTypePerDisc::getOrder() const
-{
-  return _father->getOrder();
-}
-
-double MEDFileFieldPerMeshPerTypePerDisc::getTime() const
-{
-  return _father->getTime();
-}
-
-std::string MEDFileFieldPerMeshPerTypePerDisc::getMeshName() const
-{
-  return _father->getMeshName();
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::simpleRepr(int bkOffset, std::ostream& oss, int id) const
-{
-  const char startLine[]="    ## ";
-  std::string startLine2(bkOffset,' ');
-  startLine2+=startLine;
-  INTERP_KERNEL::AutoCppPtr<MEDCouplingFieldDiscretization> tmp(MEDCouplingFieldDiscretization::New(_type));
-  oss << startLine2 << "Localization #" << id << "." << std::endl;
-  oss << startLine2 << "  Type=" << tmp->getRepr() << "." << std::endl;
-  oss << startLine2 << "  This type discretization lies on profile : \"" << _profile << "\" and on the following localization : \"" << _localization << "\"." << std::endl;
-  oss << startLine2 << "  This type discretization has " << _end-_start << " tuples (start=" << _start << ", end=" << _end << ")." << std::endl;
-  oss << startLine2 << "  This type discretization has " << (_end-_start)/_nval << " integration points." << std::endl;
-}
-
-TypeOfField MEDFileFieldPerMeshPerTypePerDisc::getType() const
-{
-  return _type;
-}
-
-INTERP_KERNEL::NormalizedCellType MEDFileFieldPerMeshPerTypePerDisc::getGeoType() const
-{
-  return _father->getGeoType();
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const
-{
-  types.insert(_type);
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::setType(TypeOfField newType)
-{
-  _type=newType;
-}
-
-int MEDFileFieldPerMeshPerTypePerDisc::getNumberOfComponents() const
-{
-  return _father->getNumberOfComponents();
-}
-
-int MEDFileFieldPerMeshPerTypePerDisc::getNumberOfTuples() const
-{
-  return _end-_start;
-}
-
-DataArray *MEDFileFieldPerMeshPerTypePerDisc::getOrCreateAndGetArray()
-{
-  return _father->getOrCreateAndGetArray();
-}
-
-const DataArray *MEDFileFieldPerMeshPerTypePerDisc::getOrCreateAndGetArray() const
-{
-  const MEDFileFieldPerMeshPerTypeCommon *fath=_father;
-  return fath->getOrCreateAndGetArray();
-}
-
-const std::vector<std::string>& MEDFileFieldPerMeshPerTypePerDisc::getInfo() const
-{
-  return _father->getInfo();
-}
-
-std::string MEDFileFieldPerMeshPerTypePerDisc::getProfile() const
-{
-  return _profile;
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::setProfile(const std::string& newPflName)
-{
-  _profile=newPflName;
-}
-
-std::string MEDFileFieldPerMeshPerTypePerDisc::getLocalization() const
-{
-  return _localization;
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::setLocalization(const std::string& newLocName)
-{
-  _localization=newLocName;
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
-    {
-      if(std::find((*it2).first.begin(),(*it2).first.end(),_profile)!=(*it2).first.end())
-        {
-          _profile=(*it2).second;
-          return;
-        }
-    }
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
-    {
-      if(std::find((*it2).first.begin(),(*it2).first.end(),_localization)!=(*it2).first.end())
-        {
-          _localization=(*it2).second;
-          return;
-        }
-    }
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::getFieldAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const
-{
-  if(type!=_type)
-    return ;
-  dads.push_back(std::pair<int,int>(_start,_end));
-  geoTypes.push_back(getGeoType());
-  if(_profile.empty())
-    pfls.push_back(0);
-  else
-    {
-      pfls.push_back(glob->getProfile(_profile.c_str()));
-    }
-  if(_localization.empty())
-    locs.push_back(-1);
-  else
-    {
-      locs.push_back(glob->getLocalizationId(_localization.c_str()));
-    }
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::fillValues(int discId, int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  entries[startEntryId]=std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int> ,std::pair<int,int> >(std::pair<INTERP_KERNEL::NormalizedCellType,int>(getGeoType(),discId),std::pair<int,int>(_start,_end));
-  startEntryId++;
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const
-{
-  TypeOfField type=getType();
-  INTERP_KERNEL::NormalizedCellType geoType(getGeoType());
-  med_geometry_type mgeoti;
-  med_entity_type menti;
-  _father->entriesForMEDfile(getType(),mgeoti,menti);
-  const DataArray *arr(getOrCreateAndGetArray());
-  if(!arr)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::writeLL : no array set !");
-  if(!arr->isAllocated())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::writeLL : the array to be written is not allocated !");
-  const DataArrayDouble *arrD=dynamic_cast<const DataArrayDouble *>(arr);
-  const DataArrayInt *arrI=dynamic_cast<const DataArrayInt *>(arr);
-  const unsigned char *locToWrite=0;
-  if(arrD)
-    locToWrite=reinterpret_cast<const unsigned char *>(arrD->getConstPointer()+_start*arr->getNumberOfComponents());
-  else if(arrI)
-    locToWrite=reinterpret_cast<const unsigned char *>(arrI->getConstPointer()+_start*arr->getNumberOfComponents());
-  else
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::writeLL : not recognized type of values ! Supported are FLOAT64 and INT32 !");
-  MEDFILESAFECALLERWR0(MEDfieldValueWithProfileWr,(fid,nasc.getName().c_str(),getIteration(),getOrder(),getTime(),menti,mgeoti,
-                                                   MED_COMPACT_PFLMODE,_profile.c_str(),_localization.c_str(),MED_FULL_INTERLACE,MED_ALL_CONSTITUENT,_nval,
-                                                   locToWrite));
-}
-
-void MEDFileFieldPerMeshPerTypePerDisc::getCoarseData(TypeOfField& type, std::pair<int,int>& dad, std::string& pfl, std::string& loc) const
-{
-  type=_type;
-  pfl=_profile;
-  loc=_localization;
-  dad.first=_start; dad.second=_end;
-}
-
-/*!
- * \param [in] codeOfMesh is of format returned by MEDCouplingUMesh::getDistributionOfTypes. And for each *i* oldCode[3*i+2] gives the position (MEDFileUMesh::PutInThirdComponentOfCodeOffset).
- *             This code corresponds to the distribution of types in the corresponding mesh.
- * \param [out] ptToFill memory zone where the output will be stored.
- * \return the size of data pushed into output param \a ptToFill
- */
-int MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode(int offset, const std::vector<int>& codeOfMesh, const MEDFileFieldGlobsReal& glob, int *ptToFill) const
-{
-  _loc_id=offset;
-  std::ostringstream oss;
-  std::size_t nbOfType=codeOfMesh.size()/3;
-  int found=-1;
-  for(std::size_t i=0;i<nbOfType && found==-1;i++)
-    if(getGeoType()==(INTERP_KERNEL::NormalizedCellType)codeOfMesh[3*i])
-      found=(int)i;
-  if(found==-1)
-    {
-      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType());
-      oss << "MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode : not found geometric type " << cm.getRepr() << " in the referenced mesh of field !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  int *work=ptToFill;
-  if(_profile.empty())
-    {
-      if(_nval!=codeOfMesh[3*found+1])
-        {
-          const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType());
-          oss << "MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode : for geometric type " << cm.getRepr() << " number of elt ids in mesh is equal to " << _nval;
-          oss << " whereas mesh has " << codeOfMesh[3*found+1] << " for this geometric type !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      for(int ii=codeOfMesh[3*found+2];ii<codeOfMesh[3*found+2]+_nval;ii++)
-        *work++=ii;
-    }
-  else
-    {
-      const DataArrayInt *pfl=glob.getProfile(_profile.c_str());
-      if(pfl->getNumberOfTuples()!=_nval)
-        {
-          const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType());
-          oss << "MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode : for geometric type " << cm.getRepr() << ", field is defined on profile \"" << _profile << "\" and size of profile is ";
-          oss << _nval;
-          oss << pfl->getNumberOfTuples() << " whereas the number of ids is set to " << _nval << " for this geometric type !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      int offset2=codeOfMesh[3*found+2];
-      for(const int *pflId=pfl->begin();pflId!=pfl->end();pflId++)
-        {
-          if(*pflId<codeOfMesh[3*found+1])
-            *work++=offset2+*pflId;
-        }
-    }
-  return _nval;
-}
-
-int MEDFileFieldPerMeshPerTypePerDisc::fillTupleIds(int *ptToFill) const
-{
-  for(int i=_start;i<_end;i++)
-    *ptToFill++=i;
-  return _end-_start;
-}
-
-int MEDFileFieldPerMeshPerTypePerDisc::ConvertType(TypeOfField type, int locId)
-{
-  switch(type)
-  {
-    case ON_CELLS:
-      return -2;
-    case ON_GAUSS_NE:
-      return -1;
-    case ON_GAUSS_PT:
-      return locId;
-    default:
-      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::ConvertType : not managed type of field !");
-  }
-}
-
-std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > MEDFileFieldPerMeshPerTypePerDisc::SplitPerDiscretization(const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entries)
-{
-  int id=0;
-  std::map<std::pair<std::string,TypeOfField>,int> m;
-  std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > ret;
-  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entries.begin();it!=entries.end();it++)
-    if(m.find(std::pair<std::string,TypeOfField>((*it)->getLocalization(),(*it)->getType()))==m.end())
-      m[std::pair<std::string,TypeOfField>((*it)->getLocalization(),(*it)->getType())]=id++;
-  ret.resize(id);
-  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entries.begin();it!=entries.end();it++)
-    ret[m[std::pair<std::string,TypeOfField>((*it)->getLocalization(),(*it)->getType())]].push_back(*it);
-  return ret;
-}
-
-/*!
- * - \c this->_loc_id mutable attribute is used for elt id in mesh offsets.
- * 
- * \param [in] offset the offset id used to take into account that \a result is not compulsary empty in input
- * \param [in] entriesOnSameDisc some entries **on same localization** if not the result can be invalid. The _start and _end on them are relative to \a arr parameter.
- * \param [in] explicitIdsInMesh ids in mesh of the considered chunk.
- * \param [in] newCode one of the input parameter to explicit the new geo type dispatch (in classical format same than those asked by MEDFileFields::renumberEntitiesLyingOnMesh)
- * \param [in,out] glob if necessary by the method, new profiles can be added to it
- * \param [in,out] arr after the call of this method \a arr is renumbered to be compliant with added entries to \a result.
- * \param [out] result All new entries will be appended on it.
- * \return false if the configuration of renumbering leads to an unnecessary resplit of input \a entriesOnSameDisc. If not true is returned (the most general case !)
- */
-bool MEDFileFieldPerMeshPerTypePerDisc::RenumberChunks(int offset, const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
-                                                       const DataArrayInt *explicitIdsInMesh,
-                                                       const std::vector<int>& newCode,
-                                                       MEDFileFieldGlobsReal& glob, DataArrayDouble *arr,
-                                                       std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >& result)
-{
-  if(entriesOnSameDisc.empty())
-    return false;
-  TypeOfField type=entriesOnSameDisc[0]->getType();
-  int szEntities=0,szTuples=0;
-  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entriesOnSameDisc.begin();it!=entriesOnSameDisc.end();it++)
-    { szEntities+=(*it)->_nval; szTuples+=(*it)->_end-(*it)->_start; }
-  int nbi=szTuples/szEntities;
-  if(szTuples%szEntities!=0)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::RenumberChunks : internal error the splitting into same dicretization failed !");
-  MCAuto<DataArrayInt> renumTuples=DataArrayInt::New(); renumTuples->alloc(szTuples,1);
-  MCAuto<DataArrayInt> ranges=MEDCouplingUMesh::ComputeRangesFromTypeDistribution(newCode);
-  std::vector< MCAuto<DataArrayInt> > newGeoTypesPerChunk(entriesOnSameDisc.size());
-  std::vector< const DataArrayInt * > newGeoTypesPerChunk2(entriesOnSameDisc.size());
-  std::vector< MCAuto<DataArrayInt> > newGeoTypesPerChunk_bis(entriesOnSameDisc.size());
-  std::vector< const DataArrayInt * > newGeoTypesPerChunk3(entriesOnSameDisc.size());
-  MCAuto<DataArrayInt> newGeoTypesPerChunk4=DataArrayInt::New(); newGeoTypesPerChunk4->alloc(szEntities,nbi);
-  int id=0;
-  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entriesOnSameDisc.begin();it!=entriesOnSameDisc.end();it++,id++)
-    {
-      int startOfEltIdOfChunk=(*it)->_start;
-      MCAuto<DataArrayInt> newEltIds=explicitIdsInMesh->subArray(startOfEltIdOfChunk,startOfEltIdOfChunk+(*it)->_nval);
-      MCAuto<DataArrayInt> rangeIdsForChunk=newEltIds->findRangeIdForEachTuple(ranges);
-      MCAuto<DataArrayInt> idsInRrangeForChunk=newEltIds->findIdInRangeForEachTuple(ranges);
-      //
-      MCAuto<DataArrayInt> tmp=rangeIdsForChunk->duplicateEachTupleNTimes(nbi); rangeIdsForChunk->rearrange(nbi);
-      newGeoTypesPerChunk4->setPartOfValues1(tmp,(*it)->_tmp_work1-offset,(*it)->_tmp_work1+(*it)->_nval*nbi-offset,1,0,nbi,1);
-      //
-      newGeoTypesPerChunk[id]=rangeIdsForChunk; newGeoTypesPerChunk2[id]=rangeIdsForChunk;
-      newGeoTypesPerChunk_bis[id]=idsInRrangeForChunk; newGeoTypesPerChunk3[id]=idsInRrangeForChunk;
-    }
-  MCAuto<DataArrayInt> newGeoTypesEltIdsAllGather=DataArrayInt::Aggregate(newGeoTypesPerChunk2); newGeoTypesPerChunk.clear(); newGeoTypesPerChunk2.clear();
-  MCAuto<DataArrayInt> newGeoTypesEltIdsAllGather2=DataArrayInt::Aggregate(newGeoTypesPerChunk3); newGeoTypesPerChunk_bis.clear(); newGeoTypesPerChunk3.clear();
-  MCAuto<DataArrayInt> diffVals=newGeoTypesEltIdsAllGather->getDifferentValues();
-  MCAuto<DataArrayInt> renumEltIds=newGeoTypesEltIdsAllGather->buildPermArrPerLevel();
-  //
-  MCAuto<DataArrayInt> renumTupleIds=newGeoTypesPerChunk4->buildPermArrPerLevel();
-  //
-  MCAuto<DataArrayDouble> arrPart=arr->subArray(offset,offset+szTuples);
-  arrPart->renumberInPlace(renumTupleIds->begin());
-  arr->setPartOfValues1(arrPart,offset,offset+szTuples,1,0,arrPart->getNumberOfComponents(),1);
-  bool ret=false;
-  const int *idIt=diffVals->begin();
-  std::list<const MEDFileFieldPerMeshPerTypePerDisc *> li(entriesOnSameDisc.begin(),entriesOnSameDisc.end());
-  int offset2=0;
-  for(int i=0;i<diffVals->getNumberOfTuples();i++,idIt++)
-    {
-      MCAuto<DataArrayInt> ids=newGeoTypesEltIdsAllGather->findIdsEqual(*idIt);
-      MCAuto<DataArrayInt> subIds=newGeoTypesEltIdsAllGather2->selectByTupleId(ids->begin(),ids->end());
-      int nbEntityElts=subIds->getNumberOfTuples();
-      bool ret2;
-      MCAuto<MEDFileFieldPerMeshPerTypePerDisc> eltToAdd=MEDFileFieldPerMeshPerTypePerDisc::
-          NewObjectOnSameDiscThanPool(type,(INTERP_KERNEL::NormalizedCellType)newCode[3*(*idIt)],subIds,!subIds->isIota(newCode[3*(*idIt)+1]),nbi,
-                                      offset+offset2,
-                                      li,glob,ret2);
-      ret=ret || ret2;
-      result.push_back(eltToAdd);
-      offset2+=nbEntityElts*nbi;
-    }
-  ret=ret || li.empty();
-  return ret;
-}
-
-/*!
- * \param [in] typeF type of field of new chunk
- * \param [in] geoType the geometric type of the chunk
- * \param [in] idsOfMeshElt the entity ids of mesh (cells or nodes) of the new chunk.
- * \param [in] isPfl specifies if a profile is requested regarding size of \a idsOfMeshElt and the number of such entities regarding underlying mesh.
- * \param [in] nbi number of integration points
- * \param [in] offset The offset in the **global array of data**.
- * \param [in,out] entriesOnSameDisc the pool **on the same discretization** inside which it will be attempted to find an existing entry corresponding exactly
- *                 to the new chunk to create.
- * \param [in,out] glob the global shared info that will be requested for existing profiles or to append a new profile if needed.
- * \param [out] notInExisting If false the return newly allocated entry is not coming from \a entriesOnSameDisc. If true the output comes from copy of \a entriesOnSameDisc
- *              and corresponding entry erased from \a entriesOnSameDisc.
- * \return a newly allocated chunk
- */
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::NewObjectOnSameDiscThanPool(TypeOfField typeF, INTERP_KERNEL::NormalizedCellType geoType, DataArrayInt *idsOfMeshElt,
-                                                                                                  bool isPfl, int nbi, int offset,
-                                                                                                  std::list< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
-                                                                                                  MEDFileFieldGlobsReal& glob,
-                                                                                                  bool &notInExisting)
-{
-  int nbMeshEntities=idsOfMeshElt->getNumberOfTuples();
-  std::list< const MEDFileFieldPerMeshPerTypePerDisc *>::iterator it=entriesOnSameDisc.begin();
-  for(;it!=entriesOnSameDisc.end();it++)
-    {
-      if(((INTERP_KERNEL::NormalizedCellType)(*it)->_loc_id)==geoType && (*it)->_nval==nbMeshEntities)
-        {
-          if(!isPfl)
-            {
-              if((*it)->_profile.empty())
-                break;
-              else
-                if(!(*it)->_profile.empty())
-                  {
-                    const DataArrayInt *pfl=glob.getProfile((*it)->_profile.c_str());
-                    if(pfl->isEqualWithoutConsideringStr(*idsOfMeshElt))
-                      break;
-                  }
-            }
-        }
-    }
-  if(it==entriesOnSameDisc.end())
-    {
-      notInExisting=true;
-      MEDFileFieldPerMeshPerTypePerDisc *ret=new MEDFileFieldPerMeshPerTypePerDisc;
-      ret->_type=typeF;
-      ret->_loc_id=(int)geoType;
-      ret->_nval=nbMeshEntities;
-      ret->_start=offset;
-      ret->_end=ret->_start+ret->_nval*nbi;
-      if(isPfl)
-        {
-          idsOfMeshElt->setName(glob.createNewNameOfPfl().c_str());
-          glob.appendProfile(idsOfMeshElt);
-          ret->_profile=idsOfMeshElt->getName();
-        }
-      //tony treatment of localization
-      return ret;
-    }
-  else
-    {
-      notInExisting=false;
-      MEDFileFieldPerMeshPerTypePerDisc *ret=MEDFileFieldPerMeshPerTypePerDisc::New(*(*it));
-      ret->_loc_id=(int)geoType;
-      ret->setNewStart(offset);
-      entriesOnSameDisc.erase(it);
-      return ret;
-    }
-
-}
-
-////////////////////////////////////
-
-MEDFileFieldPerMeshPerTypeCommon::~MEDFileFieldPerMeshPerTypeCommon()
-{
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::setFather(MEDFileFieldPerMesh *father)
-{
-  _father=father;
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::accept(MEDFileFieldVisitor& visitor) const
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    if((*it).isNotNull())
-      {
-        visitor.newPerMeshPerTypePerDisc(*it);
-      }
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::deepCopyElements()
-{
-  std::size_t i=0;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
-    {
-      if((const MEDFileFieldPerMeshPerTypePerDisc *)*it)
-        _field_pm_pt_pd[i]=(*it)->deepCopy(this);
-    }
-}
-
-std::size_t MEDFileFieldPerMeshPerTypeCommon::getHeapMemorySizeWithoutChildren() const
-{
-  return _field_pm_pt_pd.capacity()*sizeof(MCAuto<MEDFileFieldPerMeshPerTypePerDisc>);
-}
-
-std::vector<const BigMemoryObject *> MEDFileFieldPerMeshPerTypeCommon::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    ret.push_back((const MEDFileFieldPerMeshPerTypePerDisc *)*it);
-  return ret;
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  std::vector<int> pos=addNewEntryIfNecessary(field,offset,nbOfCells);
-  for(std::vector<int>::const_iterator it=pos.begin();it!=pos.end();it++)
-    _field_pm_pt_pd[*it]->assignFieldNoProfile(start,offset,nbOfCells,field,arr,glob,nasc);
-}
-
-/*!
- * This method is the most general one. No optimization is done here.
- * \param [in] multiTypePfl is the end user profile specified in high level API
- * \param [in] idsInPfl is the selection into the \a multiTypePfl whole profile that corresponds to the current geometric type.
- * \param [in] locIds is the profile needed to be created for MED file format. It can be null if all cells of current geometric type are fetched in \a multiTypePfl.
- *             \b WARNING if not null the MED file profile can be subdivided again in case of Gauss points.
- * \param [in] nbOfEltsInWholeMesh nb of elts of type \a this->_geo_type in \b WHOLE mesh
- * \param [in] mesh is the mesh coming from the MEDFileMesh instance in correspondance with the MEDFileField. The mesh inside the \a field is simply ignored.
- */
-void MEDFileFieldPerMeshPerTypeCommon::assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  std::vector<int> pos=addNewEntryIfNecessary(field,idsInPfl);
-  for(std::vector<int>::const_iterator it=pos.begin();it!=pos.end();it++)
-    _field_pm_pt_pd[*it]->assignFieldProfile(isPflAlone,start,multiTypePfl,idsInPfl,locIds,nbOfEltsInWholeMesh,field,arr,mesh,glob,nasc);
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob)
-{
-  _field_pm_pt_pd.resize(1);
-  _field_pm_pt_pd[0]=MEDFileFieldPerMeshPerTypePerDisc::New(this,ON_NODES,-3);
-  _field_pm_pt_pd[0]->assignNodeFieldNoProfile(start,field,arr,glob);
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  MCAuto<DataArrayInt> pfl2=pfl->deepCopy();
-  if(!arr || !arr->isAllocated())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeCommon::assignNodeFieldProfile : input array is null, or not allocated !");
-  _field_pm_pt_pd.resize(1);
-  _field_pm_pt_pd[0]=MEDFileFieldPerMeshPerTypePerDisc::New(this,ON_NODES,-3);
-  _field_pm_pt_pd[0]->assignFieldProfile(true,start,pfl,pfl2,pfl2,-1,field,arr,0,glob,nasc);//mesh is not requested so 0 is send.
-}
-
-std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells)
-{
-  TypeOfField type=field->getTypeOfField();
-  if(type!=ON_GAUSS_PT)
-    {
-      int locIdToFind=MEDFileFieldPerMeshPerTypePerDisc::ConvertType(type,0);
-      int sz=_field_pm_pt_pd.size();
-      bool found=false;
-      for(int j=0;j<sz && !found;j++)
-        {
-          if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
-            {
-              _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-              found=true;
-            }
-        }
-      if(!found)
-        {
-          _field_pm_pt_pd.resize(sz+1);
-          _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-        }
-      std::vector<int> ret(1,(int)sz);
-      return ret;
-    }
-  else
-    {
-      std::vector<int> ret2=addNewEntryIfNecessaryGauss(field,offset,nbOfCells);
-      int sz2=ret2.size();
-      std::vector<int> ret3(sz2);
-      int k=0;
-      for(int i=0;i<sz2;i++)
-        {
-          int sz=_field_pm_pt_pd.size();
-          int locIdToFind=ret2[i];
-          bool found=false;
-          for(int j=0;j<sz && !found;j++)
-            {
-              if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
-                {
-                  _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-                  ret3[k++]=j;
-                  found=true;
-                }
-            }
-          if(!found)
-            {
-              _field_pm_pt_pd.resize(sz+1);
-              _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-              ret3[k++]=sz;
-            }
-        }
-      return ret3;
-    }
-}
-
-std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells)
-{
-  const MEDCouplingFieldDiscretization *disc=field->getDiscretization();
-  const MEDCouplingFieldDiscretizationGauss *disc2=dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(disc);
-  if(!disc2)
-    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : invalid call to this method ! Internal Error !");
-  const DataArrayInt *da=disc2->getArrayOfDiscIds();
-  if(!da)
-    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss (no profile) : no localization ids per cell array available ! The input Gauss node field is maybe invalid !");
-  MCAuto<DataArrayInt> da2=da->selectByTupleIdSafeSlice(offset,offset+nbOfCells,1);
-  MCAuto<DataArrayInt> retTmp=da2->getDifferentValues();
-  if(retTmp->presenceOfValue(-1))
-    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : some cells have no dicretization description !");
-  std::vector<int> ret(retTmp->begin(),retTmp->end());
-  return ret;
-}
-
-std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells)
-{
-  TypeOfField type=field->getTypeOfField();
-  if(type!=ON_GAUSS_PT)
-    {
-      int locIdToFind=MEDFileFieldPerMeshPerTypePerDisc::ConvertType(type,0);
-      int sz=_field_pm_pt_pd.size();
-      bool found=false;
-      for(int j=0;j<sz && !found;j++)
-        {
-          if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
-            {
-              _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-              found=true;
-            }
-        }
-      if(!found)
-        {
-          _field_pm_pt_pd.resize(sz+1);
-          _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-        }
-      std::vector<int> ret(1,0);
-      return ret;
-    }
-  else
-    {
-      std::vector<int> ret2=addNewEntryIfNecessaryGauss(field,subCells);
-      int sz2=ret2.size();
-      std::vector<int> ret3(sz2);
-      int k=0;
-      for(int i=0;i<sz2;i++)
-        {
-          int sz=_field_pm_pt_pd.size();
-          int locIdToFind=ret2[i];
-          bool found=false;
-          for(int j=0;j<sz && !found;j++)
-            {
-              if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
-                {
-                  _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-                  ret3[k++]=j;
-                  found=true;
-                }
-            }
-          if(!found)
-            {
-              _field_pm_pt_pd.resize(sz+1);
-              _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
-              ret3[k++]=sz;
-            }
-        }
-      return ret3;
-    }
-}
-
-std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells)
-{
-  const MEDCouplingFieldDiscretization *disc=field->getDiscretization();
-  const MEDCouplingFieldDiscretizationGauss *disc2=dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(disc);
-  if(!disc2)
-    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : invalid call to this method ! Internal Error !");
-  const DataArrayInt *da=disc2->getArrayOfDiscIds();
-  if(!da)
-    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : no localization ids per cell array available ! The input Gauss node field is maybe invalid !");
-  MCAuto<DataArrayInt> da2=da->selectByTupleIdSafe(subCells->getConstPointer(),subCells->getConstPointer()+subCells->getNumberOfTuples());
-  MCAuto<DataArrayInt> retTmp=da2->getDifferentValues();
-  if(retTmp->presenceOfValue(-1))
-    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : some cells have no dicretization description !");
-  std::vector<int> ret(retTmp->begin(),retTmp->end());
-  return ret;
-}
-
-const MEDFileFieldPerMesh *MEDFileFieldPerMeshPerTypeCommon::getFather() const
-{
-  return _father;
-}
-
-bool MEDFileFieldPerMeshPerTypeCommon::isUniqueLevel(int& dim) const
-{
-  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
-  int curDim((int)cm.getDimension());
-  if(dim!=std::numeric_limits<int>::max())
-    {
-      if(dim!=curDim)
-        return false;
-    }
-  else
-    dim=curDim;
-  return true;
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    {
-      (*it)->fillTypesOfFieldAvailable(types);
-    }
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::fillFieldSplitedByType(std::vector< std::pair<int,int> >& dads, std::vector<TypeOfField>& types, std::vector<std::string>& pfls, std::vector<std::string>& locs) const
-{
-  int sz=_field_pm_pt_pd.size();
-  dads.resize(sz); types.resize(sz); pfls.resize(sz); locs.resize(sz);
-  for(int i=0;i<sz;i++)
-    {
-      _field_pm_pt_pd[i]->getCoarseData(types[i],dads[i],pfls[i],locs[i]);
-    }
-}
-
-int MEDFileFieldPerMeshPerTypeCommon::getIteration() const
-{
-  return _father->getIteration();
-}
-
-int MEDFileFieldPerMeshPerTypeCommon::getOrder() const
-{
-  return _father->getOrder();
-}
-
-double MEDFileFieldPerMeshPerTypeCommon::getTime() const
-{
-  return _father->getTime();
-}
-
-std::string MEDFileFieldPerMeshPerTypeCommon::getMeshName() const
-{
-  return _father->getMeshName();
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::getSizes(int& globalSz, int& nbOfEntries) const
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    {
-      globalSz+=(*it)->getNumberOfTuples();
-    }
-  nbOfEntries+=(int)_field_pm_pt_pd.size();
-}
-
-int MEDFileFieldPerMeshPerTypeCommon::getNumberOfComponents() const
-{
-  return _father->getNumberOfComponents();
-}
-
-bool MEDFileFieldPerMeshPerTypeCommon::presenceOfMultiDiscPerGeoType() const
-{
-  std::size_t nb(0);
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    {
-      const MEDFileFieldPerMeshPerTypePerDisc *fmtd(*it);
-      if(fmtd)
-        nb++;
-    }
-  return nb>1;
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::pushDiscretization(MEDFileFieldPerMeshPerTypePerDisc *disc)
-{
-  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> elt;
-  elt.takeRef(disc);
-  _field_pm_pt_pd.push_back(elt);
-}
-
-DataArray *MEDFileFieldPerMeshPerTypeCommon::getOrCreateAndGetArray()
-{
-  return _father->getOrCreateAndGetArray();
-}
-
-const DataArray *MEDFileFieldPerMeshPerTypeCommon::getOrCreateAndGetArray() const
-{
-  const MEDFileFieldPerMesh *fath=_father;
-  return fath->getOrCreateAndGetArray();
-}
-
-const std::vector<std::string>& MEDFileFieldPerMeshPerTypeCommon::getInfo() const
-{
-  return _father->getInfo();
-}
-
-std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getPflsReallyUsed() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
-    {
-      std::string tmp=(*it1)->getProfile();
-      if(!tmp.empty())
-        if(ret2.find(tmp)==ret2.end())
-          {
-            ret.push_back(tmp);
-            ret2.insert(tmp);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getLocsReallyUsed() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
-    {
-      std::string tmp=(*it1)->getLocalization();
-      if(!tmp.empty() && tmp!=MED_GAUSS_ELNO)
-        if(ret2.find(tmp)==ret2.end())
-          {
-            ret.push_back(tmp);
-            ret2.insert(tmp);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getPflsReallyUsedMulti() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
-    {
-      std::string tmp=(*it1)->getProfile();
-      if(!tmp.empty())
-        ret.push_back(tmp);
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getLocsReallyUsedMulti() const
-{
-  std::vector<std::string> ret;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
-    {
-      std::string tmp=(*it1)->getLocalization();
-      if(!tmp.empty() && tmp!=MED_GAUSS_ELNO)
-        ret.push_back(tmp);
-    }
-  return ret;
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
-    (*it1)->changePflsRefsNamesGen(mapOfModif);
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
-    (*it1)->changeLocsRefsNamesGen(mapOfModif);
-}
-
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId(int locId)
-{
-  if(_field_pm_pt_pd.empty())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no localizations for geotype \"" << getGeoTypeRepr() << "\" !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  if(locId>=0 && locId<(int)_field_pm_pt_pd.size())
-    return _field_pm_pt_pd[locId];
-  std::ostringstream oss2; oss2 << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no such locId available (" << locId;
-  oss2 << ") for geometric type \"" << getGeoTypeRepr() << "\" It should be in [0," << _field_pm_pt_pd.size() << ") !";
-  throw INTERP_KERNEL::Exception(oss2.str().c_str());
-  return static_cast<MEDFileFieldPerMeshPerTypePerDisc*>(0);
-}
-
-const MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId(int locId) const
-{
-  if(_field_pm_pt_pd.empty())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no localizations for geotype \"" << getGeoTypeRepr() << "\" !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  if(locId>=0 && locId<(int)_field_pm_pt_pd.size())
-    return _field_pm_pt_pd[locId];
-  std::ostringstream oss2; oss2 << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no such locId available (" << locId;
-  oss2 << ") for geometric type \"" << getGeoTypeRepr() << "\" It should be in [0," << _field_pm_pt_pd.size() << ") !";
-  throw INTERP_KERNEL::Exception(oss2.str().c_str());
-  return static_cast<const MEDFileFieldPerMeshPerTypePerDisc*>(0);
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::fillValues(int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  int i=0;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
-    {
-      (*it)->fillValues(i,startEntryId,entries);
-    }
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::setLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves)
-{
-  _field_pm_pt_pd=leaves;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    (*it)->setFather(this);
-}
-
-/*!
- *  \param [in,out] globalNum a global numbering counter for the renumbering. 
- *  \param [out] its - list of pair (start,stop) kept
- *  \return bool - false if the type of field \a tof is not contained in \a this.
- */
-bool MEDFileFieldPerMeshPerTypeCommon::keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its)
-{
-  bool ret(false);
-  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > newPmPtPd;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    if((*it)->getType()==tof)
-      {
-        newPmPtPd.push_back(*it);
-        std::pair<int,int> bgEnd; bgEnd.first=(*it)->getStart(); bgEnd.second=(*it)->getEnd();
-        (*it)->setNewStart(globalNum);
-        globalNum=(*it)->getEnd();
-        its.push_back(bgEnd);
-        ret=true;
-      }
-  if(ret)
-    _field_pm_pt_pd=newPmPtPd;
-  return ret;
-}
-
-/*!
- *  \param [in,out] globalNum a global numbering counter for the renumbering.
- *  \param [out] its - list of pair (start,stop) kept
- *  \return bool - false if the type of field \a tof is not contained in \a this.
- */
-bool MEDFileFieldPerMeshPerTypeCommon::keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its)
-{
-  if(_field_pm_pt_pd.size()<=idOfDisc)
-    return false;
-  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> elt(_field_pm_pt_pd[idOfDisc]);
-  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > newPmPtPd(1,elt);
-  std::pair<int,int> bgEnd; bgEnd.first=_field_pm_pt_pd[idOfDisc]->getStart(); bgEnd.second=_field_pm_pt_pd[idOfDisc]->getEnd();
-  elt->setNewStart(globalNum);
-  globalNum=elt->getEnd();
-  its.push_back(bgEnd);
-  _field_pm_pt_pd=newPmPtPd;
-  return true;
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::loadOnlyStructureOfDataRecursively(med_idt fid, int &start, const MEDFileFieldNameScope& nasc)
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    (*it)->loadOnlyStructureOfDataRecursively(fid,start,nasc);
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    (*it)->loadBigArray(fid,nasc);
-}
-
-void MEDFileFieldPerMeshPerTypeCommon::writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const
-{
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    {
-      (*it)->copyOptionsFrom(*this);
-      (*it)->writeLL(fid,nasc);
-    }
-}
-
-med_entity_type MEDFileFieldPerMeshPerTypeCommon::ConvertIntoMEDFileType(TypeOfField ikType, INTERP_KERNEL::NormalizedCellType ikGeoType, med_geometry_type& medfGeoType)
-{
-  switch(ikType)
-  {
-    case ON_CELLS:
-      medfGeoType=typmai3[(int)ikGeoType];
-      return MED_CELL;
-    case ON_NODES:
-      medfGeoType=MED_NONE;
-      return MED_NODE;
-    case ON_GAUSS_NE:
-      medfGeoType=typmai3[(int)ikGeoType];
-      return MED_NODE_ELEMENT;
-    case ON_GAUSS_PT:
-      medfGeoType=typmai3[(int)ikGeoType];
-      return MED_CELL;
-    default:
-      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeCommon::ConvertIntoMEDFileType : unexpected entity type ! internal error");
-  }
-  return MED_UNDEF_ENTITY_TYPE;
-}
-
-//////////////////////////////////////////////////
-
-MEDFileFieldPerMeshPerType *MEDFileFieldPerMeshPerType::NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd)
-{
-  return new MEDFileFieldPerMeshPerType(fid,fath,type,geoType,nasc,pd);
-}
-
-MEDFileFieldPerMeshPerType *MEDFileFieldPerMeshPerType::New(MEDFileFieldPerMesh *fath, INTERP_KERNEL::NormalizedCellType geoType)
-{
-  return new MEDFileFieldPerMeshPerType(fath,geoType);
-}
-
-MEDFileFieldPerMeshPerType *MEDFileFieldPerMeshPerType::deepCopy(MEDFileFieldPerMesh *father) const
-{
-  MCAuto<MEDFileFieldPerMeshPerType> ret=new MEDFileFieldPerMeshPerType(*this);
-  ret->setFather(father);
-  ret->deepCopyElements();
-  return ret.retn();
-}
-
-void MEDFileFieldPerMeshPerType::getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const
-{
-  if(_geo_type!=INTERP_KERNEL::NORM_ERROR)
-    {
-      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(_geo_type);
-      if(meshDim!=(int)cm.getDimension())
-        return ;
-    }
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
-    (*it)->getFieldAtLevel(type,glob,dads,pfls,locs,geoTypes);
-}
-
-INTERP_KERNEL::NormalizedCellType MEDFileFieldPerMeshPerType::getGeoType() const
-{
-  return _geo_type;
-}
-
-void MEDFileFieldPerMeshPerType::entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const
-{
-  ent=MEDFileFieldPerMeshPerTypeCommon::ConvertIntoMEDFileType(mct,_geo_type,gt);
-}
-
-void MEDFileFieldPerMeshPerType::getDimension(int& dim) const
-{
-  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(_geo_type));
-  int curDim((int)cm.getDimension());
-  dim=std::max(dim,curDim);
-}
-
-void MEDFileFieldPerMeshPerType::simpleRepr(int bkOffset, std::ostream& oss, int id) const
-{
-  const char startLine[]="  ## ";
-  std::string startLine2(bkOffset,' ');
-  std::string startLine3(startLine2);
-  startLine3+=startLine;
-  if(_geo_type!=INTERP_KERNEL::NORM_ERROR)
-    {
-      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(_geo_type);
-      oss << startLine3 << "Entry geometry type #" << id << " is lying on geometry types " << cm.getRepr() << "." << std::endl;
-    }
-  else
-    oss << startLine3 << "Entry geometry type #" << id << " is lying on NODES." << std::endl;
-  oss << startLine3 << "Entry is defined on " <<  _field_pm_pt_pd.size() << " localizations." << std::endl;
-  int i=0;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
-    {
-      const MEDFileFieldPerMeshPerTypePerDisc *cur=(*it);
-      if(cur)
-        cur->simpleRepr(bkOffset,oss,i);
-      else
-        {
-          oss << startLine2 << "    ## " << "Localization #" << i << " is empty !" << std::endl;
-        }
-    }
-}
-
-std::string MEDFileFieldPerMeshPerType::getGeoTypeRepr() const
-{
-  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(_geo_type));
-  return std::string(cm.getRepr());
-}
-
-MEDFileFieldPerMeshPerType::MEDFileFieldPerMeshPerType(MEDFileFieldPerMesh *father, INTERP_KERNEL::NormalizedCellType gt):MEDFileFieldPerMeshPerTypeCommon(father),_geo_type(gt)
-{
-}
-
-MEDFileFieldPerMeshPerType::MEDFileFieldPerMeshPerType(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd):MEDFileFieldPerMeshPerTypeCommon(fath),_geo_type(geoType)
-{
-  INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
-  INTERP_KERNEL::AutoPtr<char> locName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
-  med_geometry_type mgeoti;
-  med_entity_type menti(ConvertIntoMEDFileType(type,geoType,mgeoti));
-  int nbProfiles(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),menti,mgeoti,pflName,locName));
-  _field_pm_pt_pd.resize(nbProfiles);
-  for(int i=0;i<nbProfiles;i++)
-    {
-      _field_pm_pt_pd[i]=MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(this,type,i,pd);
-    }
-  if(type==ON_CELLS)
-    {
-      int nbProfiles2(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_NODE_ELEMENT,mgeoti,pflName,locName));
-      for(int i=0;i<nbProfiles2;i++)
-        _field_pm_pt_pd.push_back(MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(this,ON_GAUSS_NE,i,pd));
-    }
-}
-
-MCAuto<MEDFileFieldPerMeshPerType> MEDFileFieldPerMeshPerType::Aggregate(int &start, const std::vector<std::pair<int,const MEDFileFieldPerMeshPerType *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, INTERP_KERNEL::NormalizedCellType gt, MEDFileFieldPerMesh *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo)
-{
-  MCAuto<MEDFileFieldPerMeshPerType> ret(MEDFileFieldPerMeshPerType::New(father,gt));
-  std::map<TypeOfField, std::vector< std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc * > > > m;
-  for(std::vector<std::pair<int,const MEDFileFieldPerMeshPerType *> >::const_iterator it=pms.begin();it!=pms.end();it++)
-    {
-      for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it2=(*it).second->_field_pm_pt_pd.begin();it2!=(*it).second->_field_pm_pt_pd.end();it2++)
-        m[(*it2)->getType()].push_back(std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc * >((*it).first,*it2));
-    }
-  for(std::map<TypeOfField, std::vector< std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc * > > >::const_iterator it=m.begin();it!=m.end();it++)
-    {
-      MCAuto<MEDFileFieldPerMeshPerTypePerDisc> agg(MEDFileFieldPerMeshPerTypePerDisc::Aggregate(start,(*it).second,dts,(*it).first,ret,extractInfo));
-      ret->_field_pm_pt_pd.push_back(agg);
-    }
-  return ret;
-}
-
-//////////////////////////////////////////////////
-
-MEDFileFieldPerMeshPerTypeDyn *MEDFileFieldPerMeshPerTypeDyn::NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileEntities *entities, int idGT, const MEDFileFieldNameScope& nasc)
-{
-  if(!entities)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeDyn::NewOnRead : null pointer !");
-  const MEDFileAllStaticEntitiesPlusDyn *entities2(dynamic_cast<const MEDFileAllStaticEntitiesPlusDyn *>(entities));
-  if(!entities2)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeDyn::NewOnRead : invalid type of entities !");
-  const MEDFileStructureElement *se(entities2->getWithGT(idGT));
-  return new MEDFileFieldPerMeshPerTypeDyn(fid,fath,se,nasc);
-}
-
-MEDFileFieldPerMeshPerTypeDyn::MEDFileFieldPerMeshPerTypeDyn(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileStructureElement *se, const MEDFileFieldNameScope& nasc):MEDFileFieldPerMeshPerTypeCommon(fath)
-{
-  _se.takeRef(se);
-  INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
-  INTERP_KERNEL::AutoPtr<char> locName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
-  int nbProfiles(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_STRUCT_ELEMENT,_se->getDynGT(),pflName,locName));
-  _field_pm_pt_pd.resize(nbProfiles);
-  for(int i=0;i<nbProfiles;i++)
-    {
-      _field_pm_pt_pd[i]=MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(this,_se->getEntity(),i,NULL);
-    }
-}
-
-int MEDFileFieldPerMeshPerTypeDyn::getDynGT() const
-{
-  return _se->getDynGT();
-}
-
-std::string MEDFileFieldPerMeshPerTypeDyn::getModelName() const
-{
-  return _se->getName();
-}
-
-void MEDFileFieldPerMeshPerTypeDyn::getDimension(int& dim) const
-{
-  throw INTERP_KERNEL::Exception("not implemented yet !");
-}
-
-void MEDFileFieldPerMeshPerTypeDyn::entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const
-{
-  gt=getDynGT();
-  ent=MED_STRUCT_ELEMENT;
-}
-
-INTERP_KERNEL::NormalizedCellType MEDFileFieldPerMeshPerTypeDyn::getGeoType() const
-{
-  throw INTERP_KERNEL::Exception("not implemented yet !");
-}
-
-void MEDFileFieldPerMeshPerTypeDyn::simpleRepr(int bkOffset, std::ostream& oss, int id) const
-{
-  const char startLine[]="  ## ";
-  std::string startLine2(bkOffset,' ');
-  std::string startLine3(startLine2);
-  startLine3+=startLine;
-  oss << startLine3 << "Entry geometry type #" << id << " is lying on geometry STRUCTURE_ELEMENT type " << getDynGT() << "." << std::endl;
-  oss << startLine3 << "Entry is defined on " <<  _field_pm_pt_pd.size() << " localizations." << std::endl;
-  int i=0;
-  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
-    {
-      if((*it).isNotNull())
-        (*it)->simpleRepr(bkOffset,oss,i);
-      else
-        {
-          oss << startLine2 << "    ## " << "Localization #" << i << " is empty !" << std::endl;
-        }
-    }
-}
-
-std::string MEDFileFieldPerMeshPerTypeDyn::getGeoTypeRepr() const
-{
-  throw INTERP_KERNEL::Exception("not implemented yet !");
-}
-
-MEDFileFieldPerMeshPerTypeDyn *MEDFileFieldPerMeshPerTypeDyn::deepCopy(MEDFileFieldPerMesh *father) const
-{
-  MCAuto<MEDFileFieldPerMeshPerTypeDyn> ret(new MEDFileFieldPerMeshPerTypeDyn(*this));
-  ret->setFather(father);
-  ret->deepCopyElements();
-  return ret.retn();
-}
-
-void MEDFileFieldPerMeshPerTypeDyn::getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const
-{
-  throw INTERP_KERNEL::Exception("not implemented yet !");
-}
-
-//////////////////////////////////////////////////
-
-MEDFileFieldPerMesh *MEDFileFieldPerMesh::NewOnRead(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities)
-{
-  return new MEDFileFieldPerMesh(fid,fath,meshCsit,meshIteration,meshOrder,nasc,mm,entities);
-}
-
-MEDFileFieldPerMesh *MEDFileFieldPerMesh::New(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh)
-{
-  return new MEDFileFieldPerMesh(fath,mesh);
-}
-
-std::size_t MEDFileFieldPerMesh::getHeapMemorySizeWithoutChildren() const
-{
-  return _field_pm_pt.capacity()*sizeof(MCAuto< MEDFileFieldPerMeshPerType >);
-}
-
-std::vector<const BigMemoryObject *> MEDFileFieldPerMesh::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    ret.push_back(*it);
-  return ret;
-}
-
-MEDFileFieldPerMesh *MEDFileFieldPerMesh::deepCopy(MEDFileAnyTypeField1TSWithoutSDA *father) const
-{
-  MCAuto< MEDFileFieldPerMesh > ret=new MEDFileFieldPerMesh(*this);
-  ret->_father=father;
-  std::size_t i=0;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++,i++)
-    {
-      if((*it).isNotNull())
-        ret->_field_pm_pt[i]=(*it)->deepCopy((MEDFileFieldPerMesh *)(ret));
-    }
-  return ret.retn();
-}
-
-void MEDFileFieldPerMesh::simpleRepr(int bkOffset, std::ostream& oss, int id) const
-{
-  std::string startLine(bkOffset,' ');
-  oss << startLine << "## Field part (" << id << ") lying on mesh \"" << getMeshName() << "\", Mesh iteration=" << _mesh_iteration << ". Mesh order=" << _mesh_order << "." << std::endl;
-  oss << startLine << "## Field is defined on " << _field_pm_pt.size() << " types." << std::endl;
-  int i=0;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++,i++)
-    {
-      if((*it).isNotNull())
-        (*it)->simpleRepr(bkOffset,oss,i);
-      else
-        {
-          oss << startLine << "  ## Entry geometry type #" << i << " is empty !" << std::endl;
-        }
-    }
-}
-
-void MEDFileFieldPerMesh::copyTinyInfoFrom(const MEDCouplingMesh *mesh)
-{
-  mesh->getTime(_mesh_iteration,_mesh_order);
-}
-
-void MEDFileFieldPerMesh::assignFieldNoProfileNoRenum(int& start, const std::vector<int>& code, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  int nbOfTypes=code.size()/3;
-  int offset=0;
-  for(int i=0;i<nbOfTypes;i++)
-    {
-      INTERP_KERNEL::NormalizedCellType type=(INTERP_KERNEL::NormalizedCellType)code[3*i];
-      int nbOfCells=code[3*i+1];
-      int pos=addNewEntryIfNecessary(type);
-      _field_pm_pt[pos]->assignFieldNoProfile(start,offset,nbOfCells,field,arr,glob,nasc);
-      offset+=nbOfCells;
-    }
-}
-
-/*!
- * This method is the most general one. No optimization is done here.
- * \param [in] multiTypePfl is the end user profile specified in high level API
- * \param [in] code is the code of \a mesh[multiTypePfl] mesh. It is of size of number of different geometric types into \a mesh[multiTypePfl].
- * \param [in] code2 is the code of the \b WHOLE mesh on the same level. So all types in \a code are in \a code2.
- * \param [in] idsInPflPerType is the selection into the \a multiTypePfl whole profile that corresponds to the given geometric type. This vector is always 3 times smaller than \a code.
- * \param [in] idsPerType is a vector containing the profiles needed to be created for MED file format. \b WARNING these processed MED file profiles can be subdivided again in case of Gauss points.
- * \param [in] mesh is the mesh coming from the MEDFileMesh instance in correspondance with the MEDFileField. The mesh inside the \a field is simply ignored.
- */
-void MEDFileFieldPerMesh::assignFieldProfile(int& start, const DataArrayInt *multiTypePfl, const std::vector<int>& code, const std::vector<int>& code2, const std::vector<DataArrayInt *>& idsInPflPerType, const std::vector<DataArrayInt *>& idsPerType, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  int nbOfTypes(code.size()/3);
-  for(int i=0;i<nbOfTypes;i++)
-    {
-      INTERP_KERNEL::NormalizedCellType type=(INTERP_KERNEL::NormalizedCellType)code[3*i];
-      int pos=addNewEntryIfNecessary(type);
-      DataArrayInt *pfl=0;
-      if(code[3*i+2]!=-1)
-        pfl=idsPerType[code[3*i+2]];
-      int nbOfTupes2=code2.size()/3;
-      int found=0;
-      for(;found<nbOfTupes2;found++)
-        if(code[3*i]==code2[3*found])
-          break;
-      if(found==nbOfTupes2)
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::assignFieldProfile : internal problem ! Should never happen ! Please report bug to anthony.geay@cea.fr !");
-      _field_pm_pt[pos]->assignFieldProfile(nbOfTypes==1,start,multiTypePfl,idsInPflPerType[i],pfl,code2[3*found+1],field,arr,mesh,glob,nasc);
-    }
-}
-
-void MEDFileFieldPerMesh::assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob)
-{
-  int pos=addNewEntryIfNecessary(INTERP_KERNEL::NORM_ERROR);
-  _field_pm_pt[pos]->assignNodeFieldNoProfile(start,field,arr,glob);
-}
-
-void MEDFileFieldPerMesh::assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  int pos=addNewEntryIfNecessary(INTERP_KERNEL::NORM_ERROR);
-  _field_pm_pt[pos]->assignNodeFieldProfile(start,pfl,field,arr,glob,nasc);
-}
-
-void MEDFileFieldPerMesh::loadOnlyStructureOfDataRecursively(med_idt fid, int& start, const MEDFileFieldNameScope& nasc)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->loadOnlyStructureOfDataRecursively(fid,start,nasc);
-}
-
-void MEDFileFieldPerMesh::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->loadBigArraysRecursively(fid,nasc);
-}
-
-void MEDFileFieldPerMesh::writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const
-{
-  int nbOfTypes=_field_pm_pt.size();
-  for(int i=0;i<nbOfTypes;i++)
-    {
-      _field_pm_pt[i]->copyOptionsFrom(*this);
-      _field_pm_pt[i]->writeLL(fid,nasc);
-    }
-}
-
-void MEDFileFieldPerMesh::getDimension(int& dim) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->getDimension(dim);
-}
-
-bool MEDFileFieldPerMesh::isUniqueLevel(int& dim) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    if(!(*it)->isUniqueLevel(dim))
-      return false;
-  return true;
-}
-
-void MEDFileFieldPerMesh::fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->fillTypesOfFieldAvailable(types);
-}
-
-std::vector< std::vector< std::pair<int,int> > > MEDFileFieldPerMesh::getFieldSplitedByType(std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> > & locs) const
-{
-  int sz=_field_pm_pt.size();
-  std::vector< std::vector<std::pair<int,int> > > ret(sz);
-  types.resize(sz); typesF.resize(sz); pfls.resize(sz); locs.resize(sz);
-  for(int i=0;i<sz;i++)
-    {
-      types[i]=_field_pm_pt[i]->getGeoType();
-      _field_pm_pt[i]->fillFieldSplitedByType(ret[i],typesF[i],pfls[i],locs[i]);
-    }
-  return ret;
-}
-
-double MEDFileFieldPerMesh::getTime() const
-{
-  int tmp1,tmp2;
-  return _father->getTime(tmp1,tmp2);
-}
-
-int MEDFileFieldPerMesh::getIteration() const
-{
-  return _father->getIteration();
-}
-
-int MEDFileFieldPerMesh::getOrder() const
-{
-  return _father->getOrder();
-}
-
-int MEDFileFieldPerMesh::getNumberOfComponents() const
-{
-  return _father->getNumberOfComponents();
-}
-
-std::string MEDFileFieldPerMesh::getMeshName() const
-{
-  return _father->getMeshName();
-}
-
-void MEDFileFieldPerMesh::setMeshName(const std::string& meshName)
-{
-  _father->setMeshName(meshName);
-}
-
-bool MEDFileFieldPerMesh::presenceOfMultiDiscPerGeoType() const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      if((*it).isNull())
-        continue;
-      if((*it)->presenceOfMultiDiscPerGeoType())
-        return true;
-    }
-  return false;
-}
-
-bool MEDFileFieldPerMesh::presenceOfStructureElements() const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    if((*it).isNotNull())
-      {
-        const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
-        if(pt)
-          return true;
-      }
-  return false;
-}
-
-bool MEDFileFieldPerMesh::onlyStructureElements() const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    if((*it).isNotNull())
-      {
-        const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
-        if(!pt)
-          return false;
-      }
-  return true;
-}
-
-void MEDFileFieldPerMesh::killStructureElements()
-{
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > res;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      if((*it).isNotNull())
-        {
-          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
-          if(!pt)
-            res.push_back(*it);
-        }
-    }
-  _field_pm_pt=res;
-}
-
-void MEDFileFieldPerMesh::keepOnlyStructureElements()
-{
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > res;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      if((*it).isNotNull())
-        {
-          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
-          if(pt)
-            res.push_back(*it);
-        }
-    }
-  _field_pm_pt=res;
-}
-
-void MEDFileFieldPerMesh::keepOnlyOnSE(const std::string& seName)
-{
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > res;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      if((*it).isNotNull())
-        {
-          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
-          if(!pt)
-            throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::keepOnlyOnSE : presence of non SE !");
-          if(pt->getModelName()==seName)
-            res.push_back(*it);
-        }
-    }
-  _field_pm_pt=res;
-}
-
-void MEDFileFieldPerMesh::getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      if((*it).isNotNull())
-        {
-          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
-          if(pt)
-            {
-              ps.push_back(std::pair<std::string,std::string>(getMeshName(),pt->getModelName()));
-            }
-          else
-            throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getMeshSENames : presence of a non structure element part !");
-        }
-    }
-}
-
-DataArray *MEDFileFieldPerMesh::getOrCreateAndGetArray()
-{
-  if(!_father)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getOrCreateAndGetArray : no father ! internal error !");
-  return _father->getOrCreateAndGetArray();
-}
-
-const DataArray *MEDFileFieldPerMesh::getOrCreateAndGetArray() const
-{
-  if(!_father)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getOrCreateAndGetArray : no father ! internal error !");
-  return _father->getOrCreateAndGetArray();
-}
-
-const std::vector<std::string>& MEDFileFieldPerMesh::getInfo() const
-{
-  return _father->getInfo();
-}
-
-/*!
- * type,geoTypes,dads,pfls,locs are input parameters. They should have the same size.
- * Before the call of this method 'geoTypes','dads','pfls','locs' must be reorganized so that types in geoTypes are contiguous and ordered following typmai2 array.
- * It returns 2 output vectors :
- * - 'code' of size 3*sz where sz is the number of different values into 'geoTypes'
- * - 'notNullPfls' contains sz2 values that are extracted from 'pfls' in which null profiles have been removed.
- * 'code' and 'notNullPfls' are in MEDCouplingUMesh::checkTypeConsistencyAndContig format.
- */
-void MEDFileFieldPerMesh::SortArraysPerType(const MEDFileFieldGlobsReal *glob, TypeOfField type, const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<const DataArrayInt *>& pfls, const std::vector<int>& locs, std::vector<int>& code, std::vector<DataArrayInt *>& notNullPfls)
-{
-  int notNullPflsSz=0;
-  int nbOfArrs=geoTypes.size();
-  for(int i=0;i<nbOfArrs;i++)
-    if(pfls[i])
-      notNullPflsSz++;
-  std::set<INTERP_KERNEL::NormalizedCellType> geoTypes3(geoTypes.begin(),geoTypes.end());
-  int nbOfDiffGeoTypes=geoTypes3.size();
-  code.resize(3*nbOfDiffGeoTypes);
-  notNullPfls.resize(notNullPflsSz);
-  notNullPflsSz=0;
-  int j=0;
-  for(int i=0;i<nbOfDiffGeoTypes;i++)
-    {
-      int startZone=j;
-      INTERP_KERNEL::NormalizedCellType refType=geoTypes[j];
-      std::vector<const DataArrayInt *> notNullTmp;
-      if(pfls[j])
-        notNullTmp.push_back(pfls[j]);
-      j++;
-      for(;j<nbOfArrs;j++)
-        if(geoTypes[j]==refType)
-          {
-            if(pfls[j])
-              notNullTmp.push_back(pfls[j]);
-          }
-        else
-          break;
-      std::vector< std::pair<int,int> > tmpDads(dads.begin()+startZone,dads.begin()+j);
-      std::vector<const DataArrayInt *> tmpPfls(pfls.begin()+startZone,pfls.begin()+j);
-      std::vector<int> tmpLocs(locs.begin()+startZone,locs.begin()+j);
-      code[3*i]=(int)refType;
-      std::vector<INTERP_KERNEL::NormalizedCellType> refType2(1,refType);
-      code[3*i+1]=ComputeNbOfElems(glob,type,refType2,tmpDads,tmpLocs);
-      if(notNullTmp.empty())
-        code[3*i+2]=-1;
-      else
-        {
-          notNullPfls[notNullPflsSz]=DataArrayInt::Aggregate(notNullTmp);
-          code[3*i+2]=notNullPflsSz++;
-        }
-    }
-}
-
-/*!
- * 'dads' 'geoTypes' and 'locs' are input parameters that should have same size sz. sz should be >=1.
- */
-int MEDFileFieldPerMesh::ComputeNbOfElems(const MEDFileFieldGlobsReal *glob, TypeOfField type, const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs)
-{
-  int sz=dads.size();
-  int ret=0;
-  for(int i=0;i<sz;i++)
-    {
-      if(locs[i]==-1)
-        {
-          if(type!=ON_GAUSS_NE)
-            ret+=dads[i].second-dads[i].first;
-          else
-            {
-              const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(geoTypes[i]);
-              ret+=(dads[i].second-dads[i].first)/cm.getNumberOfNodes();
-            }
-        }
-      else
-        {
-          int nbOfGaussPtPerCell=glob->getNbOfGaussPtPerCell(locs[i]);
-          ret+=(dads[i].second-dads[i].first)/nbOfGaussPtPerCell;
-        }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldPerMesh::getPflsReallyUsed() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getPflsReallyUsed();
-      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
-        if(ret2.find(*it2)==ret2.end())
-          {
-            ret.push_back(*it2);
-            ret2.insert(*it2);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldPerMesh::getPflsReallyUsedMulti() const
-{
-  std::vector<std::string> ret;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getPflsReallyUsedMulti();
-      ret.insert(ret.end(),tmp.begin(),tmp.end());
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldPerMesh::getLocsReallyUsed() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getLocsReallyUsed();
-      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
-        if(ret2.find(*it2)==ret2.end())
-          {
-            ret.push_back(*it2);
-            ret2.insert(*it2);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldPerMesh::getLocsReallyUsedMulti() const
-{
-  std::vector<std::string> ret;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getLocsReallyUsedMulti();
-      ret.insert(ret.end(),tmp.begin(),tmp.end());
-    }
-  return ret;
-}
-
-bool MEDFileFieldPerMesh::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
-{
-  for(std::vector< std::pair<std::string,std::string> >::const_iterator it=modifTab.begin();it!=modifTab.end();it++)
-    {
-      if((*it).first==getMeshName())
-        {
-          setMeshName((*it).second);
-          return true;
-        }
-    }
-  return false;
-}
-
-void MEDFileFieldPerMesh::convertMedBallIntoClassic()
-{
-  if(_field_pm_pt.size()!=1)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : Only managed for single mesh !");
-  if(_field_pm_pt[0].isNull())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : null pointer !");
-  MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<MEDFileFieldPerMeshPerTypeDyn *>((MEDFileFieldPerMeshPerTypeCommon *)_field_pm_pt[0]));
-  if(!pt)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : this is expected to be marked as structure element !");
-  if(pt->getNumberOfLoc()!=1)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : only one loc managed !");
-  const MEDFileFieldPerMeshPerTypePerDisc *disc(pt->getLeafGivenLocId(0));
-  if(!disc)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : internal error !");
-  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> disc2(MEDFileFieldPerMeshPerTypePerDisc::New(*disc));
-  disc2->setType(ON_NODES);
-  MCAuto<MEDFileFieldPerMeshPerType> pt2(MEDFileFieldPerMeshPerType::New(this,INTERP_KERNEL::NORM_ERROR));
-  disc2->setFather(pt2);
-  pt2->setFather(this);
-  pt2->pushDiscretization(disc2);
-  _field_pm_pt[0]=DynamicCast<MEDFileFieldPerMeshPerType,MEDFileFieldPerMeshPerTypeCommon>(pt2);
-}
-
-bool MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N,
-                                                      MEDFileFieldGlobsReal& glob)
-{
-  if(getMeshName()!=meshName)
-    return false;
-  std::set<INTERP_KERNEL::NormalizedCellType> typesToKeep;
-  for(std::size_t i=0;i<oldCode.size()/3;i++) typesToKeep.insert((INTERP_KERNEL::NormalizedCellType)oldCode[3*i]);
-  std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > > entries;
-  std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> entriesKept;
-  std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> otherEntries;
-  getUndergroundDataArrayExt(entries);
-  DataArray *arr0(getOrCreateAndGetArray());//tony
-  if(!arr0)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh : DataArray storing values of field is null !");
-  DataArrayDouble *arr(dynamic_cast<DataArrayDouble *>(arr0));//tony
-  if(!arr0)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh : DataArray storing values is double ! Not managed for the moment !");
-  int sz=0;
-  if(!arr)
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh : DataArrayDouble storing values of field is null !");
-  for(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >::const_iterator it=entries.begin();it!=entries.end();it++)
-    {
-      if(typesToKeep.find((*it).first.first)!=typesToKeep.end())
-        {
-          entriesKept.push_back(getLeafGivenTypeAndLocId((*it).first.first,(*it).first.second));
-          sz+=(*it).second.second-(*it).second.first;
-        }
-      else
-        otherEntries.push_back(getLeafGivenTypeAndLocId((*it).first.first,(*it).first.second));
-    }
-  MCAuto<DataArrayInt> renumDefrag=DataArrayInt::New(); renumDefrag->alloc(arr->getNumberOfTuples(),1); renumDefrag->fillWithZero();
-  ////////////////////
-  MCAuto<DataArrayInt> explicitIdsOldInMesh=DataArrayInt::New(); explicitIdsOldInMesh->alloc(sz,1);//sz is a majorant of the real size. A realloc will be done after
-  int *workI2=explicitIdsOldInMesh->getPointer();
-  int sz1=0,sz2=0,sid=1;
-  std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > entriesKeptML=MEDFileFieldPerMeshPerTypePerDisc::SplitPerDiscretization(entriesKept);
-  // std::vector<int> tupleIdOfStartOfNewChuncksV(entriesKeptML.size());
-  for(std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator itL1=entriesKeptML.begin();itL1!=entriesKeptML.end();itL1++,sid++)
-    {
-      //  tupleIdOfStartOfNewChuncksV[sid-1]=sz2;
-      MCAuto<DataArrayInt> explicitIdsOldInArr=DataArrayInt::New(); explicitIdsOldInArr->alloc(sz,1);
-      int *workI=explicitIdsOldInArr->getPointer();
-      for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator itL2=(*itL1).begin();itL2!=(*itL1).end();itL2++)
-        {
-          int delta1=(*itL2)->fillTupleIds(workI); workI+=delta1; sz1+=delta1;
-          (*itL2)->setLocId(sz2);
-          (*itL2)->_tmp_work1=(*itL2)->getStart();
-          int delta2=(*itL2)->fillEltIdsFromCode(sz2,oldCode,glob,workI2); workI2+=delta2; sz2+=delta2;
-        }
-      renumDefrag->setPartOfValuesSimple3(sid,explicitIdsOldInArr->begin(),explicitIdsOldInArr->end(),0,1,1);
-    }
-  explicitIdsOldInMesh->reAlloc(sz2);
-  int tupleIdOfStartOfNewChuncks=arr->getNumberOfTuples()-sz2;
-  ////////////////////
-  MCAuto<DataArrayInt> permArrDefrag=renumDefrag->buildPermArrPerLevel(); renumDefrag=0;
-  // perform redispatching of non concerned MEDFileFieldPerMeshPerTypePerDisc
-  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > otherEntriesNew;
-  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=otherEntries.begin();it!=otherEntries.end();it++)
-    {
-      otherEntriesNew.push_back(MEDFileFieldPerMeshPerTypePerDisc::New(*(*it)));
-      otherEntriesNew.back()->setNewStart(permArrDefrag->getIJ((*it)->getStart(),0));
-      otherEntriesNew.back()->setLocId((*it)->getGeoType());
-    }
-  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > entriesKeptNew;
-  std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> entriesKeptNew2;
-  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entriesKept.begin();it!=entriesKept.end();it++)
-    {
-      MCAuto<MEDFileFieldPerMeshPerTypePerDisc> elt=MEDFileFieldPerMeshPerTypePerDisc::New(*(*it));
-      int newStart=elt->getLocId();
-      elt->setLocId((*it)->getGeoType());
-      elt->setNewStart(newStart);
-      elt->_tmp_work1=permArrDefrag->getIJ(elt->_tmp_work1,0);
-      entriesKeptNew.push_back(elt);
-      entriesKeptNew2.push_back(elt);
-    }
-  MCAuto<DataArrayDouble> arr2=arr->renumber(permArrDefrag->getConstPointer());
-  // perform redispatching of concerned MEDFileFieldPerMeshPerTypePerDisc -> values are in arr2
-  MCAuto<DataArrayInt> explicitIdsNewInMesh=renumO2N->selectByTupleId(explicitIdsOldInMesh->begin(),explicitIdsOldInMesh->end());
-  std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > entriesKeptPerDisc=MEDFileFieldPerMeshPerTypePerDisc::SplitPerDiscretization(entriesKeptNew2);
-  bool ret=false;
-  for(std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator it4=entriesKeptPerDisc.begin();it4!=entriesKeptPerDisc.end();it4++)
-    {
-      sid=0;
-      /*for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator itL2=(*it4).begin();itL2!=(*it4).end();itL2++)
-        {
-          MEDFileFieldPerMeshPerTypePerDisc *curNC=const_cast<MEDFileFieldPerMeshPerTypePerDisc *>(*itL2);
-          curNC->setNewStart(permArrDefrag->getIJ((*itL2)->getStart(),0)-tupleIdOfStartOfNewChuncks+tupleIdOfStartOfNewChuncksV[sid]);
-          }*/
-      ret=MEDFileFieldPerMeshPerTypePerDisc::RenumberChunks(tupleIdOfStartOfNewChuncks,*it4,explicitIdsNewInMesh,newCode,
-                                                            glob,arr2,otherEntriesNew) || ret;
-    }
-  if(!ret)
-    return false;
-  // Assign new dispatching
-  assignNewLeaves(otherEntriesNew);
-  arr->deepCopyFrom(*arr2);
-  return true;
-}
-
-/*!
- * \param [in,out] globalNum a global numbering counter for the renumbering.
- * \param [out] its - list of pair (start,stop) kept
- */
-void MEDFileFieldPerMesh::keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its)
-{
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > ret;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      std::vector< std::pair<int,int> > its2;
-      if((*it)->keepOnlySpatialDiscretization(tof,globalNum,its2))
-        {
-          ret.push_back(*it);
-          its.insert(its.end(),its2.begin(),its2.end());
-        }
-    }
-  _field_pm_pt=ret;
-}
-
-/*!
- * \param [in,out] globalNum a global numbering counter for the renumbering.
- * \param [out] its - list of pair (start,stop) kept
- */
-void MEDFileFieldPerMesh::keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its)
-{
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > ret;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      std::vector< std::pair<int,int> > its2;
-      if((*it)->keepOnlyGaussDiscretization(idOfDisc,globalNum,its2))
-        {
-          ret.push_back(*it);
-          its.insert(its.end(),its2.begin(),its2.end());
-        }
-    }
-  _field_pm_pt=ret;
-}
-
-void MEDFileFieldPerMesh::assignNewLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves)
-{
-  std::map<INTERP_KERNEL::NormalizedCellType,std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc> > > types;
-  for( std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >::const_iterator it=leaves.begin();it!=leaves.end();it++)
-    types[(INTERP_KERNEL::NormalizedCellType)(*it)->getLocId()].push_back(*it);
-  //
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > fieldPmPt(types.size());
-  std::map<INTERP_KERNEL::NormalizedCellType,std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc> > >::const_iterator it1=types.begin();
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it2=fieldPmPt.begin();
-  for(;it1!=types.end();it1++,it2++)
-    {
-      MCAuto<MEDFileFieldPerMeshPerType> elt=MEDFileFieldPerMeshPerType::New(this,(INTERP_KERNEL::NormalizedCellType)((*it1).second[0]->getLocId()));
-      elt->setLeaves((*it1).second);
-      MCAuto<MEDFileFieldPerMeshPerTypeCommon> elt2(DynamicCast<MEDFileFieldPerMeshPerType,MEDFileFieldPerMeshPerTypeCommon>(elt));
-      *it2=elt2;
-    }
-  _field_pm_pt=fieldPmPt;
-}
-
-void MEDFileFieldPerMesh::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->changePflsRefsNamesGen(mapOfModif);
-}
-
-void MEDFileFieldPerMesh::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->changeLocsRefsNamesGen(mapOfModif);
-}
-
-/*!
- * \param [in] mesh is the whole mesh
- */
-MEDCouplingFieldDouble *MEDFileFieldPerMesh::getFieldOnMeshAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  if(_field_pm_pt.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : no types field set !");
-  //
-  std::vector< std::pair<int,int> > dads;
-  std::vector<const DataArrayInt *> pfls;
-  std::vector<DataArrayInt *> notNullPflsPerGeoType;
-  std::vector<int> locs,code;
-  std::vector<INTERP_KERNEL::NormalizedCellType> geoTypes;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->getFieldAtLevel(mesh->getMeshDimension(),type,glob,dads,pfls,locs,geoTypes);
-  // Sort by types
-  SortArraysPerType(glob,type,geoTypes,dads,pfls,locs,code,notNullPflsPerGeoType);
-  if(code.empty())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevel : " << "The field \"" << nasc.getName() << "\" exists but not with such spatial discretization or such dimension specified !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  //
-  std::vector< MCAuto<DataArrayInt> > notNullPflsPerGeoType2(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
-  std::vector< const DataArrayInt *> notNullPflsPerGeoType3(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
-  if(type!=ON_NODES)
-    {
-      DataArrayInt *arr=mesh->checkTypeConsistencyAndContig(code,notNullPflsPerGeoType3);
-      if(!arr)
-        return finishField(type,glob,dads,locs,mesh,isPfl,arrOut,nasc);
-      else
-        {
-          MCAuto<DataArrayInt> arr2(arr);
-          return finishField2(type,glob,dads,locs,geoTypes,mesh,arr,isPfl,arrOut,nasc);
-        }
-    }
-  else
-    {
-      if(code.size()!=3)
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : internal error #1 !");
-      int nb=code[1];
-      if(code[2]==-1)
-        {
-          if(nb!=mesh->getNumberOfNodes())
-            {
-              std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevel : There is a problem there is " << nb << " nodes in field whereas there is " << mesh->getNumberOfNodes();
-              oss << " nodes in mesh !";
-              throw INTERP_KERNEL::Exception(oss.str());
-            }
-          return finishField(type,glob,dads,locs,mesh,isPfl,arrOut,nasc);
-        }
-      else
-        return finishFieldNode2(glob,dads,locs,mesh,notNullPflsPerGeoType3[0],isPfl,arrOut,nasc);
-    }
-}
-
-DataArray *MEDFileFieldPerMesh::getFieldOnMeshAtLevelWithPfl(TypeOfField type, const MEDCouplingMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const
-{
-  if(_field_pm_pt.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : no types field set !");
-  //
-  std::vector<std::pair<int,int> > dads;
-  std::vector<const DataArrayInt *> pfls;
-  std::vector<DataArrayInt *> notNullPflsPerGeoType;
-  std::vector<int> locs,code;
-  std::vector<INTERP_KERNEL::NormalizedCellType> geoTypes;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    (*it)->getFieldAtLevel(mesh->getMeshDimension(),type,glob,dads,pfls,locs,geoTypes);
-  // Sort by types
-  SortArraysPerType(glob,type,geoTypes,dads,pfls,locs,code,notNullPflsPerGeoType);
-  if(code.empty())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevelWithPfl : " << "The field \"" << nasc.getName() << "\" exists but not with such spatial discretization or such dimension specified !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  std::vector< MCAuto<DataArrayInt> > notNullPflsPerGeoType2(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
-  std::vector< const DataArrayInt *> notNullPflsPerGeoType3(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
-  if(type!=ON_NODES)
-    {
-      MCAuto<DataArrayInt> arr=mesh->checkTypeConsistencyAndContig(code,notNullPflsPerGeoType3);
-      return finishField4(dads,arr,mesh->getNumberOfCells(),pfl);
-    }
-  else
-    {
-      if(code.size()!=3)
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : internal error #1 !");
-      int nb=code[1];
-      if(code[2]==-1)
-        {
-          if(nb!=mesh->getNumberOfNodes())
-            {
-              std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevel : There is a problem there is " << nb << " nodes in field whereas there is " << mesh->getNumberOfNodes();
-              oss << " nodes in mesh !";
-              throw INTERP_KERNEL::Exception(oss.str());
-            }
-        }
-      return finishField4(dads,code[2]==-1?0:notNullPflsPerGeoType3[0],mesh->getNumberOfNodes(),pfl);
-    }
-  //
-  return 0;
-}
-
-void MEDFileFieldPerMesh::accept(MEDFileFieldVisitor& visitor) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    if((*it).isNotNull())
-      {
-        visitor.newPerMeshPerTypeEntry(*it);
-        (*it)->accept(visitor);
-        visitor.endPerMeshPerTypeEntry(*it);
-      }
-}
-
-void MEDFileFieldPerMesh::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  int globalSz=0;
-  int nbOfEntries=0;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      (*it)->getSizes(globalSz,nbOfEntries);
-    }
-  entries.resize(nbOfEntries);
-  nbOfEntries=0;
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      (*it)->fillValues(nbOfEntries,entries);
-    }
-}
-
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMesh::getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      if((*it)->getGeoType()==typ)
-        return (*it)->getLeafGivenLocId(locId);
-    }
-  const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(typ);
-  std::ostringstream oss; oss << "MEDFileFieldPerMesh::getLeafGivenTypeAndLocId : no such geometric type \"" << cm.getRepr() << "\" in this !" << std::endl;
-  oss << "Possiblities are : ";
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      const INTERP_KERNEL::CellModel& cm2=INTERP_KERNEL::CellModel::GetCellModel((*it)->getGeoType());
-      oss << "\"" << cm2.getRepr() << "\", ";
-    }
-  throw INTERP_KERNEL::Exception(oss.str());
-}
-
-const MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMesh::getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      if((*it)->getGeoType()==typ)
-        return (*it)->getLeafGivenLocId(locId);
-    }
-  const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(typ);
-  std::ostringstream oss; oss << "MEDFileFieldPerMesh::getLeafGivenTypeAndLocId : no such geometric type \"" << cm.getRepr() << "\" in this !" << std::endl;
-  oss << "Possiblities are : ";
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
-    {
-      const INTERP_KERNEL::CellModel& cm2=INTERP_KERNEL::CellModel::GetCellModel((*it)->getGeoType());
-      oss << "\"" << cm2.getRepr() << "\", ";
-    }
-  throw INTERP_KERNEL::Exception(oss.str());
-}
-
-/*!
- * \param [in,out] start - Integer that gives the current position in the final aggregated array
- * \param [in] pms - list of elements to aggregate. integer gives the mesh id 
- * \param [in] dts - (Distribution of types) = level 1 : meshes to aggregate. Level 2 : all geo type. Level 3 pair specifying geo type and number of elem in geotype.
- * \param [out] extractInfo - Gives information about the where the data comes from. It is a vector of triplet. First element in the triplet the mesh pos. The 2nd one the start pos. The 3rd the end pos.
- */
-MCAuto<MEDFileFieldPerMeshPerTypePerDisc> MEDFileFieldPerMeshPerTypePerDisc::Aggregate(int &start, const std::vector< std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, TypeOfField tof, MEDFileFieldPerMeshPerType *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo)
-{
-  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> ret(new MEDFileFieldPerMeshPerTypePerDisc(father,tof));
-  if(pms.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : empty input vector !");
-  for(std::vector<std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator it=pms.begin();it!=pms.end();it++)
-    {
-      if(!(*it).second)
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : presence of null pointer !");
-      if(!(*it).second->getProfile().empty())
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for profiles !");
-      if(!(*it).second->getLocalization().empty())
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for gauss pts !");
-    }
-  INTERP_KERNEL::NormalizedCellType gt(pms[0].second->getGeoType());
-  std::size_t i(0);
-  std::vector< std::pair<int,int> > filteredDTS;
-  for(std::vector< std::vector< std::pair<int,int> > >::const_iterator it=dts.begin();it!=dts.end();it++,i++)
-    for(std::vector< std::pair<int,int> >::const_iterator it2=(*it).begin();it2!=(*it).end();it2++)
-      if((*it2).first==gt)
-        filteredDTS.push_back(std::pair<int,int>(i,(*it2).second));
-  if(pms.size()!=filteredDTS.size())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for generated profiles !");
-  std::vector<std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator it1(pms.begin());
-  std::vector< std::pair<int,int> >::const_iterator it2(filteredDTS.begin());
-  int zeStart(start),nval(0);
-  for(;it1!=pms.end();it1++,it2++)
-    {
-      if((*it1).first!=(*it2).first)
-        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for generated profiles 2 !");
-      int s1((*it1).second->getStart()),e1((*it1).second->getEnd());
-      extractInfo.push_back(std::pair<int, std::pair<int,int> >((*it1).first,std::pair<int,int>(s1,e1)));
-      start+=e1-s1;
-      nval+=((*it1).second)->getNumberOfVals();
-    }
-  ret->_start=zeStart; ret->_end=start; ret->_nval=nval;
-  return ret;
-}
-
-MCAuto<MEDFileFieldPerMesh> MEDFileFieldPerMesh::Aggregate(int &start, const std::vector<const MEDFileFieldPerMesh *>& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, MEDFileAnyTypeField1TSWithoutSDA *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo)
-{
-  MCAuto<MEDFileFieldPerMesh> ret(new MEDFileFieldPerMesh(father,pms[0]->getMeshName(),pms[0]->getMeshIteration(),pms[0]->getMeshOrder()));
-  std::map<INTERP_KERNEL::NormalizedCellType, std::vector< std::pair<int,const MEDFileFieldPerMeshPerType *> > > m;
-  std::size_t i(0);
-  for(std::vector<const MEDFileFieldPerMesh *>::const_iterator it=pms.begin();it!=pms.end();it++,i++)
-    {
-      const std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >& v((*it)->_field_pm_pt);
-      for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it2=v.begin();it2!=v.end();it2++)
-        {
-          INTERP_KERNEL::NormalizedCellType gt((*it2)->getGeoType());
-          const MEDFileFieldPerMeshPerType *elt(dynamic_cast<const MEDFileFieldPerMeshPerType *>((const MEDFileFieldPerMeshPerTypeCommon *)(*it2)));
-          if(!elt)
-            throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::Aggregate : not managed for structelement !");
-          m[gt].push_back(std::pair<int,const MEDFileFieldPerMeshPerType *>(i,elt));
-        }
-    }
-  for(std::map<INTERP_KERNEL::NormalizedCellType, std::vector< std::pair<int,const MEDFileFieldPerMeshPerType *> > >::const_iterator it=m.begin();it!=m.end();it++)
-    {
-      MCAuto<MEDFileFieldPerMeshPerType> agg(MEDFileFieldPerMeshPerType::Aggregate(start,(*it).second,dts,(*it).first,ret,extractInfo));
-      MCAuto<MEDFileFieldPerMeshPerTypeCommon> agg2(DynamicCast<MEDFileFieldPerMeshPerType,MEDFileFieldPerMeshPerTypeCommon>(agg));
-      ret->_field_pm_pt.push_back(agg2);
-    }
-  return ret;
-}
-
-int MEDFileFieldPerMesh::addNewEntryIfNecessary(INTERP_KERNEL::NormalizedCellType type)
-{
-  int i=0;
-  int pos=std::distance(typmai2,std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,type));
-  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it2=_field_pm_pt.begin();
-  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++,i++)
-    {
-      INTERP_KERNEL::NormalizedCellType curType=(*it)->getGeoType();
-      if(type==curType)
-        return i;
-      else
-        {
-          int pos2=std::distance(typmai2,std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,curType));
-          if(pos>pos2)
-            it2=it+1;
-        }
-    }
-  int ret=std::distance(_field_pm_pt.begin(),it2);
-  _field_pm_pt.insert(it2,MEDFileFieldPerMeshPerType::New(this,type));
-  return ret;
-}
-
-/*!
- * 'dads' and 'locs' input parameters have the same number of elements
- * \param [in] mesh is \b NOT the global mesh, but the possibly reduced mesh. \a mesh parameter will be directly aggregated in the returned field
- */
-MEDCouplingFieldDouble *MEDFileFieldPerMesh::finishField(TypeOfField type, const MEDFileFieldGlobsReal *glob,
-                                                         const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs,
-                                                         const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  isPfl=false;
-  MCAuto<MEDCouplingFieldDouble> ret=MEDCouplingFieldDouble::New(type,ONE_TIME);
-  ret->setMesh(mesh); ret->setName(nasc.getName().c_str()); ret->setTime(getTime(),getIteration(),getOrder()); ret->setTimeUnit(nasc.getDtUnit().c_str());
-  MCAuto<DataArray> da=getOrCreateAndGetArray()->selectByTupleRanges(dads);
-  const std::vector<std::string>& infos=getInfo();
-  da->setInfoOnComponents(infos);
-  da->setName("");
-  if(type==ON_GAUSS_PT)
-    {
-      int offset=0;
-      int nbOfArrs=dads.size();
-      for(int i=0;i<nbOfArrs;i++)
-        {
-          std::vector<std::pair<int,int> > dads2(1,dads[i]); const std::vector<int> locs2(1,locs[i]);
-          const std::vector<INTERP_KERNEL::NormalizedCellType> geoTypes2(1,INTERP_KERNEL::NORM_ERROR);
-          int nbOfElems=ComputeNbOfElems(glob,type,geoTypes2,dads2,locs2);
-          MCAuto<DataArrayInt> di=DataArrayInt::New();
-          di->alloc(nbOfElems,1);
-          di->iota(offset);
-          const MEDFileFieldLoc& fl=glob->getLocalizationFromId(locs[i]);
-          ret->setGaussLocalizationOnCells(di->getConstPointer(),di->getConstPointer()+nbOfElems,fl.getRefCoords(),fl.getGaussCoords(),fl.getGaussWeights());
-          offset+=nbOfElems;
-        }
-    }
-  arrOut=da;
-  return ret.retn();
-}
-
-/*!
- * This method is an extension of MEDFileFieldPerMesh::finishField method. It deals with profiles. This method should be called when type is different from ON_NODES.
- * 'dads', 'locs' and 'geoTypes' input parameters have the same number of elements.
- * No check of this is performed. 'da' array contains an array in old2New style to be applyied to mesh to obtain the right support.
- * The order of cells in the returned field is those imposed by the profile.
- * \param [in] mesh is the global mesh.
- */
-MEDCouplingFieldDouble *MEDFileFieldPerMesh::finishField2(TypeOfField type, const MEDFileFieldGlobsReal *glob,
-                                                          const std::vector<std::pair<int,int> >& dads, const std::vector<int>& locs,
-                                                          const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes,
-                                                          const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  if(da->isIota(mesh->getNumberOfCells()))
-    return finishField(type,glob,dads,locs,mesh,isPfl,arrOut,nasc);
-  MCAuto<MEDCouplingMesh> m2=mesh->buildPart(da->getConstPointer(),da->getConstPointer()+da->getNbOfElems());
-  m2->setName(mesh->getName().c_str());
-  MCAuto<MEDCouplingFieldDouble> ret=finishField(type,glob,dads,locs,m2,isPfl,arrOut,nasc);
-  isPfl=true;
-  return ret.retn();
-}
-
-/*!
- * This method is the complement of MEDFileFieldPerMesh::finishField2 method except that this method works for node profiles.
- */
-MEDCouplingFieldDouble *MEDFileFieldPerMesh::finishFieldNode2(const MEDFileFieldGlobsReal *glob,
-                                                              const std::vector<std::pair<int,int> >& dads, const std::vector<int>& locs,
-                                                              const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  if(da->isIota(mesh->getNumberOfNodes()))
-    return finishField(ON_NODES,glob,dads,locs,mesh,isPfl,arrOut,nasc);
-  // Treatment of particular case where nodal field on pfl is requested with a meshDimRelToMax=1.
-  const MEDCouplingUMesh *meshu=dynamic_cast<const MEDCouplingUMesh *>(mesh);
-  if(meshu)
-    {
-      if(meshu->getNodalConnectivity()==0)
-        {
-          MCAuto<MEDCouplingFieldDouble> ret=finishField(ON_CELLS,glob,dads,locs,mesh,isPfl,arrOut,nasc);
-          int nb=da->getNbOfElems();
-          const int *ptr=da->getConstPointer();
-          MEDCouplingUMesh *meshuc=const_cast<MEDCouplingUMesh *>(meshu);
-          meshuc->allocateCells(nb);
-          for(int i=0;i<nb;i++)
-            meshuc->insertNextCell(INTERP_KERNEL::NORM_POINT1,1,ptr+i);
-          meshuc->finishInsertingCells();
-          ret->setMesh(meshuc);
-          const MEDCouplingFieldDiscretization *disc=ret->getDiscretization();
-          if(!disc) throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::finishFieldNode2 : internal error, no discretization on field !");
-          disc->checkCoherencyBetween(meshuc,arrOut);
-          return ret.retn();
-        }
-    }
-  //
-  MCAuto<MEDCouplingFieldDouble> ret=finishField(ON_NODES,glob,dads,locs,mesh,isPfl,arrOut,nasc);
-  isPfl=true;
-  DataArrayInt *arr2=0;
-  MCAuto<DataArrayInt> cellIds=mesh->getCellIdsFullyIncludedInNodeIds(da->getConstPointer(),da->getConstPointer()+da->getNbOfElems());
-  MCAuto<MEDCouplingMesh> mesh2=mesh->buildPartAndReduceNodes(cellIds->getConstPointer(),cellIds->getConstPointer()+cellIds->getNbOfElems(),arr2);
-  MCAuto<DataArrayInt> arr3(arr2);
-  int nnodes=mesh2->getNumberOfNodes();
-  if(nnodes==(int)da->getNbOfElems())
-    {
-      MCAuto<DataArrayInt> da3=da->transformWithIndArrR(arr2->begin(),arr2->end());
-      arrOut->renumberInPlace(da3->getConstPointer());
-      mesh2->setName(mesh->getName().c_str());
-      ret->setMesh(mesh2);
-      return ret.retn();
-    }
-  else
-    {
-      std::ostringstream oss; oss << "MEDFileFieldPerMesh::finishFieldNode2 : The field on nodes lies on a node profile so that it is impossible to find a submesh having exactly the same nodes of that profile !!!";
-      oss << "So it is impossible to return a well definied MEDCouplingFieldDouble instance on specified mesh on a specified meshDim !" << std::endl;
-      oss << "To retrieve correctly such a field you have 3 possibilities :" << std::endl;
-      oss << " - use an another meshDim compatible with the field on nodes (MED file does not have such information)" << std::endl;
-      oss << " - use an another a meshDimRelToMax equal to 1 -> it will return a mesh with artificial cell POINT1 containing the profile !" << std::endl;
-      oss << " - if definitely the node profile has no link with mesh connectivity use MEDFileField1TS::getFieldWithProfile or MEDFileFieldMultiTS::getFieldWithProfile methods instead !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  return 0;
-}
-
-/*!
- * This method is the most light method of field retrieving.
- */
-DataArray *MEDFileFieldPerMesh::finishField4(const std::vector<std::pair<int,int> >& dads, const DataArrayInt *pflIn, int nbOfElems, DataArrayInt *&pflOut) const
-{
-  if(!pflIn)
-    {
-      pflOut=DataArrayInt::New();
-      pflOut->alloc(nbOfElems,1);
-      pflOut->iota(0);
-    }
-  else
-    {
-      pflOut=const_cast<DataArrayInt*>(pflIn);
-      pflOut->incrRef();
-    }
-  MCAuto<DataArrayInt> safePfl(pflOut);
-  MCAuto<DataArray> da=getOrCreateAndGetArray()->selectByTupleRanges(dads);
-  const std::vector<std::string>& infos=getInfo();
-  int nbOfComp=infos.size();
-  for(int i=0;i<nbOfComp;i++)
-    da->setInfoOnComponent(i,infos[i].c_str());
-  safePfl->incrRef();
-  return da.retn();
-}
-
-
-/// @cond INTERNAL
-
-class MFFPMIter
-{
-public:
-  static MFFPMIter *NewCell(const MEDFileEntities *entities);
-  static bool IsPresenceOfNode(const MEDFileEntities *entities);
-  virtual ~MFFPMIter() { }
-  virtual void begin() = 0;
-  virtual bool finished() const = 0;
-  virtual void next() = 0;
-  virtual int current() const = 0;
-};
-
-class MFFPMIterSimple : public MFFPMIter
-{
-public:
-  MFFPMIterSimple():_pos(0) { }
-  void begin() { _pos=0; }
-  bool finished() const { return _pos>=MED_N_CELL_FIXED_GEO; }
-  void next() { _pos++; }
-  int current() const { return _pos; }
-private:
-  int _pos;
-};
-
-class MFFPMIter2 : public MFFPMIter
-{
-public:
-  MFFPMIter2(const std::vector<INTERP_KERNEL::NormalizedCellType>& cts);
-  void begin() { _it=_ids.begin(); }
-  bool finished() const { return _it==_ids.end(); }
-  void next() { _it++; }
-  int current() const { return *_it; }
-private:
-  std::vector<int> _ids;
-  std::vector<int>::const_iterator _it;
-};
-
-MFFPMIter *MFFPMIter::NewCell(const MEDFileEntities *entities)
-{
-  if(!entities)
-    return new MFFPMIterSimple;
-  else
-    {
-      const MEDFileStaticEntities *entities2(dynamic_cast<const MEDFileStaticEntities *>(entities));
-      if(entities2)
-        {
-          std::vector<INTERP_KERNEL::NormalizedCellType> tmp;
-          const std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >& myEnt(entities2->getEntries());
-          for(std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >::const_iterator it=myEnt.begin();it!=myEnt.end();it++)
-            {
-              if((*it).first==ON_CELLS || (*it).first==ON_GAUSS_NE || (*it).first==ON_GAUSS_PT)
-                tmp.push_back((*it).second);
-            }
-          return new MFFPMIter2(tmp);
-        }
-      return new MFFPMIterSimple;// for MEDFileAllStaticEntites and MEDFileAllStaticEntitiesPlusDyn cells are in
-    }
-}
-
-bool MFFPMIter::IsPresenceOfNode(const MEDFileEntities *entities)
-{
-  if(!entities)
-    return true;
-  else
-    {
-      const MEDFileStaticEntities *entities2(dynamic_cast<const MEDFileStaticEntities *>(entities));
-      if(entities2)
-        {
-          const std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >& myEnt(entities2->getEntries());
-          for(std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >::const_iterator it=myEnt.begin();it!=myEnt.end();it++)
-            if((*it).first==ON_NODES)
-              return true;
-          return false;
-        }
-      return true;// for MEDFileAllStaticEntites and MEDFileAllStaticEntitiesPlusDyn nodes are in
-    }
-}
-
-MFFPMIter2::MFFPMIter2(const std::vector<INTERP_KERNEL::NormalizedCellType>& cts)
-{
-  std::size_t sz(cts.size());
-  _ids.resize(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      INTERP_KERNEL::NormalizedCellType *loc(std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,cts[i]));
-      if(loc!=typmai2+MED_N_CELL_FIXED_GEO)
-        _ids[i]=(int)std::distance(typmai2,loc);
-      else
-        throw INTERP_KERNEL::Exception("MFFPMIter2 : The specified geo type does not exists !");
-    }
-}
-
-/// @endcond
-
-MEDFileFieldPerMesh::MEDFileFieldPerMesh(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities):_mesh_iteration(meshIteration),_mesh_order(meshOrder),
-    _father(fath)
-{
-  INTERP_KERNEL::AutoPtr<char> meshName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> pflName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> locName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  const MEDFileUMesh *mmu(dynamic_cast<const MEDFileUMesh *>(mm));
-  INTERP_KERNEL::AutoCppPtr<MFFPMIter> iter0(MFFPMIter::NewCell(entities));
-  for(iter0->begin();!iter0->finished();iter0->next())
-    {
-      int nbProfile (MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_CELL        ,typmai[iter0->current()],meshCsit+1,meshName,pflName,locName));
-      std::string name0(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE+1));
-      int nbProfile2(MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_NODE_ELEMENT,typmai[iter0->current()],meshCsit+1,meshName,pflName,locName));
-      std::string name1(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE+1));
-      if(nbProfile>0 || nbProfile2>0)
-        {
-          const PartDefinition *pd(0);
-          if(mmu)
-            pd=mmu->getPartDefAtLevel(mmu->getRelativeLevOnGeoType(typmai2[iter0->current()]),typmai2[iter0->current()]);
-          _field_pm_pt.push_back(MEDFileFieldPerMeshPerType::NewOnRead(fid,this,ON_CELLS,typmai2[iter0->current()],nasc,pd));
-          if(nbProfile>0)
-            setMeshName(name0);
-          else
-            setMeshName(name1);
-        }
-    }
-  if(MFFPMIter::IsPresenceOfNode(entities))
-    {
-      int nbProfile(MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_NODE,MED_NONE,meshCsit+1,meshName,pflName,locName));
-      if(nbProfile>0)
-        {
-          const PartDefinition *pd(0);
-          if(mmu)
-            pd=mmu->getPartDefAtLevel(1,INTERP_KERNEL::NORM_ERROR);
-          _field_pm_pt.push_back(MEDFileFieldPerMeshPerType::NewOnRead(fid,this,ON_NODES,INTERP_KERNEL::NORM_ERROR,nasc,pd));
-          setMeshName(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE));
-        }
-    }
-  if(!entities)
-    return ;
-  std::vector<int> dynGT(entities->getDynGTAvail());
-  for(std::vector<int>::const_iterator it=dynGT.begin();it!=dynGT.end();it++)
-    {
-      int nbPfl(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_STRUCT_ELEMENT,*it,pflName,locName));
-      if(nbPfl>0)
-        {
-          _field_pm_pt.push_back(MEDFileFieldPerMeshPerTypeDyn::NewOnRead(fid,this,entities,*it,nasc));
-          setMeshName(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE));
-        }
-    }
-}
-
-MEDFileFieldPerMesh::MEDFileFieldPerMesh(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh):_father(fath)
-{
-  copyTinyInfoFrom(mesh);
-}
-
-void MEDFileFieldGlobs::loadProfileInFile(med_idt fid, int id, const std::string& pflName)
-{
-  if(id>=(int)_pfls.size())
-    _pfls.resize(id+1);
-  _pfls[id]=DataArrayInt::New();
-  int lgth(MEDprofileSizeByName(fid,pflName.c_str()));
-  _pfls[id]->setName(pflName);
-  _pfls[id]->alloc(lgth,1);
-  MEDFILESAFECALLERRD0(MEDprofileRd,(fid,pflName.c_str(),_pfls[id]->getPointer()));
-  _pfls[id]->applyLin(1,-1,0);//Converting into C format
-}
-
-void MEDFileFieldGlobs::loadProfileInFile(med_idt fid, int i)
-{
-  INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
-  int sz;
-  MEDFILESAFECALLERRD0(MEDprofileInfo,(fid,i+1,pflName,&sz));
-  std::string pflCpp=MEDLoaderBase::buildStringFromFortran(pflName,MED_NAME_SIZE);
-  if(i>=(int)_pfls.size())
-    _pfls.resize(i+1);
-  _pfls[i]=DataArrayInt::New();
-  _pfls[i]->alloc(sz,1);
-  _pfls[i]->setName(pflCpp.c_str());
-  MEDFILESAFECALLERRD0(MEDprofileRd,(fid,pflName,_pfls[i]->getPointer()));
-  _pfls[i]->applyLin(1,-1,0);//Converting into C format
-}
-
-void MEDFileFieldGlobs::writeGlobals(med_idt fid, const MEDFileWritable& opt) const
-{
-  int nbOfPfls=_pfls.size();
-  for(int i=0;i<nbOfPfls;i++)
-    {
-      MCAuto<DataArrayInt> cpy=_pfls[i]->deepCopy();
-      cpy->applyLin(1,1,0);
-      INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
-      MEDLoaderBase::safeStrCpy(_pfls[i]->getName().c_str(),MED_NAME_SIZE,pflName,opt.getTooLongStrPolicy());
-      MEDFILESAFECALLERWR0(MEDprofileWr,(fid,pflName,_pfls[i]->getNumberOfTuples(),cpy->getConstPointer()));
-    }
-  //
-  int nbOfLocs=_locs.size();
-  for(int i=0;i<nbOfLocs;i++)
-    _locs[i]->writeLL(fid);
-}
-
-void MEDFileFieldGlobs::appendGlobs(const MEDFileFieldGlobs& other, double eps)
-{
-  std::vector<std::string> pfls=getPfls();
-  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=other._pfls.begin();it!=other._pfls.end();it++)
-    {
-      std::vector<std::string>::iterator it2=std::find(pfls.begin(),pfls.end(),(*it)->getName());
-      if(it2==pfls.end())
-        {
-          _pfls.push_back(*it);
-        }
-      else
-        {
-          int id=std::distance(pfls.begin(),it2);
-          if(!(*it)->isEqual(*_pfls[id]))
-            {
-              std::ostringstream oss; oss << "MEDFileFieldGlobs::appendGlobs : Profile \"" << (*it)->getName() << "\" already exists and is different from those expecting to be append !";
-              throw INTERP_KERNEL::Exception(oss.str());
-            }
-        }
-    }
-  std::vector<std::string> locs=getLocs();
-  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=other._locs.begin();it!=other._locs.end();it++)
-    {
-      std::vector<std::string>::iterator it2=std::find(locs.begin(),locs.end(),(*it)->getName());
-      if(it2==locs.end())
-        {
-          _locs.push_back(*it);
-        }
-      else
-        {
-          int id=std::distance(locs.begin(),it2);
-          if(!(*it)->isEqual(*_locs[id],eps))
-            {
-              std::ostringstream oss; oss << "MEDFileFieldGlobs::appendGlobs : Localization \"" << (*it)->getName() << "\" already exists and is different from those expecting to be append !";
-              throw INTERP_KERNEL::Exception(oss.str());
-            }
-        }
-    }
-}
-
-void MEDFileFieldGlobs::checkGlobsPflsPartCoherency(const std::vector<std::string>& pflsUsed) const
-{
-  for(std::vector<std::string>::const_iterator it=pflsUsed.begin();it!=pflsUsed.end();it++)
-    getProfile((*it).c_str());
-}
-
-void MEDFileFieldGlobs::checkGlobsLocsPartCoherency(const std::vector<std::string>& locsUsed) const
-{
-  for(std::vector<std::string>::const_iterator it=locsUsed.begin();it!=locsUsed.end();it++)
-    getLocalization((*it).c_str());
-}
-
-void MEDFileFieldGlobs::loadGlobals(med_idt fid, const MEDFileFieldGlobsReal& real)
-{
-  std::vector<std::string> profiles=real.getPflsReallyUsed();
-  int sz=profiles.size();
-  _pfls.resize(sz);
-  for(int i=0;i<sz;i++)
-    loadProfileInFile(fid,i,profiles[i].c_str());
-  //
-  std::vector<std::string> locs=real.getLocsReallyUsed();
-  sz=locs.size();
-  _locs.resize(sz);
-  for(int i=0;i<sz;i++)
-    _locs[i]=MEDFileFieldLoc::New(fid,locs[i].c_str());
-}
-
-void MEDFileFieldGlobs::loadAllGlobals(med_idt fid, const MEDFileEntities *entities)
-{
-  int nProfil=MEDnProfile(fid);
-  for(int i=0;i<nProfil;i++)
-    loadProfileInFile(fid,i);
-  int sz=MEDnLocalization(fid);
-  _locs.resize(sz);
-  for(int i=0;i<sz;i++)
-    {
-      _locs[i]=MEDFileFieldLoc::New(fid,i,entities);
-    }
-}
-
-MEDFileFieldGlobs *MEDFileFieldGlobs::New(med_idt fid)
-{
-  return new MEDFileFieldGlobs(fid);
-}
-
-MEDFileFieldGlobs *MEDFileFieldGlobs::New()
-{
-  return new MEDFileFieldGlobs;
-}
-
-std::size_t MEDFileFieldGlobs::getHeapMemorySizeWithoutChildren() const
-{
-  return _file_name.capacity()+_pfls.capacity()*sizeof(MCAuto<DataArrayInt>)+_locs.capacity()*sizeof(MCAuto<MEDFileFieldLoc>);
-}
-
-std::vector<const BigMemoryObject *> MEDFileFieldGlobs::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret;
-  for(std::vector< MCAuto< DataArrayInt > >::const_iterator it=_pfls.begin();it!=_pfls.end();it++)
-    ret.push_back((const DataArrayInt *)*it);
-  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++)
-    ret.push_back((const MEDFileFieldLoc *)*it);
-  return ret;
-}
-
-MEDFileFieldGlobs *MEDFileFieldGlobs::deepCopy() const
-{
-  MCAuto<MEDFileFieldGlobs> ret=new MEDFileFieldGlobs(*this);
-  std::size_t i=0;
-  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++,i++)
-    {
-      if((const DataArrayInt *)*it)
-        ret->_pfls[i]=(*it)->deepCopy();
-    }
-  i=0;
-  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++,i++)
-    {
-      if((const MEDFileFieldLoc*)*it)
-        ret->_locs[i]=(*it)->deepCopy();
-    }
-  return ret.retn();
-}
-
-/*!
- * \throw if a profile in \a pfls in not in \a this.
- * \throw if a localization in \a locs in not in \a this.
- * \sa MEDFileFieldGlobs::deepCpyPart
- */
-MEDFileFieldGlobs *MEDFileFieldGlobs::shallowCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const
-{
-  MCAuto<MEDFileFieldGlobs> ret=MEDFileFieldGlobs::New();
-  for(std::vector<std::string>::const_iterator it1=pfls.begin();it1!=pfls.end();it1++)
-    {
-      DataArrayInt *pfl=const_cast<DataArrayInt *>(getProfile((*it1).c_str()));
-      if(!pfl)
-        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::shallowCpyPart : internal error ! pfl null !");
-      pfl->incrRef();
-      MCAuto<DataArrayInt> pfl2(pfl);
-      ret->_pfls.push_back(pfl2);
-    }
-  for(std::vector<std::string>::const_iterator it2=locs.begin();it2!=locs.end();it2++)
-    {
-      MEDFileFieldLoc *loc=const_cast<MEDFileFieldLoc *>(&getLocalization((*it2).c_str()));
-      if(!loc)
-        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::shallowCpyPart : internal error ! loc null !");
-      loc->incrRef();
-      MCAuto<MEDFileFieldLoc> loc2(loc);
-      ret->_locs.push_back(loc2);
-    }
-  ret->setFileName(getFileName());
-  return ret.retn();
-}
-
-/*!
- * \throw if a profile in \a pfls in not in \a this.
- * \throw if a localization in \a locs in not in \a this.
- * \sa MEDFileFieldGlobs::shallowCpyPart
- */
-MEDFileFieldGlobs *MEDFileFieldGlobs::deepCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const
-{
-  MCAuto<MEDFileFieldGlobs> ret=MEDFileFieldGlobs::New();
-  for(std::vector<std::string>::const_iterator it1=pfls.begin();it1!=pfls.end();it1++)
-    {
-      DataArrayInt *pfl=const_cast<DataArrayInt *>(getProfile((*it1).c_str()));
-      if(!pfl)
-        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::deepCpyPart : internal error ! pfl null !");
-      ret->_pfls.push_back(pfl->deepCopy());
-    }
-  for(std::vector<std::string>::const_iterator it2=locs.begin();it2!=locs.end();it2++)
-    {
-      MEDFileFieldLoc *loc=const_cast<MEDFileFieldLoc *>(&getLocalization((*it2).c_str()));
-      if(!loc)
-        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::deepCpyPart : internal error ! loc null !");
-      ret->_locs.push_back(loc->deepCopy());
-    }
-  ret->setFileName(getFileName());
-  return ret.retn();
-}
-
-MEDFileFieldGlobs::MEDFileFieldGlobs(med_idt fid):_file_name(MEDFileWritable::FileNameFromFID(fid))
-{
-}
-
-MEDFileFieldGlobs::MEDFileFieldGlobs()
-{
-}
-
-MEDFileFieldGlobs::~MEDFileFieldGlobs()
-{
-}
-
-void MEDFileFieldGlobs::simpleRepr(std::ostream& oss) const
-{
-  oss << "Profiles :\n";
-  std::size_t n=_pfls.size();
-  for(std::size_t i=0;i<n;i++)
-    {
-      oss << "  - #" << i << " ";
-      const DataArrayInt *pfl=_pfls[i];
-      if(pfl)
-        oss << "\"" << pfl->getName() << "\"\n";
-      else
-        oss << "EMPTY !\n";
-    }
-  n=_locs.size();
-  oss << "Localizations :\n";
-  for(std::size_t i=0;i<n;i++)
-    {
-      oss << "  - #" << i << " ";
-      const MEDFileFieldLoc *loc=_locs[i];
-      if(loc)
-        loc->simpleRepr(oss);
-      else
-        oss<< "EMPTY !\n";
-    }
-}
-
-void MEDFileFieldGlobs::changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto<DataArrayInt> >::iterator it=_pfls.begin();it!=_pfls.end();it++)
-    {
-      DataArrayInt *elt(*it);
-      if(elt)
-        {
-          std::string name(elt->getName());
-          for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
-            {
-              if(std::find((*it2).first.begin(),(*it2).first.end(),name)!=(*it2).first.end())
-                {
-                  elt->setName((*it2).second.c_str());
-                  return;
-                }
-            }
-        }
-    }
-}
-
-void MEDFileFieldGlobs::changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto<MEDFileFieldLoc> >::iterator it=_locs.begin();it!=_locs.end();it++)
-    {
-      MEDFileFieldLoc *elt(*it);
-      if(elt)
-        {
-          std::string name(elt->getName());
-          for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
-            {
-              if(std::find((*it2).first.begin(),(*it2).first.end(),name)!=(*it2).first.end())
-                {
-                  elt->setName((*it2).second.c_str());
-                  return;
-                }
-            }
-        }
-    }
-}
-
-int MEDFileFieldGlobs::getNbOfGaussPtPerCell(int locId) const
-{
-  if(locId<0 || locId>=(int)_locs.size())
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getNbOfGaussPtPerCell : Invalid localization id !");
-  return _locs[locId]->getNbOfGaussPtPerCell();
-}
-
-const MEDFileFieldLoc& MEDFileFieldGlobs::getLocalization(const std::string& locName) const
-{
-  return getLocalizationFromId(getLocalizationId(locName));
-}
-
-const MEDFileFieldLoc& MEDFileFieldGlobs::getLocalizationFromId(int locId) const
-{
-  if(locId<0 || locId>=(int)_locs.size())
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getLocalizationFromId : Invalid localization id !");
-  return *_locs[locId];
-}
-
-/// @cond INTERNAL
-namespace MEDCouplingImpl
-{
-  class LocFinder
-  {
-  public:
-    LocFinder(const std::string& loc):_loc(loc) { }
-    bool operator() (const MCAuto<MEDFileFieldLoc>& loc) { return loc->isName(_loc); }
-  private:
-    const std::string &_loc;
-  };
-
-  class PflFinder
-  {
-  public:
-    PflFinder(const std::string& pfl):_pfl(pfl) { }
-    bool operator() (const MCAuto<DataArrayInt>& pfl) { return _pfl==pfl->getName(); }
-  private:
-    const std::string& _pfl;
-  };
-}
-/// @endcond
-
-int MEDFileFieldGlobs::getLocalizationId(const std::string& loc) const
-{
-  std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=std::find_if(_locs.begin(),_locs.end(),MEDCouplingImpl::LocFinder(loc));
-  if(it==_locs.end())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldGlobs::getLocalisationId : no such localisation name : \"" << loc << "\" Possible localizations are : ";
-      for(it=_locs.begin();it!=_locs.end();it++)
-        oss << "\"" << (*it)->getName() << "\", ";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  return std::distance(_locs.begin(),it);
-}
-
-/*!
- * The returned value is never null.
- */
-const DataArrayInt *MEDFileFieldGlobs::getProfile(const std::string& pflName) const
-{
-  std::string pflNameCpp(pflName);
-  std::vector< MCAuto<DataArrayInt> >::const_iterator it=std::find_if(_pfls.begin(),_pfls.end(),MEDCouplingImpl::PflFinder(pflNameCpp));
-  if(it==_pfls.end())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldGlobs::getProfile: no such profile name : \"" << pflNameCpp << "\" Possible profiles are : ";
-      for(it=_pfls.begin();it!=_pfls.end();it++)
-        oss << "\"" << (*it)->getName() << "\", ";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  return *it;
-}
-
-const DataArrayInt *MEDFileFieldGlobs::getProfileFromId(int pflId) const
-{
-  if(pflId<0 || pflId>=(int)_pfls.size())
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getProfileFromId : Invalid profile id !");
-  return _pfls[pflId];
-}
-
-MEDFileFieldLoc& MEDFileFieldGlobs::getLocalizationFromId(int locId)
-{
-  if(locId<0 || locId>=(int)_locs.size())
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getLocalizationFromId : Invalid localization id !");
-  return *_locs[locId];
-}
-
-MEDFileFieldLoc& MEDFileFieldGlobs::getLocalization(const std::string& locName)
-{
-  return getLocalizationFromId(getLocalizationId(locName));
-}
-
-/*!
- * The returned value is never null.
- */
-DataArrayInt *MEDFileFieldGlobs::getProfile(const std::string& pflName)
-{
-  std::string pflNameCpp(pflName);
-  std::vector< MCAuto<DataArrayInt> >::iterator it=std::find_if(_pfls.begin(),_pfls.end(),MEDCouplingImpl::PflFinder(pflNameCpp));
-  if(it==_pfls.end())
-    {
-      std::ostringstream oss; oss << "MEDFileFieldGlobs::getProfile: no such profile name : \"" << pflNameCpp << "\" Possible profiles are : ";
-      for(it=_pfls.begin();it!=_pfls.end();it++)
-        oss << "\"" << (*it)->getName() << "\", ";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  return *it;
-}
-
-DataArrayInt *MEDFileFieldGlobs::getProfileFromId(int pflId)
-{
-  if(pflId<0 || pflId>=(int)_pfls.size())
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getProfileFromId : Invalid profile id !");
-  return _pfls[pflId];
-}
-
-void MEDFileFieldGlobs::killProfileIds(const std::vector<int>& pflIds)
-{
-  std::vector< MCAuto<DataArrayInt> > newPfls;
-  int i=0;
-  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++,i++)
-    {
-      if(std::find(pflIds.begin(),pflIds.end(),i)==pflIds.end())
-        newPfls.push_back(*it);
-    }
-  _pfls=newPfls;
-}
-
-void MEDFileFieldGlobs::killLocalizationIds(const std::vector<int>& locIds)
-{
-  std::vector< MCAuto<MEDFileFieldLoc> > newLocs;
-  int i=0;
-  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++,i++)
-    {
-      if(std::find(locIds.begin(),locIds.end(),i)==locIds.end())
-        newLocs.push_back(*it);
-    }
-  _locs=newLocs;
-}
-
-void MEDFileFieldGlobs::killStructureElementsInGlobs()
-{
-  std::vector< MCAuto<MEDFileFieldLoc> > newLocs;
-  for(std::vector< MCAuto<MEDFileFieldLoc> >::iterator it=_locs.begin();it!=_locs.end();it++)
-    {
-      if((*it).isNull())
-        continue;
-      if(!(*it)->isOnStructureElement())
-        newLocs.push_back(*it);
-    }
-  _locs=newLocs;
-}
-
-std::vector<std::string> MEDFileFieldGlobs::getPfls() const
-{
-  int sz=_pfls.size();
-  std::vector<std::string> ret(sz);
-  for(int i=0;i<sz;i++)
-    ret[i]=_pfls[i]->getName();
-  return ret;
-}
-
-std::vector<std::string> MEDFileFieldGlobs::getLocs() const
-{
-  int sz=_locs.size();
-  std::vector<std::string> ret(sz);
-  for(int i=0;i<sz;i++)
-    ret[i]=_locs[i]->getName();
-  return ret;
-}
-
-bool MEDFileFieldGlobs::existsPfl(const std::string& pflName) const
-{
-  std::vector<std::string> v=getPfls();
-  std::string s(pflName);
-  return std::find(v.begin(),v.end(),s)!=v.end();
-}
-
-bool MEDFileFieldGlobs::existsLoc(const std::string& locName) const
-{
-  std::vector<std::string> v=getLocs();
-  std::string s(locName);
-  return std::find(v.begin(),v.end(),s)!=v.end();
-}
-
-std::vector< std::vector<int> > MEDFileFieldGlobs::whichAreEqualProfiles() const
-{
-  std::map<int,std::vector<int> > m;
-  int i=0;
-  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++,i++)
-    {
-      const DataArrayInt *tmp=(*it);
-      if(tmp)
-        {
-          m[tmp->getHashCode()].push_back(i);
-        }
-    }
-  std::vector< std::vector<int> > ret;
-  for(std::map<int,std::vector<int> >::const_iterator it2=m.begin();it2!=m.end();it2++)
-    {
-      if((*it2).second.size()>1)
-        {
-          std::vector<int> ret0;
-          bool equalityOrNot=false;
-          for(std::vector<int>::const_iterator it3=(*it2).second.begin();it3!=(*it2).second.end();it3++)
-            {
-              std::vector<int>::const_iterator it4=it3; it4++;
-              for(;it4!=(*it2).second.end();it4++)
-                {
-                  if(_pfls[*it3]->isEqualWithoutConsideringStr(*_pfls[*it4]))
-                    {
-                      if(!equalityOrNot)
-                        ret0.push_back(*it3);
-                      ret0.push_back(*it4);
-                      equalityOrNot=true;
-                    }
-                }
-            }
-          if(!ret0.empty())
-            ret.push_back(ret0);
-        }
-    }
-  return ret;
-}
-
-std::vector< std::vector<int> > MEDFileFieldGlobs::whichAreEqualLocs(double eps) const
-{
-  throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::whichAreEqualLocs : no implemented yet ! Sorry !");
-}
-
-void MEDFileFieldGlobs::appendProfile(DataArrayInt *pfl)
-{
-  std::string name(pfl->getName());
-  if(name.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::appendProfile : unsupported profiles with no name !");
-  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++)
-    if(name==(*it)->getName())
-      {
-        if(!pfl->isEqual(*(*it)))
-          {
-            std::ostringstream oss; oss << "MEDFileFieldGlobs::appendProfile : profile \"" << name << "\" already exists and is different from existing !";
-            throw INTERP_KERNEL::Exception(oss.str());
-          }
-      }
-  pfl->incrRef();
-  _pfls.push_back(pfl);
-}
-
-void MEDFileFieldGlobs::appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w)
-{
-  std::string name(locName);
-  if(name.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::appendLoc : unsupported localizations with no name !");
-  MCAuto<MEDFileFieldLoc> obj=MEDFileFieldLoc::New(locName,geoType,refCoo,gsCoo,w);
-  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++)
-    if((*it)->isName(locName))
-      {
-        if(!(*it)->isEqual(*obj,1e-12))
-          {
-            std::ostringstream oss; oss << "MEDFileFieldGlobs::appendLoc : localization \"" << name << "\" already exists and is different from existing !";
-            throw INTERP_KERNEL::Exception(oss.str());
-          }
-      }
-  _locs.push_back(obj);
-}
-
-std::string MEDFileFieldGlobs::createNewNameOfPfl() const
-{
-  std::vector<std::string> names=getPfls();
-  return CreateNewNameNotIn("NewPfl_",names);
-}
-
-std::string MEDFileFieldGlobs::createNewNameOfLoc() const
-{
-  std::vector<std::string> names=getLocs();
-  return CreateNewNameNotIn("NewLoc_",names);
-}
-
-std::string MEDFileFieldGlobs::CreateNewNameNotIn(const std::string& prefix, const std::vector<std::string>& namesToAvoid)
-{
-  for(std::size_t sz=0;sz<100000;sz++)
-    {
-      std::ostringstream tryName;
-      tryName << prefix << sz;
-      if(std::find(namesToAvoid.begin(),namesToAvoid.end(),tryName.str())==namesToAvoid.end())
-        return tryName.str();
-    }
-  throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::CreateNewNameNotIn : impossible to create an additional profile limit of 100000 profiles reached !");
-}
-
-/*!
- * Creates a MEDFileFieldGlobsReal on a given file name. Nothing is read here.
- *  \param [in] fname - the file name.
- */
-MEDFileFieldGlobsReal::MEDFileFieldGlobsReal(med_idt fid):_globals(MEDFileFieldGlobs::New(fid))
-{
-}
-
-/*!
- * Creates an empty MEDFileFieldGlobsReal.
- */
-MEDFileFieldGlobsReal::MEDFileFieldGlobsReal():_globals(MEDFileFieldGlobs::New())
-{
-}
-
-std::size_t MEDFileFieldGlobsReal::getHeapMemorySizeWithoutChildren() const
-{
-  return 0;
-}
-
-std::vector<const BigMemoryObject *> MEDFileFieldGlobsReal::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret;
-  ret.push_back((const MEDFileFieldGlobs *)_globals);
-  return ret;
-}
-
-/*!
- * Returns a string describing profiles and Gauss points held in \a this.
- *  \return std::string - the description string.
- */
-void MEDFileFieldGlobsReal::simpleReprGlobs(std::ostream& oss) const
-{
-  const MEDFileFieldGlobs *glob=_globals;
-  std::ostringstream oss2; oss2 << glob;
-  std::string stars(oss2.str().length(),'*');
-  oss << "Globals information on fields (at " << oss2.str() << "):" << "\n************************************" << stars  << "\n\n";
-  if(glob)
-    glob->simpleRepr(oss);
-  else
-    oss << "NO GLOBAL INFORMATION !\n";
-}
-
-void MEDFileFieldGlobsReal::resetContent()
-{
-  _globals=MEDFileFieldGlobs::New();
-}
-
-void MEDFileFieldGlobsReal::killStructureElementsInGlobs()
-{
-  contentNotNull()->killStructureElementsInGlobs();
-}
-
-MEDFileFieldGlobsReal::~MEDFileFieldGlobsReal()
-{
-}
-
-/*!
- * Copies references to profiles and Gauss points from another MEDFileFieldGlobsReal.
- *  \param [in] other - the other MEDFileFieldGlobsReal to copy data from.
- */
-void MEDFileFieldGlobsReal::shallowCpyGlobs(const MEDFileFieldGlobsReal& other)
-{
-  _globals=other._globals;
-}
-
-/*!
- * Copies references to ** only used ** by \a this, profiles and Gauss points from another MEDFileFieldGlobsReal.
- *  \param [in] other - the other MEDFileFieldGlobsReal to copy data from.
- */
-void MEDFileFieldGlobsReal::shallowCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other)
-{
-  const MEDFileFieldGlobs *otherg(other._globals);
-  if(!otherg)
-    return ;
-  _globals=otherg->shallowCpyPart(getPflsReallyUsed(),getLocsReallyUsed());
-}
-
-/*!
- * Copies deeply to ** only used ** by \a this, profiles and Gauss points from another MEDFileFieldGlobsReal.
- *  \param [in] other - the other MEDFileFieldGlobsReal to copy data from.
- */
-void MEDFileFieldGlobsReal::deepCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other)
-{
-  const MEDFileFieldGlobs *otherg(other._globals);
-  if(!otherg)
-    return ;
-  _globals=otherg->deepCpyPart(getPflsReallyUsed(),getLocsReallyUsed());
-}
-
-void MEDFileFieldGlobsReal::deepCpyGlobs(const MEDFileFieldGlobsReal& other)
-{
-  _globals=other._globals;
-  if((const MEDFileFieldGlobs *)_globals)
-    _globals=other._globals->deepCopy();
-}
-
-/*!
- * Adds profiles and Gauss points held by another MEDFileFieldGlobsReal to \a this one.
- *  \param [in] other - the MEDFileFieldGlobsReal to copy data from.
- *  \param [in] eps - a precision used to compare Gauss points with same name held by
- *         \a this and \a other MEDFileFieldGlobsReal.
- *  \throw If \a this and \a other hold profiles with equal names but different ids.
- *  \throw If  \a this and \a other hold different Gauss points with equal names.
- */
-void MEDFileFieldGlobsReal::appendGlobs(const MEDFileFieldGlobsReal& other, double eps)
-{
-  const MEDFileFieldGlobs *thisGlobals(_globals),*otherGlobals(other._globals);
-  if(thisGlobals==otherGlobals)
-    return ;
-  if(!thisGlobals)
-    {
-      _globals=other._globals;
-      return ;
-    }
-  _globals->appendGlobs(*other._globals,eps);
-}
-
-void MEDFileFieldGlobsReal::checkGlobsCoherency() const
-{
-  checkGlobsPflsPartCoherency();
-  checkGlobsLocsPartCoherency();
-}
-
-void MEDFileFieldGlobsReal::checkGlobsPflsPartCoherency() const
-{
-  contentNotNull()->checkGlobsPflsPartCoherency(getPflsReallyUsed());
-}
-
-void MEDFileFieldGlobsReal::checkGlobsLocsPartCoherency() const
-{
-  contentNotNull()->checkGlobsLocsPartCoherency(getLocsReallyUsed());
-}
-
-void MEDFileFieldGlobsReal::loadProfileInFile(med_idt fid, int id, const std::string& pflName)
-{
-  contentNotNull()->loadProfileInFile(fid,id,pflName);
-}
-
-void MEDFileFieldGlobsReal::loadProfileInFile(med_idt fid, int id)
-{
-  contentNotNull()->loadProfileInFile(fid,id);
-}
-
-void MEDFileFieldGlobsReal::loadGlobals(med_idt fid)
-{
-  contentNotNull()->loadGlobals(fid,*this);
-}
-
-void MEDFileFieldGlobsReal::loadAllGlobals(med_idt fid, const MEDFileEntities *entities)
-{
-  contentNotNull()->loadAllGlobals(fid,entities);
-}
-
-void MEDFileFieldGlobsReal::writeGlobals(med_idt fid, const MEDFileWritable& opt) const
-{
-  contentNotNull()->writeGlobals(fid,opt);
-}
-
-/*!
- * Returns names of all profiles. To get only used profiles call getPflsReallyUsed()
- * or getPflsReallyUsedMulti().
- *  \return std::vector<std::string> - a sequence of names of all profiles.
- */
-std::vector<std::string> MEDFileFieldGlobsReal::getPfls() const
-{
-  return contentNotNull()->getPfls();
-}
-
-/*!
- * Returns names of all localizations. To get only used localizations call getLocsReallyUsed()
- * or getLocsReallyUsedMulti().
- *  \return std::vector<std::string> - a sequence of names of all localizations.
- */
-std::vector<std::string> MEDFileFieldGlobsReal::getLocs() const
-{
-  return contentNotNull()->getLocs();
-}
-
-/*!
- * Checks if the profile with a given name exists.
- *  \param [in] pflName - the profile name of interest.
- *  \return bool - \c true if the profile named \a pflName exists.
- */
-bool MEDFileFieldGlobsReal::existsPfl(const std::string& pflName) const
-{
-  return contentNotNull()->existsPfl(pflName);
-}
-
-/*!
- * Checks if the localization with a given name exists.
- *  \param [in] locName - the localization name of interest.
- *  \return bool - \c true if the localization named \a locName exists.
- */
-bool MEDFileFieldGlobsReal::existsLoc(const std::string& locName) const
-{
-  return contentNotNull()->existsLoc(locName);
-}
-
-std::string MEDFileFieldGlobsReal::createNewNameOfPfl() const
-{
-  return contentNotNull()->createNewNameOfPfl();
-}
-
-std::string MEDFileFieldGlobsReal::createNewNameOfLoc() const
-{
-  return contentNotNull()->createNewNameOfLoc();
-}
-
-/*!
- * Sets the name of a MED file.
- *  \param [inout] fileName - the file name.
- */
-void MEDFileFieldGlobsReal::setFileName(const std::string& fileName)
-{
-  contentNotNull()->setFileName(fileName);
-}
-
-/*!
- * Finds equal profiles. Two profiles are considered equal if they contain the same ids
- * in the same order.
- *  \return std::vector< std::vector<int> > - a sequence of groups of equal profiles.
- *          Each item of this sequence is a vector containing ids of equal profiles.
- */
-std::vector< std::vector<int> > MEDFileFieldGlobsReal::whichAreEqualProfiles() const
-{
-  return contentNotNull()->whichAreEqualProfiles();
-}
-
-/*!
- * Finds equal localizations.
- *  \param [in] eps - a precision used to compare real values of the localizations.
- *  \return std::vector< std::vector<int> > - a sequence of groups of equal localizations.
- *          Each item of this sequence is a vector containing ids of equal localizations.
- */
-std::vector< std::vector<int> > MEDFileFieldGlobsReal::whichAreEqualLocs(double eps) const
-{
-  return contentNotNull()->whichAreEqualLocs(eps);
-}
-
-/*!
- * Renames the profiles. References to profiles (a reference is a profile name) are not changed.
- * \param [in] mapOfModif - a sequence describing required renaming. Each element of
- *        this sequence is a pair whose 
- *        - the first item is a vector of profile names to replace by the second item,
- *        - the second item is a profile name to replace every profile name of the first item.
- */
-void MEDFileFieldGlobsReal::changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  contentNotNull()->changePflsNamesInStruct(mapOfModif);
-}
-
-/*!
- * Renames the localizations. References to localizations (a reference is a localization name) are not changed.
- * \param [in] mapOfModif - a sequence describing required renaming. Each element of
- *        this sequence is a pair whose 
- *        - the first item is a vector of localization names to replace by the second item,
- *        - the second item is a localization name to replace every localization name of the first item.
- */
-void MEDFileFieldGlobsReal::changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  contentNotNull()->changeLocsNamesInStruct(mapOfModif);
-}
-
-/*!
- * Replaces references to some profiles (a reference is a profile name) by references
- * to other profiles and, contrary to changePflsRefsNamesGen(), renames the profiles
- * them-selves accordingly. <br>
- * This method is a generalization of changePflName().
- * \param [in] mapOfModif - a sequence describing required replacements. Each element of
- *        this sequence is a pair whose 
- *        - the first item is a vector of profile names to replace by the second item,
- *        - the second item is a profile name to replace every profile of the first item.
- * \sa changePflsRefsNamesGen()
- * \sa changePflName()
- */
-void MEDFileFieldGlobsReal::changePflsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  changePflsRefsNamesGen(mapOfModif);
-  changePflsNamesInStruct(mapOfModif);
-}
-
-/*!
- * Replaces references to some localizations (a reference is a localization name) by references
- * to other localizations and, contrary to changeLocsRefsNamesGen(), renames the localizations
- * them-selves accordingly. <br>
- * This method is a generalization of changeLocName().
- * \param [in] mapOfModif - a sequence describing required replacements. Each element of
- *        this sequence is a pair whose 
- *        - the first item is a vector of localization names to replace by the second item,
- *        - the second item is a localization name to replace every localization of the first item.
- * \sa changeLocsRefsNamesGen()
- * \sa changeLocName()
- */
-void MEDFileFieldGlobsReal::changeLocsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  changeLocsRefsNamesGen(mapOfModif);
-  changeLocsNamesInStruct(mapOfModif);
-}
-
-/*!
- * Renames the profile having a given name and updates references to this profile.
- *  \param [in] oldName - the name of the profile to rename.
- *  \param [in] newName - a new name of the profile.
- * \sa changePflsNames().
- */
-void MEDFileFieldGlobsReal::changePflName(const std::string& oldName, const std::string& newName)
-{
-  std::vector< std::pair<std::vector<std::string>, std::string > > mapOfModif(1);
-  std::pair<std::vector<std::string>, std::string > p(std::vector<std::string>(1,std::string(oldName)),std::string(newName));
-  mapOfModif[0]=p;
-  changePflsNames(mapOfModif);
-}
-
-/*!
- * Renames the localization having a given name and updates references to this localization.
- *  \param [in] oldName - the name of the localization to rename.
- *  \param [in] newName - a new name of the localization.
- * \sa changeLocsNames().
- */
-void MEDFileFieldGlobsReal::changeLocName(const std::string& oldName, const std::string& newName)
-{
-  std::vector< std::pair<std::vector<std::string>, std::string > > mapOfModif(1);
-  std::pair<std::vector<std::string>, std::string > p(std::vector<std::string>(1,std::string(oldName)),std::string(newName));
-  mapOfModif[0]=p;
-  changeLocsNames(mapOfModif);
-}
-
-/*!
- * Removes duplicated profiles. Returns a map used to update references to removed 
- * profiles via changePflsRefsNamesGen().
- * Equal profiles are found using whichAreEqualProfiles().
- *  \return std::vector< std::pair<std::vector<std::string>, std::string > > - 
- *          a sequence describing the performed replacements of profiles. Each element of
- *          this sequence is a pair whose
- *          - the first item is a vector of profile names replaced by the second item,
- *          - the second item is a profile name replacing every profile of the first item.
- */
-std::vector< std::pair<std::vector<std::string>, std::string > > MEDFileFieldGlobsReal::zipPflsNames()
-{
-  std::vector< std::vector<int> > pseudoRet=whichAreEqualProfiles();
-  std::vector< std::pair<std::vector<std::string>, std::string > > ret(pseudoRet.size());
-  int i=0;
-  for(std::vector< std::vector<int> >::const_iterator it=pseudoRet.begin();it!=pseudoRet.end();it++,i++)
-    {
-      std::vector< std::string > tmp((*it).size());
-      int j=0;
-      for(std::vector<int>::const_iterator it2=(*it).begin();it2!=(*it).end();it2++,j++)
-        tmp[j]=std::string(getProfileFromId(*it2)->getName());
-      std::pair<std::vector<std::string>, std::string > p(tmp,tmp.front());
-      ret[i]=p;
-      std::vector<int> tmp2((*it).begin()+1,(*it).end());
-      killProfileIds(tmp2);
-    }
-  changePflsRefsNamesGen(ret);
-  return ret;
-}
-
-/*!
- * Removes duplicated localizations. Returns a map used to update references to removed 
- * localizations via changeLocsRefsNamesGen().
- * Equal localizations are found using whichAreEqualLocs().
- *  \param [in] eps - a precision used to compare real values of the localizations.
- *  \return std::vector< std::pair<std::vector<std::string>, std::string > > - 
- *          a sequence describing the performed replacements of localizations. Each element of
- *          this sequence is a pair whose
- *          - the first item is a vector of localization names replaced by the second item,
- *          - the second item is a localization name replacing every localization of the first item.
- */
-std::vector< std::pair<std::vector<std::string>, std::string > > MEDFileFieldGlobsReal::zipLocsNames(double eps)
-{
-  std::vector< std::vector<int> > pseudoRet=whichAreEqualLocs(eps);
-  std::vector< std::pair<std::vector<std::string>, std::string > > ret(pseudoRet.size());
-  int i=0;
-  for(std::vector< std::vector<int> >::const_iterator it=pseudoRet.begin();it!=pseudoRet.end();it++,i++)
-    {
-      std::vector< std::string > tmp((*it).size());
-      int j=0;
-      for(std::vector<int>::const_iterator it2=(*it).begin();it2!=(*it).end();it2++,j++)
-        tmp[j]=std::string(getLocalizationFromId(*it2).getName());
-      std::pair<std::vector<std::string>, std::string > p(tmp,tmp.front());
-      ret[i]=p;
-      std::vector<int> tmp2((*it).begin()+1,(*it).end());
-      killLocalizationIds(tmp2);
-    }
-  changeLocsRefsNamesGen(ret);
-  return ret;
-}
-
-/*!
- * Returns number of Gauss points per cell in a given localization.
- *  \param [in] locId - an id of the localization of interest.
- *  \return int - the number of the Gauss points per cell.
- */
-int MEDFileFieldGlobsReal::getNbOfGaussPtPerCell(int locId) const
-{
-  return contentNotNull()->getNbOfGaussPtPerCell(locId);
-}
-
-/*!
- * Returns an id of a localization by its name.
- *  \param [in] loc - the localization name of interest.
- *  \return int - the id of the localization.
- *  \throw If there is no a localization named \a loc.
- */
-int MEDFileFieldGlobsReal::getLocalizationId(const std::string& loc) const
-{
-  return contentNotNull()->getLocalizationId(loc);
-}
-
-/*!
- * Returns the name of the MED file.
- *  \return const std::string&  - the MED file name.
- */
-std::string MEDFileFieldGlobsReal::getFileName() const
-{
-  return contentNotNull()->getFileName();
-}
-
-/*!
- * Returns a localization object by its name.
- *  \param [in] locName - the name of the localization of interest.
- *  \return const MEDFileFieldLoc& - the localization object having the name \a locName.
- *  \throw If there is no a localization named \a locName.
- */
-const MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalization(const std::string& locName) const
-{
-  return contentNotNull()->getLocalization(locName);
-}
-
-/*!
- * Returns a localization object by its id.
- *  \param [in] locId - the id of the localization of interest.
- *  \return const MEDFileFieldLoc& - the localization object having the id \a locId.
- *  \throw If there is no a localization with id \a locId.
- */
-const MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalizationFromId(int locId) const
-{
-  return contentNotNull()->getLocalizationFromId(locId);
-}
-
-/*!
- * Returns a profile array by its name.
- *  \param [in] pflName - the name of the profile of interest.
- *  \return const DataArrayInt * - the profile array having the name \a pflName.
- *  \throw If there is no a profile named \a pflName.
- */
-const DataArrayInt *MEDFileFieldGlobsReal::getProfile(const std::string& pflName) const
-{
-  return contentNotNull()->getProfile(pflName);
-}
-
-/*!
- * Returns a profile array by its id.
- *  \param [in] pflId - the id of the profile of interest.
- *  \return const DataArrayInt * - the profile array having the id \a pflId.
- *  \throw If there is no a profile with id \a pflId.
- */
-const DataArrayInt *MEDFileFieldGlobsReal::getProfileFromId(int pflId) const
-{
-  return contentNotNull()->getProfileFromId(pflId);
-}
-
-/*!
- * Returns a localization object, apt for modification, by its id.
- *  \param [in] locId - the id of the localization of interest.
- *  \return MEDFileFieldLoc& - a non-const reference to the localization object
- *          having the id \a locId.
- *  \throw If there is no a localization with id \a locId.
- */
-MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalizationFromId(int locId)
-{
-  return contentNotNull()->getLocalizationFromId(locId);
-}
-
-/*!
- * Returns a localization object, apt for modification, by its name.
- *  \param [in] locName - the name of the localization of interest.
- *  \return MEDFileFieldLoc& - a non-const reference to the localization object
- *          having the name \a locName.
- *  \throw If there is no a localization named \a locName.
- */
-MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalization(const std::string& locName)
-{
-  return contentNotNull()->getLocalization(locName);
-}
-
-/*!
- * Returns a profile array, apt for modification, by its name.
- *  \param [in] pflName - the name of the profile of interest.
- *  \return DataArrayInt * - a non-const pointer to the profile array having the name \a pflName.
- *  \throw If there is no a profile named \a pflName.
- */
-DataArrayInt *MEDFileFieldGlobsReal::getProfile(const std::string& pflName)
-{
-  return contentNotNull()->getProfile(pflName);
-}
-
-/*!
- * Returns a profile array, apt for modification, by its id.
- *  \param [in] pflId - the id of the profile of interest.
- *  \return DataArrayInt * - a non-const pointer to the profile array having the id \a pflId.
- *  \throw If there is no a profile with id \a pflId.
- */
-DataArrayInt *MEDFileFieldGlobsReal::getProfileFromId(int pflId)
-{
-  return contentNotNull()->getProfileFromId(pflId);
-}
-
-/*!
- * Removes profiles given by their ids. No data is updated to track this removal.
- *  \param [in] pflIds - a sequence of ids of the profiles to remove.
- */
-void MEDFileFieldGlobsReal::killProfileIds(const std::vector<int>& pflIds)
-{
-  contentNotNull()->killProfileIds(pflIds);
-}
-
-/*!
- * Removes localizations given by their ids. No data is updated to track this removal.
- *  \param [in] locIds - a sequence of ids of the localizations to remove.
- */
-void MEDFileFieldGlobsReal::killLocalizationIds(const std::vector<int>& locIds)
-{
-  contentNotNull()->killLocalizationIds(locIds);
-}
-
-/*!
- * Stores a profile array.
- *  \param [in] pfl - the profile array to store.
- *  \throw If the name of \a pfl is empty.
- *  \throw If a profile with the same name as that of \a pfl already exists but contains
- *         different ids.
- */
-void MEDFileFieldGlobsReal::appendProfile(DataArrayInt *pfl)
-{
-  contentNotNull()->appendProfile(pfl);
-}
-
-/*!
- * Adds a new localization of Gauss points.
- *  \param [in] locName - the name of the new localization.
- *  \param [in] geoType - a geometrical type of the reference cell.
- *  \param [in] refCoo - coordinates of points of the reference cell. Size of this vector
- *         must be \c nbOfNodesPerCell * \c dimOfType.
- *  \param [in] gsCoo - coordinates of Gauss points on the reference cell. Size of this vector
- *         must be  _wg_.size() * \c dimOfType.
- *  \param [in] w - the weights of Gauss points.
- *  \throw If \a locName is empty.
- *  \throw If a localization with the name \a locName already exists but is
- *         different form the new one.
- */
-void MEDFileFieldGlobsReal::appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w)
-{
-  contentNotNull()->appendLoc(locName,geoType,refCoo,gsCoo,w);
-}
-
-MEDFileFieldGlobs *MEDFileFieldGlobsReal::contentNotNull()
-{
-  MEDFileFieldGlobs *g(_globals);
-  if(!g)
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobsReal::contentNotNull : no content in not const !");
-  return g;
-}
-
-const MEDFileFieldGlobs *MEDFileFieldGlobsReal::contentNotNull() const
-{
-  const MEDFileFieldGlobs *g(_globals);
-  if(!g)
-    throw INTERP_KERNEL::Exception("MEDFileFieldGlobsReal::contentNotNull : no content in const !");
-  return g;
-}
-
-//= MEDFileFieldNameScope
-
-MEDFileFieldNameScope::MEDFileFieldNameScope()
-{
-}
-
-MEDFileFieldNameScope::MEDFileFieldNameScope(const std::string& fieldName, const std::string& meshName):_name(fieldName),_mesh_name(meshName)
-{
-}
-
-/*!
- * Returns the name of \a this field.
- *  \return std::string - a string containing the field name.
- */
-std::string MEDFileFieldNameScope::getName() const
-{
-  return _name;
-}
-
-/*!
- * Sets name of \a this field
- *  \param [in] name - the new field name.
- */
-void MEDFileFieldNameScope::setName(const std::string& fieldName)
-{
-  _name=fieldName;
-}
-
-std::string MEDFileFieldNameScope::getDtUnit() const
-{
-  return _dt_unit;
-}
-
-void MEDFileFieldNameScope::setDtUnit(const std::string& dtUnit)
-{
-  _dt_unit=dtUnit;
-}
-
-void MEDFileFieldNameScope::copyNameScope(const MEDFileFieldNameScope& other)
-{
-  _name=other._name;
-  _mesh_name=other._mesh_name;
-  _dt_unit=other._dt_unit;
-}
-
-/*!
- * Returns the mesh name.
- *  \return std::string - a string holding the mesh name.
- *  \throw If \c _field_per_mesh.empty()
- */
-std::string MEDFileFieldNameScope::getMeshName() const
-{
-  return _mesh_name;
-}
-
-void MEDFileFieldNameScope::setMeshName(const std::string& meshName)
-{
-  _mesh_name=meshName;
-}
-
-//= MEDFileAnyTypeField1TSWithoutSDA
-
-void MEDFileAnyTypeField1TSWithoutSDA::deepCpyLeavesFrom(const MEDFileAnyTypeField1TSWithoutSDA& other)
-{
-  _field_per_mesh.resize(other._field_per_mesh.size());
-  std::size_t i=0;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=other._field_per_mesh.begin();it!=other._field_per_mesh.end();it++,i++)
-    {
-      if((const MEDFileFieldPerMesh *)*it)
-        _field_per_mesh[i]=(*it)->deepCopy(this);
-    }
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::accept(MEDFileFieldVisitor& visitor) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      {
-        visitor.newMeshEntry(*it);
-        (*it)->accept(visitor);
-        visitor.endMeshEntry(*it);
-      }
-}
-
-/*!
- * Prints a string describing \a this field into a stream. This string is outputted 
- * by \c print Python command.
- *  \param [in] bkOffset - number of white spaces printed at the beginning of each line.
- *  \param [in,out] oss - the out stream.
- *  \param [in] f1tsId - the field index within a MED file. If \a f1tsId < 0, the tiny
- *          info id printed, else, not.
- */
-void MEDFileAnyTypeField1TSWithoutSDA::simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const
-{
-  std::string startOfLine(bkOffset,' ');
-  oss << startOfLine << "Field ";
-  if(bkOffset==0)
-    oss << "[Type=" << getTypeStr() << "] with name \"" << getName() << "\" ";
-  oss << "on one time Step ";
-  if(f1tsId>=0)
-    oss << "(" << f1tsId << ") ";
-  oss << "on iteration=" << _iteration << " order=" << _order << "." << std::endl;
-  oss << startOfLine << "Time attached is : " << _dt << " [" << _dt_unit << "]." << std::endl;
-  const DataArray *arr=getUndergroundDataArray();
-  if(arr)
-    {
-      const std::vector<std::string> &comps=arr->getInfoOnComponents();
-      if(f1tsId<0)
-        {
-          oss << startOfLine << "Field has " << comps.size() << " components with the following infos :" << std::endl;
-          for(std::vector<std::string>::const_iterator it=comps.begin();it!=comps.end();it++)
-            oss << startOfLine << "  -  \"" << (*it) << "\"" << std::endl;
-        }
-      if(arr->isAllocated())
-        {
-          oss << startOfLine << "Whole field contains " << arr->getNumberOfTuples() << " tuples." << std::endl;
-        }
-      else
-        oss << startOfLine << "The array of the current field has not allocated yet !" << std::endl;
-    }
-  else
-    {
-      oss << startOfLine << "Field infos are empty ! Not defined yet !" << std::endl;
-    }
-  oss << startOfLine << "----------------------" << std::endl;
-  if(!_field_per_mesh.empty())
-    {
-      int i=0;
-      for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it2=_field_per_mesh.begin();it2!=_field_per_mesh.end();it2++,i++)
-        {
-          const MEDFileFieldPerMesh *cur=(*it2);
-          if(cur)
-            cur->simpleRepr(bkOffset,oss,i);
-          else
-            oss << startOfLine << "Field per mesh #" << i << " is not defined !" << std::endl;
-        }
-    }
-  else
-    {
-      oss << startOfLine << "Field is not defined on any meshes !" << std::endl;
-    }
-  oss << startOfLine << "----------------------" << std::endl;
-}
-
-std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > MEDFileAnyTypeField1TSWithoutSDA::splitComponents() const
-{
-  const DataArray *arr(getUndergroundDataArray());
-  if(!arr)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::splitComponents : no array defined !");
-  int nbOfCompo=arr->getNumberOfComponents();
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret(nbOfCompo);
-  for(int i=0;i<nbOfCompo;i++)
-    {
-      ret[i]=deepCopy();
-      std::vector<int> v(1,i);
-      MCAuto<DataArray> arr2=arr->keepSelectedComponents(v);
-      ret[i]->setArray(arr2);
-    }
-  return ret;
-}
-
-MEDFileAnyTypeField1TSWithoutSDA::MEDFileAnyTypeField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order):MEDFileFieldNameScope(fieldName,meshName),_iteration(iteration),_order(order),_csit(csit),_nb_of_tuples_to_be_allocated(-2)
-{
-}
-
-MEDFileAnyTypeField1TSWithoutSDA::MEDFileAnyTypeField1TSWithoutSDA():_iteration(-1),_order(-1),_dt(0.),_csit(-1),_nb_of_tuples_to_be_allocated(-1)
-{
-}
-
-/*!
- * Returns the maximal dimension of supporting elements. Returns -2 if \a this is
- * empty. Returns -1 if this in on nodes.
- *  \return int - the dimension of \a this.
- */
-int MEDFileAnyTypeField1TSWithoutSDA::getDimension() const
-{
-  int ret=-2;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    (*it)->getDimension(ret);
-  return ret;
-}
-
-bool MEDFileAnyTypeField1TSWithoutSDA::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
-{
-  bool ret=false;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      MEDFileFieldPerMesh *cur(*it);
-      if(cur)
-        ret=cur->changeMeshNames(modifTab) || ret;
-    }
-  return ret;
-}
-
-/*!
- * Returns the number of iteration of the state of underlying mesh.
- *  \return int - the iteration number.
- *  \throw If \c _field_per_mesh.empty()
- */
-int MEDFileAnyTypeField1TSWithoutSDA::getMeshIteration() const
-{
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::getMeshIteration : No field set !");
-  return _field_per_mesh[0]->getMeshIteration();
-}
-
-/*!
- * Returns the order number of iteration of the state of underlying mesh.
- *  \return int - the order number.
- *  \throw If \c _field_per_mesh.empty()
- */
-int MEDFileAnyTypeField1TSWithoutSDA::getMeshOrder() const
-{
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::getMeshOrder : No field set !");
-  return _field_per_mesh[0]->getMeshOrder();
-}
-
-/*!
- * Checks if \a this field is tagged by a given iteration number and a given
- * iteration order number.
- *  \param [in] iteration - the iteration number of interest.
- *  \param [in] order - the iteration order number of interest.
- *  \return bool - \c true if \a this->getIteration() == \a iteration && 
- *          \a this->getOrder() == \a order.
- */
-bool MEDFileAnyTypeField1TSWithoutSDA::isDealingTS(int iteration, int order) const
-{
-  return iteration==_iteration && order==_order;
-}
-
-/*!
- * Returns number of iteration and order number of iteration when
- * \a this field has been calculated.
- *  \return std::pair<int,int> - a pair of the iteration number and the iteration
- *          order number.
- */
-std::pair<int,int> MEDFileAnyTypeField1TSWithoutSDA::getDtIt() const
-{
-  std::pair<int,int> p;
-  fillIteration(p);
-  return p;
-}
-
-/*!
- * Returns number of iteration and order number of iteration when
- * \a this field has been calculated.
- *  \param [in,out] p - a pair returning the iteration number and the iteration
- *          order number.
- */
-void MEDFileAnyTypeField1TSWithoutSDA::fillIteration(std::pair<int,int>& p) const
-{
-  p.first=_iteration;
-  p.second=_order;
-}
-
-/*!
- * Returns all types of spatial discretization of \a this field.
- *  \param [in,out] types - a sequence of types of \a this field.
- */
-void MEDFileAnyTypeField1TSWithoutSDA::fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const
-{
-  std::set<TypeOfField> types2;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      (*it)->fillTypesOfFieldAvailable(types2);
-    }
-  std::back_insert_iterator< std::vector<TypeOfField> > bi(types);
-  std::copy(types2.begin(),types2.end(),bi);
-}
-
-/*!
- * Returns all types of spatial discretization of \a this field.
- *  \return std::vector<TypeOfField> - a sequence of types of spatial discretization
- *          of \a this field.
- */
-std::vector<TypeOfField> MEDFileAnyTypeField1TSWithoutSDA::getTypesOfFieldAvailable() const
-{
-  std::vector<TypeOfField> ret;
-  fillTypesOfFieldAvailable(ret);
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getPflsReallyUsed2() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getPflsReallyUsed();
-      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
-        if(ret2.find(*it2)==ret2.end())
-          {
-            ret.push_back(*it2);
-            ret2.insert(*it2);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getLocsReallyUsed2() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getLocsReallyUsed();
-      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
-        if(ret2.find(*it2)==ret2.end())
-          {
-            ret.push_back(*it2);
-            ret2.insert(*it2);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getPflsReallyUsedMulti2() const
-{
-  std::vector<std::string> ret;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getPflsReallyUsedMulti();
-      ret.insert(ret.end(),tmp.begin(),tmp.end());
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeField1TSWithoutSDA::getLocsReallyUsedMulti2() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getLocsReallyUsedMulti();
-      ret.insert(ret.end(),tmp.begin(),tmp.end());
-    }
-  return ret;
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    (*it)->changePflsRefsNamesGen(mapOfModif);
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    (*it)->changeLocsRefsNamesGen(mapOfModif);
-}
-
-/*!
- * Returns all attributes of parts of \a this field lying on a given mesh.
- * Each part differs from other ones by a type of supporting mesh entity. The _i_-th
- * item of every of returned sequences refers to the _i_-th part of \a this field.
- * Thus all sequences returned by this method are of the same length equal to number
- * of different types of supporting entities.<br>
- * A field part can include sub-parts with several different spatial discretizations,
- * \ref MEDCoupling::ON_CELLS "ON_CELLS" and \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT"
- * for example. Hence, some of the returned sequences contains nested sequences, and an item
- * of a nested sequence corresponds to a type of spatial discretization.<br>
- * This method allows for iteration over MEDFile DataStructure without any overhead.
- *  \param [in] mname - a name of a mesh of interest. It can be \c NULL, which is valid
- *          for the case with only one underlying mesh. (Actually, the number of meshes is
- *          not checked if \a mname == \c NULL).
- *  \param [in,out] types - a sequence of types of underlying mesh entities. A type per
- *          a field part is returned. 
- *  \param [in,out] typesF - a sequence of sequences of types of spatial discretizations.
- *          This sequence is of the same length as \a types. 
- *  \param [in,out] pfls - a sequence returning a profile name per each type of spatial
- *          discretization. A profile name can be empty.
- *          Length of this and of nested sequences is the same as that of \a typesF.
- *  \param [in,out] locs - a sequence returning a localization name per each type of spatial
- *          discretization. A localization name can be empty.
- *          Length of this and of nested sequences is the same as that of \a typesF.
- *  \return std::vector< std::vector< std::pair<int,int> > > - a sequence holding a range
- *          of ids of tuples within the data array, per each type of spatial
- *          discretization within one mesh entity type. 
- *          Length of this and of nested sequences is the same as that of \a typesF.
- *  \throw If no field is lying on \a mname.
- */
-std::vector< std::vector< std::pair<int,int> > > MEDFileAnyTypeField1TSWithoutSDA::getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldSplitedByType : This is empty !");
-  return _field_per_mesh[0]->getFieldSplitedByType(types,typesF,pfls,locs);
-}
-
-/*!
- * Returns dimensions of mesh elements \a this field lies on. The returned value is a
- * maximal absolute dimension and values returned via the out parameter \a levs are 
- * dimensions relative to the maximal absolute dimension. <br>
- * This method is designed for MEDFileField1TS instances that have a discretization
- * \ref MEDCoupling::ON_CELLS "ON_CELLS", 
- * \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT", 
- * \ref MEDCoupling::ON_GAUSS_NE "ON_GAUSS_NE".
- * Only these 3 discretizations will be taken into account here. If \a this is
- * \ref MEDCoupling::ON_NODES "ON_NODES", -1 is returned and \a levs are empty.<br>
- * This method is useful to make the link between the dimension of the underlying mesh
- * and the levels of \a this, because it is possible that the highest dimension of \a this
- * field is not equal to the dimension of the underlying mesh.
- * 
- * Let's consider the following case:
- * - mesh \a m1 has a meshDimension 3 and has non empty levels [0,-1,-2] with elements
- * TETRA4, HEXA8, TRI3 and SEG2.
- * - field \a f1 lies on \a m1 and is defined on 3D and 1D elements TETRA4 and SEG2.
- * - field \a f2 lies on \a m1 and is defined on 2D and 1D elements TRI3 and SEG2.
- *
- * In this case \a f1->getNonEmptyLevels() returns (3,[0,-2]) and \a
- * f2->getNonEmptyLevels() returns (2,[0,-1]). <br>
- * The returned values can be used for example to retrieve a MEDCouplingFieldDouble lying
- * on elements of a certain relative level by calling getFieldAtLevel(). \a meshDimRelToMax
- * parameter of getFieldAtLevel() is computed basing on the returned values as this:
- * <em> meshDimRelToMax = absDim - meshDim + relativeLev </em>.
- * For example<br>
- * to retrieve the highest level of
- * \a f1: <em>f1->getFieldAtLevel( ON_CELLS, 3-3+0 ); // absDim - meshDim + relativeLev</em><br> 
- * to retrieve the lowest level of \a f1: <em>f1->getFieldAtLevel( ON_CELLS, 3-3+(-2) );</em><br>
- * to retrieve the highest level of \a f2: <em>f2->getFieldAtLevel( ON_CELLS, 2-3+0 );</em><br>
- * to retrieve the lowest level of \a f2: <em>f2->getFieldAtLevel( ON_CELLS, 2-3+(-1) )</em>.
- *  \param [in] mname - a name of a mesh of interest. It can be \c NULL, which is valid
- *          for the case with only one underlying mesh. (Actually, the number of meshes is
- *          not checked if \a mname == \c NULL).
- *  \param [in,out] levs - a sequence returning the dimensions relative to the maximal
- *          absolute one. They are in decreasing order. This sequence is cleared before
- *          filling it in.
- *  \return int - the maximal absolute dimension of elements \a this fields lies on.
- *  \throw If no field is lying on \a mname.
- */
-int MEDFileAnyTypeField1TSWithoutSDA::getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const
-{
-  levs.clear();
-  std::vector<INTERP_KERNEL::NormalizedCellType> types;
-  std::vector< std::vector<TypeOfField> > typesF;
-  std::vector< std::vector<std::string> > pfls, locs;
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getNonEmptyLevels : This is empty !");
-  _field_per_mesh[0]->getFieldSplitedByType(types,typesF,pfls,locs);
-  if(types.empty())
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getNonEmptyLevels : 'this' is empty !");
-  std::set<INTERP_KERNEL::NormalizedCellType> st(types.begin(),types.end());
-  if(st.size()==1 && (*st.begin())==INTERP_KERNEL::NORM_ERROR)
-    return -1;
-  st.erase(INTERP_KERNEL::NORM_ERROR);
-  std::set<int> ret1;
-  for(std::set<INTERP_KERNEL::NormalizedCellType>::const_iterator it=st.begin();it!=st.end();it++)
-    {
-      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(*it);
-      ret1.insert((int)cm.getDimension());
-    }
-  int ret=*std::max_element(ret1.begin(),ret1.end());
-  std::copy(ret1.rbegin(),ret1.rend(),std::back_insert_iterator<std::vector<int> >(levs));
-  std::transform(levs.begin(),levs.end(),levs.begin(),std::bind2nd(std::plus<int>(),-ret));
-  return ret;
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::convertMedBallIntoClassic()
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it<_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      (*it)->convertMedBallIntoClassic();
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl)
-{
-  if(!pfl)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : null pfl !");
-  std::string name(pfl->getName());
-  pfl->checkAllocated();
-  if(pfl->getNumberOfComponents()!=1)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : non mono compo array !");
-  if(name.empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : empty pfl name !");
-  if(_field_per_mesh.size()!=1)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : only single mesh supported !");
-  MCAuto<MEDFileFieldPerMesh> fpm(_field_per_mesh[0]);
-  if(fpm.isNull())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : only single not null mesh supported !");
-  MEDFileFieldPerMeshPerTypePerDisc *disc(fpm->getLeafGivenTypeAndLocId(ct,0));
-  if(disc->getType()!=tof)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : error !");
-  int s(disc->getStart()),e(disc->getEnd()),nt(pfl->getNumberOfTuples());
-  DataArray *arr(getUndergroundDataArray());
-  int nt2(arr->getNumberOfTuples()),delta((e-s)-nt);
-  if(delta<0)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::makeReduction : internal error !");
-  MCAuto<DataArray> arr0(arr->selectByTupleIdSafeSlice(0,s,1)),arr1(arr->selectByTupleIdSafeSlice(s,e,1)),arr2(arr->selectByTupleIdSafeSlice(e,nt2,1));
-  MCAuto<DataArray> arr11(arr1->selectByTupleIdSafe(pfl->begin(),pfl->end()));
-  MCAuto<DataArray> arrOut(arr->buildNewEmptyInstance());
-  arrOut->alloc(nt2-delta,arr->getNumberOfComponents());
-  arrOut->copyStringInfoFrom(*arr);
-  arrOut->setContigPartOfSelectedValuesSlice(0,arr0,0,s,1);
-  arrOut->setContigPartOfSelectedValuesSlice(s,arr11,0,nt,1);
-  arrOut->setContigPartOfSelectedValuesSlice(e-delta,arr2,0,nt2-e,1);
-  setArray(arrOut);
-  disc->setEnd(e-delta);
-  disc->setProfile(name);
-}
-
-/*!
- * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
- * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
- * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
- *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
- */
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId)
-{
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId : This is empty !");
-  return _field_per_mesh[0]->getLeafGivenTypeAndLocId(typ,locId);
-}
-
-/*!
- * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
- * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
- * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
- *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
- */
-const MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const
-{
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getLeafGivenMeshAndTypeAndLocId : This is empty !");
-  return _field_per_mesh[0]->getLeafGivenTypeAndLocId(typ,locId);
-}
-
-/*!
- * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
- */
-int MEDFileAnyTypeField1TSWithoutSDA::getMeshIdFromMeshName(const std::string& mName) const
-{
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getMeshIdFromMeshName : No field set !");
-  if(mName.empty())
-    return 0;
-  std::string mName2(mName);
-  int ret=0;
-  std::vector<std::string> msg;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++,ret++)
-    if(mName2==(*it)->getMeshName())
-      return ret;
-    else
-      msg.push_back((*it)->getMeshName());
-  std::ostringstream oss; oss << "MEDFileField1TSWithoutSDA::getMeshIdFromMeshName : No such mesh \"" << mName2 << "\" as underlying mesh of field \"" << getName() << "\" !\n";
-  oss << "Possible meshes are : ";
-  for(std::vector<std::string>::const_iterator it2=msg.begin();it2!=msg.end();it2++)
-    oss << "\"" << (*it2) << "\" ";
-  throw INTERP_KERNEL::Exception(oss.str());
-}
-
-int MEDFileAnyTypeField1TSWithoutSDA::addNewEntryIfNecessary(const MEDCouplingMesh *mesh)
-{
-  if(!mesh)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::addNewEntryIfNecessary : input mesh is NULL !");
-  std::string tmp(mesh->getName());
-  if(tmp.empty())
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::addNewEntryIfNecessary : empty mesh name ! unsupported by MED file !");
-  setMeshName(tmp);
-  std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();
-  int i=0;
-  for(;it!=_field_per_mesh.end();it++,i++)
-    {
-      if((*it)->getMeshName()==tmp)
-        return i;
-    }
-  int sz=_field_per_mesh.size();
-  _field_per_mesh.resize(sz+1);
-  _field_per_mesh[sz]=MEDFileFieldPerMesh::New(this,mesh);
-  return sz;
-}
-
-bool MEDFileAnyTypeField1TSWithoutSDA::renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N,
-                                                                   MEDFileFieldGlobsReal& glob)
-{
-  bool ret=false;
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      MEDFileFieldPerMesh *fpm(*it);
-      if(fpm)
-        ret=fpm->renumberEntitiesLyingOnMesh(meshName,oldCode,newCode,renumO2N,glob) || ret;
-    }
-  return ret;
-}
-
-/*!
- * This method splits \a this into several sub-parts so that each sub parts have exactly one spatial discretization. This method implements the minimal
- * splitting that leads to single spatial discretization of this.
- *
- * \sa splitMultiDiscrPerGeoTypes
- */
-std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > MEDFileAnyTypeField1TSWithoutSDA::splitDiscretizations() const
-{
-  std::vector<INTERP_KERNEL::NormalizedCellType> types;
-  std::vector< std::vector<TypeOfField> > typesF;
-  std::vector< std::vector<std::string> > pfls,locs;
-  std::vector< std::vector<std::pair<int,int> > > bgEnd(getFieldSplitedByType(getMeshName().c_str(),types,typesF,pfls,locs));
-  std::set<TypeOfField> allEnt;
-  for(std::vector< std::vector<TypeOfField> >::const_iterator it1=typesF.begin();it1!=typesF.end();it1++)
-    for(std::vector<TypeOfField>::const_iterator it2=(*it1).begin();it2!=(*it1).end();it2++)
-      allEnt.insert(*it2);
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret(allEnt.size());
-  std::set<TypeOfField>::const_iterator it3(allEnt.begin());
-  for(std::size_t i=0;i<allEnt.size();i++,it3++)
-    {
-      std::vector< std::pair<int,int> > its;
-      ret[i]=shallowCpy();
-      int newLgth(ret[i]->keepOnlySpatialDiscretization(*it3,its));
-      ret[i]->updateData(newLgth,its);
-    }
-  return ret;
-}
-
-/*!
- * This method performs a sub splitting as splitDiscretizations does but finer. This is the finest spliting level that can be done.
- * This method implements the minimal splitting so that each returned elements are mono Gauss discretization per geometric type.
- *
- * \sa splitDiscretizations
- */
-std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > MEDFileAnyTypeField1TSWithoutSDA::splitMultiDiscrPerGeoTypes() const
-{
-  std::vector<INTERP_KERNEL::NormalizedCellType> types;
-  std::vector< std::vector<TypeOfField> > typesF;
-  std::vector< std::vector<std::string> > pfls,locs;
-  std::vector< std::vector<std::pair<int,int> > > bgEnd(getFieldSplitedByType(getMeshName().c_str(),types,typesF,pfls,locs));
-  std::set<TypeOfField> allEnt;
-  std::size_t nbOfMDPGT(0),ii(0);
-  for(std::vector< std::vector<TypeOfField> >::const_iterator it1=typesF.begin();it1!=typesF.end();it1++,ii++)
-    {
-      nbOfMDPGT=std::max(nbOfMDPGT,locs[ii].size());
-      for(std::vector<TypeOfField>::const_iterator it2=(*it1).begin();it2!=(*it1).end();it2++)
-        allEnt.insert(*it2);
-    }
-  if(allEnt.size()!=1)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::splitMultiDiscrPerGeoTypes : this field is expected to be defined only on one spatial discretization !");
-  if(nbOfMDPGT==0)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::splitMultiDiscrPerGeoTypes : empty field !");
-  if(nbOfMDPGT==1)
-    {
-      std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret0(1);
-      ret0[0]=const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(this); this->incrRef();
-      return ret0;
-    }
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret(nbOfMDPGT);
-  for(std::size_t i=0;i<nbOfMDPGT;i++)
-    {
-      std::vector< std::pair<int,int> > its;
-      ret[i]=shallowCpy();
-      int newLgth(ret[i]->keepOnlyGaussDiscretization(i,its));
-      ret[i]->updateData(newLgth,its);
-    }
-  return ret;
-}
-
-int MEDFileAnyTypeField1TSWithoutSDA::keepOnlySpatialDiscretization(TypeOfField tof, std::vector< std::pair<int,int> >& its)
-{
-  int globalCounter(0);
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    (*it)->keepOnlySpatialDiscretization(tof,globalCounter,its);
-  return globalCounter;
-}
-
-int MEDFileAnyTypeField1TSWithoutSDA::keepOnlyGaussDiscretization(std::size_t idOfDisc, std::vector< std::pair<int,int> >& its)
-{
-  int globalCounter(0);
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    (*it)->keepOnlyGaussDiscretization(idOfDisc,globalCounter,its);
-  return globalCounter;
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::updateData(int newLgth, const std::vector< std::pair<int,int> >& oldStartStops)
-{
-  if(_nb_of_tuples_to_be_allocated>=0)
-    {
-      _nb_of_tuples_to_be_allocated=newLgth;
-      const DataArray *oldArr(getUndergroundDataArray());
-      if(oldArr)
-        {
-          MCAuto<DataArray> newArr(createNewEmptyDataArrayInstance());
-          newArr->setInfoAndChangeNbOfCompo(oldArr->getInfoOnComponents());
-          setArray(newArr);
-          _nb_of_tuples_to_be_allocated=newLgth;//force the _nb_of_tuples_to_be_allocated because setArray has been used specialy
-        }
-      return ;
-    }
-  if(_nb_of_tuples_to_be_allocated==-1)
-    return ;
-  if(_nb_of_tuples_to_be_allocated==-2 || _nb_of_tuples_to_be_allocated==-3)
-    {
-      const DataArray *oldArr(getUndergroundDataArray());
-      if(!oldArr || !oldArr->isAllocated())
-        throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::updateData : internal error 1 !");
-      MCAuto<DataArray> newArr(createNewEmptyDataArrayInstance());
-      newArr->alloc(newLgth,getNumberOfComponents());
-      if(oldArr)
-        newArr->copyStringInfoFrom(*oldArr);
-      int pos=0;
-      for(std::vector< std::pair<int,int> >::const_iterator it=oldStartStops.begin();it!=oldStartStops.end();it++)
-        {
-          if((*it).second<(*it).first)
-            throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::updateData : the range in the leaves was invalid !");
-          newArr->setContigPartOfSelectedValuesSlice(pos,oldArr,(*it).first,(*it).second,1);
-          pos+=(*it).second-(*it).first;
-        }
-      setArray(newArr);
-      return ;
-    }
-  throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::updateData : internal error 2 !");
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::writeLL(med_idt fid, const MEDFileWritable& opts, const MEDFileFieldNameScope& nasc) const
-{
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::writeLL : empty field !");
-  if(_field_per_mesh.size()>1)
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::writeLL : In MED3.0 mode in writting mode only ONE underlying mesh supported !");
-  _field_per_mesh[0]->copyOptionsFrom(opts);
-  _field_per_mesh[0]->writeLL(fid,nasc);
-}
-
-/*!
- * This methods returns true is the allocation has been needed leading to a modification of state in \a this->_nb_of_tuples_to_be_allocated.
- * If false is returned the memory allocation is not required.
- */
-bool MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile()
-{
-  if(_nb_of_tuples_to_be_allocated>=0)
-    {
-      getOrCreateAndGetArray()->alloc(_nb_of_tuples_to_be_allocated,getNumberOfComponents());
-      _nb_of_tuples_to_be_allocated=-2;
-      return true;
-    }
-  if(_nb_of_tuples_to_be_allocated==-2 || _nb_of_tuples_to_be_allocated==-3)
-    return false;
-  if(_nb_of_tuples_to_be_allocated==-1)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile : trying to read from a file an empty instance ! Need to prepare the structure before !");
-  if(_nb_of_tuples_to_be_allocated<-3)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile : internal error !");
-  throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocIfNecessaryTheArrayToReceiveDataFromFile : internal error !");
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::loadOnlyStructureOfDataRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  med_int numdt,numit;
-  med_float dt;
-  med_int meshnumdt,meshnumit;
-  MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,nasc.getName().c_str(),_csit,&numdt,&numit,&_dt));
-  {
-    med_bool localMesh;
-    med_int nmesh;
-    INTERP_KERNEL::AutoPtr<char> meshName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-    MEDFILESAFECALLERRD0(MEDfield23ComputingStepMeshInfo,(fid,nasc.getName().c_str(),_csit,&numdt,&numit,&dt,&nmesh,meshName,&localMesh,&meshnumdt,&meshnumit)); // to check with Adrien for legacy MED files
-  }
-  //MEDFILESAFECALLERRD0(MEDfieldComputingStepMeshInfo,(fid,nasc.getName().c_str(),_csit,&numdt,&numit,&_dt,&meshnumdt,&meshnumit));
-  if(_iteration!=numdt || _order!=numit)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::loadBigArraysRecursively : unexpected exception internal error !");
-  _field_per_mesh.resize(1);
-  //
-  MEDFileMesh *mm(0);
-  if(ms)
-    {
-      mm=ms->getMeshWithName(getMeshName());
-    }
-  //
-  _field_per_mesh[0]=MEDFileFieldPerMesh::NewOnRead(fid,this,0,meshnumdt,meshnumit,nasc,mm,entities);
-  _nb_of_tuples_to_be_allocated=0;
-  _field_per_mesh[0]->loadOnlyStructureOfDataRecursively(fid,_nb_of_tuples_to_be_allocated,nasc);
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
-{
-  allocIfNecessaryTheArrayToReceiveDataFromFile();
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    (*it)->loadBigArraysRecursively(fid,nasc);
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc)
-{
-  if(allocIfNecessaryTheArrayToReceiveDataFromFile())
-    for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-      (*it)->loadBigArraysRecursively(fid,nasc);
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::loadStructureAndBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  loadOnlyStructureOfDataRecursively(fid,nasc,ms,entities);
-  loadBigArraysRecursively(fid,nasc);
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::unloadArrays()
-{
-  DataArray *thisArr(getUndergroundDataArray());
-  if(thisArr && thisArr->isAllocated())
-    {
-      _nb_of_tuples_to_be_allocated=thisArr->getNumberOfTuples();
-      thisArr->desallocate();
-    }
-}
-
-std::size_t MEDFileAnyTypeField1TSWithoutSDA::getHeapMemorySizeWithoutChildren() const
-{
-  return _mesh_name.capacity()+_dt_unit.capacity()+_field_per_mesh.capacity()*sizeof(MCAuto< MEDFileFieldPerMesh >);
-}
-
-std::vector<const BigMemoryObject *> MEDFileAnyTypeField1TSWithoutSDA::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret;
-  if(getUndergroundDataArray())
-    ret.push_back(getUndergroundDataArray());
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    ret.push_back((const MEDFileFieldPerMesh *)*it);
-  return ret;
-}
-
-/*!
- * Adds a MEDCouplingFieldDouble to \a this. The underlying mesh of the given field is
- * checked if its elements are sorted suitable for writing to MED file ("STB" stands for
- * "Sort By Type"), if not, an exception is thrown. 
- *  \param [in] field - the field to add to \a this. The array of field \a field is ignored
- *  \param [in] arr - the array of values.
- *  \param [in,out] glob - the global data where profiles and localization present in
- *          \a field, if any, are added.
- *  \throw If the name of \a field is empty.
- *  \throw If the data array of \a field is not set.
- *  \throw If \a this->_arr is already allocated but has different number of components
- *         than \a field.
- *  \throw If the underlying mesh of \a field has no name.
- *  \throw If elements in the mesh are not in the order suitable for writing to the MED file.
- */
-void MEDFileAnyTypeField1TSWithoutSDA::setFieldNoProfileSBT(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  const MEDCouplingMesh *mesh(field->getMesh());
-  //
-  TypeOfField type(field->getTypeOfField());
-  std::vector<DataArrayInt *> dummy;
-  if(mesh)
-    setMeshName(mesh->getName());
-  int start(copyTinyInfoFrom(th,field,arr));
-  int pos(addNewEntryIfNecessary(mesh));
-  if(type!=ON_NODES)
-    {
-      std::vector<int> code=MEDFileField1TSWithoutSDA::CheckSBTMesh(mesh);
-      _field_per_mesh[pos]->assignFieldNoProfileNoRenum(start,code,field,arr,glob,nasc);
-    }
-  else
-    _field_per_mesh[pos]->assignNodeFieldNoProfile(start,field,arr,glob);
-}
-
-/*!
- * Adds a MEDCouplingFieldDouble to \a this. Specified entities of a given dimension
- * of a given mesh are used as the support of the given field (a real support is not used). 
- * Elements of the given mesh must be sorted suitable for writing to MED file. 
- * Order of underlying mesh entities of the given field specified by \a profile parameter
- * is not prescribed; this method permutes field values to have them sorted by element
- * type as required for writing to MED file. A new profile is added only if no equal
- * profile is missing. 
- *  \param [in] field - the field to add to \a this. The field double values are ignored.
- *  \param [in] arrOfVals - the values of the field \a field used.
- *  \param [in] mesh - the supporting mesh of \a field.
- *  \param [in] meshDimRelToMax - a relative dimension of mesh entities \a field lies on.
- *  \param [in] profile - ids of mesh entities on which corresponding field values lie.
- *  \param [in,out] glob - the global data where profiles and localization present in
- *          \a field, if any, are added.
- *  \throw If either \a field or \a mesh or \a profile has an empty name.
- *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in \a mesh.
- *  \throw If the data array of \a field is not set.
- *  \throw If \a this->_arr is already allocated but has different number of components
- *         than \a field.
- *  \throw If elements in \a mesh are not in the order suitable for writing to the MED file.
- *  \sa setFieldNoProfileSBT()
- */
-void MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arrOfVals, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
-{
-  if(!field)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : input field is null !");
-  if(!arrOfVals || !arrOfVals->isAllocated())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : input array is null or not allocated !");
-  TypeOfField type=field->getTypeOfField();
-  std::vector<DataArrayInt *> idsInPflPerType;
-  std::vector<DataArrayInt *> idsPerType;
-  std::vector<int> code,code2;
-  MCAuto<MEDCouplingMesh> m(mesh->getMeshAtLevel(meshDimRelToMax));
-  if(type!=ON_NODES)
-    {
-      m->splitProfilePerType(profile,code,idsInPflPerType,idsPerType);
-      std::vector< MCAuto<DataArrayInt> > idsInPflPerType2(idsInPflPerType.size()); std::copy(idsInPflPerType.begin(),idsInPflPerType.end(),idsInPflPerType2.begin());
-      std::vector< MCAuto<DataArrayInt> > idsPerType2(idsPerType.size()); std::copy(idsPerType.begin(),idsPerType.end(),idsPerType2.begin()); 
-      std::vector<const DataArrayInt *> idsPerType3(idsPerType.size()); std::copy(idsPerType.begin(),idsPerType.end(),idsPerType3.begin());
-      // start of check
-      MCAuto<MEDCouplingFieldTemplate> field2=field->clone(false);
-      int nbOfTuplesExp=field2->getNumberOfTuplesExpectedRegardingCode(code,idsPerType3);
-      if(nbOfTuplesExp!=arrOfVals->getNumberOfTuples())
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : The array is expected to have " << nbOfTuplesExp << " tuples ! It has " << arrOfVals->getNumberOfTuples() << " !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      // end of check
-      int start(copyTinyInfoFrom(th,field,arrOfVals));
-      code2=m->getDistributionOfTypes();
-      //
-      int pos=addNewEntryIfNecessary(m);
-      _field_per_mesh[pos]->assignFieldProfile(start,profile,code,code2,idsInPflPerType,idsPerType,field,arrOfVals,m,glob,nasc);
-    }
-  else
-    {
-      if(!profile || !profile->isAllocated() || profile->getNumberOfComponents()!=1)
-        throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : input profile is null, not allocated or with number of components != 1 !");
-      std::vector<int> v(3); v[0]=-1; v[1]=profile->getNumberOfTuples(); v[2]=0;
-      std::vector<const DataArrayInt *> idsPerType3(1); idsPerType3[0]=profile;
-      int nbOfTuplesExp=field->getNumberOfTuplesExpectedRegardingCode(v,idsPerType3);
-      if(nbOfTuplesExp!=arrOfVals->getNumberOfTuples())
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeField1TSWithoutSDA::setFieldProfile : For node field, the array is expected to have " << nbOfTuplesExp << " tuples ! It has " << arrOfVals->getNumberOfTuples() << " !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      int start(copyTinyInfoFrom(th,field,arrOfVals));
-      int pos(addNewEntryIfNecessary(m));
-      _field_per_mesh[pos]->assignNodeFieldProfile(start,profile,field,arrOfVals,glob,nasc);
-    }
-}
-
-/*!
- * \param [in] newNbOfTuples - The new nb of tuples to be allocated.
- */
-void MEDFileAnyTypeField1TSWithoutSDA::allocNotFromFile(int newNbOfTuples)
-{
-  if(_nb_of_tuples_to_be_allocated>=0)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::allocNotFromFile : the object is expected to be appended to a data coming from a file but not loaded ! Load before appending data !");
-  DataArray *arr(getOrCreateAndGetArray());
-  arr->alloc(newNbOfTuples,arr->getNumberOfComponents());
-  _nb_of_tuples_to_be_allocated=-3;
-}
-
-/*!
- * Copies tiny info and allocates \a this->_arr instance of DataArrayDouble to
- * append data of a given MEDCouplingFieldDouble. So that the size of \a this->_arr becomes
- * larger by the size of \a field. Returns an id of the first not filled
- * tuple of \a this->_arr.
- *  \param [in] field - the field to copy the info on components and the name from.
- *  \return int - the id of first not initialized tuple of \a this->_arr.
- *  \throw If the name of \a field is empty.
- *  \throw If the data array of \a field is not set.
- *  \throw If \a this->_arr is already allocated but has different number of components
- *         than \a field.
- */
-int MEDFileAnyTypeField1TSWithoutSDA::copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr)
-{
-  if(!field)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::copyTinyInfoFrom : input field is NULL !");
-  std::string name(field->getName());
-  setName(name.c_str());
-  if(field->getMesh())
-    setMeshName(field->getMesh()->getName());
-  setDtUnit(th->getTimeUnit());
-  if(name.empty())
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::copyTinyInfoFrom : unsupported fields with no name in MED file !");
-  if(!arr)
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::copyTinyInfoFrom : no array set !");
-  if(!arr->isAllocated())
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::copyTinyInfoFrom : array is not allocated !");
-  _dt=th->getTime(_iteration,_order);
-  getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(arr->getInfoOnComponents());
-  if(!getOrCreateAndGetArray()->isAllocated())
-    {
-      allocNotFromFile(arr->getNumberOfTuples());
-      return 0;
-    }
-  else
-    {
-      int oldNbOfTuples=getOrCreateAndGetArray()->getNumberOfTuples();
-      int newNbOfTuples=oldNbOfTuples+arr->getNumberOfTuples();
-      getOrCreateAndGetArray()->reAlloc(newNbOfTuples);
-      _nb_of_tuples_to_be_allocated=-3;
-      return oldNbOfTuples;
-    }
-}
-
-/*!
- * Returns number of components in \a this field
- *  \return int - the number of components.
- */
-int MEDFileAnyTypeField1TSWithoutSDA::getNumberOfComponents() const
-{
-  return getOrCreateAndGetArray()->getNumberOfComponents();
-}
-
-/*!
- * Change info on components in \a this.
- * \throw If size of \a infos is not equal to the number of components already in \a this.
- */
-void MEDFileAnyTypeField1TSWithoutSDA::setInfo(const std::vector<std::string>& infos)
-{
-  DataArray *arr=getOrCreateAndGetArray();
-  arr->setInfoOnComponents(infos);//will throw an exception if number of components mimatches
-}
-
-/*!
- * Returns info on components of \a this field.
- *  \return const std::vector<std::string>& - a sequence of strings each being an
- *          information on _i_-th component.
- */
-const std::vector<std::string>& MEDFileAnyTypeField1TSWithoutSDA::getInfo() const
-{
-  const DataArray *arr=getOrCreateAndGetArray();
-  return arr->getInfoOnComponents();
-}
-
-/*!
- * Returns a mutable info on components of \a this field.
- *  \return std::vector<std::string>& - a sequence of strings each being an
- *          information on _i_-th component.
- */
-std::vector<std::string>& MEDFileAnyTypeField1TSWithoutSDA::getInfo()
-{
-  DataArray *arr=getOrCreateAndGetArray();
-  return arr->getInfoOnComponents();
-}
-
-bool MEDFileAnyTypeField1TSWithoutSDA::presenceOfMultiDiscPerGeoType() const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    {
-      const MEDFileFieldPerMesh *fpm(*it);
-      if(!fpm)
-        continue;
-      if(fpm->presenceOfMultiDiscPerGeoType())
-        return true;
-    }
-  return false;
-}
-
-bool MEDFileAnyTypeField1TSWithoutSDA::presenceOfStructureElements() const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      if((*it)->presenceOfStructureElements())
-        return true;
-  return false;
-}
-
-bool MEDFileAnyTypeField1TSWithoutSDA::onlyStructureElements() const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      if(!(*it)->onlyStructureElements())
-        return false;
-  return true;
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::killStructureElements()
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      (*it)->killStructureElements();
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::keepOnlyStructureElements()
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      (*it)->keepOnlyStructureElements();
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::keepOnlyOnSE(const std::string& seName)
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      (*it)->keepOnlyOnSE(seName);
-}
-
-void MEDFileAnyTypeField1TSWithoutSDA::getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const
-{
-  for(std::vector< MCAuto< MEDFileFieldPerMesh > >::const_iterator it=_field_per_mesh.begin();it!=_field_per_mesh.end();it++)
-    if((*it).isNotNull())
-      (*it)->getMeshSENames(ps);
-}
-
-MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh(const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  static const char MSG0[]="MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the field is too complex to be able to be extracted with  \"field\" method ! Call getFieldOnMeshAtLevel method instead to deal with complexity !";
-  if(_field_per_mesh.empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the field is empty ! Nothing to extract !");
-  if(_field_per_mesh.size()>1)
-    throw INTERP_KERNEL::Exception(MSG0);
-  if(_field_per_mesh[0].isNull())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the field is inconsistent !");
-  const MEDFileFieldPerMesh *pm(_field_per_mesh[0]);
-  std::set<TypeOfField> types;
-  pm->fillTypesOfFieldAvailable(types);
-  if(types.size()!=1)
-    throw INTERP_KERNEL::Exception(MSG0);
-  TypeOfField type(*types.begin());
-  int meshDimRelToMax(0);
-  if(type==ON_NODES)
-    meshDimRelToMax=0;
-  else
-    {
-      int myDim(std::numeric_limits<int>::max());
-      bool isUnique(pm->isUniqueLevel(myDim));
-      if(!isUnique)
-        throw INTERP_KERNEL::Exception(MSG0);
-      meshDimRelToMax=myDim-mesh->getMeshDimension();
-      if(meshDimRelToMax>0)
-        throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::fieldOnMesh : the mesh attached to field is not compatible with the field !");
-    }
-  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,meshDimRelToMax,0/*renumPol*/,glob,mesh,arrOut,nasc);
-}
-
-/*!
- * Returns a new MEDCouplingFieldDouble of given type lying on a given support.
- *  \param [in] type - a spatial discretization of the new field.
- *  \param [in] meshDimRelToMax - a relative dimension of the supporting mesh entities.
- *  \param [in] mName - a name of the supporting mesh.
- *  \param [in] renumPol - specifies how to permute values of the result field according to
- *          the optional numbers of cells and nodes, if any. The valid values are
- *          - 0 - do not permute.
- *          - 1 - permute cells.
- *          - 2 - permute nodes.
- *          - 3 - permute cells and nodes.
- *
- *  \param [in] glob - the global data storing profiles and localization.
- *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
- *          caller is to delete this field using decrRef() as it is no more needed. 
- *  \throw If the MED file is not readable.
- *  \throw If there is no mesh named \a mName in the MED file.
- *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in the mesh.
- *  \throw If no field of \a this is lying on the mesh \a mName.
- *  \throw If no field values of the given \a type or given \a meshDimRelToMax are available.
- */
-MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldAtLevel(TypeOfField type, int meshDimRelToMax, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  MCAuto<MEDFileMesh> mm;
-  if(mName.empty())
-    mm=MEDFileMesh::New(glob->getFileName(),getMeshName().c_str(),getMeshIteration(),getMeshOrder());
-  else
-    mm=MEDFileMesh::New(glob->getFileName(),mName,getMeshIteration(),getMeshOrder());
-  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,meshDimRelToMax,renumPol,glob,mm,arrOut,nasc);
-}
-
-/*!
- * Returns a new MEDCouplingFieldDouble of given type lying on a given support.
- *  \param [in] type - a spatial discretization of the new field.
- *  \param [in] meshDimRelToMax - a relative dimension of the supporting mesh entities.
- *  \param [in] renumPol - specifies how to permute values of the result field according to
- *          the optional numbers of cells and nodes, if any. The valid values are
- *          - 0 - do not permute.
- *          - 1 - permute cells.
- *          - 2 - permute nodes.
- *          - 3 - permute cells and nodes.
- *
- *  \param [in] glob - the global data storing profiles and localization.
- *  \param [in] mesh - the supporting mesh.
- *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
- *          caller is to delete this field using decrRef() as it is no more needed. 
- *  \throw If the MED file is not readable.
- *  \throw If no field of \a this is lying on \a mesh.
- *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in the mesh.
- *  \throw If no field values of the given \a type or given \a meshDimRelToMax are available.
- */
-MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  MCAuto<MEDCouplingMesh> m(mesh->getMeshAtLevel(meshDimRelToMax,false));
-  const DataArrayInt *d(mesh->getNumberFieldAtLevel(meshDimRelToMax)),*e(mesh->getNumberFieldAtLevel(1));
-  if(meshDimRelToMax==1)
-    (static_cast<MEDCouplingUMesh *>((MEDCouplingMesh *)m))->setMeshDimension(0);
-  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,renumPol,glob,m,d,e,arrOut,nasc);
-}
-
-/*!
- * Returns a new MEDCouplingFieldDouble of a given type lying on the top level cells of a
- * given mesh. 
- *  \param [in] type - a spatial discretization of the new field.
- *  \param [in] mName - a name of the supporting mesh.
- *  \param [in] renumPol - specifies how to permute values of the result field according to
- *          the optional numbers of cells and nodes, if any. The valid values are
- *          - 0 - do not permute.
- *          - 1 - permute cells.
- *          - 2 - permute nodes.
- *          - 3 - permute cells and nodes.
- *
- *  \param [in] glob - the global data storing profiles and localization.
- *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
- *          caller is to delete this field using decrRef() as it is no more needed. 
- *  \throw If the MED file is not readable.
- *  \throw If there is no mesh named \a mName in the MED file.
- *  \throw If there are no mesh entities in the mesh.
- *  \throw If no field values of the given \a type are available.
- */
-MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldAtTopLevel(TypeOfField type, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  MCAuto<MEDFileMesh> mm;
-  if(mName.empty())
-    mm=MEDFileMesh::New(glob->getFileName(),getMeshName().c_str(),getMeshIteration(),getMeshOrder());
-  else
-    mm=MEDFileMesh::New(glob->getFileName(),mName,getMeshIteration(),getMeshOrder());
-  int absDim=getDimension();
-  int meshDimRelToMax=absDim-mm->getMeshDimension();
-  return MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(type,meshDimRelToMax,renumPol,glob,mm,arrOut,nasc);
-}
-
-/*!
- * Returns a new MEDCouplingFieldDouble of given type lying on a given support.
- *  \param [in] type - a spatial discretization of the new field.
- *  \param [in] renumPol - specifies how to permute values of the result field according to
- *          the optional numbers of cells and nodes, if any. The valid values are
- *          - 0 - do not permute.
- *          - 1 - permute cells.
- *          - 2 - permute nodes.
- *          - 3 - permute cells and nodes.
- *
- *  \param [in] glob - the global data storing profiles and localization.
- *  \param [in] mesh - the supporting mesh.
- *  \param [in] cellRenum - the cell numbers array used for permutation of the result
- *         field according to \a renumPol.
- *  \param [in] nodeRenum - the node numbers array used for permutation of the result
- *         field according to \a renumPol.
- *  \return MEDCouplingFieldDouble * - a new instance of MEDCouplingFieldDouble. The
- *          caller is to delete this field using decrRef() as it is no more needed. 
- *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in the mesh.
- *  \throw If no field of \a this is lying on \a mesh.
- *  \throw If no field values of the given \a type or given \a meshDimRelToMax are available.
- */
-MEDCouplingFieldDouble *MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel(TypeOfField type, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, const DataArrayInt *cellRenum, const DataArrayInt *nodeRenum, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
-{
-  static const char msg1[]="MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : request for a renumbered field following mesh numbering whereas it is a profile field !";
-  bool isPfl=false;
-  MCAuto<MEDCouplingFieldDouble> ret=_field_per_mesh[0]->getFieldOnMeshAtLevel(type,glob,mesh,isPfl,arrOut,nasc);
-  switch(renumPol)
-  {
-    case 0:
-      {
-        //no need to test _field_per_mesh.empty() because geMeshName has already done it
-        return ret.retn();
-      }
-    case 3:
-    case 1:
-      {
-        if(isPfl)
-          throw INTERP_KERNEL::Exception(msg1);
-        //no need to test _field_per_mesh.empty() because geMeshName has already done it
-        if(cellRenum)
-          {
-            if((int)cellRenum->getNbOfElems()!=mesh->getNumberOfCells())
-              {
-                std::ostringstream oss; oss << "MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : Request of simple renumbering but it seems that underlying mesh \"" << mesh->getName() << "\" of requested field ";
-                oss << "\"" << getName() << "\" has partial renumbering (some geotype has no renumber) !";
-                throw INTERP_KERNEL::Exception(oss.str());
-              }
-            MEDCouplingFieldDiscretization *disc=ret->getDiscretization();
-            if(!disc) throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TSWithoutSDA::getFieldOnMeshAtLevel : internal error, no discretization on field !");
-            std::vector<DataArray *> arrOut2(1,arrOut);
-            // 2 following lines replace ret->renumberCells(cellRenum->getConstPointer()) if not DataArrayDouble
-            disc->renumberArraysForCell(ret->getMesh(),arrOut2,cellRenum->getConstPointer(),true);
-            (const_cast<MEDCouplingMesh*>(ret->getMesh()))->renumberCells(cellRenum->getConstPointer(),true);
-          }
-        if(renumPol==1)
-          return ret.retn();
-      }
-    case 2:
-      {
-        //no need to test _field_per_mesh.empty() because geMeshName has already done it
-        if(isPfl)
-          throw INTERP_KERNEL::Exception(msg1);
-        if(nodeRenum)
-          {
-            if((int)nodeRenum->getNbOfElems()!=mesh->getNumberOfNodes())
-              {
-                std::ostringstream oss; oss << "MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : Request of simple renumbering but it seems that underlying mesh \"" << mesh->getName() << "\" of requested field ";
-                oss << "\"" << nasc.getName() << "\" not defined on all nodes !";
-                throw INTERP_KERNEL::Exception(oss.str());
-              }
-            MCAuto<DataArrayInt> nodeRenumSafe=nodeRenum->checkAndPreparePermutation();
-            if(!dynamic_cast<DataArrayDouble *>((DataArray *)arrOut))
-              throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : node renumbering not implemented for not double DataArrays !");
-            ret->renumberNodes(nodeRenumSafe->getConstPointer());
-          }
-        return ret.retn();
-      }
-    default:
-      throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldOnMeshAtLevel : unsupported renum policy ! Dealing with policy 0 1 2 and 3 !");
-  }
-}
-
-/*!
- * Returns values and a profile of the field of a given type lying on a given support.
- *  \param [in] type - a spatial discretization of the field.
- *  \param [in] meshDimRelToMax - a relative dimension of the supporting mesh entities.
- *  \param [in] mesh - the supporting mesh.
- *  \param [out] pfl - a new instance of DataArrayInt holding ids of mesh entities the
- *          field of interest lies on. If the field lies on all entities of the given
- *          dimension, all ids in \a pfl are zero. The caller is to delete this array
- *          using decrRef() as it is no more needed.  
- *  \param [in] glob - the global data storing profiles and localization.
- *  \return DataArrayDouble * - a new instance of DataArrayDouble holding values of the
- *          field. The caller is to delete this array using decrRef() as it is no more needed.
- *  \throw If there are no mesh entities of \a meshDimRelToMax dimension in \a mesh.
- *  \throw If no field of \a this is lying on \a mesh.
- *  \throw If no field values of the given \a type are available.
- */
-DataArray *MEDFileAnyTypeField1TSWithoutSDA::getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const
-{
-  MCAuto<MEDCouplingMesh> m(mesh->getMeshAtLevel(meshDimRelToMax));
-  MCAuto<DataArray> ret=_field_per_mesh[0]->getFieldOnMeshAtLevelWithPfl(type,m,pfl,glob,nasc);
-  ret->setName(nasc.getName().c_str());
-  return ret.retn();
-}
-
-//= MEDFileField1TSWithoutSDA
-
-/*!
- * Throws if a given value is not a valid (non-extended) relative dimension.
- *  \param [in] meshDimRelToMax - the relative dimension value.
- *  \throw If \a meshDimRelToMax > 0.
- */
-void MEDFileField1TSWithoutSDA::CheckMeshDimRel(int meshDimRelToMax)
-{
-  if(meshDimRelToMax>0)
-    throw INTERP_KERNEL::Exception("CheckMeshDimRel : This is a meshDimRel not a meshDimRelExt ! So value should be <=0 !");
-}
-
-/*!
- * Checks if elements of a given mesh are in the order suitable for writing 
- * to the MED file. If this is not so, an exception is thrown. In a case of success, returns a
- * vector describing types of elements and their number.
- *  \param [in] mesh - the mesh to check.
- *  \return std::vector<int> - a vector holding for each element type (1) item of
- *          INTERP_KERNEL::NormalizedCellType, (2) number of elements, (3) -1. 
- *          These values are in full-interlace mode.
- *  \throw If elements in \a mesh are not in the order suitable for writing to the MED file.
- */
-std::vector<int> MEDFileField1TSWithoutSDA::CheckSBTMesh(const MEDCouplingMesh *mesh)
-{
-  if(!mesh)
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::CheckSBTMesh : input mesh is NULL !");
-  std::set<INTERP_KERNEL::NormalizedCellType> geoTypes=mesh->getAllGeoTypes();
-  int nbOfTypes=geoTypes.size();
-  std::vector<int> code(3*nbOfTypes);
-  MCAuto<DataArrayInt> arr1=DataArrayInt::New();
-  arr1->alloc(nbOfTypes,1);
-  int *arrPtr=arr1->getPointer();
-  std::set<INTERP_KERNEL::NormalizedCellType>::const_iterator it=geoTypes.begin();
-  for(int i=0;i<nbOfTypes;i++,it++)
-    arrPtr[i]=std::distance(typmai2,std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,*it));
-  MCAuto<DataArrayInt> arr2=arr1->checkAndPreparePermutation();
-  const int *arrPtr2=arr2->getConstPointer();
-  int i=0;
-  for(it=geoTypes.begin();it!=geoTypes.end();it++,i++)
-    {
-      int pos=arrPtr2[i];
-      int nbCells=mesh->getNumberOfCellsWithType(*it);
-      code[3*pos]=(int)(*it);
-      code[3*pos+1]=nbCells;
-      code[3*pos+2]=-1;//no profiles
-    }
-  std::vector<const DataArrayInt *> idsPerType;//no profiles
-  DataArrayInt *da=mesh->checkTypeConsistencyAndContig(code,idsPerType);
-  if(da)
-    {
-      da->decrRef();
-      throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::CheckSBTMesh : underlying mesh is not sorted by type as MED file expects !");
-    }
-  return code;
-}
-
-MEDFileField1TSWithoutSDA *MEDFileField1TSWithoutSDA::New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos)
-{
-  return new MEDFileField1TSWithoutSDA(fieldName,meshName,csit,iteration,order,infos);
-}
-
-/*!
- * Returns all attributes and values of parts of \a this field lying on a given mesh.
- * Each part differs from other ones by a type of supporting mesh entity. The _i_-th
- * item of every of returned sequences refers to the _i_-th part of \a this field.
- * Thus all sequences returned by this method are of the same length equal to number
- * of different types of supporting entities.<br>
- * A field part can include sub-parts with several different spatial discretizations,
- * \ref MEDCoupling::ON_CELLS "ON_CELLS" and \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT"
- * for example. Hence, some of the returned sequences contains nested sequences, and an item
- * of a nested sequence corresponds to a type of spatial discretization.<br>
- * This method allows for iteration over MEDFile DataStructure with a reduced overhead.
- * The overhead is due to selecting values into new instances of DataArrayDouble.
- *  \param [in] mname - a name of a mesh of interest. It can be \c NULL, which is valid
- *          for the case with only one underlying mesh. (Actually, the number of meshes is
- *          not checked if \a mname == \c NULL).
- *  \param [in,out] types - a sequence of types of underlying mesh entities. A type per
- *          a field part is returned. 
- *  \param [in,out] typesF - a sequence of sequences of types of spatial discretizations.
- *          A field part can include sub-parts with several different spatial discretizations,
- *          \ref MEDCoupling::ON_CELLS "ON_CELLS" and 
- *          \ref MEDCoupling::ON_GAUSS_PT "ON_GAUSS_PT" for example.
- *          This sequence is of the same length as \a types. 
- *  \param [in,out] pfls - a sequence returning a profile name per each type of spatial
- *          discretization. A profile name can be empty.
- *          Length of this and of nested sequences is the same as that of \a typesF.
- *  \param [in,out] locs - a sequence returning a localization name per each type of spatial
- *          discretization. A localization name can be empty.
- *          Length of this and of nested sequences is the same as that of \a typesF.
- *  \return std::vector< std::vector<DataArrayDouble *> > - a sequence holding arrays of values
- *          per each type of spatial discretization within one mesh entity type.
- *          The caller is to delete each DataArrayDouble using decrRef() as it is no more needed.
- *          Length of this and of nested sequences is the same as that of \a typesF.
- *  \throw If no field is lying on \a mname.
- */
-std::vector< std::vector<DataArrayDouble *> > MEDFileField1TSWithoutSDA::getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  if(mname.empty())
-    if(_field_per_mesh.empty())
-      throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getFieldSplitedByType : This is empty !");
-  std::vector< std::vector< std::pair<int,int> > > ret0=_field_per_mesh[0]->getFieldSplitedByType(types,typesF,pfls,locs);
-  int nbOfRet=ret0.size();
-  std::vector< std::vector<DataArrayDouble *> > ret(nbOfRet);
-  for(int i=0;i<nbOfRet;i++)
-    {
-      const std::vector< std::pair<int,int> >& p=ret0[i];
-      int nbOfRet1=p.size();
-      ret[i].resize(nbOfRet1);
-      for(int j=0;j<nbOfRet1;j++)
-        {
-          DataArrayDouble *tmp=_arr->selectByTupleIdSafeSlice(p[j].first,p[j].second,1);
-          ret[i][j]=tmp;
-        }
-    }
-  return ret;
-}
-
-const char *MEDFileField1TSWithoutSDA::getTypeStr() const
-{
-  return TYPE_STR;
-}
-
-MEDFileIntField1TSWithoutSDA *MEDFileField1TSWithoutSDA::convertToInt() const
-{
-  MCAuto<MEDFileIntField1TSWithoutSDA> ret(new MEDFileIntField1TSWithoutSDA);
-  ret->MEDFileAnyTypeField1TSWithoutSDA::operator =(*this);
-  ret->deepCpyLeavesFrom(*this);
-  const DataArrayDouble *arr(_arr);
-  if(arr)
-    {
-      MCAuto<DataArrayInt> arr2(arr->convertToIntArr());
-      ret->setArray(arr2);
-    }
-  return ret.retn();
-}
-
-/*!
- * Returns a pointer to the underground DataArrayDouble instance and a
- * sequence describing parameters of a support of each part of \a this field. The
- * caller should not decrRef() the returned DataArrayDouble. This method allows for a
- * direct access to the field values. This method is intended for the field lying on one
- * mesh only.
- *  \param [in,out] entries - the sequence describing parameters of a support of each
- *         part of \a this field. Each item of this sequence consists of two parts. The
- *         first part describes a type of mesh entity and an id of discretization of a
- *         current field part. The second part describes a range of values [begin,end)
- *         within the returned array relating to the current field part.
- *  \return DataArrayDouble * - the pointer to the field values array.
- *  \throw If the number of underlying meshes is not equal to 1.
- *  \throw If no field values are available.
- *  \sa getUndergroundDataArray()
- */
-DataArray *MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  return getUndergroundDataArrayTemplateExt(entries);
-}
-
-MEDFileField1TSWithoutSDA::MEDFileField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos):MEDFileField1TSTemplateWithoutSDA<double>(fieldName,meshName,csit,iteration,order)
-{
-  DataArrayDouble *arr(getOrCreateAndGetArrayTemplate());
-  arr->setInfoAndChangeNbOfCompo(infos);
-}
-
-MEDFileField1TSWithoutSDA::MEDFileField1TSWithoutSDA():MEDFileField1TSTemplateWithoutSDA<double>()
-{
-}
-
-MEDFileField1TSWithoutSDA *MEDFileField1TSWithoutSDA::shallowCpy() const
-{
-  MCAuto<MEDFileField1TSWithoutSDA> ret(new MEDFileField1TSWithoutSDA(*this));
-  ret->deepCpyLeavesFrom(*this);
-  return ret.retn();
-}
-
-MEDFileField1TSWithoutSDA *MEDFileField1TSWithoutSDA::deepCopy() const
-{
-  MCAuto<MEDFileField1TSWithoutSDA> ret(shallowCpy());
-  if(_arr.isNotNull())
-    ret->_arr=_arr->deepCopy();
-  return ret.retn();
-}
-
-//= MEDFileIntField1TSWithoutSDA
-
-MEDFileIntField1TSWithoutSDA *MEDFileIntField1TSWithoutSDA::New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos)
-{
-  return new MEDFileIntField1TSWithoutSDA(fieldName,meshName,csit,iteration,order,infos);
-}
-
-MEDFileIntField1TSWithoutSDA::MEDFileIntField1TSWithoutSDA()
-{
-}
-
-MEDFileIntField1TSWithoutSDA::MEDFileIntField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order,
-                                                           const std::vector<std::string>& infos):MEDFileField1TSNDTemplateWithoutSDA<int>(fieldName,meshName,csit,iteration,order,infos)
-{
-  DataArrayInt *arr(getOrCreateAndGetArrayTemplate());
-  arr->setInfoAndChangeNbOfCompo(infos);
-}
-
-const char *MEDFileIntField1TSWithoutSDA::getTypeStr() const
-{
-  return TYPE_STR;
-}
-
-/*!
- * Returns a pointer to the underground DataArrayInt instance and a
- * sequence describing parameters of a support of each part of \a this field. The
- * caller should not decrRef() the returned DataArrayInt. This method allows for a
- * direct access to the field values. This method is intended for the field lying on one
- * mesh only.
- *  \param [in,out] entries - the sequence describing parameters of a support of each
- *         part of \a this field. Each item of this sequence consists of two parts. The
- *         first part describes a type of mesh entity and an id of discretization of a
- *         current field part. The second part describes a range of values [begin,end)
- *         within the returned array relating to the current field part.
- *  \return DataArrayInt * - the pointer to the field values array.
- *  \throw If the number of underlying meshes is not equal to 1.
- *  \throw If no field values are available.
- *  \sa getUndergroundDataArray()
- */
-DataArray *MEDFileIntField1TSWithoutSDA::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  return getUndergroundDataArrayIntExt(entries);
-}
-
-/*!
- * Returns a pointer to the underground DataArrayInt instance and a
- * sequence describing parameters of a support of each part of \a this field. The
- * caller should not decrRef() the returned DataArrayInt. This method allows for a
- * direct access to the field values. This method is intended for the field lying on one
- * mesh only.
- *  \param [in,out] entries - the sequence describing parameters of a support of each
- *         part of \a this field. Each item of this sequence consists of two parts. The
- *         first part describes a type of mesh entity and an id of discretization of a
- *         current field part. The second part describes a range of values [begin,end)
- *         within the returned array relating to the current field part.
- *  \return DataArrayInt * - the pointer to the field values array.
- *  \throw If the number of underlying meshes is not equal to 1.
- *  \throw If no field values are available.
- *  \sa getUndergroundDataArray()
- */
-DataArrayInt *MEDFileIntField1TSWithoutSDA::getUndergroundDataArrayIntExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  if(_field_per_mesh.size()!=1)
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : field lies on several meshes, this method has no sense !");
-  if(_field_per_mesh[0]==0)
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : no field specified !");
-  _field_per_mesh[0]->getUndergroundDataArrayExt(entries);
-  return getUndergroundDataArrayTemplate();
-}
-
-MEDFileIntField1TSWithoutSDA *MEDFileIntField1TSWithoutSDA::shallowCpy() const
-{
-  MCAuto<MEDFileIntField1TSWithoutSDA> ret(new MEDFileIntField1TSWithoutSDA(*this));
-  ret->deepCpyLeavesFrom(*this);
-  return ret.retn();
-}
-
-MEDFileIntField1TSWithoutSDA *MEDFileIntField1TSWithoutSDA::deepCopy() const
-{
-  MCAuto<MEDFileIntField1TSWithoutSDA> ret(shallowCpy());
-  if(_arr.isNotNull())
-    ret->_arr=_arr->deepCopy();
-  return ret.retn();
-}
-
-//= MEDFileFloatField1TSWithoutSDA
-
-MEDFileFloatField1TSWithoutSDA *MEDFileFloatField1TSWithoutSDA::New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos)
-{
-  return new MEDFileFloatField1TSWithoutSDA(fieldName,meshName,csit,iteration,order,infos);
-}
-
-MEDFileFloatField1TSWithoutSDA::MEDFileFloatField1TSWithoutSDA()
-{
-}
-
-MEDFileFloatField1TSWithoutSDA::MEDFileFloatField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order,
-                                                               const std::vector<std::string>& infos):MEDFileField1TSNDTemplateWithoutSDA<float>(fieldName,meshName,csit,iteration,order,infos)
-{
-  DataArrayFloat *arr(getOrCreateAndGetArrayTemplate());
-  arr->setInfoAndChangeNbOfCompo(infos);
-}
-
-const char *MEDFileFloatField1TSWithoutSDA::getTypeStr() const
-{
-  return TYPE_STR;
-}
-
-/*!
- * Returns a pointer to the underground DataArrayFloat instance and a
- * sequence describing parameters of a support of each part of \a this field. The
- * caller should not decrRef() the returned DataArrayFloat. This method allows for a
- * direct access to the field values. This method is intended for the field lying on one
- * mesh only.
- *  \param [in,out] entries - the sequence describing parameters of a support of each
- *         part of \a this field. Each item of this sequence consists of two parts. The
- *         first part describes a type of mesh entity and an id of discretization of a
- *         current field part. The second part describes a range of values [begin,end)
- *         within the returned array relating to the current field part.
- *  \return DataArrayFloat * - the pointer to the field values array.
- *  \throw If the number of underlying meshes is not equal to 1.
- *  \throw If no field values are available.
- *  \sa getUndergroundDataArray()
- */
-DataArray *MEDFileFloatField1TSWithoutSDA::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  return getUndergroundDataArrayFloatExt(entries);
-}
-
-/*!
- * Returns a pointer to the underground DataArrayFloat instance and a
- * sequence describing parameters of a support of each part of \a this field. The
- * caller should not decrRef() the returned DataArrayFloat. This method allows for a
- * direct access to the field values. This method is intended for the field lying on one
- * mesh only.
- *  \param [in,out] entries - the sequence describing parameters of a support of each
- *         part of \a this field. Each item of this sequence consists of two parts. The
- *         first part describes a type of mesh entity and an id of discretization of a
- *         current field part. The second part describes a range of values [begin,end)
- *         within the returned array relating to the current field part.
- *  \return DataArrayFloat * - the pointer to the field values array.
- *  \throw If the number of underlying meshes is not equal to 1.
- *  \throw If no field values are available.
- *  \sa getUndergroundDataArray()
- */
-DataArrayFloat *MEDFileFloatField1TSWithoutSDA::getUndergroundDataArrayFloatExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  if(_field_per_mesh.size()!=1)
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : field lies on several meshes, this method has no sense !");
-  if(_field_per_mesh[0]==0)
-    throw INTERP_KERNEL::Exception("MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt : no field specified !");
-  _field_per_mesh[0]->getUndergroundDataArrayExt(entries);
-  return getUndergroundDataArrayTemplate();
-}
-
-MEDFileFloatField1TSWithoutSDA *MEDFileFloatField1TSWithoutSDA::shallowCpy() const
-{
-  MCAuto<MEDFileFloatField1TSWithoutSDA> ret(new MEDFileFloatField1TSWithoutSDA(*this));
-  ret->deepCpyLeavesFrom(*this);
-  return ret.retn();
-}
-
-MEDFileFloatField1TSWithoutSDA *MEDFileFloatField1TSWithoutSDA::deepCopy() const
-{
-  MCAuto<MEDFileFloatField1TSWithoutSDA> ret(shallowCpy());
-  if(_arr.isNotNull())
-    ret->_arr=_arr->deepCopy();
-  return ret.retn();
-}
-
-//= MEDFileAnyTypeField1TS
-
-MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS()
-{
-}
-
-MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  med_field_type typcha;
-  //
-  std::vector<std::string> infos;
-  std::string dtunit,fieldName,meshName;
-  LocateField2(fid,0,true,fieldName,typcha,infos,dtunit,meshName);
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ret;
-  switch(typcha)
-  {
-    case MED_FLOAT64:
-      {
-        ret=MEDFileField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
-        break;
-      }
-    case MED_INT32:
-      {
-        ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
-        break;
-      }
-    case MED_NODE://6432
-      {
-        ret=MEDFileFloatField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
-        break;
-      }
-    default:
-      {
-        std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::BuildContentFrom(fid) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of the first field is not in [MED_FLOAT64, MED_INT32] !";
-        throw INTERP_KERNEL::Exception(oss.str());
-      }
-  }
-  ret->setDtUnit(dtunit.c_str());
-  ret->getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(infos);
-  //
-  med_int numdt,numit;
-  med_float dt;
-  MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,fieldName.c_str(),1,&numdt,&numit,&dt));
-  ret->setTime(numdt,numit,dt);
-  ret->_csit=1;
-  if(loadAll)
-    ret->loadStructureAndBigArraysRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
-  else
-    ret->loadOnlyStructureOfDataRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
-  return ret.retn();
-}
-
-MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-try:MEDFileFieldGlobsReal(fid)
-{
-  _content=BuildContentFrom(fid,loadAll,ms,entities);
-  loadGlobals(fid);
-}
-catch(INTERP_KERNEL::Exception& e)
-{
-    throw e;
-}
-
-MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  med_field_type typcha;
-  std::vector<std::string> infos;
-  std::string dtunit,meshName;
-  int nbSteps(0);
-  {
-    int iii=-1;
-    nbSteps=LocateField(fid,fieldName,iii,typcha,infos,dtunit,meshName);
-  }
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ret;
-  switch(typcha)
-  {
-    case MED_FLOAT64:
-      {
-        ret=MEDFileField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
-        break;
-      }
-    case MED_INT32:
-      {
-        ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
-        break;
-      }
-    case MED_NODE://6432
-      {
-        ret=MEDFileFloatField1TSWithoutSDA::New(fieldName,meshName,-1,-1/*iteration*/,-1/*order*/,std::vector<std::string>());
-        break;
-      }
-    default:
-      {
-        std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::BuildContentFrom(fid,fieldName) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
-        throw INTERP_KERNEL::Exception(oss.str());
-      }
-  }
-  ret->setMeshName(meshName);
-  ret->setDtUnit(dtunit.c_str());
-  ret->getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(infos);
-  //
-  if(nbSteps<1)
-    {
-      std::ostringstream oss; oss << "MEDFileField1TS(fid,fieldName) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but there is no time steps on it !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  //
-  med_int numdt,numit;
-  med_float dt;
-  MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,fieldName.c_str(),1,&numdt,&numit,&dt));
-  ret->setTime(numdt,numit,dt);
-  ret->_csit=1;
-  if(loadAll)
-    ret->loadStructureAndBigArraysRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
-  else
-    ret->loadOnlyStructureOfDataRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
-  return ret.retn();
-}
-
-MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-try:MEDFileFieldGlobsReal(fid)
-{
-  _content=BuildContentFrom(fid,fieldName,loadAll,ms,entities);
-  loadGlobals(fid);
-}
-catch(INTERP_KERNEL::Exception& e)
-{
-    throw e;
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c)
-{
-  if(!c)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::BuildNewInstanceFromContent : empty content in input : unable to build a new instance !");
-  if(dynamic_cast<const MEDFileField1TSWithoutSDA *>(c))
-    {
-      MCAuto<MEDFileField1TS> ret(MEDFileField1TS::New());
-      ret->_content=c; c->incrRef();
-      return ret.retn();
-    }
-  if(dynamic_cast<const MEDFileIntField1TSWithoutSDA *>(c))
-    {
-      MCAuto<MEDFileIntField1TS> ret(MEDFileIntField1TS::New());
-      ret->_content=c; c->incrRef();
-      return ret.retn();
-    }
-  throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::BuildNewInstanceFromContent : internal error ! a content of type different from FLOAT64 and INT32 has been built but not intercepted !");
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c, med_idt fid)
-{
-  MEDFileAnyTypeField1TS *ret(BuildNewInstanceFromContent(c));
-  ret->setFileName(FileNameFromFID(fid));
-  return ret;
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(const std::string& fileName, bool loadAll)
-{
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
-  return New(fid,loadAll);
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(med_idt fid, bool loadAll)
-{
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,loadAll,0,0));
-  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
-  ret->loadGlobals(fid);
-  return ret.retn();
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(const std::string& fileName, const std::string& fieldName, bool loadAll)
-{
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
-  return New(fid,fieldName,loadAll);
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(med_idt fid, const std::string& fieldName, bool loadAll)
-{
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,fieldName,loadAll,0,0));
-  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
-  ret->loadGlobals(fid);
-  return ret.retn();
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll)
-{
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
-  return New(fid,fieldName,iteration,order,loadAll);
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::New(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll)
-{
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,fieldName,iteration,order,loadAll,0,0));
-  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
-  ret->loadGlobals(fid);
-  return ret.retn();
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::NewAdv(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities)
-{
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
-  return NewAdv(fid,fieldName,iteration,order,loadAll,entities);
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::NewAdv(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities)
-{
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> c(BuildContentFrom(fid,fieldName,iteration,order,loadAll,0,entities));
-  MCAuto<MEDFileAnyTypeField1TS> ret(BuildNewInstanceFromContent(c,fid));
-  ret->loadGlobals(fid);
-  return ret.retn();
-}
-
-MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::BuildContentFrom(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  med_field_type typcha;
-  std::vector<std::string> infos;
-  std::string dtunit,meshName;
-  int iii(-1);
-  int nbOfStep2(LocateField(fid,fieldName,iii,typcha,infos,dtunit,meshName));
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ret;
-  switch(typcha)
-  {
-    case MED_FLOAT64:
-      {
-        ret=MEDFileField1TSWithoutSDA::New(fieldName,meshName,-1,iteration,order,std::vector<std::string>());
-        break;
-      }
-    case MED_INT32:
-      {
-        ret=MEDFileIntField1TSWithoutSDA::New(fieldName,meshName,-1,iteration,order,std::vector<std::string>());
-        break;
-      }
-    case MED_NODE://6432
-      {
-        ret=MEDFileFloatField1TSWithoutSDA::New(fieldName,meshName,-1,iteration,order,std::vector<std::string>());
-        break;
-      }
-    default:
-      {
-        std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::BuildContentFrom(fid,fieldName,iteration,order) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
-        throw INTERP_KERNEL::Exception(oss.str());
-      }
-  }
-  ret->setDtUnit(dtunit.c_str());
-  ret->getOrCreateAndGetArray()->setInfoAndChangeNbOfCompo(infos);
-  //
-  bool found=false;
-  std::vector< std::pair<int,int> > dtits(nbOfStep2);
-  for(int i=0;i<nbOfStep2 && !found;i++)
-    {
-      med_int numdt,numit;
-      med_float dt;
-      MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,fieldName.c_str(),i+1,&numdt,&numit,&dt));
-      if(numdt==iteration && numit==order)
-        {
-          found=true;
-          ret->_csit=i+1;
-        }
-      else
-        dtits[i]=std::pair<int,int>(numdt,numit);
-    }
-  if(!found)
-    {
-      std::ostringstream oss; oss << "No such iteration (" << iteration << "," << order << ") in existing field '" << fieldName << "' in file '" << FileNameFromFID(fid) << "' ! Available iterations are : ";
-      for(std::vector< std::pair<int,int> >::const_iterator iter=dtits.begin();iter!=dtits.end();iter++)
-        oss << "(" << (*iter).first << "," << (*iter).second << "), ";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  if(loadAll)
-    ret->loadStructureAndBigArraysRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
-  else
-    ret->loadOnlyStructureOfDataRecursively(fid,*((const MEDFileAnyTypeField1TSWithoutSDA*)ret),ms,entities);
-  return ret.retn();
-}
-
-MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-try:MEDFileFieldGlobsReal(fid)
-{
-  _content=BuildContentFrom(fid,fieldName,iteration,order,loadAll,ms,entities);
-  loadGlobals(fid);
-}
-catch(INTERP_KERNEL::Exception& e)
-{
-    throw e;
-}
-
-/*!
- * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
- * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
- *
- * \warning this is a shallow copy constructor
- */
-MEDFileAnyTypeField1TS::MEDFileAnyTypeField1TS(const MEDFileAnyTypeField1TSWithoutSDA& other, bool shallowCopyOfContent)
-{
-  if(!shallowCopyOfContent)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *otherPtr(&other);
-      otherPtr->incrRef();
-      _content=const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(otherPtr);
-    }
-  else
-    {
-      _content=other.shallowCpy();
-    }
-}
-
-int MEDFileAnyTypeField1TS::LocateField2(med_idt fid, int fieldIdCFormat, bool checkFieldId, std::string& fieldName, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName)
-{
-  if(checkFieldId)
-    {
-      int nbFields=MEDnField(fid);
-      if(fieldIdCFormat>=nbFields)
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeField1TS::LocateField2(fileName) : in file \'" << FileNameFromFID(fid) << "\' number of fields is " << nbFields << " ! Trying to request for id " << fieldIdCFormat << " !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-    }
-  int ncomp(MEDfieldnComponent(fid,fieldIdCFormat+1));
-  INTERP_KERNEL::AutoPtr<char> comp(MEDLoaderBase::buildEmptyString(ncomp*MED_SNAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> unit(MEDLoaderBase::buildEmptyString(ncomp*MED_SNAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> dtunit(MEDLoaderBase::buildEmptyString(MED_LNAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> nomcha(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> nomMaa(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
-  med_bool localMesh;
-  int nbOfStep;
-  MEDFILESAFECALLERRD0(MEDfieldInfo,(fid,fieldIdCFormat+1,nomcha,nomMaa,&localMesh,&typcha,comp,unit,dtunit,&nbOfStep));
-  fieldName=MEDLoaderBase::buildStringFromFortran(nomcha,MED_NAME_SIZE);
-  dtunitOut=MEDLoaderBase::buildStringFromFortran(dtunit,MED_LNAME_SIZE);
-  meshName=MEDLoaderBase::buildStringFromFortran(nomMaa,MED_NAME_SIZE);
-  infos.clear(); infos.resize(ncomp);
-  for(int j=0;j<ncomp;j++)
-    infos[j]=MEDLoaderBase::buildUnionUnit((char *)comp+j*MED_SNAME_SIZE,MED_SNAME_SIZE,(char *)unit+j*MED_SNAME_SIZE,MED_SNAME_SIZE);
-  return nbOfStep;
-}
-
-/*!
- * This method throws an INTERP_KERNEL::Exception if \a fieldName field is not in file pointed by \a fid and with name \a fileName.
- * 
- * \param [out]
- * \return in case of success the number of time steps available for the field with name \a fieldName.
- */
-int MEDFileAnyTypeField1TS::LocateField(med_idt fid, const std::string& fieldName, int& posCFormat, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName)
-{
-  int nbFields=MEDnField(fid);
-  bool found=false;
-  std::vector<std::string> fns(nbFields);
-  int nbOfStep2(-1);
-  for(int i=0;i<nbFields && !found;i++)
-    {
-      std::string tmp,tmp2;
-      nbOfStep2=LocateField2(fid,i,false,tmp,typcha,infos,dtunitOut,tmp2);
-      fns[i]=tmp;
-      found=(tmp==fieldName);
-      if(found)
-        {
-          posCFormat=i;
-          meshName=tmp2;
-        }
-    }
-  if(!found)
-    {
-      std::ostringstream oss; oss << "No such field '" << fieldName << "' in file '" << FileNameFromFID(fid) << "' ! Available fields are : ";
-      for(std::vector<std::string>::const_iterator it=fns.begin();it!=fns.end();it++)
-        oss << "\"" << *it << "\" ";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  return nbOfStep2;
-}
-
-/*!
- * This method as MEDFileField1TSW::setLocNameOnLeaf, is dedicated for advanced user that a want a very fine control on their data structure
- * without overhead. This method can be called only regarding information returned by MEDFileField1TSWithoutSDA::getFieldSplitedByType or MEDFileField1TSWithoutSDA::getFieldSplitedByType2.
- * This method changes the attribute (here it's profile name) of the leaf datastructure (MEDFileFieldPerMeshPerTypePerDisc instance).
- * It is the responsability of the caller to invoke MEDFileFieldGlobs::appendProfile or MEDFileFieldGlobs::getProfile
- * to keep a valid instance.
- * If \b this do not have any leaf that correspond to the request of the input parameter (\b mName, \b typ, \b locId) an INTERP_KERNEL::Exception will be thrown.
- * If \b newPflName profile name does not already exist the profile with old name will be renamed with name \b newPflName.
- * If \b newPflName already exists and that \b forceRenameOnGlob is false (the default) an INTERP_KERNEL::Exception will be thrown to avoid big confusion. In this case the called should rename before the profile name with name \b newPflName.
- *
- * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
- * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
- * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
- *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
- * \param [in] newLocName is the new localization name.
- * \param [in] forceRenameOnGlob specifies the behaviour in case of profile \b newPflName already exists. If true, the renaming is done without check. It can lead to major bug.
- *             If false, an exception will be thrown to force user to change previously the name of the profile with name \b newPflName
- */
-void MEDFileAnyTypeField1TS::setProfileNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newPflName, bool forceRenameOnGlob)
-{
-  MEDFileFieldPerMeshPerTypePerDisc *disc=getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
-  std::string oldPflName=disc->getProfile();
-  std::vector<std::string> vv=getPflsReallyUsedMulti();
-  int nbOfOcc=std::count(vv.begin(),vv.end(),oldPflName);
-  if(forceRenameOnGlob || (!existsPfl(newPflName) && nbOfOcc==1))
-    {
-      disc->setProfile(newPflName);
-      DataArrayInt *pfl=getProfile(oldPflName.c_str());
-      pfl->setName(newPflName);
-    }
-  else
-    {
-      std::ostringstream oss; oss << "MEDFileField1TS::setProfileNameOnLeaf : Profile \"" << newPflName << "\" already exists or referenced more than one !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-}
-
-/*!
- * This method as MEDFileField1TSW::setProfileNameOnLeaf, is dedicated for advanced user that a want a very fine control on their data structure
- * without overhead. This method can be called only regarding information returned by MEDFileField1TSWithoutSDA::getFieldSplitedByType or MEDFileField1TSWithoutSDA::getFieldSplitedByType2.
- * This method changes the attribute (here it's localization name) of the leaf datastructure (MEDFileFieldPerMeshPerTypePerDisc instance).
- * It is the responsability of the caller to invoke MEDFileFieldGlobs::appendProfile or MEDFileFieldGlobs::getProfile
- * to keep a valid instance.
- * If \b this do not have any leaf that correspond to the request of the input parameter (\b mName, \b typ, \b locId) an INTERP_KERNEL::Exception will be thrown.
- * This method is an extension of MEDFileField1TSWithoutSDA::setProfileNameOnLeafExt method because it performs a modification of global info.
- * If \b newLocName profile name does not already exist the localization with old name will be renamed with name \b newLocName.
- * If \b newLocName already exists an INTERP_KERNEL::Exception will be thrown to avoid big confusion. In this case the called should rename before the profile name with name \b newLocName.
- *
- * \param [in] mName specifies the underlying mesh name. This value can be pointer 0 for users that do not deal with fields on multi mesh.
- * \param [in] typ is for the geometric cell type (or INTERP_KERNEL::NORM_ERROR for node field) entry to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set.
- * \param [in] locId is the localization id to find the right MEDFileFieldPerMeshPerTypePerDisc instance to set. It corresponds to the position of 
- *             \c pfls[std::distance(types.begin(),std::find(types.begin(),typ)] vector in MEDFileField1TSWithoutSDA::getFieldSplitedByType. For non gausspoints field users, the value is 0.
- * \param [in] newLocName is the new localization name.
- * \param [in] forceRenameOnGlob specifies the behaviour in case of profile \b newLocName already exists. If true, the renaming is done without check. It can lead to major bug.
- *             If false, an exception will be thrown to force user to change previously the name of the profile with name \b newLocName
- */
-void MEDFileAnyTypeField1TS::setLocNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newLocName, bool forceRenameOnGlob)
-{
-  MEDFileFieldPerMeshPerTypePerDisc *disc=getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
-  std::string oldLocName=disc->getLocalization();
-  std::vector<std::string> vv=getLocsReallyUsedMulti();
-  int nbOfOcc=std::count(vv.begin(),vv.end(),oldLocName);
-  if(forceRenameOnGlob || (!existsLoc(newLocName) && nbOfOcc==1))
-    {
-      disc->setLocalization(newLocName);
-      MEDFileFieldLoc& loc=getLocalization(oldLocName.c_str());
-      loc.setName(newLocName);
-    }
-  else
-    {
-      std::ostringstream oss; oss << "MEDFileField1TS::setLocNameOnLeaf : Localization \"" << newLocName << "\" already exists or referenced more than one !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-}
-
-MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::contentNotNullBase()
-{
-  MEDFileAnyTypeField1TSWithoutSDA *ret=_content;
-  if(!ret)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS : content is expected to be not null !");
-  return ret;
-}
-
-const MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeField1TS::contentNotNullBase() const
-{
-  const MEDFileAnyTypeField1TSWithoutSDA *ret=_content;
-  if(!ret)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS : const content is expected to be not null !");
-  return ret;
-}
-
-/*!
- * This method alloc the arrays and load potentially huge arrays contained in this field.
- * This method should be called when a MEDFileAnyTypeField1TS::New constructor has been with false as the last parameter.
- * This method can be also called to refresh or reinit values from a file.
- * 
- * \throw If the fileName is not set or points to a non readable MED file.
- * \sa MEDFileAnyTypeField1TS::loadArraysIfNecessary
- */
-void MEDFileAnyTypeField1TS::loadArrays()
-{
-  if(getFileName().empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::loadArrays : the structure does not come from a file !");
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
-  contentNotNullBase()->loadBigArraysRecursively(fid,*contentNotNullBase());
-}
-
-/*!
- * This method behaves as MEDFileAnyTypeField1TS::loadArrays does, the first call, if \a this was built using a file without loading big arrays.
- * But once data loaded once, this method does nothing. Contrary to MEDFileAnyTypeField1TS::loadArrays and MEDFileAnyTypeField1TS::unloadArrays
- * this method does not throw if \a this does not come from file read.
- * 
- * \sa MEDFileAnyTypeField1TS::loadArrays, MEDFileAnyTypeField1TS::unloadArrays
- */
-void MEDFileAnyTypeField1TS::loadArraysIfNecessary()
-{
-  if(!getFileName().empty())
-    {
-      MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
-      contentNotNullBase()->loadBigArraysRecursivelyIfNecessary(fid,*contentNotNullBase());
-    }
-}
-
-/*!
- * This method releases potentially big data arrays and so returns to the same heap memory than status loaded with 'loadAll' parameter set to false.
- * \b WARNING, this method does release arrays even if \a this does not come from a load of a MED file.
- * So this method can lead to a loss of data. If you want to unload arrays safely call MEDFileAnyTypeField1TS::unloadArraysWithoutDataLoss instead.
- * 
- * \sa MEDFileAnyTypeField1TS::loadArrays, MEDFileAnyTypeField1TS::loadArraysIfNecessary, MEDFileAnyTypeField1TS::unloadArraysWithoutDataLoss
- */
-void MEDFileAnyTypeField1TS::unloadArrays()
-{
-  contentNotNullBase()->unloadArrays();
-}
-
-/*!
- * This method potentially releases big data arrays if \a this is coming from a file. If \a this has been built from scratch this method will have no effect.
- * This method is the symetrical method of MEDFileAnyTypeField1TS::loadArraysIfNecessary.
- * This method is useful to reduce \b safely amount of heap memory necessary for \a this by using MED file as database.
- * 
- * \sa MEDFileAnyTypeField1TS::loadArraysIfNecessary
- */
-void MEDFileAnyTypeField1TS::unloadArraysWithoutDataLoss()
-{
-  if(!getFileName().empty())
-    contentNotNullBase()->unloadArrays();
-}
-
-void MEDFileAnyTypeField1TS::writeLL(med_idt fid) const
-{
-  int nbComp(getNumberOfComponents());
-  INTERP_KERNEL::AutoPtr<char> comp(MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE));
-  INTERP_KERNEL::AutoPtr<char> unit(MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE));
-  for(int i=0;i<nbComp;i++)
-    {
-      std::string info=getInfo()[i];
-      std::string c,u;
-      MEDLoaderBase::splitIntoNameAndUnit(info,c,u);
-      MEDLoaderBase::safeStrCpy2(c.c_str(),MED_SNAME_SIZE,comp+i*MED_SNAME_SIZE,_too_long_str);
-      MEDLoaderBase::safeStrCpy2(u.c_str(),MED_SNAME_SIZE,unit+i*MED_SNAME_SIZE,_too_long_str);
-    }
-  if(getName().empty())
-    throw INTERP_KERNEL::Exception("MEDFileField1TS::write : MED file does not accept field with empty name !");
-  MEDFILESAFECALLERWR0(MEDfieldCr,(fid,getName().c_str(),getMEDFileFieldType(),nbComp,comp,unit,getDtUnit().c_str(),getMeshName().c_str()));
-  writeGlobals(fid,*this);
-  contentNotNullBase()->writeLL(fid,*this,*contentNotNullBase());
-}
-
-std::size_t MEDFileAnyTypeField1TS::getHeapMemorySizeWithoutChildren() const
-{
-  return MEDFileFieldGlobsReal::getHeapMemorySizeWithoutChildren();
-}
-
-std::vector<const BigMemoryObject *> MEDFileAnyTypeField1TS::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret(MEDFileFieldGlobsReal::getDirectChildrenWithNull());
-  ret.push_back((const MEDFileAnyTypeField1TSWithoutSDA *)_content);
-  return ret;
-}
-
-/*!
- * Returns a string describing \a this field. This string is outputted 
- * by \c print Python command.
- */
-std::string MEDFileAnyTypeField1TS::simpleRepr() const
-{
-  std::ostringstream oss;
-  contentNotNullBase()->simpleRepr(0,oss,-1);
-  simpleReprGlobs(oss);
-  return oss.str();
-}
-
-/*!
- * This method returns all profiles whose name is non empty used.
- * \b WARNING If profile is used several times it will be reported \b only \b once.
- * To get non empty name profiles as time as they appear in \b this call MEDFileField1TS::getPflsReallyUsedMulti instead.
- */
-std::vector<std::string> MEDFileAnyTypeField1TS::getPflsReallyUsed() const
-{
-  return contentNotNullBase()->getPflsReallyUsed2();
-}
-
-/*!
- * This method returns all localizations whose name is non empty used.
- * \b WARNING If localization is used several times it will be reported \b only \b once.
- */
-std::vector<std::string> MEDFileAnyTypeField1TS::getLocsReallyUsed() const
-{
-  return contentNotNullBase()->getLocsReallyUsed2();
-}
-
-/*!
- * This method returns all profiles whose name is non empty used.
- * \b WARNING contrary to MEDFileField1TS::getPflsReallyUsed, if profile is used several times it will be reported as time as it appears.
- */
-std::vector<std::string> MEDFileAnyTypeField1TS::getPflsReallyUsedMulti() const
-{
-  return contentNotNullBase()->getPflsReallyUsedMulti2();
-}
-
-/*!
- * This method returns all localizations whose name is non empty used.
- * \b WARNING contrary to MEDFileField1TS::getLocsReallyUsed if localization is used several times it will be reported as time as it appears.
- */
-std::vector<std::string> MEDFileAnyTypeField1TS::getLocsReallyUsedMulti() const
-{
-  return contentNotNullBase()->getLocsReallyUsedMulti2();
-}
-
-void MEDFileAnyTypeField1TS::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  contentNotNullBase()->changePflsRefsNamesGen2(mapOfModif);
-}
-
-void MEDFileAnyTypeField1TS::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  contentNotNullBase()->changeLocsRefsNamesGen2(mapOfModif);
-}
-
-int MEDFileAnyTypeField1TS::getDimension() const
-{
-  return contentNotNullBase()->getDimension();
-}
-
-int MEDFileAnyTypeField1TS::getIteration() const
-{
-  return contentNotNullBase()->getIteration();
-}
-
-int MEDFileAnyTypeField1TS::getOrder() const
-{
-  return contentNotNullBase()->getOrder();
-}
-
-double MEDFileAnyTypeField1TS::getTime(int& iteration, int& order) const
-{
-  return contentNotNullBase()->getTime(iteration,order);
-}
-
-void MEDFileAnyTypeField1TS::setTime(int iteration, int order, double val)
-{
-  contentNotNullBase()->setTime(iteration,order,val);
-}
-
-std::string MEDFileAnyTypeField1TS::getName() const
-{
-  return contentNotNullBase()->getName();
-}
-
-void MEDFileAnyTypeField1TS::setName(const std::string& name)
-{
-  contentNotNullBase()->setName(name);
-}
-
-void MEDFileAnyTypeField1TS::simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const
-{
-  contentNotNullBase()->simpleRepr(bkOffset,oss,f1tsId);
-}
-
-std::string MEDFileAnyTypeField1TS::getDtUnit() const
-{
-  return contentNotNullBase()->getDtUnit();
-}
-
-void MEDFileAnyTypeField1TS::setDtUnit(const std::string& dtUnit)
-{
-  contentNotNullBase()->setDtUnit(dtUnit);
-}
-
-std::string MEDFileAnyTypeField1TS::getMeshName() const
-{
-  return contentNotNullBase()->getMeshName();
-}
-
-void MEDFileAnyTypeField1TS::setMeshName(const std::string& newMeshName)
-{
-  contentNotNullBase()->setMeshName(newMeshName);
-}
-
-bool MEDFileAnyTypeField1TS::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
-{
-  return contentNotNullBase()->changeMeshNames(modifTab);
-}
-
-int MEDFileAnyTypeField1TS::getMeshIteration() const
-{
-  return contentNotNullBase()->getMeshIteration();
-}
-
-int MEDFileAnyTypeField1TS::getMeshOrder() const
-{
-  return contentNotNullBase()->getMeshOrder();
-}
-
-int MEDFileAnyTypeField1TS::getNumberOfComponents() const
-{
-  return contentNotNullBase()->getNumberOfComponents();
-}
-
-bool MEDFileAnyTypeField1TS::isDealingTS(int iteration, int order) const
-{
-  return contentNotNullBase()->isDealingTS(iteration,order);
-}
-
-std::pair<int,int> MEDFileAnyTypeField1TS::getDtIt() const
-{
-  return contentNotNullBase()->getDtIt();
-}
-
-void MEDFileAnyTypeField1TS::fillIteration(std::pair<int,int>& p) const
-{
-  contentNotNullBase()->fillIteration(p);
-}
-
-void MEDFileAnyTypeField1TS::fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const
-{
-  contentNotNullBase()->fillTypesOfFieldAvailable(types);
-}
-
-void MEDFileAnyTypeField1TS::setInfo(const std::vector<std::string>& infos)
-{
-  contentNotNullBase()->setInfo(infos);
-}
-
-const std::vector<std::string>& MEDFileAnyTypeField1TS::getInfo() const
-{
-  return contentNotNullBase()->getInfo();
-}
-std::vector<std::string>& MEDFileAnyTypeField1TS::getInfo()
-{
-  return contentNotNullBase()->getInfo();
-}
-
-bool MEDFileAnyTypeField1TS::presenceOfMultiDiscPerGeoType() const
-{
-  return contentNotNullBase()->presenceOfMultiDiscPerGeoType();
-}
-
-MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TS::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId)
-{
-  return contentNotNullBase()->getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
-}
-
-const MEDFileFieldPerMeshPerTypePerDisc *MEDFileAnyTypeField1TS::getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const
-{
-  return contentNotNullBase()->getLeafGivenMeshAndTypeAndLocId(mName,typ,locId);
-}
-
-int MEDFileAnyTypeField1TS::getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const
-{
-  return contentNotNullBase()->getNonEmptyLevels(mname,levs);
-}
-
-void MEDFileAnyTypeField1TS::convertMedBallIntoClassic()
-{
-  return contentNotNullBase()->convertMedBallIntoClassic();
-}
-
-void MEDFileAnyTypeField1TS::makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl)
-{
-  return contentNotNullBase()->makeReduction(ct,tof,pfl);
-}
-
-std::vector<TypeOfField> MEDFileAnyTypeField1TS::getTypesOfFieldAvailable() const
-{
-  return contentNotNullBase()->getTypesOfFieldAvailable();
-}
-
-std::vector< std::vector<std::pair<int,int> > > MEDFileAnyTypeField1TS::getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
-                                                                                              std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  return contentNotNullBase()->getFieldSplitedByType(mname,types,typesF,pfls,locs);
-}
-
-/*!
- * This method returns as MEDFileAnyTypeField1TS new instances as number of components in \a this.
- * The returned instances are deep copy of \a this except that for globals that are share with those contained in \a this.
- * ** WARNING ** do no forget to rename the ouput instances to avoid to write n-times in the same MED file field !
- */
-std::vector< MCAuto< MEDFileAnyTypeField1TS > > MEDFileAnyTypeField1TS::splitComponents() const
-{
-  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
-  if(!content)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::splitComponents : no content in this ! Unable to split components !");
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > contentsSplit=content->splitComponents();
-  std::size_t sz(contentsSplit.size());
-  std::vector< MCAuto< MEDFileAnyTypeField1TS > > ret(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      ret[i]=shallowCpy();
-      ret[i]->_content=contentsSplit[i];
-    }
-  return ret;
-}
-
-/*!
- * This method returns as MEDFileAnyTypeField1TS new instances as number of spatial discretizations in \a this.
- * The returned instances are shallowed copied of \a this except that for globals that are share with those contained in \a this.
- */
-std::vector< MCAuto< MEDFileAnyTypeField1TS > > MEDFileAnyTypeField1TS::splitDiscretizations() const
-{
-  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
-  if(!content)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::splitDiscretizations : no content in this ! Unable to split discretization !");
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > contentsSplit(content->splitDiscretizations());
-  std::size_t sz(contentsSplit.size());
-  std::vector< MCAuto< MEDFileAnyTypeField1TS > > ret(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      ret[i]=shallowCpy();
-      ret[i]->_content=contentsSplit[i];
-    }
-  return ret;
-}
-
-/*!
- * This method returns as MEDFileAnyTypeField1TS new instances as number of maximal number of discretization in \a this.
- * The returned instances are shallowed copied of \a this except that for globals that are share with those contained in \a this.
- */
-std::vector< MCAuto< MEDFileAnyTypeField1TS > > MEDFileAnyTypeField1TS::splitMultiDiscrPerGeoTypes() const
-{
-  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
-  if(!content)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeField1TS::splitMultiDiscrPerGeoTypes : no content in this ! Unable to split discretization !");
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > contentsSplit(content->splitMultiDiscrPerGeoTypes());
-  std::size_t sz(contentsSplit.size());
-  std::vector< MCAuto< MEDFileAnyTypeField1TS > > ret(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      ret[i]=shallowCpy();
-      ret[i]->_content=contentsSplit[i];
-    }
-  return ret;
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeField1TS::deepCopy() const
-{
-  MCAuto<MEDFileAnyTypeField1TS> ret=shallowCpy();
-  if((const MEDFileAnyTypeField1TSWithoutSDA *)_content)
-    ret->_content=_content->deepCopy();
-  ret->deepCpyGlobs(*this);
-  return ret.retn();
-}
-
-int MEDFileAnyTypeField1TS::copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr)
-{
-  MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::New(*field));
-  return copyTinyInfoFrom(field->timeDiscrSafe(),ft,arr);
-}
-
-int MEDFileAnyTypeField1TS::copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr)
-{
-  return contentNotNullBase()->copyTinyInfoFrom(th,field,arr);
-}
-
-//= MEDFileField1TS
-
-/*!
- * This method performs a copy with datatype modification ( float64->int32 ) of \a this. The globals information are copied
- * following the given input policy.
- *
- * \param [in] isDeepCpyGlobs - a boolean that indicates the behaviour concerning globals (profiles and localizations)
- *                            By default (true) the globals are deeply copied.
- * \return MEDFileIntField1TS * - a new object that is the result of the conversion of \a this to int32 field.
- */
-MEDFileIntField1TS *MEDFileField1TS::convertToInt(bool isDeepCpyGlobs) const
-{
-  MCAuto<MEDFileIntField1TS> ret;
-  const MEDFileAnyTypeField1TSWithoutSDA *content(_content);
-  if(content)
-    {
-      const MEDFileField1TSWithoutSDA *contc=dynamic_cast<const MEDFileField1TSWithoutSDA *>(content);
-      if(!contc)
-        throw INTERP_KERNEL::Exception("MEDFileField1TS::convertToInt : the content inside this is not FLOAT64 ! This is incoherent !");
-      MCAuto<MEDFileIntField1TSWithoutSDA> newc(contc->convertToInt());
-      ret=static_cast<MEDFileIntField1TS *>(MEDFileAnyTypeField1TS::BuildNewInstanceFromContent((MEDFileIntField1TSWithoutSDA *)newc));
-    }
-  else
-    ret=MEDFileIntField1TS::New();
-  if(isDeepCpyGlobs)
-    ret->deepCpyGlobs(*this);
-  else
-    ret->shallowCpyGlobs(*this);
-  return ret.retn();
-}
-
-MEDFileField1TS::MEDFileField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
-try:MEDFileTemplateField1TS<double>(fid,loadAll,ms)
-{
-}
-catch(INTERP_KERNEL::Exception& e)
-{ throw e; }
-
-MEDFileField1TS::MEDFileField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms)
-try:MEDFileTemplateField1TS<double>(fid,fieldName,loadAll,ms)
-{
-}
-catch(INTERP_KERNEL::Exception& e)
-{ throw e; }
-
-MEDFileField1TS::MEDFileField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms)
-try:MEDFileTemplateField1TS<double>(fid,fieldName,iteration,order,loadAll,ms)
-{
-}
-catch(INTERP_KERNEL::Exception& e)
-{ throw e; }
-
-/*!
- * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
- * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
- *
- * \warning this is a shallow copy constructor
- */
-MEDFileField1TS::MEDFileField1TS(const MEDFileField1TSWithoutSDA& other, bool shallowCopyOfContent)
-try:MEDFileTemplateField1TS<double>(other,shallowCopyOfContent)
-{
-}
-catch(INTERP_KERNEL::Exception& e)
-{ throw e; }
-
-MEDFileField1TS *MEDFileField1TS::shallowCpy() const
-{
-  return new MEDFileField1TS(*this);
-}
-
-std::vector< std::vector<DataArrayDouble *> > MEDFileField1TS::getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
-                                                                                      std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  return contentNotNull()->getFieldSplitedByType2(mname,types,typesF,pfls,locs);
-}
-
-//= MEDFileIntField1TS
-
-MCAuto<MEDCouplingFieldDouble> MEDFileIntField1TS::ConvertFieldIntToFieldDouble(const MEDCouplingFieldInt *f)
-{
-  if(!f)
-    throw INTERP_KERNEL::Exception("MEDFileIntField1TS::ConvertFieldIntToFieldDouble : null input field !");
-  int t1,t2;
-  double t0(f->getTime(t1,t2));
-  std::string tu(f->getTimeUnit());
-  MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::New(*f));
-  MCAuto<MEDCouplingFieldDouble> ret(MEDCouplingFieldDouble::New(*ft));
-  ret->setTime(t0,t1,t2); ret->setTimeUnit(tu);
-  return ret;
-}
-
-//= MEDFileFloatField1TS
-
-//= MEDFileFloatField1TS
-
-//= MEDFileAnyTypeFieldMultiTSWithoutSDA
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA()
-{
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileFieldNameScope(fieldName,meshName)
-{
-}
-
-/*!
- * \param [in] fieldId field id in C mode
- */
-MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  med_field_type typcha;
-  std::string dtunitOut,meshName;
-  int nbOfStep(MEDFileAnyTypeField1TS::LocateField2(fid,fieldId,false,_name,typcha,_infos,dtunitOut,meshName));
-  setMeshName(meshName);
-  setDtUnit(dtunitOut.c_str());
-  loadStructureOrStructureAndBigArraysRecursively(fid,nbOfStep,typcha,loadAll,ms,entities);
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-try:MEDFileFieldNameScope(fieldName,meshName),_infos(infos)
-{
-  setDtUnit(dtunit.c_str());
-  loadStructureOrStructureAndBigArraysRecursively(fid,nbOfStep,fieldTyp,loadAll,ms,entities);
-}
-catch(INTERP_KERNEL::Exception& e)
-{
-    throw e;
-}
-
-std::size_t MEDFileAnyTypeFieldMultiTSWithoutSDA::getHeapMemorySizeWithoutChildren() const
-{
-  std::size_t ret(_mesh_name.capacity()+_name.capacity()+_infos.capacity()*sizeof(std::string)+_time_steps.capacity()*sizeof(MCAuto<MEDFileField1TSWithoutSDA>));
-  for(std::vector<std::string>::const_iterator it=_infos.begin();it!=_infos.end();it++)
-    ret+=(*it).capacity();
-  return ret;
-}
-
-std::vector<const BigMemoryObject *> MEDFileAnyTypeFieldMultiTSWithoutSDA::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    ret.push_back((const MEDFileAnyTypeField1TSWithoutSDA *)*it);
-  return ret;
-}
-
-/*!
- * If one of the id in [ \a startIds , \a endIds ) points to a null element, there is not throw. Simply, this empty element is added as if it were not
- * NULL.
- */
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds(const int *startIds, const int *endIds) const
-{
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret=createNew();
-  ret->setInfo(_infos);
-  int sz=(int)_time_steps.size();
-  for(const int *id=startIds;id!=endIds;id++)
-    {
-      if(*id>=0 && *id<sz)
-        {
-          const MEDFileAnyTypeField1TSWithoutSDA *tse=_time_steps[*id];
-          MCAuto<MEDFileAnyTypeField1TSWithoutSDA> tse2;
-          if(tse)
-            {
-              tse->incrRef();
-              tse2=(const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(tse));
-            }
-          ret->pushBackTimeStep(tse2);
-        }
-      else
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds : At pos #" << std::distance(startIds,id) << " value is " << *id;
-          oss << " ! Should be in [0," << sz << ") !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-    }
-  if(ret->getNumberOfTS()>0)
-    ret->synchronizeNameScope();
-  ret->copyNameScope(*this);
-  return ret.retn();
-}
-
-/*!
- * If one of the id in the input range points to a null element, there is not throw. Simply, this empty element is added as if it were not
- * NULL.
- */
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds2(int bg, int end, int step) const
-{
-  static const char msg[]="MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds2";
-  int nbOfEntriesToKeep=DataArrayInt::GetNumberOfItemGivenBESRelative(bg,end,step,msg);
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret=createNew();
-  ret->setInfo(_infos);
-  int sz=(int)_time_steps.size();
-  int j=bg;
-  for(int i=0;i<nbOfEntriesToKeep;i++,j+=step)
-    {
-      if(j>=0 && j<sz)
-        {
-          const MEDFileAnyTypeField1TSWithoutSDA *tse=_time_steps[j];
-          MCAuto<MEDFileAnyTypeField1TSWithoutSDA> tse2;
-          if(tse)
-            {
-              tse->incrRef();
-              tse2=(const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(tse));
-            }
-          ret->pushBackTimeStep(tse2);
-        }
-      else
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds : At pos #" << i << " value is " << j;
-          oss << " ! Should be in [0," << sz << ") !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-    }
-  if(ret->getNumberOfTS()>0)
-    ret->synchronizeNameScope();
-  ret->copyNameScope(*this);
-  return ret.retn();
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::partOfThisLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const
-{
-  int id=0;
-  MCAuto<DataArrayInt> ids=DataArrayInt::New(); ids->alloc(0,1);
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,id++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
-      if(!cur)
-        continue;
-      std::pair<int,int> p(cur->getIteration(),cur->getOrder());
-      if(std::find(timeSteps.begin(),timeSteps.end(),p)!=timeSteps.end())
-        ids->pushBackSilent(id);
-    }
-  return buildFromTimeStepIds(ids->begin(),ids->end());
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::partOfThisNotLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const
-{
-  int id=0;
-  MCAuto<DataArrayInt> ids=DataArrayInt::New(); ids->alloc(0,1);
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,id++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
-      if(!cur)
-        continue;
-      std::pair<int,int> p(cur->getIteration(),cur->getOrder());
-      if(std::find(timeSteps.begin(),timeSteps.end(),p)==timeSteps.end())
-        ids->pushBackSilent(id);
-    }
-  return buildFromTimeStepIds(ids->begin(),ids->end());
-}
-
-bool MEDFileAnyTypeFieldMultiTSWithoutSDA::presenceOfStructureElements() const
-{
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      if((*it)->presenceOfStructureElements())
-        return true;
-  return false;
-}
-
-bool MEDFileAnyTypeFieldMultiTSWithoutSDA::onlyStructureElements() const
-{
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      if(!(*it)->onlyStructureElements())
-        return false;
-  return true;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::killStructureElements()
-{
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      {
-        if((*it)->presenceOfStructureElements())
-          {
-            if(!(*it)->onlyStructureElements())
-              {
-                (*it)->killStructureElements();
-                ret.push_back(*it);
-              }
-          }
-        else
-          {
-            ret.push_back(*it);
-          }
-      }
-  _time_steps=ret;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::keepOnlyStructureElements()
-{
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      {
-        if((*it)->presenceOfStructureElements())
-          {
-            if(!(*it)->onlyStructureElements())
-              (*it)->keepOnlyStructureElements();
-            ret.push_back(*it);
-          }
-      }
-  _time_steps=ret;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::keepOnlyOnSE(const std::string& seName)
-{
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      (*it)->keepOnlyOnSE(seName);
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const
-{
-  std::vector< std::pair<std::string,std::string> > ps2;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      {
-        (*it)->getMeshSENames(ps2);
-        break;
-      }
-  if(ps2.empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::getMeshSENames : this appears to not contain SE only !");
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      {
-        std::vector< std::pair<std::string,std::string> > ps3;
-        (*it)->getMeshSENames(ps3);
-        if(ps2!=ps3)
-          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::getMeshSENames : For the moment only homogeneous SE def through time managed !");
-      }
-  for(std::vector< std::pair<std::string,std::string> >::const_iterator it=ps2.begin();it!=ps2.end();it++)
-    {
-      std::vector< std::pair<std::string,std::string> >::iterator it2(std::find(ps.begin(),ps.end(),*it));
-      if(it2==ps.end())
-        ps.push_back(*it);
-    }
-}
-
-bool MEDFileAnyTypeFieldMultiTSWithoutSDA::presenceOfMultiDiscPerGeoType() const
-{
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
-      if(!cur)
-        continue;
-      if(cur->presenceOfMultiDiscPerGeoType())
-        return true;
-    }
-  return false;
-}
-
-const std::vector<std::string>& MEDFileAnyTypeFieldMultiTSWithoutSDA::getInfo() const
-{
-  return _infos;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::setInfo(const std::vector<std::string>& info)
-{
-  _infos=info;
-}
-
-int MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepPos(int iteration, int order) const
-{
-  int ret=0;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,ret++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *pt(*it);
-      if(pt->isDealingTS(iteration,order))
-        return ret;
-    }
-  std::ostringstream oss; oss << "MEDFileFieldMultiTS::getTimeStepPos : Muli timestep field on time (" << iteration << "," << order << ") does not exist ! Available (iteration,order) are :\n";
-  std::vector< std::pair<int,int> > vp=getIterations();
-  for(std::vector< std::pair<int,int> >::const_iterator it2=vp.begin();it2!=vp.end();it2++)
-    oss << "(" << (*it2).first << "," << (*it2).second << ") ";
-  throw INTERP_KERNEL::Exception(oss.str());
-}
-
-const MEDFileAnyTypeField1TSWithoutSDA& MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepEntry(int iteration, int order) const
-{
-  return *_time_steps[getTimeStepPos(iteration,order)];
-}
-
-MEDFileAnyTypeField1TSWithoutSDA& MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepEntry(int iteration, int order)
-{
-  return *_time_steps[getTimeStepPos(iteration,order)];
-}
-
-bool MEDFileAnyTypeFieldMultiTSWithoutSDA::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
-{
-  bool ret(false);
-  for(std::vector< std::pair<std::string,std::string> >::const_iterator it=modifTab.begin();it!=modifTab.end();it++)
-    {
-      if((*it).first==getMeshName())
-        {
-          setMeshName((*it).second);
-          ret=true;
-        }
-    }
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
-      if(cur)
-        ret=cur->changeMeshNames(modifTab) || ret;
-    }
-  return ret;
-}
-
-/*!
- * See doc at MEDFileField1TSWithoutSDA::getUndergroundDataArray
- */
-DataArray *MEDFileAnyTypeFieldMultiTSWithoutSDA::getUndergroundDataArray(int iteration, int order) const
-{
-  return getTimeStepEntry(iteration,order).getUndergroundDataArray();
-}
-
-/*!
- * See doc at MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt
- */
-DataArray *MEDFileAnyTypeFieldMultiTSWithoutSDA::getUndergroundDataArrayExt(int iteration, int order, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
-{
-  return getTimeStepEntry(iteration,order).getUndergroundDataArrayExt(entries);
-}
-
-bool MEDFileAnyTypeFieldMultiTSWithoutSDA::renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N,
-                                                                       MEDFileFieldGlobsReal& glob)
-{
-  bool ret=false;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      MEDFileAnyTypeField1TSWithoutSDA *f1ts(*it);
-      if(f1ts)
-        ret=f1ts->renumberEntitiesLyingOnMesh(meshName,oldCode,newCode,renumO2N,glob) || ret;
-    }
-  return ret;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::accept(MEDFileFieldVisitor& visitor) const
-{
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    if((*it).isNotNull())
-      {
-        visitor.newTimeStepEntry(*it);
-        (*it)->accept(visitor);
-        visitor.endTimeStepEntry(*it);
-      }
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const
-{
-  std::string startLine(bkOffset,' ');
-  oss << startLine << "Field multi time steps [Type=" << getTypeStr() << "]";
-  if(fmtsId>=0)
-    oss << " (" << fmtsId << ")";
-  oss << " has the following name: \"" << _name << "\"." << std::endl;
-  oss << startLine << "Field multi time steps has " << _infos.size() << " components with the following infos :" << std::endl;
-  for(std::vector<std::string>::const_iterator it=_infos.begin();it!=_infos.end();it++)
-    {
-      oss << startLine << "  -  \"" << *it << "\"" << std::endl;
-    }
-  int i=0;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,i++)
-    {
-      std::string chapter(17,'0'+i);
-      oss << startLine << chapter << std::endl;
-      const MEDFileAnyTypeField1TSWithoutSDA *cur=(*it);
-      if(cur)
-        cur->simpleRepr(bkOffset+2,oss,i);
-      else
-        oss << startLine << "  Field on one time step #" << i << " is not defined !" << std::endl;
-      oss << startLine << chapter << std::endl;
-    }
-}
-
-std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeSteps(std::vector<double>& ret1) const
-{
-  std::size_t sz=_time_steps.size();
-  std::vector< std::pair<int,int> > ret(sz);
-  ret1.resize(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *f1ts=_time_steps[i];
-      if(f1ts)
-        {
-          ret1[i]=f1ts->getTime(ret[i].first,ret[i].second);
-        }
-      else
-        {
-          std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::getTimeSteps : At rank #" << i << " time step is not defined. Invoke eraseEmptyTS method !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-    }
-  return ret;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep(MCAuto<MEDFileAnyTypeField1TSWithoutSDA>& tse)
-{
-  MEDFileAnyTypeField1TSWithoutSDA *tse2(tse);
-  if(!tse2)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep : input content object is null !");
-  checkCoherencyOfType(tse2);
-  if(_time_steps.empty())
-    {
-      setName(tse2->getName());
-      setMeshName(tse2->getMeshName());
-      setInfo(tse2->getInfo());
-    }
-  checkThatComponentsMatch(tse2->getInfo());
-  if(getDtUnit().empty() && !tse->getDtUnit().empty())
-    setDtUnit(tse->getDtUnit());
-  _time_steps.push_back(tse);
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::synchronizeNameScope()
-{
-  std::size_t nbOfCompo=_infos.size();
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      MEDFileAnyTypeField1TSWithoutSDA *cur=(*it);
-      if(cur)
-        {
-          if((cur->getInfo()).size()!=nbOfCompo)
-            {
-              std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::synchronizeNameScope : Mismatch in the number of components of parts ! Should be " << nbOfCompo;
-              oss << " ! but the field at iteration=" << cur->getIteration() << " order=" << cur->getOrder() << " has " << (cur->getInfo()).size() << " components !";
-              throw INTERP_KERNEL::Exception(oss.str());
-            }
-          cur->copyNameScope(*this);
-        }
-    }
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::loadStructureOrStructureAndBigArraysRecursively(med_idt fid, int nbPdt, med_field_type fieldTyp, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  _time_steps.resize(nbPdt);
-  for(int i=0;i<nbPdt;i++)
-    {
-      std::vector< std::pair<int,int> > ts;
-      med_int numdt=0,numo=0;
-      med_float dt=0.0;
-      MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,_name.c_str(),i+1,&numdt,&numo,&dt));
-      switch(fieldTyp)
-      {
-        case MED_FLOAT64:
-          {
-            _time_steps[i]=MEDFileField1TSWithoutSDA::New(getName(),getMeshName(),i+1,numdt,numo,_infos);
-            break;
-          }
-        case MED_INT32:
-          {
-            _time_steps[i]=MEDFileIntField1TSWithoutSDA::New(getName(),getMeshName(),i+1,numdt,numo,_infos);
-            break;
-          }
-        case MED_NODE://6432
-          {
-            _time_steps[i]=MEDFileFloatField1TSWithoutSDA::New(getName(),getMeshName(),i+1,numdt,numo,_infos);
-            break;
-          }
-        default:
-          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::loadStructureOrStructureAndBigArraysRecursively : managed field type are : FLOAT64, INT32, FLOAT32 !");
-      }
-      if(loadAll)
-        _time_steps[i]->loadStructureAndBigArraysRecursively(fid,*this,ms,entities);
-      else
-        _time_steps[i]->loadOnlyStructureOfDataRecursively(fid,*this,ms,entities);
-      synchronizeNameScope();
-    }
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::writeLL(med_idt fid, const MEDFileWritable& opts) const
-{
-  if(_time_steps.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::writeLL : no time steps set !");
-  checkThatNbOfCompoOfTSMatchThis();
-  std::vector<std::string> infos(getInfo());
-  int nbComp=infos.size();
-  INTERP_KERNEL::AutoPtr<char> comp=MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE);
-  INTERP_KERNEL::AutoPtr<char> unit=MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE);
-  for(int i=0;i<nbComp;i++)
-    {
-      std::string info=infos[i];
-      std::string c,u;
-      MEDLoaderBase::splitIntoNameAndUnit(info,c,u);
-      MEDLoaderBase::safeStrCpy2(c.c_str(),MED_SNAME_SIZE,comp+i*MED_SNAME_SIZE,opts.getTooLongStrPolicy());
-      MEDLoaderBase::safeStrCpy2(u.c_str(),MED_SNAME_SIZE,unit+i*MED_SNAME_SIZE,opts.getTooLongStrPolicy());
-    }
-  if(_name.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::write : MED file does not accept field with empty name !");
-  MEDFILESAFECALLERWR0(MEDfieldCr,(fid,_name.c_str(),getMEDFileFieldType(),nbComp,comp,unit,getDtUnit().c_str(),getMeshName().c_str()));
-  int nbOfTS=_time_steps.size();
-  for(int i=0;i<nbOfTS;i++)
-    _time_steps[i]->writeLL(fid,opts,*this);
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
-{
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
-      if(elt)
-        elt->loadBigArraysRecursively(fid,nasc);
-    }
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc)
-{
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
-      if(elt)
-        elt->loadBigArraysRecursivelyIfNecessary(fid,nasc);
-    }
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::unloadArrays()
-{
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
-      if(elt)
-        elt->unloadArrays();
-    }
-}
-
-int MEDFileAnyTypeFieldMultiTSWithoutSDA::getNumberOfTS() const
-{
-  return _time_steps.size();
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseEmptyTS()
-{
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  > newTS;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *tmp=(*it);
-      if(tmp)
-        newTS.push_back(*it);
-    }
-  _time_steps=newTS;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseTimeStepIds(const int *startIds, const int *endIds)
-{
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > newTS;
-  int maxId=(int)_time_steps.size();
-  int ii=0;
-  std::set<int> idsToDel;
-  for(const int *id=startIds;id!=endIds;id++,ii++)
-    {
-      if(*id>=0 && *id<maxId)
-        {
-          idsToDel.insert(*id);
-        }
-      else
-        {
-          std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::eraseTimeStepIds : At pos #" << ii << " request for id=" << *id << " not in [0," << maxId << ") !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-    }
-  for(int iii=0;iii<maxId;iii++)
-    if(idsToDel.find(iii)==idsToDel.end())
-      newTS.push_back(_time_steps[iii]);
-  _time_steps=newTS;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseTimeStepIds2(int bg, int end, int step)
-{
-  static const char msg[]="MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseTimeStepIds2";
-  int nbOfEntriesToKill=DataArrayInt::GetNumberOfItemGivenBESRelative(bg,end,step,msg);
-  if(nbOfEntriesToKill==0)
-    return ;
-  std::size_t sz=_time_steps.size();
-  std::vector<bool> b(sz,true);
-  int j=bg;
-  for(int i=0;i<nbOfEntriesToKill;i++,j+=step)
-    b[j]=false;
-  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > newTS;
-  for(std::size_t i=0;i<sz;i++)
-    if(b[i])
-      newTS.push_back(_time_steps[i]);
-  _time_steps=newTS;
-}
-
-int MEDFileAnyTypeFieldMultiTSWithoutSDA::getPosOfTimeStep(int iteration, int order) const
-{
-  int ret=0;
-  std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::getPosOfTimeStep : No such time step (" << iteration << "," << order << ") !\nPossibilities are : "; 
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,ret++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *tmp(*it);
-      if(tmp)
-        {
-          int it2,ord;
-          tmp->getTime(it2,ord);
-          if(it2==iteration && order==ord)
-            return ret;
-          else
-            oss << "(" << it2 << ","  << ord << "), ";
-        }
-    }
-  throw INTERP_KERNEL::Exception(oss.str());
-}
-
-int MEDFileAnyTypeFieldMultiTSWithoutSDA::getPosGivenTime(double time, double eps) const
-{
-  int ret=0;
-  std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::getPosGivenTime : No such time step " << time << "! \nPossibilities are : ";
-  oss.precision(15);
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,ret++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *tmp(*it);
-      if(tmp)
-        {
-          int it2,ord;
-          double ti=tmp->getTime(it2,ord);
-          if(fabs(time-ti)<eps)
-            return ret;
-          else
-            oss << ti << ", ";
-        }
-    }
-  throw INTERP_KERNEL::Exception(oss.str());
-}
-
-std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTSWithoutSDA::getIterations() const
-{
-  int lgth=_time_steps.size();
-  std::vector< std::pair<int,int> > ret(lgth);
-  for(int i=0;i<lgth;i++)
-    _time_steps[i]->fillIteration(ret[i]);
-  return ret;
-}
-
-/*!
- * This method has 3 inputs 'iteration' 'order' 'mname'. 'mname' can be null if the user is the general case where there is only one meshName lying on 'this'
- * This method returns two things.
- * - The absolute dimension of 'this' in first parameter. 
- * - The available ext levels relative to the absolute dimension returned in first parameter. These relative levels are relative
- *   to the first output parameter. The values in 'levs' will be returned in decreasing order.
- *
- * This method is designed for MEDFileFieldMultiTS instances that have a discritization ON_CELLS, ON_GAUSS_NE and ON_GAUSS.
- * Only these 3 discretizations will be taken into account here.
- *
- * If 'this' is empty this method will throw an INTERP_KERNEL::Exception.
- * If there is \b only node fields defined in 'this' -1 is returned and 'levs' output parameter will be empty. In this
- * case the caller has to know the underlying mesh it refers to. By defaut it is the level 0 of the corresponding mesh.
- *
- * This method is usefull to make the link between meshDimension of the underlying mesh in 'this' and the levels on 'this'.
- * It is possible (even if it is not common) that the highest level in 'this' were not equal to the meshDimension of the underlying mesh in 'this'.
- * 
- * Let's consider the typical following case :
- * - a mesh 'm1' has a meshDimension 3 and has the following non empty levels
- * [0,-1,-2] for example 'm1' lies on TETRA4, HEXA8 TRI3 and SEG2
- * - 'f1' lies on 'm1' and is defined on 3D and 1D cells for example
- *   TETRA4 and SEG2
- * - 'f2' lies on 'm1' too and is defined on 2D and 1D cells for example TRI3 and SEG2
- *
- * In this case f1->getNonEmptyLevelsExt will return (3,[0,-2]) and f2->getNonEmptyLevelsExt will return (2,[0,-1])
- * 
- * To retrieve the highest level of f1 it should be done, f1->getFieldAtLevel(ON_CELLS,3-3+0);//absDim-meshDim+relativeLev
- * To retrieve the lowest level of f1 it should be done, f1->getFieldAtLevel(ON_CELLS,3-3+(-2));//absDim-meshDim+relativeLev
- * To retrieve the highest level of f2 it should be done, f1->getFieldAtLevel(ON_CELLS,2-3+0);//absDim-meshDim+relativeLev
- * To retrieve the lowest level of f2 it should be done, f1->getFieldAtLevel(ON_CELLS,2-3+(-1));//absDim-meshDim+relativeLev
- */
-int MEDFileAnyTypeFieldMultiTSWithoutSDA::getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const
-{
-  return getTimeStepEntry(iteration,order).getNonEmptyLevels(mname,levs);
-}
-
-const MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2(int pos) const
-{
-  if(pos<0 || pos>=(int)_time_steps.size())
-    {
-      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << " whereas should be in [0," << _time_steps.size() << ") !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  const MEDFileAnyTypeField1TSWithoutSDA *item=_time_steps[pos];
-  if(item==0)
-    {
-      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << ", this pos id exists but the underlying Field1TS is null !";
-      oss << "\nTry to use following method eraseEmptyTS !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  return item;
-}
-
-MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2(int pos)
-{
-  if(pos<0 || pos>=(int)_time_steps.size())
-    {
-      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << " whereas should be in [0," << _time_steps.size() << ") !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  MEDFileAnyTypeField1TSWithoutSDA *item=_time_steps[pos];
-  if(item==0)
-    {
-      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << ", this pos id exists but the underlying Field1TS is null !";
-      oss << "\nTry to use following method eraseEmptyTS !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  return item;
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getPflsReallyUsed2() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getPflsReallyUsed2();
-      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
-        if(ret2.find(*it2)==ret2.end())
-          {
-            ret.push_back(*it2);
-            ret2.insert(*it2);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getLocsReallyUsed2() const
-{
-  std::vector<std::string> ret;
-  std::set<std::string> ret2;
-  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getLocsReallyUsed2();
-      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
-        if(ret2.find(*it2)==ret2.end())
-          {
-            ret.push_back(*it2);
-            ret2.insert(*it2);
-          }
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getPflsReallyUsedMulti2() const
-{
-  std::vector<std::string> ret;
-  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getPflsReallyUsedMulti2();
-      ret.insert(ret.end(),tmp.begin(),tmp.end());
-    }
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getLocsReallyUsedMulti2() const
-{
-  std::vector<std::string> ret;
-  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    {
-      std::vector<std::string> tmp=(*it)->getLocsReallyUsedMulti2();
-      ret.insert(ret.end(),tmp.begin(),tmp.end());
-    }
-  return ret;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    (*it)->changePflsRefsNamesGen2(mapOfModif);
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
-    (*it)->changeLocsRefsNamesGen2(mapOfModif);
-}
-
-std::vector< std::vector<TypeOfField> > MEDFileAnyTypeFieldMultiTSWithoutSDA::getTypesOfFieldAvailable() const
-{
-  int lgth=_time_steps.size();
-  std::vector< std::vector<TypeOfField> > ret(lgth);
-  for(int i=0;i<lgth;i++)
-    _time_steps[i]->fillTypesOfFieldAvailable(ret[i]);
-  return ret;
-}
-
-/*!
- * entry point for users that want to iterate into MEDFile DataStructure without any overhead.
- */
-std::vector< std::vector< std::pair<int,int> > > MEDFileAnyTypeFieldMultiTSWithoutSDA::getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  return getTimeStepEntry(iteration,order).getFieldSplitedByType(mname,types,typesF,pfls,locs);
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::deepCopy() const
-{
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret=shallowCpy();
-  std::size_t i=0;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,i++)
-    {
-      if((const MEDFileAnyTypeField1TSWithoutSDA *)*it)
-        ret->_time_steps[i]=(*it)->deepCopy();
-    }
-  return ret.retn();
-}
-
-std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > MEDFileAnyTypeFieldMultiTSWithoutSDA::splitComponents() const
-{
-  std::size_t sz(_infos.size()),sz2(_time_steps.size());
-  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > ret(sz);
-  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > ts(sz2);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      ret[i]=shallowCpy();
-      ret[i]->_infos.resize(1); ret[i]->_infos[0]=_infos[i];
-    }
-  for(std::size_t i=0;i<sz2;i++)
-    {
-      std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret1=_time_steps[i]->splitComponents();
-      if(ret1.size()!=sz)
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::splitComponents : At rank #" << i << " number of components is " << ret1.size() << " whereas it should be for all time steps " << sz << " !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      ts[i]=ret1;
-    }
-  for(std::size_t i=0;i<sz;i++)
-    for(std::size_t j=0;j<sz2;j++)
-      ret[i]->_time_steps[j]=ts[j][i];
-  return ret;
-}
-
-/*!
- * This method splits into discretization each time steps in \a this.
- * ** WARNING ** the returned instances are not compulsary defined on the same time steps series !
- */
-std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > MEDFileAnyTypeFieldMultiTSWithoutSDA::splitDiscretizations() const
-{
-  std::size_t sz(_time_steps.size());
-  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > items(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *timeStep(_time_steps[i]);
-      if(!timeStep)
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::splitDiscretizations : time step #" << i << " is null !"; 
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      items[i]=timeStep->splitDiscretizations();  
-    }
-  //
-  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > ret;
-  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > ret2;
-  std::vector< TypeOfField > types;
-  for(std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > >::const_iterator it0=items.begin();it0!=items.end();it0++)
-    for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it1=(*it0).begin();it1!=(*it0).end();it1++)
-      {
-        std::vector<TypeOfField> ts=(*it1)->getTypesOfFieldAvailable();
-        if(ts.size()!=1)
-          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::splitDiscretizations : it appears that the splitting of MEDFileAnyTypeField1TSWithoutSDA::splitDiscretizations has returned invalid result !");
-        std::vector< TypeOfField >::iterator it2=std::find(types.begin(),types.end(),ts[0]);
-        if(it2==types.end())
-          types.push_back(ts[0]);
-      }
-  ret.resize(types.size()); ret2.resize(types.size());
-  for(std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > >::const_iterator it0=items.begin();it0!=items.end();it0++)
-    for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it1=(*it0).begin();it1!=(*it0).end();it1++)
-      {
-        TypeOfField typ=(*it1)->getTypesOfFieldAvailable()[0];
-        std::size_t pos=std::distance(types.begin(),std::find(types.begin(),types.end(),typ));
-        ret2[pos].push_back(*it1);
-      }
-  for(std::size_t i=0;i<types.size();i++)
-    {
-      MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> elt(createNew());
-      for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it1=ret2[i].begin();it1!=ret2[i].end();it1++)
-        elt->pushBackTimeStep(*it1);//also updates infos in elt
-      ret[i]=elt;
-      elt->MEDFileFieldNameScope::operator=(*this);
-    }
-  return ret;
-}
-
-/*!
- * Contrary to splitDiscretizations method this method makes the hypothesis that the times series are **NOT** impacted by the splitting of multi discretization.
- */
-std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes() const
-{
-  std::size_t sz(_time_steps.size());
-  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > items(sz);
-  std::size_t szOut(std::numeric_limits<std::size_t>::max());
-  for(std::size_t i=0;i<sz;i++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *timeStep(_time_steps[i]);
-      if(!timeStep)
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes : time step #" << i << " is null !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      items[i]=timeStep->splitMultiDiscrPerGeoTypes();
-      if(szOut==std::numeric_limits<std::size_t>::max())
-        szOut=items[i].size();
-      else
-        if(items[i].size()!=szOut)
-          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes : The splitting per discretization is expected to be same among time steps !");
-    }
-  if(szOut==std::numeric_limits<std::size_t>::max())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes : empty field !");
-  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > ret(szOut);
-  for(std::size_t i=0;i<szOut;i++)
-    {
-      MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> elt(createNew());
-      for(std::size_t j=0;j<sz;j++)
-        elt->pushBackTimeStep(items[j][i]);
-      ret[i]=elt;
-      elt->MEDFileFieldNameScope::operator=(*this);
-    }
-  return ret;
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr)
-{
-  setName(field->getName());
-  if(field->getMesh())
-    setMeshName(field->getMesh()->getName());
-  if(_name.empty())
-    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::copyTinyInfoFrom : unsupported fields with no name in MED file !");
-  if(!arr)
-    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::copyTinyInfoFrom : no array set !");
-  _infos=arr->getInfoOnComponents();
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::checkCoherencyOfTinyInfo(const MEDCouplingFieldDouble *field, const DataArray *arr) const
-{
-  static const char MSG[]="MEDFileFieldMultiTSWithoutSDA::checkCoherencyOfTinyInfo : invalid ";
-  if(_name!=field->getName())
-    {
-      std::ostringstream oss; oss << MSG << "name ! should be \"" << _name;
-      oss << "\" and it is set in input field to \"" << field->getName() << "\" !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  if(!arr)
-    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::checkCoherencyOfTinyInfo : no array set !");
-  checkThatComponentsMatch(arr->getInfoOnComponents());
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::checkThatComponentsMatch(const std::vector<std::string>& compos) const
-{
-  static const char MSG[]="MEDFileFieldMultiTSWithoutSDA::checkThatComponentsMatch : ";
-  if(getInfo().size()!=compos.size())
-    {
-      std::ostringstream oss; oss << MSG << "mismatch of number of components between this (" << getInfo().size() << ") and ";
-      oss << " number of components of element to append (" << compos.size() << ") !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  if(_infos!=compos)
-    {
-      std::ostringstream oss; oss << MSG << "components have same size but are different ! should be \"";
-      std::copy(_infos.begin(),_infos.end(),std::ostream_iterator<std::string>(oss,", "));
-      oss << " But compo in input fields are : ";
-      std::copy(compos.begin(),compos.end(),std::ostream_iterator<std::string>(oss,", "));
-      oss << " !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::checkThatNbOfCompoOfTSMatchThis() const
-{
-  std::size_t sz=_infos.size();
-  int j=0;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,j++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
-      if(elt)
-        if(elt->getInfo().size()!=sz)
-          {
-            std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::checkThatNbOfCompoOfTSMatchThis : At pos #" << j << " the number of components is equal to ";
-            oss << elt->getInfo().size() << " whereas it is expected to be equal to " << sz << " !";
-            throw INTERP_KERNEL::Exception(oss.str());
-          }
-    }
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::appendFieldNoProfileSBT(const MEDCouplingFieldDouble *field, const DataArray *arr, MEDFileFieldGlobsReal& glob)
-{
-  if(!field)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::appendFieldNoProfileSBT : input field is NULL !");
-  if(!_time_steps.empty())
-    checkCoherencyOfTinyInfo(field,arr);
-  MEDFileAnyTypeField1TSWithoutSDA *objC(createNew1TSWithoutSDAEmptyInstance());
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> obj(objC);
-  {
-    MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::New(*field));
-    objC->setFieldNoProfileSBT(field->timeDiscrSafe(),ft,arr,glob,*this);
-  }
-  copyTinyInfoFrom(field,arr);
-  _time_steps.push_back(obj);
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::appendFieldProfile(const MEDCouplingFieldDouble *field, const DataArray *arr, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob)
-{
-  if(!field)
-    throw INTERP_KERNEL::Exception("MEDFileIntFieldMultiTSWithoutSDA::appendFieldNoProfileSBT : input field is NULL !");
-  if(!_time_steps.empty())
-    checkCoherencyOfTinyInfo(field,arr);
-  MEDFileAnyTypeField1TSWithoutSDA *objC=createNew1TSWithoutSDAEmptyInstance();
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> obj(objC);
-  {
-    MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::NewWithoutCheck(*field));
-    objC->setFieldProfile(field->timeDiscrSafe(),ft,arr,mesh,meshDimRelToMax,profile,glob,*this);
-  }
-  copyTinyInfoFrom(field,arr);
-  setMeshName(objC->getMeshName());
-  _time_steps.push_back(obj);
-}
-
-void MEDFileAnyTypeFieldMultiTSWithoutSDA::setIteration(int i, MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ts)
-{
-  int sz=(int)_time_steps.size();
-  if(i<0 || i>=sz)
-    {
-      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::setIteration : trying to set element at place #" << i << " should be in [0," << sz << ") !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  const MEDFileAnyTypeField1TSWithoutSDA *tsPtr(ts);
-  if(tsPtr)
-    {
-      if(tsPtr->getNumberOfComponents()!=(int)_infos.size())
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::setIteration : trying to set element with " << tsPtr->getNumberOfComponents() << " components ! Should be " << _infos.size() <<  " !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-    }
-  _time_steps[i]=ts;
-}
-
-//= MEDFileFieldMultiTSWithoutSDA
-
-/*!
- * entry point for users that want to iterate into MEDFile DataStructure with a reduced overhead because output arrays are extracted (created) specially
- * for the call of this method. That's why the DataArrayDouble instance in returned vector of vector should be dealed by the caller.
- */
-std::vector< std::vector<DataArrayDouble *> > MEDFileFieldMultiTSWithoutSDA::getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  const MEDFileAnyTypeField1TSWithoutSDA& myF1TS=getTimeStepEntry(iteration,order);
-  const MEDFileField1TSWithoutSDA *myF1TSC=dynamic_cast<const MEDFileField1TSWithoutSDA *>(&myF1TS);
-  if(!myF1TSC)
-    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::getFieldSplitedByType2 : mismatch of type of field expecting FLOAT64 !");
-  return myF1TSC->getFieldSplitedByType2(mname,types,typesF,pfls,locs);
-}
-
-MEDFileIntFieldMultiTSWithoutSDA *MEDFileFieldMultiTSWithoutSDA::convertToInt() const
-{
-  MCAuto<MEDFileIntFieldMultiTSWithoutSDA> ret(new MEDFileIntFieldMultiTSWithoutSDA);
-  ret->MEDFileAnyTypeFieldMultiTSWithoutSDA::operator =(*this);
-  int i=0;
-  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,i++)
-    {
-      const MEDFileAnyTypeField1TSWithoutSDA *eltToConv(*it);
-      if(eltToConv)
-        {
-          const MEDFileField1TSWithoutSDA *eltToConvC=dynamic_cast<const MEDFileField1TSWithoutSDA *>(eltToConv);
-          if(!eltToConvC)
-            throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::convertToInt : presence of an invalid 1TS type ! Should be of type FLOAT64 !");
-          MCAuto<MEDFileAnyTypeField1TSWithoutSDA> elt=eltToConvC->convertToInt();
-          ret->setIteration(i,elt);
-        }
-    }
-  return ret.retn();
-}
-
-//= MEDFileAnyTypeFieldMultiTS
-
-MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS()
-{
-}
-
-MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
-try:MEDFileFieldGlobsReal(fid)
-{
-  _content=BuildContentFrom(fid,loadAll,ms);
-  loadGlobals(fid);
-}
-catch(INTERP_KERNEL::Exception& e)
-{
-    throw e;
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-{
-  med_field_type typcha;
-  std::vector<std::string> infos;
-  std::string dtunit;
-  std::string meshName;
-  int i(-1);
-  MEDFileAnyTypeField1TS::LocateField(fid,fieldName,i,typcha,infos,dtunit,meshName);
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret;
-  switch(typcha)
-  {
-    case MED_FLOAT64:
-      {
-        ret=new MEDFileFieldMultiTSWithoutSDA(fid,i,loadAll,ms,entities);
-        break;
-      }
-    case MED_INT32:
-      {
-        ret=new MEDFileIntFieldMultiTSWithoutSDA(fid,i,loadAll,ms,entities);
-        break;
-      }
-    case MED_NODE://6432
-      {
-        ret=new MEDFileFloatFieldMultiTSWithoutSDA(fid,i,loadAll,ms,entities);
-        break;
-      }
-    default:
-      {
-        std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::BuildContentFrom(fid,fieldName) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
-        throw INTERP_KERNEL::Exception(oss.str());
-      }
-  }
-  ret->setMeshName(meshName);
-  ret->setDtUnit(dtunit.c_str());
-  return ret.retn();
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
-{
-  med_field_type typcha;
-  //
-  std::vector<std::string> infos;
-  std::string dtunit,fieldName,meshName;
-  MEDFileAnyTypeField1TS::LocateField2(fid,0,true,fieldName,typcha,infos,dtunit,meshName);
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret;
-  switch(typcha)
-  {
-    case MED_FLOAT64:
-      {
-        ret=new MEDFileFieldMultiTSWithoutSDA(fid,0,loadAll,ms,0);
-        break;
-      }
-    case MED_INT32:
-      {
-        ret=new MEDFileIntFieldMultiTSWithoutSDA(fid,0,loadAll,ms,0);
-        break;
-      }
-    case MED_NODE://6432
-      {
-        ret=new MEDFileFloatFieldMultiTSWithoutSDA(fid,0,loadAll,ms,0);
-        break;
-      }
-    default:
-      {
-        std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::BuildContentFrom(fid) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of the first field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
-        throw INTERP_KERNEL::Exception(oss.str());
-      }
-  }
-  ret->setMeshName(meshName);
-  ret->setDtUnit(dtunit.c_str());
-  return ret.retn();
-}
-
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c)
-{
-  if(!c)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent : empty content in input : unable to build a new instance !");
-  if(dynamic_cast<const MEDFileFieldMultiTSWithoutSDA *>(c))
-    {
-      MCAuto<MEDFileFieldMultiTS> ret(MEDFileFieldMultiTS::New());
-      ret->_content=c;  c->incrRef();
-      return ret.retn();
-    }
-  if(dynamic_cast<const MEDFileIntFieldMultiTSWithoutSDA *>(c))
-    {
-      MCAuto<MEDFileIntFieldMultiTS> ret(MEDFileIntFieldMultiTS::New());
-      ret->_content=c;  c->incrRef();
-      return ret.retn();
-    }
-  throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent : internal error ! a content of type different from FLOAT64 and INT32 has been built but not intercepted !");
-}
-
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c, med_idt fid)
-{
-  MEDFileAnyTypeFieldMultiTS *ret(BuildNewInstanceFromContent(c));
-  std::string fileName(FileNameFromFID(fid));
-  ret->setFileName(fileName);
-  return ret;
-}
-
-MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-try:MEDFileFieldGlobsReal(fid)
-{
-  _content=BuildContentFrom(fid,fieldName,loadAll,ms,entities);
-  loadGlobals(fid);
-}
-catch(INTERP_KERNEL::Exception& e)
-{
-    throw e;
-}
-
-//= MEDFileAnyTypeFieldMultiTS
-
-/*!
- * Returns a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS holding data of the first field
- * that has been read from a specified MED file.
- *  \param [in] fileName - the name of the MED file to read.
- *  \return MEDFileFieldMultiTS * - a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS. The caller
- *          is to delete this field using decrRef() as it is no more needed.
- *  \throw If reading the file fails.
- */
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(const std::string& fileName, bool loadAll)
-{
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
-  return New(fid,loadAll);
-}
-
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(med_idt fid, bool loadAll)
-{
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c(BuildContentFrom(fid,loadAll,0));
-  MCAuto<MEDFileAnyTypeFieldMultiTS> ret(BuildNewInstanceFromContent(c,fid));
-  ret->loadGlobals(fid);
-  return ret.retn();
-}
-
-/*!
- * Returns a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS holding data of a given field
- * that has been read from a specified MED file.
- *  \param [in] fileName - the name of the MED file to read.
- *  \param [in] fieldName - the name of the field to read.
- *  \return MEDFileFieldMultiTS * - a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS. The caller
- *          is to delete this field using decrRef() as it is no more needed.
- *  \throw If reading the file fails.
- *  \throw If there is no field named \a fieldName in the file.
- */
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(const std::string& fileName, const std::string& fieldName, bool loadAll)
-{
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
-  return New(fid,fieldName,loadAll);
-}
-
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(med_idt fid, const std::string& fieldName, bool loadAll)
-{
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c(BuildContentFrom(fid,fieldName,loadAll,0,0));
-  MCAuto<MEDFileAnyTypeFieldMultiTS> ret(BuildNewInstanceFromContent(c,fid));
-  ret->loadGlobals(fid);
-  return ret.retn();
-}
-
-/*!
- * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
- * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
- *
- * \warning this is a shallow copy constructor
- */
-MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS(const MEDFileAnyTypeFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent)
-{
-  if(!shallowCopyOfContent)
-    {
-      const MEDFileAnyTypeFieldMultiTSWithoutSDA *otherPtr(&other);
-      otherPtr->incrRef();
-      _content=const_cast<MEDFileAnyTypeFieldMultiTSWithoutSDA *>(otherPtr);
-    }
-  else
-    {
-      _content=other.shallowCpy();
-    }
-}
-
-MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::contentNotNullBase()
-{
-  MEDFileAnyTypeFieldMultiTSWithoutSDA *ret=_content;
-  if(!ret)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS : content is expected to be not null !");
-  return ret;
-}
-
-const MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::contentNotNullBase() const
-{
-  const MEDFileAnyTypeFieldMultiTSWithoutSDA *ret=_content;
-  if(!ret)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS : const content is expected to be not null !");
-  return ret;
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getPflsReallyUsed() const
-{
-  return contentNotNullBase()->getPflsReallyUsed2();
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getLocsReallyUsed() const
-{
-  return contentNotNullBase()->getLocsReallyUsed2();
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getPflsReallyUsedMulti() const
-{
-  return contentNotNullBase()->getPflsReallyUsedMulti2();
-}
-
-std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getLocsReallyUsedMulti() const
-{
-  return contentNotNullBase()->getLocsReallyUsedMulti2();
-}
-
-void MEDFileAnyTypeFieldMultiTS::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  contentNotNullBase()->changePflsRefsNamesGen2(mapOfModif);
-}
-
-void MEDFileAnyTypeFieldMultiTS::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
-{
-  contentNotNullBase()->changeLocsRefsNamesGen2(mapOfModif);
-}
-
-int MEDFileAnyTypeFieldMultiTS::getNumberOfTS() const
-{
-  return contentNotNullBase()->getNumberOfTS();
-}
-
-void MEDFileAnyTypeFieldMultiTS::eraseEmptyTS()
-{
-  contentNotNullBase()->eraseEmptyTS();
-}
-
-void MEDFileAnyTypeFieldMultiTS::eraseTimeStepIds(const int *startIds, const int *endIds)
-{
-  contentNotNullBase()->eraseTimeStepIds(startIds,endIds);
-}
-
-void MEDFileAnyTypeFieldMultiTS::eraseTimeStepIds2(int bg, int end, int step)
-{
-  contentNotNullBase()->eraseTimeStepIds2(bg,end,step);
-}
-
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::buildSubPart(const int *startIds, const int *endIds) const
-{
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c=contentNotNullBase()->buildFromTimeStepIds(startIds,endIds);
-  MCAuto<MEDFileAnyTypeFieldMultiTS> ret=shallowCpy();
-  ret->_content=c;
-  return ret.retn();
-}
-
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::buildSubPartSlice(int bg, int end, int step) const
-{
-  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c=contentNotNullBase()->buildFromTimeStepIds2(bg,end,step);
-  MCAuto<MEDFileAnyTypeFieldMultiTS> ret=shallowCpy();
-  ret->_content=c;
-  return ret.retn();
-}
-
-std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTS::getIterations() const
-{
-  return contentNotNullBase()->getIterations();
-}
-
-void MEDFileAnyTypeFieldMultiTS::pushBackTimeSteps(const std::vector<MEDFileAnyTypeField1TS *>& f1ts)
-{
-  for(std::vector<MEDFileAnyTypeField1TS *>::const_iterator it=f1ts.begin();it!=f1ts.end();it++)
-    pushBackTimeStep(*it);
-}
-
-void MEDFileAnyTypeFieldMultiTS::pushBackTimeSteps(MEDFileAnyTypeFieldMultiTS *fmts)
-{
-  if(!fmts)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::pushBackTimeSteps : Input fmts is NULL !");
-  int nbOfTS(fmts->getNumberOfTS());
-  for(int i=0;i<nbOfTS;i++)
-    {
-      MCAuto<MEDFileAnyTypeField1TS> elt(fmts->getTimeStepAtPos(i));
-      pushBackTimeStep(elt);
-    }
-}
-
-void MEDFileAnyTypeFieldMultiTS::pushBackTimeStep(MEDFileAnyTypeField1TS *f1ts)
-{
-  if(!f1ts)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep : input pointer is NULL !");
-  checkCoherencyOfType(f1ts);
-  f1ts->incrRef();
-  MCAuto<MEDFileAnyTypeField1TS> f1tsSafe(f1ts);
-  MEDFileAnyTypeField1TSWithoutSDA *c=f1ts->contentNotNullBase();
-  c->incrRef();
-  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> cSafe(c);
-  if(!((MEDFileAnyTypeFieldMultiTSWithoutSDA *)_content))
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep : no content in this !");
-  _content->pushBackTimeStep(cSafe);
-  appendGlobs(*f1ts,1e-12);
-}
-
-void MEDFileAnyTypeFieldMultiTS::synchronizeNameScope()
-{
-  contentNotNullBase()->synchronizeNameScope();
-}
-
-int MEDFileAnyTypeFieldMultiTS::getPosOfTimeStep(int iteration, int order) const
-{
-  return contentNotNullBase()->getPosOfTimeStep(iteration,order);
-}
-
-int MEDFileAnyTypeFieldMultiTS::getPosGivenTime(double time, double eps) const
-{
-  return contentNotNullBase()->getPosGivenTime(time,eps);
-}
-
-int MEDFileAnyTypeFieldMultiTS::getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const
-{
-  return contentNotNullBase()->getNonEmptyLevels(iteration,order,mname,levs);
-}
-
-std::vector< std::vector<TypeOfField> > MEDFileAnyTypeFieldMultiTS::getTypesOfFieldAvailable() const
-{
-  return contentNotNullBase()->getTypesOfFieldAvailable();
-}
-
-std::vector< std::vector< std::pair<int,int> > > MEDFileAnyTypeFieldMultiTS::getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  return contentNotNullBase()->getFieldSplitedByType(iteration,order,mname,types,typesF,pfls,locs);
-}
-
-std::string MEDFileAnyTypeFieldMultiTS::getName() const
-{
-  return contentNotNullBase()->getName();
-}
-
-void MEDFileAnyTypeFieldMultiTS::setName(const std::string& name)
-{
-  contentNotNullBase()->setName(name);
-}
-
-std::string MEDFileAnyTypeFieldMultiTS::getDtUnit() const
-{
-  return contentNotNullBase()->getDtUnit();
-}
-
-void MEDFileAnyTypeFieldMultiTS::setDtUnit(const std::string& dtUnit)
-{
-  contentNotNullBase()->setDtUnit(dtUnit);
-}
-
-void MEDFileAnyTypeFieldMultiTS::simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const
-{
-  contentNotNullBase()->simpleRepr(bkOffset,oss,fmtsId);
-}
-
-std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTS::getTimeSteps(std::vector<double>& ret1) const
-{
-  return contentNotNullBase()->getTimeSteps(ret1);
-}
-
-std::string MEDFileAnyTypeFieldMultiTS::getMeshName() const
-{
-  return contentNotNullBase()->getMeshName();
-}
-
-void MEDFileAnyTypeFieldMultiTS::setMeshName(const std::string& newMeshName)
-{
-  contentNotNullBase()->setMeshName(newMeshName);
-}
-
-bool MEDFileAnyTypeFieldMultiTS::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
-{
-  return contentNotNullBase()->changeMeshNames(modifTab);
-}
-
-const std::vector<std::string>& MEDFileAnyTypeFieldMultiTS::getInfo() const
-{
-  return contentNotNullBase()->getInfo();
-}
-
-bool MEDFileAnyTypeFieldMultiTS::presenceOfMultiDiscPerGeoType() const
-{
-  return contentNotNullBase()->presenceOfMultiDiscPerGeoType();
-}
-
-void MEDFileAnyTypeFieldMultiTS::setInfo(const std::vector<std::string>& info)
-{
-  return contentNotNullBase()->setInfo(info);
-}
-
-int MEDFileAnyTypeFieldMultiTS::getNumberOfComponents() const
-{
-  const std::vector<std::string> ret=getInfo();
-  return (int)ret.size();
-}
-
-void MEDFileAnyTypeFieldMultiTS::writeLL(med_idt fid) const
-{
-  writeGlobals(fid,*this);
-  contentNotNullBase()->writeLL(fid,*this);
-}
-
-/*!
- * This method alloc the arrays and load potentially huge arrays contained in this field.
- * This method should be called when a MEDFileAnyTypeFieldMultiTS::New constructor has been with false as the last parameter.
- * This method can be also called to refresh or reinit values from a file.
- * 
- * \throw If the fileName is not set or points to a non readable MED file.
- */
-void MEDFileAnyTypeFieldMultiTS::loadArrays()
-{
-  if(getFileName().empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::loadArrays : the structure does not come from a file !");
-  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
-  contentNotNullBase()->loadBigArraysRecursively(fid,*contentNotNullBase());
-}
-
-/*!
- * This method behaves as MEDFileAnyTypeFieldMultiTS::loadArrays does, the first call, if \a this was built using a file without loading big arrays.
- * But once data loaded once, this method does nothing.
- * 
- * \throw If the fileName is not set or points to a non readable MED file.
- * \sa MEDFileAnyTypeFieldMultiTS::loadArrays, MEDFileAnyTypeFieldMultiTS::unloadArrays
- */
-void MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary()
-{
-  if(!getFileName().empty())
-    {
-      MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
-      contentNotNullBase()->loadBigArraysRecursivelyIfNecessary(fid,*contentNotNullBase());
-    }
-}
-
-/*!
- * This method releases potentially big data arrays and so returns to the same heap memory than status loaded with 'loadAll' parameter set to false.
- * \b WARNING, this method does release arrays even if \a this does not come from a load of a MED file.
- * So this method can lead to a loss of data. If you want to unload arrays safely call MEDFileAnyTypeFieldMultiTS::unloadArraysWithoutDataLoss instead.
- * 
- * \sa MEDFileAnyTypeFieldMultiTS::loadArrays, MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary, MEDFileAnyTypeFieldMultiTS::unloadArraysWithoutDataLoss
- */
-void MEDFileAnyTypeFieldMultiTS::unloadArrays()
-{
-  contentNotNullBase()->unloadArrays();
-}
-
-/*!
- * This method potentially releases big data arrays if \a this is coming from a file. If \a this has been built from scratch this method will have no effect.
- * This method is the symetrical method of MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary.
- * This method is useful to reduce \b safely amount of heap memory necessary for \a this by using MED file as database.
- * 
- * \sa MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary
- */
-void MEDFileAnyTypeFieldMultiTS::unloadArraysWithoutDataLoss()
-{
-  if(!getFileName().empty())
-    contentNotNullBase()->unloadArrays();
-}
-
-std::string MEDFileAnyTypeFieldMultiTS::simpleRepr() const
-{
-  std::ostringstream oss;
-  contentNotNullBase()->simpleRepr(0,oss,-1);
-  simpleReprGlobs(oss);
-  return oss.str();
-}
-
-std::size_t MEDFileAnyTypeFieldMultiTS::getHeapMemorySizeWithoutChildren() const
-{
-  return MEDFileFieldGlobsReal::getHeapMemorySizeWithoutChildren();
-}
-
-std::vector<const BigMemoryObject *> MEDFileAnyTypeFieldMultiTS::getDirectChildrenWithNull() const
-{
-  std::vector<const BigMemoryObject *> ret(MEDFileFieldGlobsReal::getDirectChildrenWithNull());
-  ret.push_back((const MEDFileAnyTypeFieldMultiTSWithoutSDA *)_content);
-  return ret;
-}
-
-/*!
- * This method returns as MEDFileAnyTypeFieldMultiTS new instances as number of components in \a this.
- * The returned instances are deep copy of \a this except that for globals that are share with those contained in \a this.
- * ** WARNING ** do no forget to rename the ouput instances to avoid to write n-times in the same MED file field !
- */
-std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > MEDFileAnyTypeFieldMultiTS::splitComponents() const
-{
-  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
-  if(!content)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::splitComponents : no content in this ! Unable to split components !");
-  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > contentsSplit=content->splitComponents();
-  std::size_t sz(contentsSplit.size());
-  std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > ret(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      ret[i]=shallowCpy();
-      ret[i]->_content=contentsSplit[i];
-    }
-  return ret;
-}
-
-/*!
- * This method returns as MEDFileAnyTypeFieldMultiTS new instances as number of discretizations over time steps in \a this.
- * The returned instances are shallow copied of \a this included globals that are share with those contained in \a this.
- */
-std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > MEDFileAnyTypeFieldMultiTS::splitDiscretizations() const
-{
-  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
-  if(!content)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::splitDiscretizations : no content in this ! Unable to split discretizations !");
-  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > contentsSplit(content->splitDiscretizations());
-  std::size_t sz(contentsSplit.size());
-  std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > ret(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      ret[i]=shallowCpy();
-      ret[i]->_content=contentsSplit[i];
-    }
-  return ret;
-}
-
-/*!
- * This method returns as MEDFileAnyTypeFieldMultiTS new instances as number of sub-discretizations over time steps in \a this.
- * The returned instances are shallow copied of \a this included globals that are share with those contained in \a this.
- */
-std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > MEDFileAnyTypeFieldMultiTS::splitMultiDiscrPerGeoTypes() const
-{
-  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
-  if(!content)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::splitMultiDiscrPerGeoTypes : no content in this ! Unable to split discretizations !");
-  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > contentsSplit(content->splitMultiDiscrPerGeoTypes());
-  std::size_t sz(contentsSplit.size());
-  std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > ret(sz);
-  for(std::size_t i=0;i<sz;i++)
-    {
-      ret[i]=shallowCpy();
-      ret[i]->_content=contentsSplit[i];
-    }
-  return ret;
-}
-
-MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::deepCopy() const
-{
-  MCAuto<MEDFileAnyTypeFieldMultiTS> ret=shallowCpy();
-  if((const MEDFileAnyTypeFieldMultiTSWithoutSDA *)_content)
-    ret->_content=_content->deepCopy();
-  ret->deepCpyGlobs(*this);
-  return ret.retn();
-}
-
-MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> MEDFileAnyTypeFieldMultiTS::getContent()
-{
-  return _content;
-}
-
-/*!
- * Returns a new MEDFileField1TS or MEDFileIntField1TS holding data of a given time step of \a this field.
- *  \param [in] iteration - the iteration number of a required time step.
- *  \param [in] order - the iteration order number of required time step.
- *  \return MEDFileField1TS * or MEDFileIntField1TS *- a new instance of MEDFileField1TS or MEDFileIntField1TS. The caller is to
- *          delete this field using decrRef() as it is no more needed.
- *  \throw If there is no required time step in \a this field.
- */
-MEDFileAnyTypeField1TS *MEDFileAnyTypeFieldMultiTS::getTimeStep(int iteration, int order) const
-{
-  int pos=getPosOfTimeStep(iteration,order);
-  return getTimeStepAtPos(pos);
-}
-
-/*!
- * Returns a new MEDFileField1TS or MEDFileIntField1TS holding data of a given time step of \a this field.
- *  \param [in] time - the time of the time step of interest.
- *  \param [in] eps - a precision used to compare time values.
- *  \return MEDFileField1TS * - a new instance of MEDFileField1TS. The caller is to
- *          delete this field using decrRef() as it is no more needed.
- *  \throw If there is no required time step in \a this field.
- */
-MEDFileAnyTypeField1TS *MEDFileAnyTypeFieldMultiTS::getTimeStepGivenTime(double time, double eps) const
-{
-  int pos=getPosGivenTime(time,eps);
-  return getTimeStepAtPos(pos);
-}
-
-/*!
- * This method groups not null items in \a vectFMTS per time step series. Two time series are considered equal if the list of their pair of integers iteration,order are equal.
- * The float64 value of time attached to the pair of integers are not considered here.
- * WARNING the returned pointers are not incremented. The caller is \b not responsible to deallocate them ! This method only reorganizes entries in \a vectFMTS.
- *
- * \param [in] vectFMTS - vector of not null fields defined on a same global data pointer.
- * \throw If there is a null pointer in \a vectFMTS.
- */
-std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > MEDFileAnyTypeFieldMultiTS::SplitIntoCommonTimeSeries(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS)
-{
-  static const char msg[]="MEDFileAnyTypeFieldMultiTS::SplitIntoCommonTimeSeries : presence of null instance in input vector !";
-  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > ret;
-  std::list<MEDFileAnyTypeFieldMultiTS *> lstFMTS(vectFMTS.begin(),vectFMTS.end());
-  while(!lstFMTS.empty())
-    {
-      std::list<MEDFileAnyTypeFieldMultiTS *>::iterator it(lstFMTS.begin());
-      MEDFileAnyTypeFieldMultiTS *curIt(*it);
-      if(!curIt)
-        throw INTERP_KERNEL::Exception(msg);
-      std::vector< std::pair<int,int> > refIts=curIt->getIterations();
-      std::vector<MEDFileAnyTypeFieldMultiTS *> elt;
-      elt.push_back(curIt); it=lstFMTS.erase(it);
-      while(it!=lstFMTS.end())
-        {
-          curIt=*it;
-          if(!curIt)
-            throw INTERP_KERNEL::Exception(msg);
-          std::vector< std::pair<int,int> > curIts=curIt->getIterations();
-          if(refIts==curIts)
-            { elt.push_back(curIt); it=lstFMTS.erase(it); }
-          else
-            it++;
-        }
-      ret.push_back(elt);
-    }
-  return ret;
-}
-
-/*!
- * This method splits the input list \a vectFMTS considering the aspect of the geometrical support over time.
- * All returned instances in a subvector can be safely loaded, rendered along time
- * All items must be defined on the same time step ids ( see MEDFileAnyTypeFieldMultiTS::SplitIntoCommonTimeSeries method ).
- * Each item in \a vectFMTS is expected to have one and exactly one spatial discretization along time.
- * All items in \a vectFMTS must lie on the mesh (located by meshname and time step) and compatible with the input mesh \a mesh (having the same name than those in items).
- * All items in \a vectFMTS whose spatial discretization is not ON_NODES will appear once.
- * For items in \a vectFMTS that are ON_NODES it is possible to appear several times (more than once or once) in the returned vector.
- *
- * \param [in] vectFMTS - list of multi times step part all defined each on a same spatial discretization along time and pointing to a mesh whose name is equal to \c mesh->getName().
- * \param [in] mesh - the mesh shared by all items in \a vectFMTS across time.
- * \param [out] fsc - A vector having same size than returned vector. It specifies the support comporator of the corresponding vector of MEDFileAnyTypeFieldMultiTS in returned vector of vector.
- * \return - A vector of vector of objects that contains the same pointers (objects) than thoose in \a vectFMTS except that there are organized differently. So pointers included in returned vector of vector should \b not been dealt by the caller.
- *
- * \throw If an element in \a vectFMTS has not only one spatial discretization set.
- * \throw If an element in \a vectFMTS change of spatial discretization along time.
- * \throw If an element in \a vectFMTS lies on a mesh with meshname different from those in \a mesh.
- * \thorw If some elements in \a vectFMTS do not have the same times steps.
- * \throw If mesh is null.
- * \throw If an element in \a vectFMTS is null.
- * \sa MEDFileAnyTypeFieldMultiTS::AreOnSameSupportAcrossTime
- */
-std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& fsc)
-{
-  static const char msg[]="MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport : presence of a null instance in the input vector !";
-  if(!mesh)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport : input mesh is null !");
-  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > ret;
-  if(vectFMTS.empty())
-    return ret;
-  std::vector<MEDFileAnyTypeFieldMultiTS *>::const_iterator it(vectFMTS.begin());
-  MEDFileAnyTypeFieldMultiTS *frstElt(*it);
-  if(!frstElt)
-    throw INTERP_KERNEL::Exception(msg);
-  std::size_t i=0;
-  std::vector<MEDFileAnyTypeFieldMultiTS *> vectFMTSNotNodes;
-  std::vector<MEDFileAnyTypeFieldMultiTS *> vectFMTSNodes;
-  for(;it!=vectFMTS.end();it++,i++)
-    {
-      if(!(*it))
-        throw INTERP_KERNEL::Exception(msg);
-      TypeOfField tof0,tof1;
-      if(CheckSupportAcrossTime(frstElt,*it,mesh,tof0,tof1)>0)
-        {
-          if(tof1!=ON_NODES)
-            vectFMTSNotNodes.push_back(*it);
-          else
-            vectFMTSNodes.push_back(*it);
-        }
-      else
-        vectFMTSNotNodes.push_back(*it);
-    }
-  std::vector< MCAuto<MEDFileFastCellSupportComparator> > cmps;
-  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > retCell=SplitPerCommonSupportNotNodesAlg(vectFMTSNotNodes,mesh,cmps);
-  ret=retCell;
-  for(std::vector<MEDFileAnyTypeFieldMultiTS *>::const_iterator it2=vectFMTSNodes.begin();it2!=vectFMTSNodes.end();it2++)
-    {
-      i=0;
-      bool isFetched(false);
-      for(std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> >::const_iterator it0=retCell.begin();it0!=retCell.end();it0++,i++)
-        {
-          if((*it0).empty())
-            throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport : internal error !");
-          if(cmps[i]->isCompatibleWithNodesDiscr(*it2))
-            { ret[i].push_back(*it2); isFetched=true; }
-        }
-      if(!isFetched)
-        {
-          std::vector<MEDFileAnyTypeFieldMultiTS *> tmp(1,*it2);
-          MCAuto<MEDFileMeshStruct> tmp2(MEDFileMeshStruct::New(mesh));
-          ret.push_back(tmp); retCell.push_back(tmp); cmps.push_back(MEDFileFastCellSupportComparator::New(tmp2,*it2));
-        }
-    }
-  fsc=cmps;
-  return ret;
-}
-
-/*!
- * WARNING no check here. The caller must be sure that all items in vectFMTS are coherent each other in time steps, only one same spatial discretization and not ON_NODES.
- * \param [out] cmps - same size than the returned vector.
- */
-std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupportNotNodesAlg(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& cmps)
-{
-  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > ret;
-  std::list<MEDFileAnyTypeFieldMultiTS *> lstFMTS(vectFMTS.begin(),vectFMTS.end());
-  while(!lstFMTS.empty())
-    {
-      std::list<MEDFileAnyTypeFieldMultiTS *>::iterator it(lstFMTS.begin());
-      MEDFileAnyTypeFieldMultiTS *ref(*it);
-      std::vector<MEDFileAnyTypeFieldMultiTS *> elt;
-      elt.push_back(ref); it=lstFMTS.erase(it);
-      MCAuto<MEDFileMeshStruct> mst(MEDFileMeshStruct::New(mesh));
-      MCAuto<MEDFileFastCellSupportComparator> cmp(MEDFileFastCellSupportComparator::New(mst,ref));
-      while(it!=lstFMTS.end())
-        {
-          MEDFileAnyTypeFieldMultiTS *curIt(*it);
-          if(cmp->isEqual(curIt))
-            { elt.push_back(curIt); it=lstFMTS.erase(it); }
-          else
-            it++;
-        }
-      ret.push_back(elt); cmps.push_back(cmp);
-    }
-  return ret;
-}
-
-/*!
- * This method scan the two main structs along time of \a f0 and \a f1 to see if there are all lying on the same mesh along time than those in \a mesh.
- * \a f0 and \a f1 must be defined each only on a same spatial discretization even if this can be different each other.
- *
- * \throw If \a f0 or \a f1 has not only one spatial discretization set.
- * \throw If \a f0 or \a f1 change of spatial discretization along time.
- * \throw If \a f0 or \a f1 on a mesh with meshname different from those in \a mesh.
- * \thorw If \a f0 and \a f1 do not have the same times steps.
- * \throw If mesh is null.
- * \throw If \a f0 or \a f1 is null.
- * \sa MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport
- */
-int MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime(MEDFileAnyTypeFieldMultiTS *f0, MEDFileAnyTypeFieldMultiTS *f1, const MEDFileMesh *mesh, TypeOfField& tof0, TypeOfField& tof1)
-{
-  if(!mesh)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : input mesh is null !");
-  if(!f0 || !f1)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : presence of null instance in fields over time !");
-  if(f0->getMeshName()!=mesh->getName())
-    {
-      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : first field points to mesh \""<< f0->getMeshName() << "\" and input mesh to compare has name \"" << mesh->getName() << "\" !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  if(f1->getMeshName()!=mesh->getName())
-    {
-      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : second field points to mesh \""<< f1->getMeshName() << "\" and input mesh to compare has name \"" << mesh->getName() << "\" !";
-      throw INTERP_KERNEL::Exception(oss.str());
-    }
-  int nts=f0->getNumberOfTS();
-  if(nts!=f1->getNumberOfTS())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : number of time steps are not the same !");
-  if(nts==0)
-    return nts;
-  for(int i=0;i<nts;i++)
-    {
-      MCAuto<MEDFileAnyTypeField1TS> f0cur=f0->getTimeStepAtPos(i);
-      MCAuto<MEDFileAnyTypeField1TS> f1cur=f1->getTimeStepAtPos(i);
-      std::vector<TypeOfField> tofs0(f0cur->getTypesOfFieldAvailable()),tofs1(f1cur->getTypesOfFieldAvailable());
-      if(tofs0.size()!=1 || tofs1.size()!=1)
-        throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : All time steps must be defined on only one spatial discretization !");
-      if(i!=0)
-        {
-          if(tof0!=tofs0[0] || tof1!=tofs1[0])
-            throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : Across times steps MEDFileAnyTypeFieldMultiTS instances have to keep the same unique spatial discretization !");
-        }
-      else
-        { tof0=tofs0[0]; tof1=tofs1[0]; }
-      if(f0cur->getMeshIteration()!=mesh->getIteration() || f0cur->getMeshOrder()!=mesh->getOrder())
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : first field points to mesh time step (" << f0cur->getMeshIteration() << ","<< f0cur->getMeshOrder() << ") whereas input mesh points to time step (" << mesh->getIteration() << "," << mesh->getOrder() << ") !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      if(f1cur->getMeshIteration()!=mesh->getIteration() || f1cur->getMeshOrder()!=mesh->getOrder())
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : second field points to mesh time step (" << f1cur->getMeshIteration() << ","<< f1cur->getMeshOrder() << ") whereas input mesh points to time step (" << mesh->getIteration() << "," << mesh->getOrder() << ") !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-      if(f0cur->getIteration()!=f1cur->getIteration() || f0cur->getOrder()!=f1cur->getOrder())
-        {
-          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : all the time steps must be the same ! it is not the case (" << f0cur->getIteration() << "," << f0cur->getOrder() << ")!=(" << f1cur->getIteration() << "," << f1cur->getOrder() << ") !";
-          throw INTERP_KERNEL::Exception(oss.str());
-        }
-    }
-  return nts;
-}
-
-template<class T>
-MCAuto<MEDFileAnyTypeField1TS> AggregateHelperF1TS(const std::vector< typename MLFieldTraits<T>::F1TSType const *>& f1tss, const std::vector< std::vector< std::pair<int,int> > >& dts)
-{
-  MCAuto< typename MLFieldTraits<T>::F1TSType > ret(MLFieldTraits<T>::F1TSType::New());
-  if(f1tss.empty())
-    throw INTERP_KERNEL::Exception("AggregateHelperF1TS : empty vector !");
-  std::size_t sz(f1tss.size()),i(0);
-  std::vector< typename MLFieldTraits<T>::F1TSWSDAType const *> f1tsw(sz);
-  for(typename std::vector< typename MLFieldTraits<T>::F1TSType const *>::const_iterator it=f1tss.begin();it!=f1tss.end();it++,i++)
-    {
-      typename MLFieldTraits<T>::F1TSType const *elt(*it);
-      if(!elt)
-        throw INTERP_KERNEL::Exception("AggregateHelperF1TS : presence of a null pointer !");
-      f1tsw[i]=dynamic_cast<typename MLFieldTraits<T>::F1TSWSDAType const *>(elt->contentNotNullBase());
-    }
-  typename MLFieldTraits<T>::F1TSWSDAType *retc(dynamic_cast<typename MLFieldTraits<T>::F1TSWSDAType *>(ret->contentNotNullBase()));
-  if(!retc)
-    throw INTERP_KERNEL::Exception("AggregateHelperF1TS : internal error 1 !");
-  retc->aggregate(f1tsw,dts);
-  ret->setDtUnit(f1tss[0]->getDtUnit());
-  return DynamicCast<typename MLFieldTraits<T>::F1TSType , MEDFileAnyTypeField1TS>(ret);
-}
-
-template<class T>
-MCAuto< MEDFileAnyTypeFieldMultiTS > AggregateHelperFMTS(const std::vector< typename MLFieldTraits<T>::FMTSType const *>& fmtss, const std::vector< std::vector< std::pair<int,int> > >& dts)
-{
-  MCAuto< typename MLFieldTraits<T>::FMTSType > ret(MLFieldTraits<T>::FMTSType::New());
-  if(fmtss.empty())
-    throw INTERP_KERNEL::Exception("AggregateHelperFMTS : empty vector !");
-  std::size_t sz(fmtss.size());
-  for(typename std::vector< typename MLFieldTraits<T>::FMTSType const *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++)
-    {
-      typename MLFieldTraits<T>::FMTSType const *elt(*it);
-      if(!elt)
-        throw INTERP_KERNEL::Exception("AggregateHelperFMTS : presence of null pointer !");
-    }
-  int nbTS(fmtss[0]->getNumberOfTS());
-  for(typename std::vector< typename MLFieldTraits<T>::FMTSType const *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++)
-    if((*it)->getNumberOfTS()!=nbTS)
-      throw INTERP_KERNEL::Exception("AggregateHelperFMTS : all fields must have the same number of TS !");
-  for(int iterTS=0;iterTS<nbTS;iterTS++)
-    {
-      std::size_t i(0);
-      std::vector< typename MLFieldTraits<T>::F1TSType const *> f1tss(sz);
-      std::vector< MCAuto<typename MLFieldTraits<T>::F1TSType> > f1tss2(sz);
-      for(typename std::vector< typename MLFieldTraits<T>::FMTSType const *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++,i++)
-        { f1tss2[i]=(*it)->getTimeStepAtPos(iterTS); f1tss[i]=f1tss2[i]; }
-      MCAuto<MEDFileAnyTypeField1TS> f1ts(AggregateHelperF1TS<T>(f1tss,dts));
-      ret->pushBackTimeStep(f1ts);
-      ret->setDtUnit(f1ts->getDtUnit());
-    }
-  return DynamicCast<typename MLFieldTraits<T>::FMTSType , MEDFileAnyTypeFieldMultiTS>(ret);
-}
-
-/*!
- * \a dts and \a ftmss are expected to have same size.
- */
-MCAuto<MEDFileAnyTypeFieldMultiTS> MEDFileAnyTypeFieldMultiTS::Aggregate(const std::vector<const MEDFileAnyTypeFieldMultiTS *>& fmtss, const std::vector< std::vector< std::pair<int,int> > >& dts)
-{
-  if(fmtss.empty())
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : input vector is empty !");
-  std::size_t sz(fmtss.size());
-  std::vector<const MEDFileFieldMultiTS *> fmtss1;
-  std::vector<const MEDFileIntFieldMultiTS *> fmtss2;
-  for(std::vector<const MEDFileAnyTypeFieldMultiTS *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++)
-    {
-      if(!(*it))
-        throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : presence of null instance in input vector !");
-      const MEDFileFieldMultiTS *elt1(dynamic_cast<const MEDFileFieldMultiTS *>(*it));
-      if(elt1)
-        {
-          fmtss1.push_back(elt1);
-          continue;
-        }
-      const MEDFileIntFieldMultiTS *elt2(dynamic_cast<const MEDFileIntFieldMultiTS *>(*it));
-      if(elt2)
-        {
-          fmtss2.push_back(elt2);
-          continue;
-        }
-      throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : not recognized type !");
-    }
-  if(fmtss1.size()!=sz && fmtss2.size()!=sz)
-    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : type of data is not homogeneous !");
-  if(fmtss1.size()==sz)
-    return AggregateHelperFMTS<double>(fmtss1,dts);
-  if(fmtss2.size()!=sz)
-    return AggregateHelperFMTS<int>(fmtss2,dts);
-  throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : not implemented yet !");
-}
-
-MEDFileAnyTypeFieldMultiTSIterator *MEDFileAnyTypeFieldMultiTS::iterator()
-{
-  return new MEDFileAnyTypeFieldMultiTSIterator(this);
-}
-
-//= MEDFileFieldMultiTS
-
-MEDFileAnyTypeFieldMultiTS *MEDFileFieldMultiTS::shallowCpy() const
-{
-  return new MEDFileFieldMultiTS(*this);
-}
-
-/*!
- * This method performs a copy with datatype modification ( float64->int32 ) of \a this. The globals information are copied
- * following the given input policy.
- *
- * \param [in] isDeepCpyGlobs - a boolean that indicates the behaviour concerning globals (profiles and localizations)
- *                            By default (true) the globals are deeply copied.
- * \return MEDFileIntFieldMultiTS * - a new object that is the result of the conversion of \a this to int32 field.
- */
-MEDFileIntFieldMultiTS *MEDFileFieldMultiTS::convertToInt(bool isDeepCpyGlobs) const
-{
-  MCAuto<MEDFileIntFieldMultiTS> ret;
-  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
-  if(content)
-    {
-      const MEDFileFieldMultiTSWithoutSDA *contc=dynamic_cast<const MEDFileFieldMultiTSWithoutSDA *>(content);
-      if(!contc)
-        throw INTERP_KERNEL::Exception("MEDFileFieldMultiTS::convertToInt : the content inside this is not FLOAT64 ! This is incoherent !");
-      MCAuto<MEDFileIntFieldMultiTSWithoutSDA> newc(contc->convertToInt());
-      ret=static_cast<MEDFileIntFieldMultiTS *>(MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent((MEDFileIntFieldMultiTSWithoutSDA *)newc));
-    }
-  else
-    ret=MEDFileIntFieldMultiTS::New();
-  if(isDeepCpyGlobs)
-    ret->deepCpyGlobs(*this);
-  else
-    ret->shallowCpyGlobs(*this);
-  return ret.retn();
-}
-
-MEDFileFieldMultiTS::MEDFileFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
-try:MEDFileTemplateFieldMultiTS<double>(fid,loadAll,ms)
-{
-}
-catch(INTERP_KERNEL::Exception& e)
-{ throw e; }
-
-MEDFileFieldMultiTS::MEDFileFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
-try:MEDFileTemplateFieldMultiTS<double>(fid,fieldName,loadAll,ms,entities)
-{
-}
-catch(INTERP_KERNEL::Exception& e)
-{ throw e; }
-
-MEDFileFieldMultiTS::MEDFileFieldMultiTS(const MEDFileFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent):MEDFileTemplateFieldMultiTS<double>(other,shallowCopyOfContent)
-{
-}
-
-std::vector< std::vector<DataArrayDouble *> > MEDFileFieldMultiTS::getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
-{
-  return contentNotNull()->getFieldSplitedByType2(iteration,order,mname,types,typesF,pfls,locs);
-}
-
-//= MEDFileAnyTypeFieldMultiTSIterator
-
-MEDFileAnyTypeFieldMultiTSIterator::MEDFileAnyTypeFieldMultiTSIterator(MEDFileAnyTypeFieldMultiTS *fmts):_fmts(fmts),_iter_id(0),_nb_iter(0)
-{
-  if(fmts)
-    {
-      fmts->incrRef();
-      _nb_iter=fmts->getNumberOfTS();
-    }
-}
-
-MEDFileAnyTypeFieldMultiTSIterator::~MEDFileAnyTypeFieldMultiTSIterator() 
-{
-}
-
-MEDFileAnyTypeField1TS *MEDFileAnyTypeFieldMultiTSIterator::nextt()
-{
-  if(_iter_id<_nb_iter)
-    {
-      MEDFileAnyTypeFieldMultiTS *fmts(_fmts);
-      if(fmts)
-        return fmts->getTimeStepAtPos(_iter_id++);
-      else
-        return 0;
-    }
-  else
-    return 0;
-}
-
-//= MEDFileIntFieldMultiTS
-
 //= MEDFileFields
 
 MEDFileFields *MEDFileFields::New()
@@ -9187,11 +276,19 @@
             _fields[i]=MEDFileIntFieldMultiTSWithoutSDA::New(fid,fieldName,meshName,typcha,infos,nbOfStep,dtunit,loadAll,ms,entities);
             break;
           }
-        case MED_NODE://6432
+        case MED_FLOAT32:
           {
             _fields[i]=MEDFileFloatFieldMultiTSWithoutSDA::New(fid,fieldName,meshName,typcha,infos,nbOfStep,dtunit,loadAll,ms,entities);
             break;
           }
+        case MED_INT:
+          {
+            if(sizeof(med_int)==sizeof(int))
+              {
+                _fields[i]=MEDFileIntFieldMultiTSWithoutSDA::New(fid,fieldName,meshName,typcha,infos,nbOfStep,dtunit,loadAll,ms,entities);
+                break;
+              }
+          }
         default:
           {
             std::ostringstream oss; oss << "constructor MEDFileFields(fileName) : file \'" << FileNameFromFID(fid) << "\' at pos #" << i << " field has name \'" << fieldName << "\' but the type of field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
@@ -9282,7 +379,7 @@
 
 /*!
  * This method potentially releases big data arrays if \a this is coming from a file. If \a this has been built from scratch this method will have no effect.
- * This method is the symetrical method of MEDFileFields::loadArraysIfNecessary.
+ * This method is the symmetrical method of MEDFileFields::loadArraysIfNecessary.
  * This method is useful to reduce \b safely amount of heap memory necessary for \a this by using MED file as database.
  * 
  * \sa MEDFileFields::loadArraysIfNecessary
@@ -9456,7 +553,7 @@
  *             This code corresponds to the distribution of types in the corresponding mesh.
  * \param [in] newCode idem to param \a oldCode except that here the new distribution is given.
  * \param [in] renumO2N the old to new renumber array.
- * \return If true a renumbering has been performed. The structure in \a this has been modified. If false, nothing has been done: it is typically the case if \a meshName is not refered by any 
+ * \return If true a renumbering has been performed. The structure in \a this has been modified. If false, nothing has been done: it is typically the case if \a meshName is not referred by any 
  *         field in \a this.
  */
 bool MEDFileFields::renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N)
@@ -9510,6 +607,235 @@
       }
 }
 
+class PFLData
+{
+public:
+  PFLData():_add_pts_in_pfl(0) { }
+  PFLData(const MCAuto<DataArrayInt>& mat, const MCAuto<DataArrayInt>& pfl, int nbOfNewPts):_matrix(mat),_pfl(pfl),_add_pts_in_pfl(nbOfNewPts) { }
+  std::string getPflName() const { if(_pfl.isNull()) { return std::string(); } else { return _pfl->getName(); } }
+  int getNbOfAddPtsInPfl() const { return _add_pts_in_pfl; }
+  MCAuto<DataArrayInt> getProfile() const { return _pfl; }
+  MCAuto<DataArrayInt> getMatrix() const { return _matrix; }
+private:
+  MCAuto<DataArrayInt> _matrix;
+  MCAuto<DataArrayInt> _pfl;
+  int _add_pts_in_pfl;
+};
+
+class MEDFileFieldLin2QuadVisitor : public MEDFileFieldVisitor
+{
+public:
+  MEDFileFieldLin2QuadVisitor(const MEDFileUMesh *lin, const MEDFileUMesh *quad, const MEDFileFieldGlobsReal *linGlobs, MEDFileFields* outFs):_lin(lin),_quad(quad),_lin_globs(linGlobs),_out_fs(outFs),_gt(INTERP_KERNEL::NORM_ERROR),_1ts_update_requested(false) { }
+  void newFieldEntry(const MEDFileAnyTypeFieldMultiTSWithoutSDA *field) { if(field->getMeshName()!=_lin->getName()) return; _cur_fmts=MEDFileFieldMultiTS::New(); }
+  void endFieldEntry(const MEDFileAnyTypeFieldMultiTSWithoutSDA *field) { if(_cur_fmts.isNotNull()) { if(_cur_fmts->getNumberOfTS()>0) _out_fs->pushField(_cur_fmts); } }
+  //
+  void newTimeStepEntry(const MEDFileAnyTypeField1TSWithoutSDA *ts);
+  void endTimeStepEntry(const MEDFileAnyTypeField1TSWithoutSDA *ts);
+  //
+  void newMeshEntry(const MEDFileFieldPerMesh *fpm);
+  void endMeshEntry(const MEDFileFieldPerMesh *fpm) { }
+  //
+  void newPerMeshPerTypeEntry(const MEDFileFieldPerMeshPerTypeCommon *pmpt);
+  void endPerMeshPerTypeEntry(const MEDFileFieldPerMeshPerTypeCommon *pmpt) { }
+  //
+  void newPerMeshPerTypePerDisc(const MEDFileFieldPerMeshPerTypePerDisc *pmptpd);
+private:
+  void updateData(MEDFileFieldPerMeshPerTypePerDisc *pmtd, int deltaNbNodes);
+private:
+  const MEDFileUMesh *_lin;
+  const MEDFileUMesh *_quad;
+  const MEDFileFieldGlobsReal *_lin_globs;
+  MEDFileFields *_out_fs;
+  MCAuto<MEDFileFieldMultiTS> _cur_fmts;
+  MCAuto<MEDFileField1TS> _cur_f1ts;
+  INTERP_KERNEL::NormalizedCellType _gt;
+  // Info on 1TS modification
+  bool _1ts_update_requested;
+  // Cache of matrix to compute faster the values on newly created points
+  std::map< std::string, PFLData > _cache;
+  std::vector<std::string> _pfls_to_be_updated;
+};
+
+void MEDFileFieldLin2QuadVisitor::newPerMeshPerTypePerDisc(const MEDFileFieldPerMeshPerTypePerDisc *pmptpd)
+{
+  if(_cur_f1ts.isNull())
+    return;
+  if(pmptpd->getType()!=ON_NODES)
+    throw INTERP_KERNEL::Exception("Not managed yet for ON_CELLS ON_GAUSS_NE and ON_GAUSS_PT");
+  _1ts_update_requested=true;
+  MEDFileAnyTypeField1TSWithoutSDA *ct(_cur_f1ts->contentNotNullBase());
+  int locId(pmptpd->getFather()->locIdOfLeaf(pmptpd));
+  MEDFileFieldPerMeshPerTypePerDisc *pmtdToModify(ct->getLeafGivenMeshAndTypeAndLocId(_lin->getName(),_gt,locId));
+  std::string pflName(pmptpd->getProfile());
+  _pfls_to_be_updated.push_back(pflName);
+  std::map< std::string, PFLData >::iterator itCache(_cache.find(pflName));
+  if(itCache!=_cache.end())
+    {
+      updateData(pmtdToModify,(*itCache).second.getNbOfAddPtsInPfl());
+      return ;
+    }
+  MCAuto<DataArrayInt> pfl;
+  if(pflName.empty())
+    pfl=DataArrayInt::Range(0,pmptpd->getNumberOfVals(),1);
+  else
+    pfl=_lin_globs->getProfile(pflName)->deepCopy();
+  //
+  MCAuto<MEDCouplingUMesh> mesh3D(_lin->getMeshAtLevel(0)),mesh3DQuadratic(_quad->getMeshAtLevel(0));
+  MCAuto<DataArrayInt> cellIds(mesh3D->getCellIdsLyingOnNodes(pfl->begin(),pfl->end(),true));
+  MCAuto<MEDCouplingUMesh> mesh3DQuadraticRestricted(mesh3DQuadratic->buildPartOfMySelf(cellIds->begin(),cellIds->end(),true));
+  MCAuto<DataArrayInt> mesh3DQuadraticRestrictedNodeIds(mesh3DQuadraticRestricted->computeFetchedNodeIds());
+  mesh3DQuadraticRestrictedNodeIds->checkMonotonic(true);
+  MCAuto<DataArrayInt> newPtsIds(mesh3DQuadraticRestrictedNodeIds->buildSubstraction(pfl));
+  MCAuto<MEDCoupling1SGTUMesh> allSeg3;
+  {
+    MCAuto<DataArrayInt> a,b,c,d;
+    MCAuto<MEDCouplingUMesh> seg3Tmp(mesh3DQuadraticRestricted->explodeIntoEdges(a,b,c,d));
+    allSeg3=MEDCoupling1SGTUMesh::New(seg3Tmp);
+  }
+  if(allSeg3->getCellModelEnum()!=INTERP_KERNEL::NORM_SEG3)
+    throw INTERP_KERNEL::Exception("MEDFileFieldLin2QuadVisitor::newPerMeshPerTypePerDisc : invalid situation where SEG3 expected !");
+  MCAuto<DataArrayInt> midPts,cellSeg3Ids,matrix;
+  {
+    DataArrayInt *nodeConn(allSeg3->getNodalConnectivity());
+    nodeConn->rearrange(3);
+    {
+      std::vector<int> v(1,2);
+      midPts=nodeConn->keepSelectedComponents(v);
+    }
+    cellSeg3Ids=DataArrayInt::FindPermutationFromFirstToSecond(midPts,newPtsIds);
+    {
+      std::vector<int> v(2); v[0]=0; v[1]=1;
+      MCAuto<DataArrayInt> tmp(nodeConn->keepSelectedComponents(v));
+      matrix=tmp->selectByTupleId(cellSeg3Ids->begin(),cellSeg3Ids->end());
+    }
+    nodeConn->rearrange(1);
+  }
+  MCAuto<DataArrayInt> pflq;
+  if(!pflName.empty())
+    {
+      std::vector<const DataArrayInt *> vs(2);
+      vs[0]=pfl; vs[1]=newPtsIds;
+      pflq=DataArrayInt::Aggregate(vs);
+      pflq->setName(pflName);
+    }
+  PFLData pdata(matrix,pflq,newPtsIds->getNumberOfTuples());
+  _cache[pflName]=pdata;
+  updateData(pmtdToModify,pdata.getNbOfAddPtsInPfl());
+}
+
+void MEDFileFieldLin2QuadVisitor::updateData(MEDFileFieldPerMeshPerTypePerDisc *pmtd, int deltaNbNodes)
+{
+  pmtd->incrementNbOfVals(deltaNbNodes);
+}
+
+void MEDFileFieldLin2QuadVisitor::newPerMeshPerTypeEntry(const MEDFileFieldPerMeshPerTypeCommon *pmpt)
+{
+  const MEDFileFieldPerMeshPerType *pmpt2(dynamic_cast<const MEDFileFieldPerMeshPerType *>(pmpt));
+  if(!pmpt2)
+    throw INTERP_KERNEL::Exception("MEDFileFieldLin2QuadVisitor::newPerMeshPerTypeEntry : not managed for structure elements !");
+  if(pmpt2->getNumberOfLoc()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileFieldLin2QuadVisitor::newPerMeshPerTypeEntry : not managed for multi discr per timestep !");
+  _gt=pmpt->getGeoType();
+}
+
+void MEDFileFieldLin2QuadVisitor::newMeshEntry(const MEDFileFieldPerMesh *fpm)
+{
+  if(fpm->getMeshName()!=_lin->getName())
+    throw INTERP_KERNEL::Exception("MEDFileFieldLin2QuadVisitor::newMeshEntry : mismatch into meshName !");
+}
+
+void MEDFileFieldLin2QuadVisitor::newTimeStepEntry(const MEDFileAnyTypeField1TSWithoutSDA *ts)
+{
+  _1ts_update_requested=false; _pfls_to_be_updated.clear();
+  if(!ts)
+    return ;
+  const MEDFileField1TSWithoutSDA *tsd(dynamic_cast<const MEDFileField1TSWithoutSDA *>(ts));
+  if(!tsd)
+    return ;
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> contentCpy(ts->deepCopy());
+  MCAuto<MEDFileField1TSWithoutSDA> contentCpy2(DynamicCastSafe<MEDFileAnyTypeField1TSWithoutSDA,MEDFileField1TSWithoutSDA>(contentCpy));
+  if(contentCpy2.isNull())
+    return;
+  _cur_f1ts=MEDFileField1TS::New(*contentCpy2,true);
+  _cur_f1ts->deepCpyGlobs(*_lin_globs);
+}
+
+void MEDFileFieldLin2QuadVisitor::endTimeStepEntry(const MEDFileAnyTypeField1TSWithoutSDA *ts)
+{
+  if(_cur_f1ts.isNull())
+    return ;
+  if(_1ts_update_requested)
+    {
+      MCAuto<DataArrayInt> matrix,oldPfl;
+      for(std::vector<std::string>::const_iterator it=_pfls_to_be_updated.begin();it!=_pfls_to_be_updated.end();it++)
+        {
+          std::map< std::string, PFLData >::const_iterator it2(_cache.find(*it));
+          if(it2==_cache.end())
+            throw INTERP_KERNEL::Exception("MEDFileFieldLin2QuadVisitor::endTimeStepEntry : invalid situation !");
+          matrix=(*it2).second.getMatrix();
+          if((*it).empty())
+            continue;
+          int locId(_cur_f1ts->getProfileId(*it));
+          oldPfl.takeRef(_cur_f1ts->getProfile(*it));
+          {
+            std::vector<int> locToKill(1,locId);
+            _cur_f1ts->killProfileIds(locToKill);
+          }
+          _cur_f1ts->appendProfile((*it2).second.getProfile());
+        }
+      DataArrayDouble *arr(_cur_f1ts->getUndergroundDataArray());
+      MCAuto<DataArrayDouble> res;
+      {
+        std::vector<int> v(1,0),v2(1,1);
+        MCAuto<DataArrayInt> pts0(matrix->keepSelectedComponents(v));
+        MCAuto<DataArrayInt> pts1(matrix->keepSelectedComponents(v2));
+        if(oldPfl.isNotNull())
+          {
+            pts0=oldPfl->findIdForEach(pts0->begin(),pts0->end());
+            pts1=oldPfl->findIdForEach(pts1->begin(),pts1->end());
+          }
+        MCAuto<DataArrayDouble> part0(arr->selectByTupleId(*pts0));
+        MCAuto<DataArrayDouble> part1(arr->selectByTupleId(*pts1));
+        res=DataArrayDouble::Add(part0,part1);
+        res->applyLin(0.5,0.);
+      }
+      res=DataArrayDouble::Aggregate(arr,res);
+      _cur_f1ts->setArray(res);
+    }
+  if(_cur_fmts.isNotNull())
+    { _cur_fmts->pushBackTimeStep(_cur_f1ts); }
+  _1ts_update_requested=false;
+}
+
+/*!
+ * \a newQuad is expected to be the result of MEDFileUMesh::linearToQuadratic of \a oldLin
+ */
+MCAuto<MEDFileFields> MEDFileFields::linearToQuadratic(const MEDFileMeshes *oldLin, const MEDFileMeshes *newQuad) const
+{
+  if(!oldLin || !newQuad)
+    throw INTERP_KERNEL::Exception("MEDFileFields::linearToQuadratic : input meshes must be non NULL !");
+  MCAuto<MEDFileFields> ret(MEDFileFields::New());
+  for(int i=0;i<oldLin->getNumberOfMeshes();i++)
+    {
+      MEDFileMesh *mm(oldLin->getMeshAtPos(i));
+      if(!mm)
+        continue;
+      MEDFileUMesh *mmu(dynamic_cast<MEDFileUMesh *>(mm));
+      if(!mmu)
+        continue;
+      MEDFileMesh *mmq(newQuad->getMeshWithName(mmu->getName()));
+      MEDFileUMesh *mmqu(dynamic_cast<MEDFileUMesh *>(mmq));
+      if(!mmqu)
+        {
+          std::ostringstream oss; oss << "MEDFileFields::linearToQuadratic : mismatch of name between input meshes for name \"" << mmu->getName() << "\"";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      MEDFileFieldLin2QuadVisitor vis(mmu,mmqu,this,ret);
+      accept(vis);
+    }
+  return ret;
+}
+
 MEDFileAnyTypeFieldMultiTS *MEDFileFields::getFieldAtPos(int i) const
 {
   if(i<0 || i>=(int)_fields.size())
@@ -9523,13 +849,16 @@
   MCAuto<MEDFileAnyTypeFieldMultiTS> ret;
   const MEDFileFieldMultiTSWithoutSDA *fmtsC(dynamic_cast<const MEDFileFieldMultiTSWithoutSDA *>(fmts));
   const MEDFileIntFieldMultiTSWithoutSDA *fmtsC2(dynamic_cast<const MEDFileIntFieldMultiTSWithoutSDA *>(fmts));
+  const MEDFileFloatFieldMultiTSWithoutSDA *fmtsC3(dynamic_cast<const MEDFileFloatFieldMultiTSWithoutSDA *>(fmts));
   if(fmtsC)
     ret=MEDFileFieldMultiTS::New(*fmtsC,false);
   else if(fmtsC2)
     ret=MEDFileIntFieldMultiTS::New(*fmtsC2,false);
+  else if(fmtsC3)
+    ret=MEDFileFloatFieldMultiTS::New(*fmtsC3,false);
   else
     {
-      std::ostringstream oss; oss << "MEDFileFields::getFieldAtPos : At pos #" << i << " field is neither double (FLOAT64) nor integer (INT32) !";
+      std::ostringstream oss; oss << "MEDFileFields::getFieldAtPos : At pos #" << i << " field is neither double (FLOAT64) nor float (FLOAT32) nor integer (INT32) !";
       throw INTERP_KERNEL::Exception(oss.str());
     }
   ret->shallowCpyGlobs(*this);
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldGlobs.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldGlobs.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldGlobs.cxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldGlobs.cxx	2018-04-19 17:25:17.743797475 +0200
@@ -0,0 +1,1279 @@
+// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#include "MEDFileFieldGlobs.hxx"
+#include "MEDFileField.txx"
+#include "MEDFileMesh.hxx"
+#include "MEDLoaderBase.hxx"
+#include "MEDLoaderTraits.hxx"
+#include "MEDFileSafeCaller.txx"
+#include "MEDFileFieldOverView.hxx"
+#include "MEDFileBlowStrEltUp.hxx"
+#include "MEDFileFieldVisitor.hxx"
+
+#include "MEDCouplingFieldDiscretization.hxx"
+#include "MCType.hxx"
+
+#include "InterpKernelAutoPtr.hxx"
+#include "CellModel.hxx"
+
+#include <algorithm>
+#include <iterator>
+
+using namespace MEDCoupling;
+
+void MEDFileFieldGlobs::loadProfileInFile(med_idt fid, int id, const std::string& pflName)
+{
+  if(id>=(int)_pfls.size())
+    _pfls.resize(id+1);
+  _pfls[id]=DataArrayInt::New();
+  int lgth(MEDprofileSizeByName(fid,pflName.c_str()));
+  _pfls[id]->setName(pflName);
+  _pfls[id]->alloc(lgth,1);
+  MEDFILESAFECALLERRD0(MEDprofileRd,(fid,pflName.c_str(),_pfls[id]->getPointer()));
+  _pfls[id]->applyLin(1,-1,0);//Converting into C format
+}
+
+void MEDFileFieldGlobs::loadProfileInFile(med_idt fid, int i)
+{
+  INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
+  int sz;
+  MEDFILESAFECALLERRD0(MEDprofileInfo,(fid,i+1,pflName,&sz));
+  std::string pflCpp=MEDLoaderBase::buildStringFromFortran(pflName,MED_NAME_SIZE);
+  if(i>=(int)_pfls.size())
+    _pfls.resize(i+1);
+  _pfls[i]=DataArrayInt::New();
+  _pfls[i]->alloc(sz,1);
+  _pfls[i]->setName(pflCpp.c_str());
+  MEDFILESAFECALLERRD0(MEDprofileRd,(fid,pflName,_pfls[i]->getPointer()));
+  _pfls[i]->applyLin(1,-1,0);//Converting into C format
+}
+
+void MEDFileFieldGlobs::writeGlobals(med_idt fid, const MEDFileWritable& opt) const
+{
+  int nbOfPfls=_pfls.size();
+  for(int i=0;i<nbOfPfls;i++)
+    {
+      MCAuto<DataArrayInt> cpy=_pfls[i]->deepCopy();
+      cpy->applyLin(1,1,0);
+      INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
+      MEDLoaderBase::safeStrCpy(_pfls[i]->getName().c_str(),MED_NAME_SIZE,pflName,opt.getTooLongStrPolicy());
+      MEDFILESAFECALLERWR0(MEDprofileWr,(fid,pflName,_pfls[i]->getNumberOfTuples(),cpy->getConstPointer()));
+    }
+  //
+  int nbOfLocs=_locs.size();
+  for(int i=0;i<nbOfLocs;i++)
+    _locs[i]->writeLL(fid);
+}
+
+void MEDFileFieldGlobs::appendGlobs(const MEDFileFieldGlobs& other, double eps)
+{
+  std::vector<std::string> pfls=getPfls();
+  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=other._pfls.begin();it!=other._pfls.end();it++)
+    {
+      std::vector<std::string>::iterator it2=std::find(pfls.begin(),pfls.end(),(*it)->getName());
+      if(it2==pfls.end())
+        {
+          _pfls.push_back(*it);
+        }
+      else
+        {
+          int id=std::distance(pfls.begin(),it2);
+          if(!(*it)->isEqual(*_pfls[id]))
+            {
+              std::ostringstream oss; oss << "MEDFileFieldGlobs::appendGlobs : Profile \"" << (*it)->getName() << "\" already exists and is different from those expecting to be append !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+        }
+    }
+  std::vector<std::string> locs=getLocs();
+  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=other._locs.begin();it!=other._locs.end();it++)
+    {
+      std::vector<std::string>::iterator it2=std::find(locs.begin(),locs.end(),(*it)->getName());
+      if(it2==locs.end())
+        {
+          _locs.push_back(*it);
+        }
+      else
+        {
+          int id=std::distance(locs.begin(),it2);
+          if(!(*it)->isEqual(*_locs[id],eps))
+            {
+              std::ostringstream oss; oss << "MEDFileFieldGlobs::appendGlobs : Localization \"" << (*it)->getName() << "\" already exists and is different from those expecting to be append !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+        }
+    }
+}
+
+void MEDFileFieldGlobs::checkGlobsPflsPartCoherency(const std::vector<std::string>& pflsUsed) const
+{
+  for(std::vector<std::string>::const_iterator it=pflsUsed.begin();it!=pflsUsed.end();it++)
+    getProfile((*it).c_str());
+}
+
+void MEDFileFieldGlobs::checkGlobsLocsPartCoherency(const std::vector<std::string>& locsUsed) const
+{
+  for(std::vector<std::string>::const_iterator it=locsUsed.begin();it!=locsUsed.end();it++)
+    getLocalization((*it).c_str());
+}
+
+void MEDFileFieldGlobs::loadGlobals(med_idt fid, const MEDFileFieldGlobsReal& real)
+{
+  std::vector<std::string> profiles=real.getPflsReallyUsed();
+  int sz=profiles.size();
+  _pfls.resize(sz);
+  for(int i=0;i<sz;i++)
+    loadProfileInFile(fid,i,profiles[i].c_str());
+  //
+  std::vector<std::string> locs=real.getLocsReallyUsed();
+  sz=locs.size();
+  _locs.resize(sz);
+  for(int i=0;i<sz;i++)
+    _locs[i]=MEDFileFieldLoc::New(fid,locs[i].c_str());
+}
+
+void MEDFileFieldGlobs::loadAllGlobals(med_idt fid, const MEDFileEntities *entities)
+{
+  int nProfil=MEDnProfile(fid);
+  for(int i=0;i<nProfil;i++)
+    loadProfileInFile(fid,i);
+  int sz=MEDnLocalization(fid);
+  _locs.resize(sz);
+  for(int i=0;i<sz;i++)
+    {
+      _locs[i]=MEDFileFieldLoc::New(fid,i,entities);
+    }
+}
+
+MEDFileFieldGlobs *MEDFileFieldGlobs::New(med_idt fid)
+{
+  return new MEDFileFieldGlobs(fid);
+}
+
+MEDFileFieldGlobs *MEDFileFieldGlobs::New()
+{
+  return new MEDFileFieldGlobs;
+}
+
+std::size_t MEDFileFieldGlobs::getHeapMemorySizeWithoutChildren() const
+{
+  return _file_name.capacity()+_pfls.capacity()*sizeof(MCAuto<DataArrayInt>)+_locs.capacity()*sizeof(MCAuto<MEDFileFieldLoc>);
+}
+
+std::vector<const BigMemoryObject *> MEDFileFieldGlobs::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret;
+  for(std::vector< MCAuto< DataArrayInt > >::const_iterator it=_pfls.begin();it!=_pfls.end();it++)
+    ret.push_back((const DataArrayInt *)*it);
+  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++)
+    ret.push_back((const MEDFileFieldLoc *)*it);
+  return ret;
+}
+
+MEDFileFieldGlobs *MEDFileFieldGlobs::deepCopy() const
+{
+  MCAuto<MEDFileFieldGlobs> ret=new MEDFileFieldGlobs(*this);
+  std::size_t i=0;
+  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++,i++)
+    {
+      if((const DataArrayInt *)*it)
+        ret->_pfls[i]=(*it)->deepCopy();
+    }
+  i=0;
+  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++,i++)
+    {
+      if((const MEDFileFieldLoc*)*it)
+        ret->_locs[i]=(*it)->deepCopy();
+    }
+  return ret.retn();
+}
+
+/*!
+ * \throw if a profile in \a pfls in not in \a this.
+ * \throw if a localization in \a locs in not in \a this.
+ * \sa MEDFileFieldGlobs::deepCpyPart
+ */
+MEDFileFieldGlobs *MEDFileFieldGlobs::shallowCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const
+{
+  MCAuto<MEDFileFieldGlobs> ret=MEDFileFieldGlobs::New();
+  for(std::vector<std::string>::const_iterator it1=pfls.begin();it1!=pfls.end();it1++)
+    {
+      DataArrayInt *pfl=const_cast<DataArrayInt *>(getProfile((*it1).c_str()));
+      if(!pfl)
+        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::shallowCpyPart : internal error ! pfl null !");
+      pfl->incrRef();
+      MCAuto<DataArrayInt> pfl2(pfl);
+      ret->_pfls.push_back(pfl2);
+    }
+  for(std::vector<std::string>::const_iterator it2=locs.begin();it2!=locs.end();it2++)
+    {
+      MEDFileFieldLoc *loc=const_cast<MEDFileFieldLoc *>(&getLocalization((*it2).c_str()));
+      if(!loc)
+        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::shallowCpyPart : internal error ! loc null !");
+      loc->incrRef();
+      MCAuto<MEDFileFieldLoc> loc2(loc);
+      ret->_locs.push_back(loc2);
+    }
+  ret->setFileName(getFileName());
+  return ret.retn();
+}
+
+/*!
+ * \throw if a profile in \a pfls in not in \a this.
+ * \throw if a localization in \a locs in not in \a this.
+ * \sa MEDFileFieldGlobs::shallowCpyPart
+ */
+MEDFileFieldGlobs *MEDFileFieldGlobs::deepCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const
+{
+  MCAuto<MEDFileFieldGlobs> ret=MEDFileFieldGlobs::New();
+  for(std::vector<std::string>::const_iterator it1=pfls.begin();it1!=pfls.end();it1++)
+    {
+      DataArrayInt *pfl=const_cast<DataArrayInt *>(getProfile((*it1).c_str()));
+      if(!pfl)
+        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::deepCpyPart : internal error ! pfl null !");
+      ret->_pfls.push_back(pfl->deepCopy());
+    }
+  for(std::vector<std::string>::const_iterator it2=locs.begin();it2!=locs.end();it2++)
+    {
+      MEDFileFieldLoc *loc=const_cast<MEDFileFieldLoc *>(&getLocalization((*it2).c_str()));
+      if(!loc)
+        throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::deepCpyPart : internal error ! loc null !");
+      ret->_locs.push_back(loc->deepCopy());
+    }
+  ret->setFileName(getFileName());
+  return ret.retn();
+}
+
+MEDFileFieldGlobs::MEDFileFieldGlobs(med_idt fid):_file_name(MEDFileWritable::FileNameFromFID(fid))
+{
+}
+
+MEDFileFieldGlobs::MEDFileFieldGlobs()
+{
+}
+
+MEDFileFieldGlobs::~MEDFileFieldGlobs()
+{
+}
+
+void MEDFileFieldGlobs::simpleRepr(std::ostream& oss) const
+{
+  oss << "Profiles :\n";
+  std::size_t n=_pfls.size();
+  for(std::size_t i=0;i<n;i++)
+    {
+      oss << "  - #" << i << " ";
+      const DataArrayInt *pfl=_pfls[i];
+      if(pfl)
+        oss << "\"" << pfl->getName() << "\"\n";
+      else
+        oss << "EMPTY !\n";
+    }
+  n=_locs.size();
+  oss << "Localizations :\n";
+  for(std::size_t i=0;i<n;i++)
+    {
+      oss << "  - #" << i << " ";
+      const MEDFileFieldLoc *loc=_locs[i];
+      if(loc)
+        loc->simpleRepr(oss);
+      else
+        oss<< "EMPTY !\n";
+    }
+}
+
+void MEDFileFieldGlobs::changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto<DataArrayInt> >::iterator it=_pfls.begin();it!=_pfls.end();it++)
+    {
+      DataArrayInt *elt(*it);
+      if(elt)
+        {
+          std::string name(elt->getName());
+          for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
+            {
+              if(std::find((*it2).first.begin(),(*it2).first.end(),name)!=(*it2).first.end())
+                {
+                  elt->setName((*it2).second.c_str());
+                  return;
+                }
+            }
+        }
+    }
+}
+
+void MEDFileFieldGlobs::changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto<MEDFileFieldLoc> >::iterator it=_locs.begin();it!=_locs.end();it++)
+    {
+      MEDFileFieldLoc *elt(*it);
+      if(elt)
+        {
+          std::string name(elt->getName());
+          for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
+            {
+              if(std::find((*it2).first.begin(),(*it2).first.end(),name)!=(*it2).first.end())
+                {
+                  elt->setName((*it2).second.c_str());
+                  return;
+                }
+            }
+        }
+    }
+}
+
+int MEDFileFieldGlobs::getNbOfGaussPtPerCell(int locId) const
+{
+  if(locId<0 || locId>=(int)_locs.size())
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getNbOfGaussPtPerCell : Invalid localization id !");
+  return _locs[locId]->getNbOfGaussPtPerCell();
+}
+
+const MEDFileFieldLoc& MEDFileFieldGlobs::getLocalization(const std::string& locName) const
+{
+  return getLocalizationFromId(getLocalizationId(locName));
+}
+
+const MEDFileFieldLoc& MEDFileFieldGlobs::getLocalizationFromId(int locId) const
+{
+  if(locId<0 || locId>=(int)_locs.size())
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getLocalizationFromId : Invalid localization id !");
+  return *_locs[locId];
+}
+
+/// @cond INTERNAL
+namespace MEDCouplingImpl
+{
+  class LocFinder
+  {
+  public:
+    LocFinder(const std::string& loc):_loc(loc) { }
+    bool operator() (const MCAuto<MEDFileFieldLoc>& loc) { return loc->isName(_loc); }
+  private:
+    const std::string &_loc;
+  };
+
+  class PflFinder
+  {
+  public:
+    PflFinder(const std::string& pfl):_pfl(pfl) { }
+    bool operator() (const MCAuto<DataArrayInt>& loc) { return loc->getName()==_pfl; }
+  private:
+    const std::string _pfl;
+  };
+}
+/// @endcond
+
+int MEDFileFieldGlobs::getLocalizationId(const std::string& loc) const
+{
+  std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=std::find_if(_locs.begin(),_locs.end(),MEDCouplingImpl::LocFinder(loc));
+  if(it==_locs.end())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldGlobs::getLocalisationId : no such localisation name : \"" << loc << "\" Possible localizations are : ";
+      for(it=_locs.begin();it!=_locs.end();it++)
+        oss << "\"" << (*it)->getName() << "\", ";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  return std::distance(_locs.begin(),it);
+}
+
+int MEDFileFieldGlobs::getProfileId(const std::string& pfl) const
+{
+  std::vector< MCAuto<DataArrayInt> >::const_iterator it=std::find_if(_pfls.begin(),_pfls.end(),MEDCouplingImpl::PflFinder(pfl));
+  if(it==_pfls.end())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldGlobs::getProfileId : no such profile name : \"" << pfl << "\" Possible localizations are : ";
+      for(it=_pfls.begin();it!=_pfls.end();it++)
+        oss << "\"" << (*it)->getName() << "\", ";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  return std::distance(_pfls.begin(),it);
+}
+
+/*!
+ * The returned value is never null.
+ */
+const DataArrayInt *MEDFileFieldGlobs::getProfile(const std::string& pflName) const
+{
+  return getProfileFromId(getProfileId(pflName));
+}
+
+const DataArrayInt *MEDFileFieldGlobs::getProfileFromId(int pflId) const
+{
+  if(pflId<0 || pflId>=(int)_pfls.size())
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getProfileFromId : Invalid profile id !");
+  return _pfls[pflId];
+}
+
+MEDFileFieldLoc& MEDFileFieldGlobs::getLocalizationFromId(int locId)
+{
+  if(locId<0 || locId>=(int)_locs.size())
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getLocalizationFromId : Invalid localization id !");
+  return *_locs[locId];
+}
+
+MEDFileFieldLoc& MEDFileFieldGlobs::getLocalization(const std::string& locName)
+{
+  return getLocalizationFromId(getLocalizationId(locName));
+}
+
+/*!
+ * The returned value is never null. Borrowed reference returned.
+ */
+DataArrayInt *MEDFileFieldGlobs::getProfile(const std::string& pflName)
+{
+  std::string pflNameCpp(pflName);
+  std::vector< MCAuto<DataArrayInt> >::iterator it=std::find_if(_pfls.begin(),_pfls.end(),MEDCouplingImpl::PflFinder(pflNameCpp));
+  if(it==_pfls.end())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldGlobs::getProfile: no such profile name : \"" << pflNameCpp << "\" Possible profiles are : ";
+      for(it=_pfls.begin();it!=_pfls.end();it++)
+        oss << "\"" << (*it)->getName() << "\", ";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  return *it;
+}
+
+DataArrayInt *MEDFileFieldGlobs::getProfileFromId(int pflId)
+{
+  if(pflId<0 || pflId>=(int)_pfls.size())
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::getProfileFromId : Invalid profile id !");
+  return _pfls[pflId];
+}
+
+void MEDFileFieldGlobs::killProfileIds(const std::vector<int>& pflIds)
+{
+  std::vector< MCAuto<DataArrayInt> > newPfls;
+  int i=0;
+  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++,i++)
+    {
+      if(std::find(pflIds.begin(),pflIds.end(),i)==pflIds.end())
+        newPfls.push_back(*it);
+    }
+  _pfls=newPfls;
+}
+
+void MEDFileFieldGlobs::killLocalizationIds(const std::vector<int>& locIds)
+{
+  std::vector< MCAuto<MEDFileFieldLoc> > newLocs;
+  int i=0;
+  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++,i++)
+    {
+      if(std::find(locIds.begin(),locIds.end(),i)==locIds.end())
+        newLocs.push_back(*it);
+    }
+  _locs=newLocs;
+}
+
+void MEDFileFieldGlobs::killStructureElementsInGlobs()
+{
+  std::vector< MCAuto<MEDFileFieldLoc> > newLocs;
+  for(std::vector< MCAuto<MEDFileFieldLoc> >::iterator it=_locs.begin();it!=_locs.end();it++)
+    {
+      if((*it).isNull())
+        continue;
+      if(!(*it)->isOnStructureElement())
+        newLocs.push_back(*it);
+    }
+  _locs=newLocs;
+}
+
+std::vector<std::string> MEDFileFieldGlobs::getPfls() const
+{
+  int sz=_pfls.size();
+  std::vector<std::string> ret(sz);
+  for(int i=0;i<sz;i++)
+    ret[i]=_pfls[i]->getName();
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldGlobs::getLocs() const
+{
+  int sz=_locs.size();
+  std::vector<std::string> ret(sz);
+  for(int i=0;i<sz;i++)
+    ret[i]=_locs[i]->getName();
+  return ret;
+}
+
+bool MEDFileFieldGlobs::existsPfl(const std::string& pflName) const
+{
+  std::vector<std::string> v=getPfls();
+  std::string s(pflName);
+  return std::find(v.begin(),v.end(),s)!=v.end();
+}
+
+bool MEDFileFieldGlobs::existsLoc(const std::string& locName) const
+{
+  std::vector<std::string> v=getLocs();
+  std::string s(locName);
+  return std::find(v.begin(),v.end(),s)!=v.end();
+}
+
+std::vector< std::vector<int> > MEDFileFieldGlobs::whichAreEqualProfiles() const
+{
+  std::map<int,std::vector<int> > m;
+  int i=0;
+  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++,i++)
+    {
+      const DataArrayInt *tmp=(*it);
+      if(tmp)
+        {
+          m[tmp->getHashCode()].push_back(i);
+        }
+    }
+  std::vector< std::vector<int> > ret;
+  for(std::map<int,std::vector<int> >::const_iterator it2=m.begin();it2!=m.end();it2++)
+    {
+      if((*it2).second.size()>1)
+        {
+          std::vector<int> ret0;
+          bool equalityOrNot=false;
+          for(std::vector<int>::const_iterator it3=(*it2).second.begin();it3!=(*it2).second.end();it3++)
+            {
+              std::vector<int>::const_iterator it4=it3; it4++;
+              for(;it4!=(*it2).second.end();it4++)
+                {
+                  if(_pfls[*it3]->isEqualWithoutConsideringStr(*_pfls[*it4]))
+                    {
+                      if(!equalityOrNot)
+                        ret0.push_back(*it3);
+                      ret0.push_back(*it4);
+                      equalityOrNot=true;
+                    }
+                }
+            }
+          if(!ret0.empty())
+            ret.push_back(ret0);
+        }
+    }
+  return ret;
+}
+
+std::vector< std::vector<int> > MEDFileFieldGlobs::whichAreEqualLocs(double eps) const
+{
+  throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::whichAreEqualLocs : no implemented yet ! Sorry !");
+}
+
+void MEDFileFieldGlobs::appendProfile(DataArrayInt *pfl)
+{
+  std::string name(pfl->getName());
+  if(name.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::appendProfile : unsupported profiles with no name !");
+  for(std::vector< MCAuto<DataArrayInt> >::const_iterator it=_pfls.begin();it!=_pfls.end();it++)
+    if(name==(*it)->getName())
+      {
+        if(!pfl->isEqual(*(*it)))
+          {
+            std::ostringstream oss; oss << "MEDFileFieldGlobs::appendProfile : profile \"" << name << "\" already exists and is different from existing !";
+            throw INTERP_KERNEL::Exception(oss.str());
+          }
+      }
+  pfl->incrRef();
+  _pfls.push_back(pfl);
+}
+
+void MEDFileFieldGlobs::appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w)
+{
+  std::string name(locName);
+  if(name.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::appendLoc : unsupported localizations with no name !");
+  MCAuto<MEDFileFieldLoc> obj=MEDFileFieldLoc::New(locName,geoType,refCoo,gsCoo,w);
+  for(std::vector< MCAuto<MEDFileFieldLoc> >::const_iterator it=_locs.begin();it!=_locs.end();it++)
+    if((*it)->isName(locName))
+      {
+        if(!(*it)->isEqual(*obj,1e-12))
+          {
+            std::ostringstream oss; oss << "MEDFileFieldGlobs::appendLoc : localization \"" << name << "\" already exists and is different from existing !";
+            throw INTERP_KERNEL::Exception(oss.str());
+          }
+      }
+  _locs.push_back(obj);
+}
+
+std::string MEDFileFieldGlobs::createNewNameOfPfl() const
+{
+  std::vector<std::string> names=getPfls();
+  return CreateNewNameNotIn("NewPfl_",names);
+}
+
+std::string MEDFileFieldGlobs::createNewNameOfLoc() const
+{
+  std::vector<std::string> names=getLocs();
+  return CreateNewNameNotIn("NewLoc_",names);
+}
+
+std::string MEDFileFieldGlobs::CreateNewNameNotIn(const std::string& prefix, const std::vector<std::string>& namesToAvoid)
+{
+  for(std::size_t sz=0;sz<100000;sz++)
+    {
+      std::ostringstream tryName;
+      tryName << prefix << sz;
+      if(std::find(namesToAvoid.begin(),namesToAvoid.end(),tryName.str())==namesToAvoid.end())
+        return tryName.str();
+    }
+  throw INTERP_KERNEL::Exception("MEDFileFieldGlobs::CreateNewNameNotIn : impossible to create an additional profile limit of 100000 profiles reached !");
+}
+
+/*!
+ * Creates a MEDFileFieldGlobsReal on a given file name. Nothing is read here.
+ *  \param [in] fname - the file name.
+ */
+MEDFileFieldGlobsReal::MEDFileFieldGlobsReal(med_idt fid):_globals(MEDFileFieldGlobs::New(fid))
+{
+}
+
+/*!
+ * Creates an empty MEDFileFieldGlobsReal.
+ */
+MEDFileFieldGlobsReal::MEDFileFieldGlobsReal():_globals(MEDFileFieldGlobs::New())
+{
+}
+
+std::size_t MEDFileFieldGlobsReal::getHeapMemorySizeWithoutChildren() const
+{
+  return 0;
+}
+
+std::vector<const BigMemoryObject *> MEDFileFieldGlobsReal::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret;
+  ret.push_back((const MEDFileFieldGlobs *)_globals);
+  return ret;
+}
+
+/*!
+ * Returns a string describing profiles and Gauss points held in \a this.
+ *  \return std::string - the description string.
+ */
+void MEDFileFieldGlobsReal::simpleReprGlobs(std::ostream& oss) const
+{
+  const MEDFileFieldGlobs *glob=_globals;
+  std::ostringstream oss2; oss2 << glob;
+  std::string stars(oss2.str().length(),'*');
+  oss << "Globals information on fields (at " << oss2.str() << "):" << "\n************************************" << stars  << "\n\n";
+  if(glob)
+    glob->simpleRepr(oss);
+  else
+    oss << "NO GLOBAL INFORMATION !\n";
+}
+
+void MEDFileFieldGlobsReal::resetContent()
+{
+  _globals=MEDFileFieldGlobs::New();
+}
+
+void MEDFileFieldGlobsReal::killStructureElementsInGlobs()
+{
+  contentNotNull()->killStructureElementsInGlobs();
+}
+
+MEDFileFieldGlobsReal::~MEDFileFieldGlobsReal()
+{
+}
+
+/*!
+ * Copies references to profiles and Gauss points from another MEDFileFieldGlobsReal.
+ *  \param [in] other - the other MEDFileFieldGlobsReal to copy data from.
+ */
+void MEDFileFieldGlobsReal::shallowCpyGlobs(const MEDFileFieldGlobsReal& other)
+{
+  _globals=other._globals;
+}
+
+/*!
+ * Copies references to ** only used ** by \a this, profiles and Gauss points from another MEDFileFieldGlobsReal.
+ *  \param [in] other - the other MEDFileFieldGlobsReal to copy data from.
+ */
+void MEDFileFieldGlobsReal::shallowCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other)
+{
+  const MEDFileFieldGlobs *otherg(other._globals);
+  if(!otherg)
+    return ;
+  _globals=otherg->shallowCpyPart(getPflsReallyUsed(),getLocsReallyUsed());
+}
+
+/*!
+ * Copies deeply to ** only used ** by \a this, profiles and Gauss points from another MEDFileFieldGlobsReal.
+ *  \param [in] other - the other MEDFileFieldGlobsReal to copy data from.
+ */
+void MEDFileFieldGlobsReal::deepCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other)
+{
+  const MEDFileFieldGlobs *otherg(other._globals);
+  if(!otherg)
+    return ;
+  _globals=otherg->deepCpyPart(getPflsReallyUsed(),getLocsReallyUsed());
+}
+
+void MEDFileFieldGlobsReal::deepCpyGlobs(const MEDFileFieldGlobsReal& other)
+{
+  _globals=other._globals;
+  if((const MEDFileFieldGlobs *)_globals)
+    _globals=other._globals->deepCopy();
+}
+
+/*!
+ * Adds profiles and Gauss points held by another MEDFileFieldGlobsReal to \a this one.
+ *  \param [in] other - the MEDFileFieldGlobsReal to copy data from.
+ *  \param [in] eps - a precision used to compare Gauss points with same name held by
+ *         \a this and \a other MEDFileFieldGlobsReal.
+ *  \throw If \a this and \a other hold profiles with equal names but different ids.
+ *  \throw If  \a this and \a other hold different Gauss points with equal names.
+ */
+void MEDFileFieldGlobsReal::appendGlobs(const MEDFileFieldGlobsReal& other, double eps)
+{
+  const MEDFileFieldGlobs *thisGlobals(_globals),*otherGlobals(other._globals);
+  if(thisGlobals==otherGlobals)
+    return ;
+  if(!thisGlobals)
+    {
+      _globals=other._globals;
+      return ;
+    }
+  _globals->appendGlobs(*other._globals,eps);
+}
+
+void MEDFileFieldGlobsReal::checkGlobsCoherency() const
+{
+  checkGlobsPflsPartCoherency();
+  checkGlobsLocsPartCoherency();
+}
+
+void MEDFileFieldGlobsReal::checkGlobsPflsPartCoherency() const
+{
+  contentNotNull()->checkGlobsPflsPartCoherency(getPflsReallyUsed());
+}
+
+void MEDFileFieldGlobsReal::checkGlobsLocsPartCoherency() const
+{
+  contentNotNull()->checkGlobsLocsPartCoherency(getLocsReallyUsed());
+}
+
+void MEDFileFieldGlobsReal::loadProfileInFile(med_idt fid, int id, const std::string& pflName)
+{
+  contentNotNull()->loadProfileInFile(fid,id,pflName);
+}
+
+void MEDFileFieldGlobsReal::loadProfileInFile(med_idt fid, int id)
+{
+  contentNotNull()->loadProfileInFile(fid,id);
+}
+
+void MEDFileFieldGlobsReal::loadGlobals(med_idt fid)
+{
+  contentNotNull()->loadGlobals(fid,*this);
+}
+
+void MEDFileFieldGlobsReal::loadAllGlobals(med_idt fid, const MEDFileEntities *entities)
+{
+  contentNotNull()->loadAllGlobals(fid,entities);
+}
+
+void MEDFileFieldGlobsReal::writeGlobals(med_idt fid, const MEDFileWritable& opt) const
+{
+  contentNotNull()->writeGlobals(fid,opt);
+}
+
+/*!
+ * Returns names of all profiles. To get only used profiles call getPflsReallyUsed()
+ * or getPflsReallyUsedMulti().
+ *  \return std::vector<std::string> - a sequence of names of all profiles.
+ */
+std::vector<std::string> MEDFileFieldGlobsReal::getPfls() const
+{
+  return contentNotNull()->getPfls();
+}
+
+/*!
+ * Returns names of all localizations. To get only used localizations call getLocsReallyUsed()
+ * or getLocsReallyUsedMulti().
+ *  \return std::vector<std::string> - a sequence of names of all localizations.
+ */
+std::vector<std::string> MEDFileFieldGlobsReal::getLocs() const
+{
+  return contentNotNull()->getLocs();
+}
+
+/*!
+ * Checks if the profile with a given name exists.
+ *  \param [in] pflName - the profile name of interest.
+ *  \return bool - \c true if the profile named \a pflName exists.
+ */
+bool MEDFileFieldGlobsReal::existsPfl(const std::string& pflName) const
+{
+  return contentNotNull()->existsPfl(pflName);
+}
+
+/*!
+ * Checks if the localization with a given name exists.
+ *  \param [in] locName - the localization name of interest.
+ *  \return bool - \c true if the localization named \a locName exists.
+ */
+bool MEDFileFieldGlobsReal::existsLoc(const std::string& locName) const
+{
+  return contentNotNull()->existsLoc(locName);
+}
+
+std::string MEDFileFieldGlobsReal::createNewNameOfPfl() const
+{
+  return contentNotNull()->createNewNameOfPfl();
+}
+
+std::string MEDFileFieldGlobsReal::createNewNameOfLoc() const
+{
+  return contentNotNull()->createNewNameOfLoc();
+}
+
+/*!
+ * Sets the name of a MED file.
+ *  \param [inout] fileName - the file name.
+ */
+void MEDFileFieldGlobsReal::setFileName(const std::string& fileName)
+{
+  contentNotNull()->setFileName(fileName);
+}
+
+/*!
+ * Finds equal profiles. Two profiles are considered equal if they contain the same ids
+ * in the same order.
+ *  \return std::vector< std::vector<int> > - a sequence of groups of equal profiles.
+ *          Each item of this sequence is a vector containing ids of equal profiles.
+ */
+std::vector< std::vector<int> > MEDFileFieldGlobsReal::whichAreEqualProfiles() const
+{
+  return contentNotNull()->whichAreEqualProfiles();
+}
+
+/*!
+ * Finds equal localizations.
+ *  \param [in] eps - a precision used to compare real values of the localizations.
+ *  \return std::vector< std::vector<int> > - a sequence of groups of equal localizations.
+ *          Each item of this sequence is a vector containing ids of equal localizations.
+ */
+std::vector< std::vector<int> > MEDFileFieldGlobsReal::whichAreEqualLocs(double eps) const
+{
+  return contentNotNull()->whichAreEqualLocs(eps);
+}
+
+/*!
+ * Renames the profiles. References to profiles (a reference is a profile name) are not changed.
+ * \param [in] mapOfModif - a sequence describing required renaming. Each element of
+ *        this sequence is a pair whose 
+ *        - the first item is a vector of profile names to replace by the second item,
+ *        - the second item is a profile name to replace every profile name of the first item.
+ */
+void MEDFileFieldGlobsReal::changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  contentNotNull()->changePflsNamesInStruct(mapOfModif);
+}
+
+/*!
+ * Renames the localizations. References to localizations (a reference is a localization name) are not changed.
+ * \param [in] mapOfModif - a sequence describing required renaming. Each element of
+ *        this sequence is a pair whose 
+ *        - the first item is a vector of localization names to replace by the second item,
+ *        - the second item is a localization name to replace every localization name of the first item.
+ */
+void MEDFileFieldGlobsReal::changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  contentNotNull()->changeLocsNamesInStruct(mapOfModif);
+}
+
+/*!
+ * Replaces references to some profiles (a reference is a profile name) by references
+ * to other profiles and, contrary to changePflsRefsNamesGen(), renames the profiles
+ * them-selves accordingly. <br>
+ * This method is a generalization of changePflName().
+ * \param [in] mapOfModif - a sequence describing required replacements. Each element of
+ *        this sequence is a pair whose 
+ *        - the first item is a vector of profile names to replace by the second item,
+ *        - the second item is a profile name to replace every profile of the first item.
+ * \sa changePflsRefsNamesGen()
+ * \sa changePflName()
+ */
+void MEDFileFieldGlobsReal::changePflsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  changePflsRefsNamesGen(mapOfModif);
+  changePflsNamesInStruct(mapOfModif);
+}
+
+/*!
+ * Replaces references to some localizations (a reference is a localization name) by references
+ * to other localizations and, contrary to changeLocsRefsNamesGen(), renames the localizations
+ * them-selves accordingly. <br>
+ * This method is a generalization of changeLocName().
+ * \param [in] mapOfModif - a sequence describing required replacements. Each element of
+ *        this sequence is a pair whose 
+ *        - the first item is a vector of localization names to replace by the second item,
+ *        - the second item is a localization name to replace every localization of the first item.
+ * \sa changeLocsRefsNamesGen()
+ * \sa changeLocName()
+ */
+void MEDFileFieldGlobsReal::changeLocsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  changeLocsRefsNamesGen(mapOfModif);
+  changeLocsNamesInStruct(mapOfModif);
+}
+
+/*!
+ * Renames the profile having a given name and updates references to this profile.
+ *  \param [in] oldName - the name of the profile to rename.
+ *  \param [in] newName - a new name of the profile.
+ * \sa changePflsNames().
+ */
+void MEDFileFieldGlobsReal::changePflName(const std::string& oldName, const std::string& newName)
+{
+  std::vector< std::pair<std::vector<std::string>, std::string > > mapOfModif(1);
+  std::pair<std::vector<std::string>, std::string > p(std::vector<std::string>(1,std::string(oldName)),std::string(newName));
+  mapOfModif[0]=p;
+  changePflsNames(mapOfModif);
+}
+
+/*!
+ * Renames the localization having a given name and updates references to this localization.
+ *  \param [in] oldName - the name of the localization to rename.
+ *  \param [in] newName - a new name of the localization.
+ * \sa changeLocsNames().
+ */
+void MEDFileFieldGlobsReal::changeLocName(const std::string& oldName, const std::string& newName)
+{
+  std::vector< std::pair<std::vector<std::string>, std::string > > mapOfModif(1);
+  std::pair<std::vector<std::string>, std::string > p(std::vector<std::string>(1,std::string(oldName)),std::string(newName));
+  mapOfModif[0]=p;
+  changeLocsNames(mapOfModif);
+}
+
+/*!
+ * Removes duplicated profiles. Returns a map used to update references to removed 
+ * profiles via changePflsRefsNamesGen().
+ * Equal profiles are found using whichAreEqualProfiles().
+ *  \return std::vector< std::pair<std::vector<std::string>, std::string > > - 
+ *          a sequence describing the performed replacements of profiles. Each element of
+ *          this sequence is a pair whose
+ *          - the first item is a vector of profile names replaced by the second item,
+ *          - the second item is a profile name replacing every profile of the first item.
+ */
+std::vector< std::pair<std::vector<std::string>, std::string > > MEDFileFieldGlobsReal::zipPflsNames()
+{
+  std::vector< std::vector<int> > pseudoRet=whichAreEqualProfiles();
+  std::vector< std::pair<std::vector<std::string>, std::string > > ret(pseudoRet.size());
+  int i=0;
+  for(std::vector< std::vector<int> >::const_iterator it=pseudoRet.begin();it!=pseudoRet.end();it++,i++)
+    {
+      std::vector< std::string > tmp((*it).size());
+      int j=0;
+      for(std::vector<int>::const_iterator it2=(*it).begin();it2!=(*it).end();it2++,j++)
+        tmp[j]=std::string(getProfileFromId(*it2)->getName());
+      std::pair<std::vector<std::string>, std::string > p(tmp,tmp.front());
+      ret[i]=p;
+      std::vector<int> tmp2((*it).begin()+1,(*it).end());
+      killProfileIds(tmp2);
+    }
+  changePflsRefsNamesGen(ret);
+  return ret;
+}
+
+/*!
+ * Removes duplicated localizations. Returns a map used to update references to removed 
+ * localizations via changeLocsRefsNamesGen().
+ * Equal localizations are found using whichAreEqualLocs().
+ *  \param [in] eps - a precision used to compare real values of the localizations.
+ *  \return std::vector< std::pair<std::vector<std::string>, std::string > > - 
+ *          a sequence describing the performed replacements of localizations. Each element of
+ *          this sequence is a pair whose
+ *          - the first item is a vector of localization names replaced by the second item,
+ *          - the second item is a localization name replacing every localization of the first item.
+ */
+std::vector< std::pair<std::vector<std::string>, std::string > > MEDFileFieldGlobsReal::zipLocsNames(double eps)
+{
+  std::vector< std::vector<int> > pseudoRet=whichAreEqualLocs(eps);
+  std::vector< std::pair<std::vector<std::string>, std::string > > ret(pseudoRet.size());
+  int i=0;
+  for(std::vector< std::vector<int> >::const_iterator it=pseudoRet.begin();it!=pseudoRet.end();it++,i++)
+    {
+      std::vector< std::string > tmp((*it).size());
+      int j=0;
+      for(std::vector<int>::const_iterator it2=(*it).begin();it2!=(*it).end();it2++,j++)
+        tmp[j]=std::string(getLocalizationFromId(*it2).getName());
+      std::pair<std::vector<std::string>, std::string > p(tmp,tmp.front());
+      ret[i]=p;
+      std::vector<int> tmp2((*it).begin()+1,(*it).end());
+      killLocalizationIds(tmp2);
+    }
+  changeLocsRefsNamesGen(ret);
+  return ret;
+}
+
+/*!
+ * Returns number of Gauss points per cell in a given localization.
+ *  \param [in] locId - an id of the localization of interest.
+ *  \return int - the number of the Gauss points per cell.
+ */
+int MEDFileFieldGlobsReal::getNbOfGaussPtPerCell(int locId) const
+{
+  return contentNotNull()->getNbOfGaussPtPerCell(locId);
+}
+
+/*!
+ * Returns an id of a localization by its name.
+ *  \param [in] loc - the localization name of interest.
+ *  \return int - the id of the localization.
+ *  \throw If there is no a localization named \a loc.
+ */
+int MEDFileFieldGlobsReal::getLocalizationId(const std::string& loc) const
+{
+  return contentNotNull()->getLocalizationId(loc);
+}
+
+/*!
+ * Returns an id of a profile by its name.
+ *  \param [in] loc - the profile name of interest.
+ *  \return int - the id of the profile.
+ *  \throw If there is no a profile named \a loc.
+ */
+int MEDFileFieldGlobsReal::getProfileId(const std::string& pfl) const
+{
+  return contentNotNull()->getProfileId(pfl);
+}
+
+/*!
+ * Returns the name of the MED file.
+ *  \return const std::string&  - the MED file name.
+ */
+std::string MEDFileFieldGlobsReal::getFileName() const
+{
+  return contentNotNull()->getFileName();
+}
+
+/*!
+ * Returns a localization object by its name.
+ *  \param [in] locName - the name of the localization of interest.
+ *  \return const MEDFileFieldLoc& - the localization object having the name \a locName.
+ *  \throw If there is no a localization named \a locName.
+ */
+const MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalization(const std::string& locName) const
+{
+  return contentNotNull()->getLocalization(locName);
+}
+
+/*!
+ * Returns a localization object by its id.
+ *  \param [in] locId - the id of the localization of interest.
+ *  \return const MEDFileFieldLoc& - the localization object having the id \a locId.
+ *  \throw If there is no a localization with id \a locId.
+ */
+const MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalizationFromId(int locId) const
+{
+  return contentNotNull()->getLocalizationFromId(locId);
+}
+
+/*!
+ * Returns a profile array by its name.
+ *  \param [in] pflName - the name of the profile of interest.
+ *  \return const DataArrayInt * - the profile array having the name \a pflName.
+ *  \throw If there is no a profile named \a pflName.
+ */
+const DataArrayInt *MEDFileFieldGlobsReal::getProfile(const std::string& pflName) const
+{
+  return contentNotNull()->getProfile(pflName);
+}
+
+/*!
+ * Returns a profile array by its id.
+ *  \param [in] pflId - the id of the profile of interest.
+ *  \return const DataArrayInt * - the profile array having the id \a pflId.
+ *  \throw If there is no a profile with id \a pflId.
+ */
+const DataArrayInt *MEDFileFieldGlobsReal::getProfileFromId(int pflId) const
+{
+  return contentNotNull()->getProfileFromId(pflId);
+}
+
+/*!
+ * Returns a localization object, apt for modification, by its id.
+ *  \param [in] locId - the id of the localization of interest.
+ *  \return MEDFileFieldLoc& - a non-const reference to the localization object
+ *          having the id \a locId.
+ *  \throw If there is no a localization with id \a locId.
+ */
+MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalizationFromId(int locId)
+{
+  return contentNotNull()->getLocalizationFromId(locId);
+}
+
+/*!
+ * Returns a localization object, apt for modification, by its name.
+ *  \param [in] locName - the name of the localization of interest.
+ *  \return MEDFileFieldLoc& - a non-const reference to the localization object
+ *          having the name \a locName.
+ *  \throw If there is no a localization named \a locName.
+ */
+MEDFileFieldLoc& MEDFileFieldGlobsReal::getLocalization(const std::string& locName)
+{
+  return contentNotNull()->getLocalization(locName);
+}
+
+/*!
+ * Returns a profile array, apt for modification, by its name.
+ *  \param [in] pflName - the name of the profile of interest.
+ *  \return DataArrayInt * - Borrowed reference - a non-const pointer to the profile array having the name \a pflName.
+ *  \throw If there is no a profile named \a pflName.
+ */
+DataArrayInt *MEDFileFieldGlobsReal::getProfile(const std::string& pflName)
+{
+  return contentNotNull()->getProfile(pflName);
+}
+
+/*!
+ * Returns a profile array, apt for modification, by its id.
+ *  \param [in] pflId - the id of the profile of interest.
+ *  \return DataArrayInt * - Borrowed reference - a non-const pointer to the profile array having the id \a pflId.
+ *  \throw If there is no a profile with id \a pflId.
+ */
+DataArrayInt *MEDFileFieldGlobsReal::getProfileFromId(int pflId)
+{
+  return contentNotNull()->getProfileFromId(pflId);
+}
+
+/*!
+ * Removes profiles given by their ids. No data is updated to track this removal.
+ *  \param [in] pflIds - a sequence of ids of the profiles to remove.
+ */
+void MEDFileFieldGlobsReal::killProfileIds(const std::vector<int>& pflIds)
+{
+  contentNotNull()->killProfileIds(pflIds);
+}
+
+/*!
+ * Removes localizations given by their ids. No data is updated to track this removal.
+ *  \param [in] locIds - a sequence of ids of the localizations to remove.
+ */
+void MEDFileFieldGlobsReal::killLocalizationIds(const std::vector<int>& locIds)
+{
+  contentNotNull()->killLocalizationIds(locIds);
+}
+
+/*!
+ * Stores a profile array.
+ *  \param [in] pfl - the profile array to store.
+ *  \throw If the name of \a pfl is empty.
+ *  \throw If a profile with the same name as that of \a pfl already exists but contains
+ *         different ids.
+ */
+void MEDFileFieldGlobsReal::appendProfile(DataArrayInt *pfl)
+{
+  contentNotNull()->appendProfile(pfl);
+}
+
+/*!
+ * Adds a new localization of Gauss points.
+ *  \param [in] locName - the name of the new localization.
+ *  \param [in] geoType - a geometrical type of the reference cell.
+ *  \param [in] refCoo - coordinates of points of the reference cell. Size of this vector
+ *         must be \c nbOfNodesPerCell * \c dimOfType.
+ *  \param [in] gsCoo - coordinates of Gauss points on the reference cell. Size of this vector
+ *         must be  _wg_.size() * \c dimOfType.
+ *  \param [in] w - the weights of Gauss points.
+ *  \throw If \a locName is empty.
+ *  \throw If a localization with the name \a locName already exists but is
+ *         different form the new one.
+ */
+void MEDFileFieldGlobsReal::appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w)
+{
+  contentNotNull()->appendLoc(locName,geoType,refCoo,gsCoo,w);
+}
+
+MEDFileFieldGlobs *MEDFileFieldGlobsReal::contentNotNull()
+{
+  MEDFileFieldGlobs *g(_globals);
+  if(!g)
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobsReal::contentNotNull : no content in not const !");
+  return g;
+}
+
+const MEDFileFieldGlobs *MEDFileFieldGlobsReal::contentNotNull() const
+{
+  const MEDFileFieldGlobs *g(_globals);
+  if(!g)
+    throw INTERP_KERNEL::Exception("MEDFileFieldGlobsReal::contentNotNull : no content in const !");
+  return g;
+}
+
+//= MEDFileFieldNameScope
+
+MEDFileFieldNameScope::MEDFileFieldNameScope()
+{
+}
+
+MEDFileFieldNameScope::MEDFileFieldNameScope(const std::string& fieldName, const std::string& meshName):_name(fieldName),_mesh_name(meshName)
+{
+}
+
+/*!
+ * Returns the name of \a this field.
+ *  \return std::string - a string containing the field name.
+ */
+std::string MEDFileFieldNameScope::getName() const
+{
+  return _name;
+}
+
+/*!
+ * Sets name of \a this field
+ *  \param [in] name - the new field name.
+ */
+void MEDFileFieldNameScope::setName(const std::string& fieldName)
+{
+  _name=fieldName;
+}
+
+std::string MEDFileFieldNameScope::getDtUnit() const
+{
+  return _dt_unit;
+}
+
+void MEDFileFieldNameScope::setDtUnit(const std::string& dtUnit)
+{
+  _dt_unit=dtUnit;
+}
+
+void MEDFileFieldNameScope::copyNameScope(const MEDFileFieldNameScope& other)
+{
+  _name=other._name;
+  _mesh_name=other._mesh_name;
+  _dt_unit=other._dt_unit;
+}
+
+/*!
+ * Returns the mesh name.
+ *  \return std::string - a string holding the mesh name.
+ *  \throw If \c _field_per_mesh.empty()
+ */
+std::string MEDFileFieldNameScope::getMeshName() const
+{
+  return _mesh_name;
+}
+
+void MEDFileFieldNameScope::setMeshName(const std::string& meshName)
+{
+  _mesh_name=meshName;
+}
+
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldGlobs.hxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldGlobs.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldGlobs.hxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldGlobs.hxx	2018-04-19 17:25:17.835799294 +0200
@@ -0,0 +1,192 @@
+// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#ifndef __MEDFILEFIELDGLOBS_HXX__
+#define __MEDFILEFIELDGLOBS_HXX__
+
+#include "MEDLoaderDefines.hxx"
+
+#include "NormalizedGeometricTypes"
+#include "MEDCouplingMemArray.hxx"
+#include "MCAuto.hxx"
+
+#include "med.h"
+
+namespace MEDCoupling
+{
+  class MEDFileFieldGlobsReal;
+  class MEDFileEntities;
+  class MEDFileWritable;
+  class MEDFileFieldLoc;
+  
+  class MEDFileFieldGlobs : public RefCountObject
+  {
+  public:
+    static MEDFileFieldGlobs *New(med_idt fid);
+    static MEDFileFieldGlobs *New();
+    std::size_t getHeapMemorySizeWithoutChildren() const;
+    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDFileFieldGlobs *deepCopy() const;
+    MEDFileFieldGlobs *shallowCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const;
+    MEDFileFieldGlobs *deepCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const;
+    void simpleRepr(std::ostream& oss) const;
+    void appendGlobs(const MEDFileFieldGlobs& other, double eps);
+    void checkGlobsPflsPartCoherency(const std::vector<std::string>& pflsUsed) const;
+    void checkGlobsLocsPartCoherency(const std::vector<std::string>& locsUsed) const;
+    void loadProfileInFile(med_idt fid, int id, const std::string& pflName);
+    void loadProfileInFile(med_idt fid, int id);
+    void loadGlobals(med_idt fid, const MEDFileFieldGlobsReal& real);
+    void loadAllGlobals(med_idt fid, const MEDFileEntities *entities);
+    void writeGlobals(med_idt fid, const MEDFileWritable& opt) const;
+    std::vector<std::string> getPfls() const;
+    std::vector<std::string> getLocs() const;
+    bool existsPfl(const std::string& pflName) const;
+    bool existsLoc(const std::string& locName) const;
+    std::string createNewNameOfPfl() const;
+    std::string createNewNameOfLoc() const;
+    std::vector< std::vector<int> > whichAreEqualProfiles() const;
+    std::vector< std::vector<int> > whichAreEqualLocs(double eps) const;
+    void setFileName(const std::string& fileName) { _file_name=fileName; }
+    void changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    void changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    int getNbOfGaussPtPerCell(int locId) const;
+    int getLocalizationId(const std::string& loc) const;
+    int getProfileId(const std::string& pfl) const;
+    std::string getFileName() const { return _file_name; }
+    const MEDFileFieldLoc& getLocalizationFromId(int locId) const;
+    const MEDFileFieldLoc& getLocalization(const std::string& locName) const;
+    const DataArrayInt *getProfileFromId(int pflId) const;
+    const DataArrayInt *getProfile(const std::string& pflName) const;
+    MEDFileFieldLoc& getLocalizationFromId(int locId);
+    MEDFileFieldLoc& getLocalization(const std::string& locName);
+    DataArrayInt *getProfile(const std::string& pflName);
+    DataArrayInt *getProfileFromId(int pflId);
+    void killProfileIds(const std::vector<int>& pflIds);
+    void killLocalizationIds(const std::vector<int>& locIds);
+    void killStructureElementsInGlobs();
+    //
+    void appendProfile(DataArrayInt *pfl);
+    void appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
+    //
+    static std::string CreateNewNameNotIn(const std::string& prefix, const std::vector<std::string>& namesToAvoid);
+  protected:
+    MEDFileFieldGlobs(med_idt fid);
+    MEDFileFieldGlobs();
+    ~MEDFileFieldGlobs();
+  protected:
+    std::vector< MCAuto<DataArrayInt> > _pfls;
+    std::vector< MCAuto<MEDFileFieldLoc> > _locs;
+    std::string _file_name;
+  };
+
+  /// @endcond INTERNAL
+
+  class MEDFileFieldGlobsReal
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileFieldGlobsReal(med_idt fid);
+    MEDLOADER_EXPORT MEDFileFieldGlobsReal();
+    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
+    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDLOADER_EXPORT void simpleReprGlobs(std::ostream& oss) const;
+    MEDLOADER_EXPORT void resetContent();
+    MEDLOADER_EXPORT void killStructureElementsInGlobs();
+    MEDLOADER_EXPORT void shallowCpyGlobs(const MEDFileFieldGlobsReal& other);
+    MEDLOADER_EXPORT void deepCpyGlobs(const MEDFileFieldGlobsReal& other);
+    MEDLOADER_EXPORT void shallowCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other);
+    MEDLOADER_EXPORT void deepCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other);
+    MEDLOADER_EXPORT void appendGlobs(const MEDFileFieldGlobsReal& other, double eps);
+    MEDLOADER_EXPORT void checkGlobsCoherency() const;
+    MEDLOADER_EXPORT void checkGlobsPflsPartCoherency() const;
+    MEDLOADER_EXPORT void checkGlobsLocsPartCoherency() const;
+    MEDLOADER_EXPORT virtual std::vector<std::string> getPflsReallyUsed() const = 0;
+    MEDLOADER_EXPORT virtual std::vector<std::string> getLocsReallyUsed() const = 0;
+    MEDLOADER_EXPORT virtual std::vector<std::string> getPflsReallyUsedMulti() const = 0;
+    MEDLOADER_EXPORT virtual std::vector<std::string> getLocsReallyUsedMulti() const = 0;
+    MEDLOADER_EXPORT virtual void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif) = 0;
+    MEDLOADER_EXPORT virtual void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif) = 0;
+    MEDLOADER_EXPORT virtual ~MEDFileFieldGlobsReal();
+    //
+    MEDLOADER_EXPORT void loadProfileInFile(med_idt fid, int id, const std::string& pflName);
+    MEDLOADER_EXPORT void loadProfileInFile(med_idt fid, int id);
+    MEDLOADER_EXPORT void loadGlobals(med_idt fid);
+    MEDLOADER_EXPORT void loadAllGlobals(med_idt fid, const MEDFileEntities *entities=0);
+    MEDLOADER_EXPORT void writeGlobals(med_idt fid, const MEDFileWritable& opt) const;
+    MEDLOADER_EXPORT std::vector<std::string> getPfls() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocs() const;
+    MEDLOADER_EXPORT bool existsPfl(const std::string& pflName) const;
+    MEDLOADER_EXPORT bool existsLoc(const std::string& locName) const;
+    MEDLOADER_EXPORT std::string createNewNameOfPfl() const;
+    MEDLOADER_EXPORT std::string createNewNameOfLoc() const;
+    MEDLOADER_EXPORT std::vector< std::vector<int> > whichAreEqualProfiles() const;
+    MEDLOADER_EXPORT std::vector< std::vector<int> > whichAreEqualLocs(double eps) const;
+    MEDLOADER_EXPORT void setFileName(const std::string& fileName);
+    MEDLOADER_EXPORT void changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changePflsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changeLocsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changePflName(const std::string& oldName, const std::string& newName);
+    MEDLOADER_EXPORT void changeLocName(const std::string& oldName, const std::string& newName);
+    MEDLOADER_EXPORT std::vector< std::pair<std::vector<std::string>, std::string > > zipPflsNames();
+    MEDLOADER_EXPORT std::vector< std::pair<std::vector<std::string>, std::string > > zipLocsNames(double eps);
+    MEDLOADER_EXPORT int getNbOfGaussPtPerCell(int locId) const;
+    MEDLOADER_EXPORT int getLocalizationId(const std::string& loc) const;
+    MEDLOADER_EXPORT int getProfileId(const std::string& pfl) const;
+    MEDLOADER_EXPORT std::string getFileName() const;
+    MEDLOADER_EXPORT const MEDFileFieldLoc& getLocalizationFromId(int locId) const;
+    MEDLOADER_EXPORT const MEDFileFieldLoc& getLocalization(const std::string& locName) const;
+    MEDLOADER_EXPORT MEDFileFieldLoc& getLocalizationFromId(int locId);
+    MEDLOADER_EXPORT MEDFileFieldLoc& getLocalization(const std::string& locName);
+    MEDLOADER_EXPORT const DataArrayInt *getProfile(const std::string& pflName) const;
+    MEDLOADER_EXPORT const DataArrayInt *getProfileFromId(int pflId) const;
+    MEDLOADER_EXPORT DataArrayInt *getProfile(const std::string& pflName);
+    MEDLOADER_EXPORT DataArrayInt *getProfileFromId(int pflId);
+    MEDLOADER_EXPORT void killProfileIds(const std::vector<int>& pflIds);
+    MEDLOADER_EXPORT void killLocalizationIds(const std::vector<int>& locIds);
+    //
+    MEDLOADER_EXPORT void appendProfile(DataArrayInt *pfl);
+    MEDLOADER_EXPORT void appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
+  protected:
+    MEDFileFieldGlobs *contentNotNull();
+    const MEDFileFieldGlobs *contentNotNull() const;
+  protected:
+    MCAuto< MEDFileFieldGlobs > _globals;
+  };
+
+  class MEDFileFieldNameScope
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileFieldNameScope();
+    MEDLOADER_EXPORT MEDFileFieldNameScope(const std::string& fieldName, const std::string& meshName);
+    MEDLOADER_EXPORT std::string getName() const;
+    MEDLOADER_EXPORT void setName(const std::string& fieldName);
+    MEDLOADER_EXPORT std::string getDtUnit() const;
+    MEDLOADER_EXPORT void setDtUnit(const std::string& dtUnit);
+    MEDLOADER_EXPORT void copyNameScope(const MEDFileFieldNameScope& other);
+    MEDLOADER_EXPORT std::string getMeshName() const;
+    MEDLOADER_EXPORT void setMeshName(const std::string& meshName);
+  protected:
+    std::string _name;
+    std::string _dt_unit;
+    std::string _mesh_name;
+  };
+}
+
+#endif
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileField.hxx MEDCOUPLING_new/src/MEDLoader/MEDFileField.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileField.hxx	2018-04-19 17:04:36.757223122 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileField.hxx	2018-04-19 17:25:17.821799017 +0200
@@ -23,6 +23,11 @@
 
 #include "MEDLoaderDefines.hxx"
 
+#include "MEDFileFieldInternal.hxx"
+#include "MEDFileFieldGlobs.hxx"
+#include "MEDFileField1TS.hxx"
+#include "MEDFileFieldMultiTS.hxx"
+
 #include "MEDFileFieldOverView.hxx"
 #include "MEDFileUtilities.txx"
 #include "MEDFileEntities.hxx"
@@ -53,1326 +58,8 @@
   class MEDFileMesh;
   class MEDFileFieldVisitor;
 
-  class MEDFileGTKeeper
-  {
-  public:
-    virtual MEDFileGTKeeper *deepCopy() const = 0;
-    virtual INTERP_KERNEL::NormalizedCellType getGeoType() const = 0;
-    virtual std::string getRepr() const = 0;
-    virtual bool isEqual(const MEDFileGTKeeper *other) const = 0;
-    virtual ~MEDFileGTKeeper();
-  };
-
-  class MEDFileGTKeeperSta : public MEDFileGTKeeper
-  {
-  public:
-    MEDFileGTKeeperSta(INTERP_KERNEL::NormalizedCellType gt):_geo_type(gt) { }
-    MEDFileGTKeeper *deepCopy() const;
-    INTERP_KERNEL::NormalizedCellType getGeoType() const;
-    std::string getRepr() const;
-    bool isEqual(const MEDFileGTKeeper *other) const;
-  private:
-    INTERP_KERNEL::NormalizedCellType _geo_type;
-  };
-
-
-  class MEDFileGTKeeperDyn : public MEDFileGTKeeper
-  {
-  public:
-    MEDFileGTKeeperDyn(const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileStructureElement *se);
-    MEDFileGTKeeper *deepCopy() const;
-    INTERP_KERNEL::NormalizedCellType getGeoType() const;
-    std::string getRepr() const;
-    bool isEqual(const MEDFileGTKeeper *other) const;
-    const MEDFileUMesh *getMesh() const { return _mesh; }
-    const MEDFileUMesh *getSection() const { return _section; }
-    const MEDFileStructureElement *getSE() const { return _se; }
-  private:
-    MCConstAuto<MEDFileUMesh> _mesh;
-    MCConstAuto<MEDFileUMesh> _section;
-    MCConstAuto<MEDFileStructureElement> _se;
-  };
-    
-  class MEDFileFieldLoc : public RefCountObject
-  {
-  public:
-    MEDLOADER_EXPORT void simpleRepr(std::ostream& oss) const;
-    MEDLOADER_EXPORT std::string getName() const { return _name; }
-    MEDLOADER_EXPORT void setName(const std::string& name);
-    static MEDFileFieldLoc *New(med_idt fid, const std::string& locName);
-    static MEDFileFieldLoc *New(med_idt fid, int i, const MEDFileEntities *entities);
-    static MEDFileFieldLoc *New(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
-    std::size_t getHeapMemorySizeWithoutChildren() const;
-    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDFileFieldLoc *deepCopy() const;
-    bool isOnStructureElement() const;
-    const MEDFileGTKeeper *getUndergroundGTKeeper() const { return _gt; }
-    MEDLOADER_EXPORT int getNbOfGaussPtPerCell() const { return _nb_gauss_pt; }
-    MEDLOADER_EXPORT void writeLL(med_idt fid) const;
-    MEDLOADER_EXPORT std::string repr() const;
-    MEDLOADER_EXPORT bool isName(const std::string& name) const { return _name==name; }
-    MEDLOADER_EXPORT int getDimension() const { return _dim; }
-    MEDLOADER_EXPORT int getNumberOfGaussPoints() const { return _nb_gauss_pt; }
-    MEDLOADER_EXPORT int getNumberOfPointsInCells() const { return _nb_node_per_cell; }
-    MEDLOADER_EXPORT const std::vector<double>& getRefCoords() const { return _ref_coo; }
-    MEDLOADER_EXPORT const std::vector<double>& getGaussCoords() const { return _gs_coo; }
-    MEDLOADER_EXPORT const std::vector<double>& getGaussWeights() const { return _w; }
-    MEDLOADER_EXPORT INTERP_KERNEL::NormalizedCellType getGeoType() const { return _gt->getGeoType(); }
-    MEDLOADER_EXPORT bool isEqual(const MEDFileFieldLoc& other, double eps) const;
-  private:
-    MEDFileFieldLoc(const MEDFileFieldLoc& other);
-    MEDFileFieldLoc(med_idt fid, const std::string& locName);
-    MEDFileFieldLoc(med_idt fid, int id, const MEDFileEntities *entities);
-    MEDFileFieldLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
-  private:
-    int _dim;
-    int _nb_gauss_pt;
-    INTERP_KERNEL::AutoCppPtr<MEDFileGTKeeper> _gt;
-    int _nb_node_per_cell;
-    std::string _name;
-    std::vector<double> _ref_coo;
-    std::vector<double> _gs_coo;
-    std::vector<double> _w;
-  };
-
-  /// @cond INTERNAL
-  class MEDFileAnyTypeField1TSWithoutSDA;
-  class MEDFileFieldPerMeshPerTypeCommon;
-  class MEDFileFieldPerMeshPerType;
-  class MEDFileField1TSWithoutSDA;
-  class MEDFileFieldNameScope;
-  class MEDFileFieldGlobsReal;
-  class MEDFileFieldPerMesh;
-
-  class MEDFileFieldPerMeshPerTypePerDisc : public RefCountObject, public MEDFileWritable
-  {
-  public:
-    static MEDFileFieldPerMeshPerTypePerDisc *NewOnRead(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const PartDefinition *pd);
-    static MEDFileFieldPerMeshPerTypePerDisc *New(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int locId);
-    static MEDFileFieldPerMeshPerTypePerDisc *New(const MEDFileFieldPerMeshPerTypePerDisc& other);
-    std::size_t getHeapMemorySizeWithoutChildren() const;
-    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDFileFieldPerMeshPerTypePerDisc *deepCopy(MEDFileFieldPerMeshPerTypeCommon *father) const;
-    void assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    void assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arrr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    void assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob);
-    void getCoarseData(TypeOfField& type, std::pair<int,int>& dad, std::string& pfl, std::string& loc) const;
-    void writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const;
-    const MEDFileFieldPerMeshPerTypeCommon *getFather() const;
-    void loadOnlyStructureOfDataRecursively(med_idt fid, int& start, const MEDFileFieldNameScope& nasc);
-    void loadBigArray(med_idt fid, const MEDFileFieldNameScope& nasc);
-    void setNewStart(int newValueOfStart);
-    int getIteration() const;
-    int getOrder() const;
-    double getTime() const;
-    std::string getMeshName() const;
-    TypeOfField getType() const;
-    void simpleRepr(int bkOffset, std::ostream& oss, int id) const;
-    void fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const;
-    void setType(TypeOfField newType);
-    INTERP_KERNEL::NormalizedCellType getGeoType() const;
-    int getNumberOfComponents() const;
-    int getNumberOfTuples() const;
-    int getStart() const { return _start; }
-    int getEnd() const { return _end; }
-    void setEnd(int endd) { _end=endd; }
-    int getNumberOfVals() const { return _nval; }
-    DataArray *getOrCreateAndGetArray();
-    const DataArray *getOrCreateAndGetArray() const;
-    const std::vector<std::string>& getInfo() const;
-    std::string getProfile() const;
-    void setProfile(const std::string& newPflName);
-    std::string getLocalization() const;
-    void setLocalization(const std::string& newLocName);
-    int getLocId() const { return _loc_id; }
-    void setLocId(int newId) const { _loc_id=newId; }
-    void setFather(MEDFileFieldPerMeshPerTypeCommon *newFather) { _father=newFather; }
-    void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    void getFieldAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs,
-                         std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const;
-    void fillValues(int discId, int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    int fillEltIdsFromCode(int offset, const std::vector<int>& codeOfMesh, const MEDFileFieldGlobsReal& glob, int *ptToFill) const;
-    int fillTupleIds(int *ptToFill) const;
-    static int ConvertType(TypeOfField type, int locId);
-    static std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > SplitPerDiscretization(const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entries);
-    static bool RenumberChunks(int offset, const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
-                               const DataArrayInt *explicitIdsInMesh, const std::vector<int>& newCode,
-                               MEDFileFieldGlobsReal& glob, DataArrayDouble *arr, std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >& result);
-    static MEDFileFieldPerMeshPerTypePerDisc *NewObjectOnSameDiscThanPool(TypeOfField typeF, INTERP_KERNEL::NormalizedCellType geoType, DataArrayInt *idsOfMeshElt,
-                                                                          bool isPfl, int nbi, int offset, std::list< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
-                                                                          MEDFileFieldGlobsReal& glob, bool &notInExisting);
-    static MCAuto<MEDFileFieldPerMeshPerTypePerDisc> Aggregate(int &start, const std::vector<std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, TypeOfField tof, MEDFileFieldPerMeshPerType *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo);
-    MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type):_type(type),_father(fath),_start(-1),_end(-1),_nval(-1),_loc_id(-5),_profile_it(-1) { }
-  private:
-    MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const PartDefinition *pd);
-    MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const std::string& dummy);
-    MEDFileFieldPerMeshPerTypePerDisc(const MEDFileFieldPerMeshPerTypePerDisc& other);
-    MEDFileFieldPerMeshPerTypePerDisc();
-  private:
-    void goReadZeValuesInFile(med_idt fid, const std::string& fieldName, int nbOfCompo, int iteration, int order, med_entity_type menti, med_geometry_type mgeoti, unsigned char *startFeedingPtr);
-  private:
-    TypeOfField _type;
-    MEDFileFieldPerMeshPerTypeCommon *_father;
-    int _start;
-    int _end;
-    //! _nval is different than end-start in case of ON_GAUSS_PT and ON_GAUSS_NE ! (_nval=(_end-_start)/nbi)
-    int _nval;
-    std::string _profile;
-    std::string _localization;
-    //! only on assignement -3 : ON_NODES, -2 : ON_CELLS, -1 : ON_GAUSS_NE, 0..* : ON_GAUSS_PT
-    mutable int _loc_id;
-    mutable int _profile_it;
-    MCAuto<PartDefinition> _pd;
-  public:
-    mutable int _tmp_work1;
-  };
-
-  class MEDFileFieldPerMeshPerTypeCommon : public RefCountObject, public MEDFileWritable
-  {
-  public:
-    std::size_t getHeapMemorySizeWithoutChildren() const;
-    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    void assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    void assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    void assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob);
-    void assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    const MEDFileFieldPerMesh *getFather() const;
-    void loadOnlyStructureOfDataRecursively(med_idt fid, int &start, const MEDFileFieldNameScope& nasc);
-    void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
-    void writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const;
-    bool isUniqueLevel(int& dim) const;
-    void fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const;
-    void fillFieldSplitedByType(std::vector< std::pair<int,int> >& dads, std::vector<TypeOfField>& types, std::vector<std::string>& pfls, std::vector<std::string>& locs) const;
-    int getIteration() const;
-    int getOrder() const;
-    double getTime() const;
-    std::string getMeshName() const;
-    void getSizes(int& globalSz, int& nbOfEntries) const;
-    int getNumberOfComponents() const;
-    bool presenceOfMultiDiscPerGeoType() const;
-    void pushDiscretization(MEDFileFieldPerMeshPerTypePerDisc *disc);
-    DataArray *getOrCreateAndGetArray();
-    const DataArray *getOrCreateAndGetArray() const;
-    const std::vector<std::string>& getInfo() const;
-    std::vector<std::string> getPflsReallyUsed() const;
-    std::vector<std::string> getLocsReallyUsed() const;
-    std::vector<std::string> getPflsReallyUsedMulti() const;
-    std::vector<std::string> getLocsReallyUsedMulti() const;
-    void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenLocId(int locId);
-    const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenLocId(int locId) const;
-    int getNumberOfLoc() const { return _field_pm_pt_pd.size(); }
-    void fillValues(int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    void setLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves);
-    bool keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its);
-    bool keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its);
-    static med_entity_type ConvertIntoMEDFileType(TypeOfField ikType, INTERP_KERNEL::NormalizedCellType ikGeoType, med_geometry_type& medfGeoType);
-    MEDFileFieldPerMeshPerTypeCommon(MEDFileFieldPerMesh *father):_father(father) { }
-    void setFather(MEDFileFieldPerMesh *father);
-    void accept(MEDFileFieldVisitor& visitor) const;
-  public:
-    virtual ~MEDFileFieldPerMeshPerTypeCommon();
-    virtual void getDimension(int& dim) const = 0;
-    virtual INTERP_KERNEL::NormalizedCellType getGeoType() const = 0;
-    virtual void entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const = 0;
-    virtual void simpleRepr(int bkOffset, std::ostream& oss, int id) const = 0;
-    virtual std::string getGeoTypeRepr() const = 0;
-    virtual MEDFileFieldPerMeshPerTypeCommon *deepCopy(MEDFileFieldPerMesh *father) const = 0;
-    virtual void getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const = 0;
-  protected:
-    void deepCopyElements();
-    std::vector<int> addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells);
-    std::vector<int> addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells);
-    std::vector<int> addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells);
-    std::vector<int> addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells);
-  private:
-    MEDFileFieldPerMesh *_father;
-  protected:
-    std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > _field_pm_pt_pd;
-  };
-
-  class MEDFileFieldPerMeshPerType : public MEDFileFieldPerMeshPerTypeCommon
-  {
-  public:
-    static MEDFileFieldPerMeshPerType *New(MEDFileFieldPerMesh *fath, INTERP_KERNEL::NormalizedCellType geoType);
-    static MEDFileFieldPerMeshPerType *NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd);
-    static MCAuto<MEDFileFieldPerMeshPerType> Aggregate(int &start, const std::vector< std::pair<int,const MEDFileFieldPerMeshPerType *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, INTERP_KERNEL::NormalizedCellType gt, MEDFileFieldPerMesh *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo);
-  public:// overload of abstract methods
-    void getDimension(int& dim) const;
-    INTERP_KERNEL::NormalizedCellType getGeoType() const;
-    void entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const;
-    void simpleRepr(int bkOffset, std::ostream& oss, int id) const;
-    std::string getGeoTypeRepr() const;
-    MEDFileFieldPerMeshPerType *deepCopy(MEDFileFieldPerMesh *father) const;
-    void getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const;
-  private:
-    MEDFileFieldPerMeshPerType(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd);
-    MEDFileFieldPerMeshPerType(MEDFileFieldPerMesh *father, INTERP_KERNEL::NormalizedCellType gt);
-  private:
-    INTERP_KERNEL::NormalizedCellType _geo_type;
-  };
-
-  class MEDFileFieldPerMeshPerTypeDyn : public MEDFileFieldPerMeshPerTypeCommon
-  {
-  public:
-    static MEDFileFieldPerMeshPerTypeDyn *NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileEntities *entities, int idGT, const MEDFileFieldNameScope& nasc);
-    int getDynGT() const;
-    std::string getModelName() const;
-  public:
-    void getDimension(int& dim) const;
-    INTERP_KERNEL::NormalizedCellType getGeoType() const;
-    void entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const;
-    void simpleRepr(int bkOffset, std::ostream& oss, int id) const;
-    std::string getGeoTypeRepr() const;
-    MEDFileFieldPerMeshPerTypeDyn *deepCopy(MEDFileFieldPerMesh *father) const;
-    void getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const;
-  private:
-    MEDFileFieldPerMeshPerTypeDyn(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileStructureElement *se, const MEDFileFieldNameScope& nasc);
-  private:
-    MCConstAuto<MEDFileStructureElement> _se;
-  };
-  
-  class MEDFileMesh;
-
-  class MEDFileFieldPerMesh : public RefCountObject, public MEDFileWritable
-  {
-  public:
-    static MEDFileFieldPerMesh *New(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh);
-    static MEDFileFieldPerMesh *NewOnRead(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities);
-    std::size_t getHeapMemorySizeWithoutChildren() const;
-    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDFileFieldPerMesh *deepCopy(MEDFileAnyTypeField1TSWithoutSDA *father) const;
-    void simpleRepr(int bkOffset,std::ostream& oss, int id) const;
-    void copyTinyInfoFrom(const MEDCouplingMesh *mesh);
-    void assignFieldProfile(int& start, const DataArrayInt *multiTypePfl, const std::vector<int>& code, const std::vector<int>& code2, const std::vector<DataArrayInt *>& idsInPflPerType, const std::vector<DataArrayInt *>& idsPerType, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    void assignFieldNoProfileNoRenum(int& start, const std::vector<int>& code, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    void assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob);
-    void assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    void loadOnlyStructureOfDataRecursively(med_idt fid, int &start, const MEDFileFieldNameScope& nasc);
-    void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
-    void writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const;
-    void fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const;
-    std::vector< std::vector< std::pair<int,int> > > getFieldSplitedByType(std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    void accept(MEDFileFieldVisitor& visitor) const;
-    void getDimension(int& dim) const;
-    bool isUniqueLevel(int& dim) const;
-    double getTime() const;
-    int getIteration() const;
-    int getOrder() const;
-    int getMeshIteration() const { return _mesh_iteration; }
-    int getMeshOrder() const { return _mesh_order; }
-    std::string getMeshName() const;
-    void setMeshName(const std::string& meshName);
-    int getNumberOfComponents() const;
-    bool presenceOfMultiDiscPerGeoType() const;
-    bool presenceOfStructureElements() const;
-    bool onlyStructureElements() const;
-    void killStructureElements();
-    void keepOnlyStructureElements();
-    void keepOnlyOnSE(const std::string& seName);
-    void getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const;
-    DataArray *getOrCreateAndGetArray();
-    const DataArray *getOrCreateAndGetArray() const;
-    const std::vector<std::string>& getInfo() const;
-    std::vector<std::string> getPflsReallyUsed() const;
-    std::vector<std::string> getLocsReallyUsed() const;
-    std::vector<std::string> getPflsReallyUsedMulti() const;
-    std::vector<std::string> getLocsReallyUsedMulti() const;
-    void convertMedBallIntoClassic();
-    bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
-    bool renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N, MEDFileFieldGlobsReal& glob);
-    void keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its);
-    void keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its);
-    void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDCouplingFieldDouble *getFieldOnMeshAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    DataArray *getFieldOnMeshAtLevelWithPfl(TypeOfField type, const MEDCouplingMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const;
-    void getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId);
-    const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId) const;
-    static MCAuto<MEDFileFieldPerMesh> Aggregate(int &start, const std::vector<const MEDFileFieldPerMesh *>& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, MEDFileAnyTypeField1TSWithoutSDA *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo);
-  private:
-    int addNewEntryIfNecessary(INTERP_KERNEL::NormalizedCellType type);
-    MEDCouplingFieldDouble *finishField(TypeOfField type, const MEDFileFieldGlobsReal *glob,
-                                        const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs, const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    MEDCouplingFieldDouble *finishField2(TypeOfField type, const MEDFileFieldGlobsReal *glob,
-                                         const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs,
-                                         const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes,
-                                         const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    MEDCouplingFieldDouble *finishFieldNode2(const MEDFileFieldGlobsReal *glob,
-                                             const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs,
-                                             const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    DataArray *finishField4(const std::vector< std::pair<int,int> >& dads, const DataArrayInt *pflIn, int nbOfElems, DataArrayInt *&pflOut) const;
-    void assignNewLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves);
-    static void SortArraysPerType(const MEDFileFieldGlobsReal *glob, TypeOfField type, 
-                                  const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<const DataArrayInt *>& pfls, const std::vector<int>& locs,
-                                  std::vector<int>& code, std::vector<DataArrayInt *>& notNullPfls);
-    static int ComputeNbOfElems(const MEDFileFieldGlobsReal *glob, TypeOfField type, const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs);
-    MEDFileFieldPerMesh(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities);
-    MEDFileFieldPerMesh(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh);
-    MEDFileFieldPerMesh(MEDFileAnyTypeField1TSWithoutSDA *fath, const std::string& meshName, int meshIt, int meshOrd):_father(fath),_mesh_iteration(meshIt),_mesh_order(meshOrd) { }
-  private:
-    int _mesh_iteration;
-    int _mesh_order;
-    MEDFileAnyTypeField1TSWithoutSDA *_father;
-    std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > _field_pm_pt;
-  };
-
-  class MEDFileFieldGlobsReal;
-
-  class MEDFileFieldGlobs : public RefCountObject
-  {
-  public:
-    static MEDFileFieldGlobs *New(med_idt fid);
-    static MEDFileFieldGlobs *New();
-    std::size_t getHeapMemorySizeWithoutChildren() const;
-    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDFileFieldGlobs *deepCopy() const;
-    MEDFileFieldGlobs *shallowCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const;
-    MEDFileFieldGlobs *deepCpyPart(const std::vector<std::string>& pfls, const std::vector<std::string>& locs) const;
-    void simpleRepr(std::ostream& oss) const;
-    void appendGlobs(const MEDFileFieldGlobs& other, double eps);
-    void checkGlobsPflsPartCoherency(const std::vector<std::string>& pflsUsed) const;
-    void checkGlobsLocsPartCoherency(const std::vector<std::string>& locsUsed) const;
-    void loadProfileInFile(med_idt fid, int id, const std::string& pflName);
-    void loadProfileInFile(med_idt fid, int id);
-    void loadGlobals(med_idt fid, const MEDFileFieldGlobsReal& real);
-    void loadAllGlobals(med_idt fid, const MEDFileEntities *entities);
-    void writeGlobals(med_idt fid, const MEDFileWritable& opt) const;
-    std::vector<std::string> getPfls() const;
-    std::vector<std::string> getLocs() const;
-    bool existsPfl(const std::string& pflName) const;
-    bool existsLoc(const std::string& locName) const;
-    std::string createNewNameOfPfl() const;
-    std::string createNewNameOfLoc() const;
-    std::vector< std::vector<int> > whichAreEqualProfiles() const;
-    std::vector< std::vector<int> > whichAreEqualLocs(double eps) const;
-    void setFileName(const std::string& fileName) { _file_name=fileName; }
-    void changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    void changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    int getNbOfGaussPtPerCell(int locId) const;
-    int getLocalizationId(const std::string& loc) const;
-    std::string getFileName() const { return _file_name; }
-    const MEDFileFieldLoc& getLocalizationFromId(int locId) const;
-    const MEDFileFieldLoc& getLocalization(const std::string& locName) const;
-    const DataArrayInt *getProfileFromId(int pflId) const;
-    const DataArrayInt *getProfile(const std::string& pflName) const;
-    MEDFileFieldLoc& getLocalizationFromId(int locId);
-    MEDFileFieldLoc& getLocalization(const std::string& locName);
-    DataArrayInt *getProfile(const std::string& pflName);
-    DataArrayInt *getProfileFromId(int pflId);
-    void killProfileIds(const std::vector<int>& pflIds);
-    void killLocalizationIds(const std::vector<int>& locIds);
-    void killStructureElementsInGlobs();
-    //
-    void appendProfile(DataArrayInt *pfl);
-    void appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
-    //
-    static std::string CreateNewNameNotIn(const std::string& prefix, const std::vector<std::string>& namesToAvoid);
-  protected:
-    MEDFileFieldGlobs(med_idt fid);
-    MEDFileFieldGlobs();
-    ~MEDFileFieldGlobs();
-  protected:
-    std::vector< MCAuto<DataArrayInt> > _pfls;
-    std::vector< MCAuto<MEDFileFieldLoc> > _locs;
-    std::string _file_name;
-  };
-
-  /// @endcond INTERNAL
-
-  class MEDFileFieldGlobsReal
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileFieldGlobsReal(med_idt fid);
-    MEDLOADER_EXPORT MEDFileFieldGlobsReal();
-    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
-    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDLOADER_EXPORT void simpleReprGlobs(std::ostream& oss) const;
-    MEDLOADER_EXPORT void resetContent();
-    MEDLOADER_EXPORT void killStructureElementsInGlobs();
-    MEDLOADER_EXPORT void shallowCpyGlobs(const MEDFileFieldGlobsReal& other);
-    MEDLOADER_EXPORT void deepCpyGlobs(const MEDFileFieldGlobsReal& other);
-    MEDLOADER_EXPORT void shallowCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other);
-    MEDLOADER_EXPORT void deepCpyOnlyUsedGlobs(const MEDFileFieldGlobsReal& other);
-    MEDLOADER_EXPORT void appendGlobs(const MEDFileFieldGlobsReal& other, double eps);
-    MEDLOADER_EXPORT void checkGlobsCoherency() const;
-    MEDLOADER_EXPORT void checkGlobsPflsPartCoherency() const;
-    MEDLOADER_EXPORT void checkGlobsLocsPartCoherency() const;
-    MEDLOADER_EXPORT virtual std::vector<std::string> getPflsReallyUsed() const = 0;
-    MEDLOADER_EXPORT virtual std::vector<std::string> getLocsReallyUsed() const = 0;
-    MEDLOADER_EXPORT virtual std::vector<std::string> getPflsReallyUsedMulti() const = 0;
-    MEDLOADER_EXPORT virtual std::vector<std::string> getLocsReallyUsedMulti() const = 0;
-    MEDLOADER_EXPORT virtual void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif) = 0;
-    MEDLOADER_EXPORT virtual void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif) = 0;
-    MEDLOADER_EXPORT virtual ~MEDFileFieldGlobsReal();
-    //
-    MEDLOADER_EXPORT void loadProfileInFile(med_idt fid, int id, const std::string& pflName);
-    MEDLOADER_EXPORT void loadProfileInFile(med_idt fid, int id);
-    MEDLOADER_EXPORT void loadGlobals(med_idt fid);
-    MEDLOADER_EXPORT void loadAllGlobals(med_idt fid, const MEDFileEntities *entities=0);
-    MEDLOADER_EXPORT void writeGlobals(med_idt fid, const MEDFileWritable& opt) const;
-    MEDLOADER_EXPORT std::vector<std::string> getPfls() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocs() const;
-    MEDLOADER_EXPORT bool existsPfl(const std::string& pflName) const;
-    MEDLOADER_EXPORT bool existsLoc(const std::string& locName) const;
-    MEDLOADER_EXPORT std::string createNewNameOfPfl() const;
-    MEDLOADER_EXPORT std::string createNewNameOfLoc() const;
-    MEDLOADER_EXPORT std::vector< std::vector<int> > whichAreEqualProfiles() const;
-    MEDLOADER_EXPORT std::vector< std::vector<int> > whichAreEqualLocs(double eps) const;
-    MEDLOADER_EXPORT void setFileName(const std::string& fileName);
-    MEDLOADER_EXPORT void changePflsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changeLocsNamesInStruct(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changePflsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changeLocsNames(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changePflName(const std::string& oldName, const std::string& newName);
-    MEDLOADER_EXPORT void changeLocName(const std::string& oldName, const std::string& newName);
-    MEDLOADER_EXPORT std::vector< std::pair<std::vector<std::string>, std::string > > zipPflsNames();
-    MEDLOADER_EXPORT std::vector< std::pair<std::vector<std::string>, std::string > > zipLocsNames(double eps);
-    MEDLOADER_EXPORT int getNbOfGaussPtPerCell(int locId) const;
-    MEDLOADER_EXPORT int getLocalizationId(const std::string& loc) const;
-    MEDLOADER_EXPORT std::string getFileName() const;
-    MEDLOADER_EXPORT const MEDFileFieldLoc& getLocalizationFromId(int locId) const;
-    MEDLOADER_EXPORT const MEDFileFieldLoc& getLocalization(const std::string& locName) const;
-    MEDLOADER_EXPORT MEDFileFieldLoc& getLocalizationFromId(int locId);
-    MEDLOADER_EXPORT MEDFileFieldLoc& getLocalization(const std::string& locName);
-    MEDLOADER_EXPORT const DataArrayInt *getProfile(const std::string& pflName) const;
-    MEDLOADER_EXPORT const DataArrayInt *getProfileFromId(int pflId) const;
-    MEDLOADER_EXPORT DataArrayInt *getProfile(const std::string& pflName);
-    MEDLOADER_EXPORT DataArrayInt *getProfileFromId(int pflId);
-    MEDLOADER_EXPORT void killProfileIds(const std::vector<int>& pflIds);
-    MEDLOADER_EXPORT void killLocalizationIds(const std::vector<int>& locIds);
-    //
-    MEDLOADER_EXPORT void appendProfile(DataArrayInt *pfl);
-    MEDLOADER_EXPORT void appendLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
-  protected:
-    MEDFileFieldGlobs *contentNotNull();
-    const MEDFileFieldGlobs *contentNotNull() const;
-  protected:
-    MCAuto< MEDFileFieldGlobs > _globals;
-  };
-
-  class MEDFileFieldNameScope
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileFieldNameScope();
-    MEDLOADER_EXPORT MEDFileFieldNameScope(const std::string& fieldName, const std::string& meshName);
-    MEDLOADER_EXPORT std::string getName() const;
-    MEDLOADER_EXPORT void setName(const std::string& fieldName);
-    MEDLOADER_EXPORT std::string getDtUnit() const;
-    MEDLOADER_EXPORT void setDtUnit(const std::string& dtUnit);
-    MEDLOADER_EXPORT void copyNameScope(const MEDFileFieldNameScope& other);
-    MEDLOADER_EXPORT std::string getMeshName() const;
-    MEDLOADER_EXPORT void setMeshName(const std::string& meshName);
-  protected:
-    std::string _name;
-    std::string _dt_unit;
-    std::string _mesh_name;
-  };
-
   class MEDFileMeshes;
 
-  /*!
-   * SDA is for Shared Data Arrays such as profiles.
-   */
-  class MEDFileAnyTypeField1TSWithoutSDA : public RefCountObject, public MEDFileFieldNameScope
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA();
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order);
-    MEDLOADER_EXPORT int getIteration() const { return _iteration; }
-    MEDLOADER_EXPORT int getOrder() const { return _order; }
-    MEDLOADER_EXPORT double getTime(int& iteration, int& order) const { iteration=_iteration; order=_order; return _dt; }
-    MEDLOADER_EXPORT void setTime(int iteration, int order, double val) { _dt=val; _iteration=iteration; _order=order; }
-    MEDLOADER_EXPORT int getDimension() const;
-    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
-    MEDLOADER_EXPORT int getMeshIteration() const;
-    MEDLOADER_EXPORT int getMeshOrder() const;
-    MEDLOADER_EXPORT bool isDealingTS(int iteration, int order) const;
-    MEDLOADER_EXPORT std::pair<int,int> getDtIt() const;
-    MEDLOADER_EXPORT void fillIteration(std::pair<int,int>& p) const;
-    MEDLOADER_EXPORT void fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const;
-    MEDLOADER_EXPORT std::vector<TypeOfField> getTypesOfFieldAvailable() const;
-    //
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed2() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed2() const;
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti2() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti2() const;
-    MEDLOADER_EXPORT void changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    //
-    MEDLOADER_EXPORT int getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const;
-    MEDLOADER_EXPORT void convertMedBallIntoClassic();
-    MEDLOADER_EXPORT void makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl);
-    MEDLOADER_EXPORT std::vector< std::vector<std::pair<int,int> > > getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    //
-    MEDLOADER_EXPORT MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId);
-    MEDLOADER_EXPORT const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const;
-    MEDLOADER_EXPORT void deepCpyLeavesFrom(const MEDFileAnyTypeField1TSWithoutSDA& other);
-    MEDLOADER_EXPORT void accept(MEDFileFieldVisitor& visitor) const;
-  public:
-    MEDLOADER_EXPORT int getNumberOfComponents() const;
-    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
-    MEDLOADER_EXPORT std::vector<std::string>& getInfo();
-    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
-    MEDLOADER_EXPORT bool presenceOfStructureElements() const;
-    MEDLOADER_EXPORT bool onlyStructureElements() const;
-    MEDLOADER_EXPORT void killStructureElements();
-    MEDLOADER_EXPORT void keepOnlyStructureElements();
-    MEDLOADER_EXPORT void keepOnlyOnSE(const std::string& seName);
-    MEDLOADER_EXPORT void getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const;
-    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& infos);
-    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
-    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDLOADER_EXPORT int copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr);
-    MEDLOADER_EXPORT void setFieldNoProfileSBT(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    MEDLOADER_EXPORT void setFieldProfile(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arrOfVals, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
-    MEDLOADER_EXPORT virtual void simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TSWithoutSDA *deepCopy() const = 0;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TSWithoutSDA *shallowCpy() const = 0;
-    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > splitComponents() const;
-    MEDLOADER_EXPORT virtual const char *getTypeStr() const = 0;
-    MEDLOADER_EXPORT virtual DataArray *getUndergroundDataArray() const = 0;
-    MEDLOADER_EXPORT virtual DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const = 0;
-    MEDLOADER_EXPORT virtual void setArray(DataArray *arr) = 0;
-    MEDLOADER_EXPORT virtual DataArray *createNewEmptyDataArrayInstance() const = 0;
-    MEDLOADER_EXPORT virtual DataArray *getOrCreateAndGetArray() = 0;
-    MEDLOADER_EXPORT virtual const DataArray *getOrCreateAndGetArray() const = 0;
-  public:
-    MEDLOADER_EXPORT MEDCouplingFieldDouble *fieldOnMesh(const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const;
-    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldAtLevel(TypeOfField type, int meshDimRelToMax, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldOnMeshAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDFileMesh *mesh, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldAtTopLevel(TypeOfField type, const std::string& mName, int renumPol, const MEDFileFieldGlobsReal *glob, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    MEDLOADER_EXPORT MEDCouplingFieldDouble *getFieldOnMeshAtLevel(TypeOfField type, int renumPol, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, const DataArrayInt *cellRenum, const DataArrayInt *nodeRenum, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
-    DataArray *getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const;
-  public:
-    MEDLOADER_EXPORT bool renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N, MEDFileFieldGlobsReal& glob);
-    MEDLOADER_EXPORT std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > splitDiscretizations() const;
-    MEDLOADER_EXPORT std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > splitMultiDiscrPerGeoTypes() const;
-    MEDLOADER_EXPORT int keepOnlySpatialDiscretization(TypeOfField tof, std::vector< std::pair<int,int> >& its);
-    MEDLOADER_EXPORT int keepOnlyGaussDiscretization(std::size_t idOfDisc, std::vector< std::pair<int,int> >& its);
-  public:
-    MEDLOADER_EXPORT void allocNotFromFile(int newNbOfTuples);
-    MEDLOADER_EXPORT bool allocIfNecessaryTheArrayToReceiveDataFromFile();
-    MEDLOADER_EXPORT void loadOnlyStructureOfDataRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
-    MEDLOADER_EXPORT void loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc);
-    MEDLOADER_EXPORT void loadStructureAndBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT void unloadArrays();
-    MEDLOADER_EXPORT void writeLL(med_idt fid, const MEDFileWritable& opts, const MEDFileFieldNameScope& nasc) const;
-  protected:
-    int getMeshIdFromMeshName(const std::string& mName) const;
-    int addNewEntryIfNecessary(const MEDCouplingMesh *mesh);
-    void updateData(int newLgth, const std::vector< std::pair<int,int> >& oldStartStops);
-  protected:
-    std::vector< MCAuto< MEDFileFieldPerMesh > > _field_per_mesh;
-    int _iteration;
-    int _order;
-    double _dt;
-  public:
-    //! only useable on reading
-    mutable int _csit;
-    // -3 means allocated and build from scratch
-    // -2 means allocated and read from a file
-    // -1 means not allocated and build from scratch
-    // >=0 means not allocated and read from a file
-    mutable int _nb_of_tuples_to_be_allocated;
-  };
-
-  class MEDFileIntField1TSWithoutSDA;
-
-  template<class T>
-  class MEDFileField1TSTemplateWithoutSDA : public MEDFileAnyTypeField1TSWithoutSDA
-  {
-  protected:
-    MEDFileField1TSTemplateWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order):MEDFileAnyTypeField1TSWithoutSDA(fieldName,meshName,csit,iteration,order) { }
-    MEDFileField1TSTemplateWithoutSDA() { }
-  public:
-    MEDLOADER_EXPORT void setArray(DataArray *arr);
-    MEDLOADER_EXPORT DataArray *createNewEmptyDataArrayInstance() const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getOrCreateAndGetArrayTemplate();
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType const *getOrCreateAndGetArrayTemplate() const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayTemplate() const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayTemplateExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDLOADER_EXPORT DataArray *getOrCreateAndGetArray();
-    MEDLOADER_EXPORT const DataArray *getOrCreateAndGetArray() const;
-    MEDLOADER_EXPORT DataArray *getUndergroundDataArray() const;
-    MEDLOADER_EXPORT void aggregate(const typename std::vector< typename MLFieldTraits<T>::F1TSWSDAType const * >& f1tss, const std::vector< std::vector< std::pair<int,int> > >& dts);
-  protected:
-    MCAuto< typename Traits<T>::ArrayType > _arr;
-  };
-
-  /*!
-   * SDA is for Shared Data Arrays such as profiles.
-   */
-  class MEDFileField1TSWithoutSDA : public MEDFileField1TSTemplateWithoutSDA<double>
-  {
-  public:
-    MEDLOADER_EXPORT const char *getTypeStr() const;
-    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    MEDLOADER_EXPORT static void CheckMeshDimRel(int meshDimRelToMax);
-    MEDLOADER_EXPORT static std::vector<int> CheckSBTMesh(const MEDCouplingMesh *mesh);
-    MEDLOADER_EXPORT static MEDFileField1TSWithoutSDA *New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
-  public:
-    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA();
-    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
-    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA *shallowCpy() const;
-    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA *deepCopy() const;
-    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA *convertToInt() const;
-  public:
-    static const char TYPE_STR[];
-  };
-
-  template<class T>
-  class MEDFileField1TSNDTemplateWithoutSDA : public MEDFileField1TSTemplateWithoutSDA<T>
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileField1TSWithoutSDA *convertToDouble() const;
-  protected:
-    MEDFileField1TSNDTemplateWithoutSDA() { }
-    MEDFileField1TSNDTemplateWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos):MEDFileField1TSTemplateWithoutSDA<T>(fieldName,meshName,csit,iteration,order) { }
-  };
-  
-  /*!
-   * SDA is for Shared Data Arrays such as profiles.
-   */
-  class MEDFileIntField1TSWithoutSDA : public MEDFileField1TSNDTemplateWithoutSDA<int>
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA();
-    MEDLOADER_EXPORT static MEDFileIntField1TSWithoutSDA *New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
-    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA *deepCopy() const;
-    MEDLOADER_EXPORT MEDFileIntField1TSWithoutSDA *shallowCpy() const;
-    MEDLOADER_EXPORT const char *getTypeStr() const;
-    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDLOADER_EXPORT DataArrayInt *getUndergroundDataArrayIntExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-  protected:
-    MEDFileIntField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
-  public:
-    MEDLOADER_EXPORT static const char TYPE_STR[];
-  };
-
-  /*!
-   * SDA is for Shared Data Arrays such as profiles.
-   */
-  class MEDFileFloatField1TSWithoutSDA : public MEDFileField1TSNDTemplateWithoutSDA<float>
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileFloatField1TSWithoutSDA();
-    MEDLOADER_EXPORT static MEDFileFloatField1TSWithoutSDA *New(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
-    MEDLOADER_EXPORT MEDFileFloatField1TSWithoutSDA *deepCopy() const;
-    MEDLOADER_EXPORT MEDFileFloatField1TSWithoutSDA *shallowCpy() const;
-    MEDLOADER_EXPORT const char *getTypeStr() const;
-    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDLOADER_EXPORT DataArrayFloat *getUndergroundDataArrayFloatExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-  protected:
-    MEDFileFloatField1TSWithoutSDA(const std::string& fieldName, const std::string& meshName, int csit, int iteration, int order, const std::vector<std::string>& infos);
-  public:
-    MEDLOADER_EXPORT static const char TYPE_STR[];
-  };
-
-  /*!
-   * User class.
-   */
-  class MEDFileAnyTypeField1TS : public RefCountObject, public MEDFileWritableStandAlone, public MEDFileFieldGlobsReal
-  {
-  protected:
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS();
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS(const MEDFileAnyTypeField1TSWithoutSDA& other, bool shallowCopyOfContent);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *BuildNewInstanceFromContent(MEDFileAnyTypeField1TSWithoutSDA *c, med_idt fid);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TSWithoutSDA *BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TSWithoutSDA *BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TSWithoutSDA *BuildContentFrom(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT void writeLL(med_idt fid) const;
-    // direct forwarding to MEDFileAnyTypeField1TSWithoutSDA instance _content
-  public:
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(const std::string& fileName, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(med_idt fid, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *New(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *NewAdv(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT static MEDFileAnyTypeField1TS *NewAdv(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT int getDimension() const;
-    MEDLOADER_EXPORT int getIteration() const;
-    MEDLOADER_EXPORT int getOrder() const;
-    MEDLOADER_EXPORT double getTime(int& iteration, int& order) const;
-    MEDLOADER_EXPORT void setTime(int iteration, int order, double val);
-    MEDLOADER_EXPORT std::string getName() const;
-    MEDLOADER_EXPORT void setName(const std::string& name);
-    MEDLOADER_EXPORT std::string simpleRepr() const;
-    MEDLOADER_EXPORT void simpleRepr(int bkOffset, std::ostream& oss, int f1tsId) const;
-    MEDLOADER_EXPORT std::string getDtUnit() const;
-    MEDLOADER_EXPORT void setDtUnit(const std::string& dtUnit);
-    MEDLOADER_EXPORT std::string getMeshName() const;
-    MEDLOADER_EXPORT void setMeshName(const std::string& newMeshName);
-    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
-    MEDLOADER_EXPORT int getMeshIteration() const;
-    MEDLOADER_EXPORT int getMeshOrder() const;
-    MEDLOADER_EXPORT int getNumberOfComponents() const;
-    MEDLOADER_EXPORT bool isDealingTS(int iteration, int order) const;
-    MEDLOADER_EXPORT std::pair<int,int> getDtIt() const;
-    MEDLOADER_EXPORT void fillIteration(std::pair<int,int>& p) const;
-    MEDLOADER_EXPORT void fillTypesOfFieldAvailable(std::vector<TypeOfField>& types) const;
-    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& infos);
-    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
-    MEDLOADER_EXPORT std::vector<std::string>& getInfo();
-    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
-    MEDLOADER_EXPORT std::vector<TypeOfField> getTypesOfFieldAvailable() const;
-    MEDLOADER_EXPORT std::vector< std::vector<std::pair<int,int> > > getFieldSplitedByType(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
-        std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    MEDLOADER_EXPORT MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId);
-    MEDLOADER_EXPORT const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenMeshAndTypeAndLocId(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId) const;
-    MEDLOADER_EXPORT int getNonEmptyLevels(const std::string& mname, std::vector<int>& levs) const;
-    MEDLOADER_EXPORT void convertMedBallIntoClassic();
-    MEDLOADER_EXPORT void makeReduction(INTERP_KERNEL::NormalizedCellType ct, TypeOfField tof, const DataArrayInt *pfl);
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const = 0;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TS *shallowCpy() const = 0;
-  public:
-    MEDLOADER_EXPORT void loadArrays();
-    MEDLOADER_EXPORT void loadArraysIfNecessary();
-    MEDLOADER_EXPORT void unloadArrays();
-    MEDLOADER_EXPORT void unloadArraysWithoutDataLoss();
-    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeField1TS > > splitComponents() const;
-    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeField1TS > > splitDiscretizations() const;
-    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeField1TS > > splitMultiDiscrPerGeoTypes() const;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *deepCopy() const;
-    MEDLOADER_EXPORT int copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr);
-    MEDLOADER_EXPORT int copyTinyInfoFrom(const TimeHolder *th, const MEDCouplingFieldTemplate *field, const DataArray *arr);
-  public:
-    //! underground method see MEDFileField1TSWithoutSDA::setProfileNameOnLeaf
-    MEDLOADER_EXPORT void setProfileNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newPflName, bool forceRenameOnGlob=false);
-    //! underground method see MEDFileField1TSWithoutSDA::setLocNameOnLeaf
-    MEDLOADER_EXPORT void setLocNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newLocName, bool forceRenameOnGlob=false);
-    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
-    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed() const;
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti() const;
-    MEDLOADER_EXPORT void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-  public:
-    MEDLOADER_EXPORT static int LocateField2(med_idt fid, int fieldIdCFormat, bool checkFieldId, std::string& fieldName, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName);
-    MEDLOADER_EXPORT static int LocateField(med_idt fid, const std::string& fieldName, int& posCFormat, med_field_type& typcha, std::vector<std::string>& infos, std::string& dtunitOut, std::string& meshName);
-  public:
-    MEDLOADER_EXPORT virtual med_field_type getMEDFileFieldType() const = 0;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA *contentNotNullBase();
-    MEDLOADER_EXPORT const MEDFileAnyTypeField1TSWithoutSDA *contentNotNullBase() const;
-  protected:
-    MCAuto<MEDFileAnyTypeField1TSWithoutSDA> _content;
-  };
-
-  class MEDFileIntField1TS;
-
-  template<class T>
-  class MEDFileTemplateField1TS : public MEDFileAnyTypeField1TS
-  {
-  public:
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New();
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const std::string& fileName, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(med_idt fid, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(DataArrayByte *db) { return BuildFromMemoryChunk<typename MLFieldTraits<T>::F1TSType>(db); }
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const std::string& fileName, const std::string& fieldName, int iteration, int order, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::F1TSType *New(const typename MLFieldTraits<T>::F1TSWSDAType& other, bool shallowCopyOfContent);
-  public:
-    MEDLOADER_EXPORT static typename Traits<T>::ArrayType *ReturnSafelyTypedDataArray(MCAuto<DataArray>& arr);
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl) const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArray() const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDLOADER_EXPORT static MCAuto<typename Traits<T>::FieldType> SetDataArrayInField(MEDCouplingFieldDouble *f, MCAuto<DataArray>& arr);
-    MEDLOADER_EXPORT static MCAuto<MEDCouplingFieldDouble> ToFieldTemplateWithTime(const typename Traits<T>::FieldType *f);
-  public:
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *field(const MEDFileMesh *mesh) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtTopLevel(TypeOfField type, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, const MEDCouplingMesh *mesh, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevelOld(TypeOfField type, const std::string& mname, int meshDimRelToMax, int renumPol=0) const;
-    MEDLOADER_EXPORT void setFieldNoProfileSBT(const typename Traits<T>::FieldType *field);
-    MEDLOADER_EXPORT void setFieldProfile(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile);
-    MEDLOADER_EXPORT typename MLFieldTraits<T>::F1TSType *extractPartImpl(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const { return this->extractPartImpl(extractDef,mm); }
-  protected:
-    ~MEDFileTemplateField1TS() { }
-    MEDFileTemplateField1TS();
-    MEDFileTemplateField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileAnyTypeField1TS(fid,loadAll,ms) { }
-    MEDFileTemplateField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileAnyTypeField1TS(fid,fieldName,loadAll,ms) { }
-    MEDFileTemplateField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileAnyTypeField1TS(fid,fieldName,iteration,order,loadAll,ms) { }
-    MEDFileTemplateField1TS(const typename MLFieldTraits<T>::F1TSWSDAType& other, bool shallowCopyOfContent):MEDFileAnyTypeField1TS(other,shallowCopyOfContent) { }
-    const typename MLFieldTraits<T>::F1TSWSDAType *contentNotNull() const;
-    typename MLFieldTraits<T>::F1TSWSDAType *contentNotNull();
-  };
-
-  /*!
-   * User class.
-   */
-  class MEDFileField1TS : public MEDFileTemplateField1TS<double>
-  {
-    friend class MEDFileTemplateField1TS<double>;
-  public:
-    MEDLOADER_EXPORT MEDFileIntField1TS *convertToInt(bool isDeepCpyGlobs=true) const;
-  public:
-    MEDLOADER_EXPORT MEDFileField1TS *shallowCpy() const;
-    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF,
-                                                                                          std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-  public:
-  private:
-    med_field_type getMEDFileFieldType() const { return MED_FLOAT64; }
-  private:
-    ~MEDFileField1TS() { }
-    MEDFileField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
-    MEDFileField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms);
-    MEDFileField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms);
-    MEDFileField1TS(const MEDFileField1TSWithoutSDA& other, bool shallowCopyOfContent);
-    MEDFileField1TS() { }
-  };
-
-  template<class T>
-  class MEDFileNDTemplateField1TS : public MEDFileTemplateField1TS<T>
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileField1TS *convertToDouble(bool isDeepCpyGlobs=true) const;
-  protected:
-    ~MEDFileNDTemplateField1TS() { }
-    MEDFileNDTemplateField1TS() { }
-    MEDFileNDTemplateField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateField1TS<T>(fid,loadAll,ms) { }
-    MEDFileNDTemplateField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateField1TS<T>(fid,fieldName,loadAll,ms) { }
-    MEDFileNDTemplateField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateField1TS<T>(fid,fieldName,iteration,order,loadAll,ms) { }
-    MEDFileNDTemplateField1TS(const typename MLFieldTraits<T>::F1TSWSDAType& other, bool shallowCopyOfContent):MEDFileTemplateField1TS<T>(other,shallowCopyOfContent) { }
-  };
-
-  class MEDFileIntField1TS : public MEDFileNDTemplateField1TS<int>
-  {
-    friend class MEDFileTemplateField1TS<int>;
-  public:
-    MEDLOADER_EXPORT MEDFileIntField1TS *shallowCpy() const { return new MEDFileIntField1TS(*this); }
-  public:
-    MEDLOADER_EXPORT static MCAuto<MEDCouplingFieldDouble> ConvertFieldIntToFieldDouble(const MEDCouplingFieldInt *f);
-  private:
-    med_field_type getMEDFileFieldType() const { return MED_INT32; }
-  private:
-    ~MEDFileIntField1TS() { }
-    MEDFileIntField1TS() { }
-    MEDFileIntField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<int>(fid,loadAll,ms) { }
-    MEDFileIntField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<int>(fid,fieldName,loadAll,ms) { }
-    MEDFileIntField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<int>(fid,fieldName,iteration,order,loadAll,ms) { }
-    /*!
-     * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
-     * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
-     *
-     * \warning this is a shallow copy constructor
-     */
-    MEDFileIntField1TS(const MEDFileIntField1TSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateField1TS<int>(other,shallowCopyOfContent) { }
-  };
-
-  class MEDFileFloatField1TS : public MEDFileNDTemplateField1TS<float>
-  {
-    friend class MEDFileTemplateField1TS<float>;
-  private:
-    med_field_type getMEDFileFieldType() const { return MED_INT32; }//6432
-    MEDLOADER_EXPORT MEDFileFloatField1TS *shallowCpy() const { return new MEDFileFloatField1TS(*this); }
-  private:
-    ~MEDFileFloatField1TS() { }
-    MEDFileFloatField1TS() { }
-    MEDFileFloatField1TS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<float>(fid,loadAll,ms) { }
-    MEDFileFloatField1TS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<float>(fid,fieldName,loadAll,ms) { }
-    MEDFileFloatField1TS(med_idt fid, const std::string& fieldName, int iteration, int order, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateField1TS<float>(fid,fieldName,iteration,order,loadAll,ms) { }
-    /*!
-     * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
-     * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
-     *
-     * \warning this is a shallow copy constructor
-     */
-    MEDFileFloatField1TS(const MEDFileFloatField1TSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateField1TS<float>(other,shallowCopyOfContent) { }
-  };
-
-  class MEDFileAnyTypeFieldMultiTSWithoutSDA : public RefCountObject, public MEDFileFieldNameScope
-  {
-  protected:
-    MEDFileAnyTypeFieldMultiTSWithoutSDA();
-    MEDFileAnyTypeFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName);
-    MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-  public:
-    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
-    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTSWithoutSDA *deepCopy() const;
-    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > splitComponents() const;
-    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > splitDiscretizations() const;
-    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > splitMultiDiscrPerGeoTypes() const;
-    MEDLOADER_EXPORT virtual const char *getTypeStr() const = 0;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const = 0;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTSWithoutSDA *createNew() const = 0;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TSWithoutSDA *createNew1TSWithoutSDAEmptyInstance() const = 0;
-    MEDLOADER_EXPORT virtual void checkCoherencyOfType(const MEDFileAnyTypeField1TSWithoutSDA *f1ts) const = 0;
-    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
-    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
-    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& info);
-    MEDLOADER_EXPORT int getTimeStepPos(int iteration, int order) const;
-    MEDLOADER_EXPORT const MEDFileAnyTypeField1TSWithoutSDA& getTimeStepEntry(int iteration, int order) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA& getTimeStepEntry(int iteration, int order);
-    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
-    MEDLOADER_EXPORT int getNumberOfTS() const;
-    MEDLOADER_EXPORT void eraseEmptyTS();
-    MEDLOADER_EXPORT void eraseTimeStepIds(const int *startIds, const int *endIds);
-    MEDLOADER_EXPORT void eraseTimeStepIds2(int bg, int end, int step);
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *buildFromTimeStepIds(const int *startIds, const int *endIds) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *buildFromTimeStepIds2(int bg, int end, int step) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *partOfThisLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *partOfThisNotLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const;
-    MEDLOADER_EXPORT bool presenceOfStructureElements() const;
-    MEDLOADER_EXPORT bool onlyStructureElements() const;
-    MEDLOADER_EXPORT void killStructureElements();
-    MEDLOADER_EXPORT void keepOnlyStructureElements();
-    MEDLOADER_EXPORT void keepOnlyOnSE(const std::string& seName);
-    MEDLOADER_EXPORT void getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const;
-    MEDLOADER_EXPORT int getPosOfTimeStep(int iteration, int order) const;
-    MEDLOADER_EXPORT int getPosGivenTime(double time, double eps=1e-8) const;
-    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getIterations() const;
-    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getTimeSteps(std::vector<double>& ret1) const;
-    MEDLOADER_EXPORT void pushBackTimeStep(MCAuto<MEDFileAnyTypeField1TSWithoutSDA>& tse);
-    MEDLOADER_EXPORT void synchronizeNameScope();
-    MEDLOADER_EXPORT void simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const;
-    MEDLOADER_EXPORT int getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const;
-    MEDLOADER_EXPORT void appendFieldNoProfileSBT(const MEDCouplingFieldDouble *field, const DataArray *arr, MEDFileFieldGlobsReal& glob);
-    MEDLOADER_EXPORT void appendFieldProfile(const MEDCouplingFieldDouble *field, const DataArray *arr, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob);
-    MEDLOADER_EXPORT std::vector< std::vector< std::pair<int,int> > > getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    MEDLOADER_EXPORT std::vector< std::vector<TypeOfField> > getTypesOfFieldAvailable() const;
-    MEDLOADER_EXPORT DataArray *getUndergroundDataArray(int iteration, int order) const;
-    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(int iteration, int order, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDLOADER_EXPORT bool renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N, MEDFileFieldGlobsReal& glob);
-    MEDLOADER_EXPORT void accept(MEDFileFieldVisitor& visitor) const;
-    MEDLOADER_EXPORT void loadStructureOrStructureAndBigArraysRecursively(med_idt fid, int nbPdt, med_field_type fieldTyp, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT void writeLL(med_idt fid, const MEDFileWritable& opts) const;
-    MEDLOADER_EXPORT void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
-    MEDLOADER_EXPORT void loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc);
-    MEDLOADER_EXPORT void unloadArrays();
-  public:
-    MEDLOADER_EXPORT const MEDFileAnyTypeField1TSWithoutSDA *getTimeStepAtPos2(int pos) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA *getTimeStepAtPos2(int pos);
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed2() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed2() const;
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti2() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti2() const;
-    MEDLOADER_EXPORT void changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void setIteration(int i, MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ts);
-  protected:
-    virtual med_field_type getMEDFileFieldType() const = 0;
-    void copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr);
-    void checkCoherencyOfTinyInfo(const MEDCouplingFieldDouble *field, const DataArray *arr) const;
-    void checkThatComponentsMatch(const std::vector<std::string>& compos) const;
-    void checkThatNbOfCompoOfTSMatchThis() const;
-  protected:
-    std::vector<std::string> _infos;
-    std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > _time_steps;
-  };
-
-  class MEDFileIntFieldMultiTSWithoutSDA;
-
-  template<class T>
-  class MEDFileTemplateFieldMultiTSWithoutSDA : public MEDFileAnyTypeFieldMultiTSWithoutSDA
-  {
-  public:
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSWSDAType *New(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-    MEDLOADER_EXPORT const char *getTypeStr() const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *createNew() const;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA *createNew1TSWithoutSDAEmptyInstance() const;
-  protected:
-    MEDFileTemplateFieldMultiTSWithoutSDA() { }
-    MEDFileTemplateFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileAnyTypeFieldMultiTSWithoutSDA(fieldName,meshName) { }
-    /** \param [in] fieldId field id in C mode */
-    MEDFileTemplateFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileAnyTypeFieldMultiTSWithoutSDA(fid,fieldId,loadAll,ms,entities) { }
-    MEDFileTemplateFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileAnyTypeFieldMultiTSWithoutSDA(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
-    void checkCoherencyOfType(const MEDFileAnyTypeField1TSWithoutSDA *f1ts) const;
-  };
-  
-  class MEDFileFieldMultiTSWithoutSDA : public MEDFileTemplateFieldMultiTSWithoutSDA<double>
-  {
-    friend class MEDFileTemplateFieldMultiTSWithoutSDA<double>;
-  public:
-    MEDLOADER_EXPORT MEDFileFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<double>(fid,fieldId,loadAll,ms,entities) { }
-    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    MEDLOADER_EXPORT MEDFileIntFieldMultiTSWithoutSDA *convertToInt() const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const { return new MEDFileFieldMultiTSWithoutSDA(*this); }
-  protected:
-    MEDFileFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileTemplateFieldMultiTSWithoutSDA<double>(fieldName,meshName) { }
-    MEDFileFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<double>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
-    med_field_type getMEDFileFieldType() const { return MED_FLOAT64; }
-  public:
-    MEDLOADER_EXPORT MEDFileFieldMultiTSWithoutSDA() { }
-  };
-
-  template<class T>
-  class MEDFileNDTemplateFieldMultiTSWithoutSDA : public MEDFileTemplateFieldMultiTSWithoutSDA<T>
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileFieldMultiTSWithoutSDA *convertToDouble() const;
-  protected:
-    MEDFileNDTemplateFieldMultiTSWithoutSDA() { }
-    MEDFileNDTemplateFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<T>(fid,fieldId,loadAll,ms,entities) { }
-    MEDFileNDTemplateFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileTemplateFieldMultiTSWithoutSDA<T>(fieldName,meshName) { }
-    MEDFileNDTemplateFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<T>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
-  };
-
-  class MEDFileIntFieldMultiTSWithoutSDA : public MEDFileNDTemplateFieldMultiTSWithoutSDA<int>
-  {
-    friend class MEDFileTemplateFieldMultiTSWithoutSDA<int>;
-  public:
-    MEDLOADER_EXPORT MEDFileIntFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<int>(fid,fieldId,loadAll,ms,entities) { }
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const { return new MEDFileIntFieldMultiTSWithoutSDA(*this); }
-  protected:
-    MEDFileIntFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileNDTemplateFieldMultiTSWithoutSDA<int>(fieldName,meshName) { }
-    MEDFileIntFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<int>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
-    med_field_type getMEDFileFieldType() const { return MED_INT32; }
-  public:
-    MEDLOADER_EXPORT MEDFileIntFieldMultiTSWithoutSDA() { }
-  };
-
-  class MEDFileFloatFieldMultiTSWithoutSDA : public MEDFileNDTemplateFieldMultiTSWithoutSDA<float>
-  {
-    friend class MEDFileTemplateFieldMultiTSWithoutSDA<float>;
-  public:
-    MEDLOADER_EXPORT MEDFileFloatFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<float>(fid,fieldId,loadAll,ms,entities) { }
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const { return new MEDFileFloatFieldMultiTSWithoutSDA(*this); }
-  protected:
-    MEDFileFloatFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileNDTemplateFieldMultiTSWithoutSDA<float>(fieldName,meshName) { }
-    MEDFileFloatFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<float>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
-    med_field_type getMEDFileFieldType() const { return MED_INT32; }//6432
-  public:
-    MEDLOADER_EXPORT MEDFileFloatFieldMultiTSWithoutSDA() { }
-  };
-
-  class MEDFileAnyTypeFieldMultiTSIterator;
-  class MEDFileFastCellSupportComparator;
-  /*!
-   * User class.
-   */
-  class MEDFileAnyTypeFieldMultiTS : public RefCountObject, public MEDFileWritableStandAlone, public MEDFileFieldGlobsReal
-  {
-  protected:
-    MEDFileAnyTypeFieldMultiTS();
-    MEDFileAnyTypeFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
-    MEDFileAnyTypeFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
-    MEDFileAnyTypeFieldMultiTS(const MEDFileAnyTypeFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent);
-    static MEDFileAnyTypeFieldMultiTS *BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c, med_idt fid);
-    static MEDFileAnyTypeFieldMultiTSWithoutSDA *BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
-    static MEDFileAnyTypeFieldMultiTSWithoutSDA *BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
-  public:
-    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(const std::string& fileName, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(med_idt fid, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c);
-    MEDLOADER_EXPORT void loadArrays();
-    MEDLOADER_EXPORT void loadArraysIfNecessary();
-    MEDLOADER_EXPORT void unloadArrays();
-    MEDLOADER_EXPORT void unloadArraysWithoutDataLoss();
-    MEDLOADER_EXPORT void writeLL(med_idt fid) const;
-    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
-    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *deepCopy() const;
-    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > splitComponents() const;
-    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > splitDiscretizations() const;
-    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > splitMultiDiscrPerGeoTypes() const;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *shallowCpy() const = 0;
-    MEDLOADER_EXPORT virtual void checkCoherencyOfType(const MEDFileAnyTypeField1TS *f1ts) const = 0;
-    //
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TS *getTimeStepAtPos(int pos) const = 0;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *getTimeStep(int iteration, int order) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *getTimeStepGivenTime(double time, double eps=1e-8) const;
-    MEDLOADER_EXPORT static std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > SplitIntoCommonTimeSeries(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS);
-    MEDLOADER_EXPORT static std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > SplitPerCommonSupport(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& fsc);
-    MEDLOADER_EXPORT static int CheckSupportAcrossTime(MEDFileAnyTypeFieldMultiTS *f0, MEDFileAnyTypeFieldMultiTS *f1, const MEDFileMesh *mesh, TypeOfField& tof0, TypeOfField& tof1);
-  public:// direct forwarding to MEDFileField1TSWithoutSDA instance _content
-    MEDLOADER_EXPORT std::string getName() const;
-    MEDLOADER_EXPORT void setName(const std::string& name);
-    MEDLOADER_EXPORT std::string getDtUnit() const;
-    MEDLOADER_EXPORT void setDtUnit(const std::string& dtUnit);
-    MEDLOADER_EXPORT std::string getMeshName() const;
-    MEDLOADER_EXPORT void setMeshName(const std::string& newMeshName);
-    MEDLOADER_EXPORT std::string simpleRepr() const;
-    MEDLOADER_EXPORT void simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const;
-    MEDLOADER_EXPORT int getNumberOfTS() const;
-    MEDLOADER_EXPORT void eraseEmptyTS();
-    MEDLOADER_EXPORT void eraseTimeStepIds(const int *startIds, const int *endIds);
-    MEDLOADER_EXPORT void eraseTimeStepIds2(int bg, int end, int step);
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *buildSubPart(const int *startIds, const int *endIds) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *buildSubPartSlice(int bg, int end, int step) const;
-    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getTimeSteps(std::vector<double>& ret1) const;
-    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getIterations() const;
-    MEDLOADER_EXPORT void pushBackTimeSteps(const std::vector<MEDFileAnyTypeField1TS *>& f1ts);
-    MEDLOADER_EXPORT void pushBackTimeSteps(MEDFileAnyTypeFieldMultiTS *fmts);
-    MEDLOADER_EXPORT void pushBackTimeStep(MEDFileAnyTypeField1TS *f1ts);
-    MEDLOADER_EXPORT void synchronizeNameScope();
-    MEDLOADER_EXPORT int getPosOfTimeStep(int iteration, int order) const;
-    MEDLOADER_EXPORT int getPosGivenTime(double time, double eps=1e-8) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSIterator *iterator();
-    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
-    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
-    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
-    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& info);
-    MEDLOADER_EXPORT int getNumberOfComponents() const;
-    MEDLOADER_EXPORT int getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const;
-    MEDLOADER_EXPORT std::vector< std::vector<TypeOfField> > getTypesOfFieldAvailable() const;
-    MEDLOADER_EXPORT std::vector< std::vector< std::pair<int,int> > > getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    MEDLOADER_EXPORT MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> getContent();
-  public:
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *buildNewEmpty() const = 0;
-    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const = 0;
-    MEDLOADER_EXPORT static MCAuto<MEDFileAnyTypeFieldMultiTS> Aggregate(const std::vector<const MEDFileAnyTypeFieldMultiTS *>& fmtss, const std::vector< std::vector< std::pair<int,int> > >& dts);
-  public:
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed() const;
-    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti() const;
-    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti() const;
-    MEDLOADER_EXPORT void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-    MEDLOADER_EXPORT void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
-  protected:
-    MEDFileAnyTypeFieldMultiTSWithoutSDA *contentNotNullBase();
-    const MEDFileAnyTypeFieldMultiTSWithoutSDA *contentNotNullBase() const;
-  private:
-    static std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > SplitPerCommonSupportNotNodesAlg(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& cmps);
-  protected:
-    MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> _content;
-  };
-
-  template<class T>
-  class MEDFileTemplateFieldMultiTS : public MEDFileAnyTypeFieldMultiTS
-  {
-  public:
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New();
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(const std::string& fileName, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(med_idt fid, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(DataArrayByte *db) { return BuildFromMemoryChunk<typename MLFieldTraits<T>::FMTSType>(db); }
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(const typename MLFieldTraits<T>::FMTSWSDAType& other, bool shallowCopyOfContent);
-    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *LoadSpecificEntities(const std::string& fileName, const std::string& fieldName, const std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >& entities, bool loadAll=true);
-    MEDLOADER_EXPORT typename MLFieldTraits<T>::FMTSType *extractPartImpl(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const;
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const { return this->extractPartImpl(extractDef,mm); }
-    //
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *field(int iteration, int order, const MEDFileMesh *mesh) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtTopLevel(TypeOfField type, int iteration, int order, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, const MEDFileMesh *mesh, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, int iteration, int order, const MEDCouplingMesh *mesh, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevelOld(TypeOfField type, int iteration, int order, const std::string& mname, int meshDimRelToMax, int renumPol=0) const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getFieldWithProfile(TypeOfField type, int iteration, int order, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl) const;
-    //
-    MEDLOADER_EXPORT void appendFieldNoProfileSBT(const typename Traits<T>::FieldType *field);
-    MEDLOADER_EXPORT void appendFieldProfile(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile);
-    //
-    MEDLOADER_EXPORT typename MLFieldTraits<T>::F1TSType *getTimeStepAtPos(int pos) const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArray(int iteration, int order) const;
-    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayExt(int iteration, int order, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
-    MEDLOADER_EXPORT typename MLFieldTraits<T>::FMTSType *buildNewEmptyImpl() const;
-    MEDLOADER_EXPORT void checkCoherencyOfType(const MEDFileAnyTypeField1TS *f1ts) const;
-  protected:
-    const typename MLFieldTraits<T>::FMTSWSDAType *contentNotNull() const;
-    typename MLFieldTraits<T>::FMTSWSDAType *contentNotNull();
-  protected:
-    ~MEDFileTemplateFieldMultiTS() { }
-    MEDFileTemplateFieldMultiTS();
-    MEDFileTemplateFieldMultiTS(const typename MLFieldTraits<T>::FMTSWSDAType& other, bool shallowCopyOfContent);
-    MEDFileTemplateFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
-    MEDFileTemplateFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
-  };
-  
-  class MEDFileIntFieldMultiTS;
-
-  /*!
-   * User class.
-   */
-  class MEDFileFieldMultiTS : public MEDFileTemplateFieldMultiTS<double>
-  {
-    friend class MEDFileTemplateFieldMultiTS<double>;
-  public:
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *shallowCpy() const;
-    MEDLOADER_EXPORT MEDFileIntFieldMultiTS *convertToInt(bool isDeepCpyGlobs=true) const;
-    //
-    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
-    MEDLOADER_EXPORT MEDFileFieldMultiTS *buildNewEmpty() const { return buildNewEmptyImpl(); }
-  public:
-  private:
-    ~MEDFileFieldMultiTS() { }
-    MEDFileFieldMultiTS() { }
-    MEDFileFieldMultiTS(const MEDFileFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent);
-    MEDFileFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
-    MEDFileFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
-  };
-
-  template<class T>
-  class MEDFileNDTemplateFieldMultiTS : public MEDFileTemplateFieldMultiTS<T>
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileFieldMultiTS *convertToDouble(bool isDeepCpyGlobs=true) const;
-  protected:
-    ~MEDFileNDTemplateFieldMultiTS() { }
-    MEDFileNDTemplateFieldMultiTS() { }
-    MEDFileNDTemplateFieldMultiTS(const typename MLFieldTraits<T>::FMTSWSDAType& other, bool shallowCopyOfContent):MEDFileTemplateFieldMultiTS<T>(other,shallowCopyOfContent) { }
-    MEDFileNDTemplateFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateFieldMultiTS<T>(fid,loadAll,ms) { }
-    MEDFileNDTemplateFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTS<T>(fid,fieldName,loadAll,ms,entities) { }
-  };
-
-  /*!
-   * User class.
-   */
-  class MEDFileIntFieldMultiTS : public MEDFileNDTemplateFieldMultiTS<int>
-  {
-    friend class MEDFileTemplateFieldMultiTS<int>;
-  public:
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *shallowCpy() const { return new MEDFileIntFieldMultiTS(*this); }
-    MEDLOADER_EXPORT MEDFileIntFieldMultiTS *buildNewEmpty() const { return buildNewEmptyImpl(); }
-  private:
-    ~MEDFileIntFieldMultiTS() { }
-    MEDFileIntFieldMultiTS() { }
-    MEDFileIntFieldMultiTS(const MEDFileIntFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateFieldMultiTS<int>(other,shallowCopyOfContent) { }
-    MEDFileIntFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateFieldMultiTS<int>(fid,loadAll,ms) { }
-    MEDFileIntFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0):MEDFileNDTemplateFieldMultiTS<int>(fid,fieldName,loadAll,ms,entities) { }
-  };
-
-  /*!
-   * User class.
-   */
-  class MEDFileFloatFieldMultiTS : public MEDFileNDTemplateFieldMultiTS<float>
-  {
-    friend class MEDFileTemplateFieldMultiTS<float>;
-  public:
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *shallowCpy() const { return new MEDFileFloatFieldMultiTS(*this); }
-    MEDLOADER_EXPORT MEDFileFloatFieldMultiTS *buildNewEmpty() const { return buildNewEmptyImpl(); }
-  private:
-    ~MEDFileFloatFieldMultiTS() { }
-    MEDFileFloatFieldMultiTS() { }
-    MEDFileFloatFieldMultiTS(const MEDFileFloatFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateFieldMultiTS<float>(other,shallowCopyOfContent) { }
-    MEDFileFloatFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateFieldMultiTS<float>(fid,loadAll,ms) { }
-    MEDFileFloatFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0):MEDFileNDTemplateFieldMultiTS<float>(fid,fieldName,loadAll,ms,entities) { }
-  };
-
-  class MEDFileAnyTypeFieldMultiTSIterator
-  {
-  public:
-    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSIterator(MEDFileAnyTypeFieldMultiTS *fmts);
-    MEDLOADER_EXPORT ~MEDFileAnyTypeFieldMultiTSIterator();
-    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *nextt();
-  private:
-    MCAuto<MEDFileAnyTypeFieldMultiTS> _fmts;
-    int _iter_id;
-    int _nb_iter;
-  };
-
   class MEDFileFieldsIterator;
   class MEDFileStructureElements;
   
@@ -1436,6 +123,7 @@
     MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
     MEDLOADER_EXPORT bool renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N);
     MEDLOADER_EXPORT void accept(MEDFileFieldVisitor& visitor) const;
+    MEDLOADER_EXPORT MCAuto<MEDFileFields> linearToQuadratic(const MEDFileMeshes *oldLin, const MEDFileMeshes *newQuad) const;
   public:
     MEDLOADER_EXPORT MEDFileFields *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const;
   public:
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldInternal.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldInternal.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldInternal.cxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldInternal.cxx	2018-04-19 17:25:17.805798701 +0200
@@ -0,0 +1,3189 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#include "MEDFileFieldInternal.hxx"
+#include "MEDFileField.hxx"
+#include "MEDFileFieldVisitor.hxx"
+#include "MEDFileStructureElement.hxx"
+#include "MEDLoaderBase.hxx"
+#include "MEDFileSafeCaller.txx"
+#include "MEDFileEntities.hxx"
+
+#include "MEDCouplingGaussLocalization.hxx"
+#include "MEDCouplingFieldTemplate.hxx"
+#include "MEDCouplingFieldDouble.hxx"
+
+#include "CellModel.hxx"
+
+extern med_geometry_type typmai[MED_N_CELL_FIXED_GEO];
+extern INTERP_KERNEL::NormalizedCellType typmai2[MED_N_CELL_FIXED_GEO];
+extern med_geometry_type typmai3[34];
+
+using namespace MEDCoupling;
+
+MEDFileGTKeeper::~MEDFileGTKeeper()
+{
+}
+
+MEDFileGTKeeper *MEDFileGTKeeperSta::deepCopy() const
+{
+  return new MEDFileGTKeeperSta(_geo_type);
+}
+
+INTERP_KERNEL::NormalizedCellType MEDFileGTKeeperSta::getGeoType() const
+{
+  return _geo_type;
+}
+
+std::string MEDFileGTKeeperSta::getRepr() const
+{
+  return INTERP_KERNEL::CellModel::GetCellModel(_geo_type).getRepr();
+}
+
+bool MEDFileGTKeeperSta::isEqual(const MEDFileGTKeeper *other) const
+{
+  const MEDFileGTKeeperSta *otherC(dynamic_cast<const MEDFileGTKeeperSta *>(other));
+  if(!otherC)
+    return false;
+  return _geo_type==otherC->_geo_type;
+}
+
+MEDFileGTKeeperDyn::MEDFileGTKeeperDyn(const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileStructureElement *se):_mesh(mesh),_section(section),_se(se)
+{
+  if(mesh)
+    mesh->incrRef();
+  if(section)
+    section->incrRef();
+  if(se)
+    se->incrRef();
+  if(_mesh.isNull() || _section.isNull() || _se.isNull())
+    throw INTERP_KERNEL::Exception("MEDFileGTKeeperDyn constructor : null pointer not allowed !");
+}
+
+MEDFileGTKeeper *MEDFileGTKeeperDyn::deepCopy() const
+{
+  return new MEDFileGTKeeperDyn(_mesh,_section,_se);
+}
+
+INTERP_KERNEL::NormalizedCellType MEDFileGTKeeperDyn::getGeoType() const
+{
+  throw INTERP_KERNEL::Exception("MEDFileGTKeeperDyn::getGeoType : not valid !");
+}
+
+std::string MEDFileGTKeeperDyn::getRepr() const
+{
+  std::ostringstream oss;
+  oss << _se->getDynGT();
+  return oss.str();
+}
+
+bool MEDFileGTKeeperDyn::isEqual(const MEDFileGTKeeper *other) const
+{
+  const MEDFileGTKeeperDyn *otherC(dynamic_cast<const MEDFileGTKeeperDyn *>(other));
+  if(!otherC)
+    return false;
+  return this==otherC;
+}
+
+MEDFileFieldLoc *MEDFileFieldLoc::New(med_idt fid, const std::string& locName)
+{
+  return new MEDFileFieldLoc(fid,locName);
+}
+
+MEDFileFieldLoc *MEDFileFieldLoc::New(med_idt fid, int id, const MEDFileEntities *entities)
+{
+  return new MEDFileFieldLoc(fid,id,entities);
+}
+
+MEDFileFieldLoc *MEDFileFieldLoc::New(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w)
+{
+  return new MEDFileFieldLoc(locName,geoType,refCoo,gsCoo,w);
+}
+
+MEDFileFieldLoc::MEDFileFieldLoc(med_idt fid, const std::string& locName):_name(locName)
+{
+  med_geometry_type geotype;
+  med_geometry_type sectiongeotype;
+  int nsectionmeshcell;
+  INTERP_KERNEL::AutoPtr<char> geointerpname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> sectionmeshname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  MEDlocalizationInfoByName(fid,locName.c_str(),&geotype,&_dim,&_nb_gauss_pt,geointerpname,sectionmeshname,&nsectionmeshcell,&sectiongeotype);
+  _gt=new MEDFileGTKeeperSta((INTERP_KERNEL::NormalizedCellType)(std::distance(typmai3,std::find(typmai3,typmai3+34,geotype))));
+  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
+  _nb_node_per_cell=cm.getNumberOfNodes();
+  _ref_coo.resize(_dim*_nb_node_per_cell);
+  _gs_coo.resize(_dim*_nb_gauss_pt);
+  _w.resize(_nb_gauss_pt);
+  MEDFILESAFECALLERRD0(MEDlocalizationRd,(fid,locName.c_str(),MED_FULL_INTERLACE,&_ref_coo[0],&_gs_coo[0],&_w[0]));
+}
+
+MEDFileFieldLoc::MEDFileFieldLoc(med_idt fid, int id, const MEDFileEntities *entities)
+{
+  med_geometry_type geotype;
+  med_geometry_type sectiongeotype;
+  int nsectionmeshcell;
+  INTERP_KERNEL::AutoPtr<char> locName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> geointerpname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> sectionmeshname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  MEDFILESAFECALLERRD0(MEDlocalizationInfo,(fid,id+1,locName,&geotype,&_dim,&_nb_gauss_pt,geointerpname,sectionmeshname,&nsectionmeshcell,&sectiongeotype));
+  _name=locName;
+  std::string sectionName(MEDLoaderBase::buildStringFromFortran(sectionmeshname,MED_NAME_SIZE));
+  if(sectionName.empty())
+    {
+      _gt=new MEDFileGTKeeperSta((INTERP_KERNEL::NormalizedCellType)(std::distance(typmai3,std::find(typmai3,typmai3+34,geotype))));
+      const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
+      _nb_node_per_cell=cm.getNumberOfNodes();
+    }
+  else
+    {
+      const MEDFileAllStaticEntitiesPlusDyn *entities2(dynamic_cast<const MEDFileAllStaticEntitiesPlusDyn *>(entities));
+      if(!entities2)
+        {
+          std::ostringstream oss; oss << "MEDFileFieldLoc cstr : for loc \"" << _name << "\" presence of non static type ! Expect entities !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      const MEDFileStructureElement *se(entities2->getWithGT(geotype));
+      const MEDFileUMesh *um(entities2->getSupMeshWithName(se->getMeshName()));
+      const MEDFileUMesh *section(entities2->getSupMeshWithName(sectionName));
+      _gt=new MEDFileGTKeeperDyn(um,section,se);
+      {
+        int dummy;
+        MEDFILESAFECALLERRD0(MEDmeshGeotypeParameter,(fid,geotype,&dummy,&_nb_node_per_cell));
+      }
+    }
+  _ref_coo.resize(_dim*_nb_node_per_cell);
+  _gs_coo.resize(_dim*_nb_gauss_pt);
+  _w.resize(_nb_gauss_pt);
+  MEDFILESAFECALLERRD0(MEDlocalizationRd,(fid,locName,MED_FULL_INTERLACE,&_ref_coo[0],&_gs_coo[0],&_w[0]));
+}
+
+MEDFileFieldLoc::MEDFileFieldLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType,
+                                 const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w):_name(locName),_gt(new MEDFileGTKeeperSta(geoType)),_ref_coo(refCoo),_gs_coo(gsCoo),_w(w)
+{
+  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
+  _dim=cm.getDimension();
+  _nb_node_per_cell=cm.getNumberOfNodes();
+  _nb_gauss_pt=_w.size();
+}
+
+
+MEDFileFieldLoc::MEDFileFieldLoc(const MEDFileFieldLoc& other):_dim(other._dim),_nb_gauss_pt(other._nb_gauss_pt),_gt(other._gt->deepCopy()),_nb_node_per_cell(other._nb_node_per_cell),_name(other._name),_ref_coo(other._ref_coo),_gs_coo(other._gs_coo),_w(other._w)
+{
+}
+
+MEDFileFieldLoc *MEDFileFieldLoc::deepCopy() const
+{
+  return new MEDFileFieldLoc(*this);
+}
+
+bool MEDFileFieldLoc::isOnStructureElement() const
+{
+  const MEDFileGTKeeper *gt(_gt);
+  if(!gt)
+    throw INTERP_KERNEL::Exception("MEDFileFieldLoc::isOnStructureElement : null pointer !");
+  const MEDFileGTKeeperDyn *gt2(dynamic_cast<const MEDFileGTKeeperDyn *>(gt));
+  return gt2!=NULL;
+}
+
+std::size_t MEDFileFieldLoc::getHeapMemorySizeWithoutChildren() const
+{
+  return (_ref_coo.capacity()+_gs_coo.capacity()+_w.capacity())*sizeof(double)+_name.capacity();
+}
+
+std::vector<const BigMemoryObject *> MEDFileFieldLoc::getDirectChildrenWithNull() const
+{
+  return std::vector<const BigMemoryObject *>();
+}
+
+void MEDFileFieldLoc::simpleRepr(std::ostream& oss) const
+{
+  static const char OFF7[]="\n    ";
+  oss << "\"" << _name << "\"" << OFF7;
+  oss << "GeoType=" << _gt->getRepr() << OFF7;
+  oss << "Dimension=" << _dim << OFF7;
+  oss << "Number of Gauss points=" << _nb_gauss_pt << OFF7;
+  oss << "Number of nodes per cell=" << _nb_node_per_cell << OFF7;
+  oss << "RefCoords="; std::copy(_ref_coo.begin(),_ref_coo.end(),std::ostream_iterator<double>(oss," ")); oss << OFF7;
+  oss << "Weights="; std::copy(_w.begin(),_w.end(),std::ostream_iterator<double>(oss," ")); oss << OFF7;
+  oss << "GaussPtsCoords="; std::copy(_gs_coo.begin(),_gs_coo.end(),std::ostream_iterator<double>(oss," ")); oss << std::endl;
+}
+
+void MEDFileFieldLoc::setName(const std::string& name)
+{
+  _name=name;
+}
+
+bool MEDFileFieldLoc::isEqual(const MEDFileFieldLoc& other, double eps) const
+{
+  if(_name!=other._name)
+    return false;
+  if(_dim!=other._dim)
+    return false;
+  if(_nb_gauss_pt!=other._nb_gauss_pt)
+    return false;
+  if(_nb_node_per_cell!=other._nb_node_per_cell)
+    return false;
+  if(!_gt->isEqual(other._gt))
+    return false;
+  if(!MEDCouplingGaussLocalization::AreAlmostEqual(_ref_coo,other._ref_coo,eps))
+    return false;
+  if(!MEDCouplingGaussLocalization::AreAlmostEqual(_gs_coo,other._gs_coo,eps))
+    return false;
+  if(!MEDCouplingGaussLocalization::AreAlmostEqual(_w,other._w,eps))
+    return false;
+
+  return true;
+}
+
+void MEDFileFieldLoc::writeLL(med_idt fid) const
+{
+  MEDFILESAFECALLERWR0(MEDlocalizationWr,(fid,_name.c_str(),typmai3[(int)getGeoType()],_dim,&_ref_coo[0],MED_FULL_INTERLACE,_nb_gauss_pt,&_gs_coo[0],&_w[0],MED_NO_INTERPOLATION,MED_NO_MESH_SUPPORT));
+}
+
+std::string MEDFileFieldLoc::repr() const
+{
+  std::ostringstream oss; oss.precision(15);
+  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
+  oss << "Localization \"" << _name << "\" :\n" << "  - Geometric Type : " << cm.getRepr();
+  oss << "\n  - Dimension : " << _dim << "\n  - Number of gauss points : ";
+  oss << _nb_gauss_pt << "\n  - Number of nodes in cell : " << _nb_node_per_cell;
+  oss << "\n  - Ref coords are : ";
+  int sz=_ref_coo.size();
+  if(sz%_dim==0)
+    {
+      int nbOfTuples=sz/_dim;
+      for(int i=0;i<nbOfTuples;i++)
+        {
+          oss << "(";
+          for(int j=0;j<_dim;j++)
+            { oss << _ref_coo[i*_dim+j]; if(j!=_dim-1) oss << ", "; }
+          oss << ") ";
+        }
+    }
+  else
+    std::copy(_ref_coo.begin(),_ref_coo.end(),std::ostream_iterator<double>(oss," "));
+  oss << "\n  - Gauss coords in reference element : ";
+  sz=_gs_coo.size();
+  if(sz%_dim==0)
+    {
+      int nbOfTuples=sz/_dim;
+      for(int i=0;i<nbOfTuples;i++)
+        {
+          oss << "(";
+          for(int j=0;j<_dim;j++)
+            { oss << _gs_coo[i*_dim+j]; if(j!=_dim-1) oss << ", "; }
+          oss << ") ";
+        }
+    }
+  else
+    std::copy(_gs_coo.begin(),_gs_coo.end(),std::ostream_iterator<double>(oss," "));
+  oss << "\n  - Weights of Gauss coords are : "; std::copy(_w.begin(),_w.end(),std::ostream_iterator<double>(oss," "));
+  return oss.str();
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  _type=field->getTypeOfField();
+  _start=start;
+  switch(_type)
+  {
+    case ON_CELLS:
+      {
+        getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,offset,offset+nbOfCells,1);
+        _end=_start+nbOfCells;
+        _nval=nbOfCells;
+        break;
+      }
+    case ON_GAUSS_NE:
+      {
+        MCAuto<DataArrayInt> arr=field->getDiscretization()->getOffsetArr(field->getMesh());
+        const int *arrPtr=arr->getConstPointer();
+        getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,arrPtr[offset],arrPtr[offset+nbOfCells],1);
+        _end=_start+(arrPtr[offset+nbOfCells]-arrPtr[offset]);
+        _nval=nbOfCells;
+        break;
+      }
+    case ON_GAUSS_PT:
+      {
+        const MEDCouplingFieldDiscretization *disc(field->getDiscretization());
+        const MEDCouplingGaussLocalization& gsLoc(field->getGaussLocalization(_loc_id));
+        const MEDCouplingFieldDiscretizationGauss *disc2(dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(disc));
+        if(!disc2)
+          throw INTERP_KERNEL::Exception("assignFieldNoProfile : invalid call to this method ! Internal Error !");
+        const DataArrayInt *dai(disc2->getArrayOfDiscIds());
+        MCAuto<DataArrayInt> dai2(disc2->getOffsetArr(field->getMesh()));
+        const int *dai2Ptr(dai2->getConstPointer());
+        int nbi(gsLoc.getWeights().size());
+        MCAuto<DataArrayInt> da2(dai->selectByTupleIdSafeSlice(offset,offset+nbOfCells,1));
+        MCAuto<DataArrayInt> da3(da2->findIdsEqual(_loc_id));
+        const int *da3Ptr(da3->getConstPointer());
+        if(da3->getNumberOfTuples()!=nbOfCells)
+          {//profile : for gauss even in NoProfile !!!
+            std::ostringstream oss; oss << "Pfl_" << nasc.getName() << "_" << INTERP_KERNEL::CellModel::GetCellModel(getGeoType()).getRepr() << "_" << _loc_id;
+            _profile=oss.str();
+            da3->setName(_profile.c_str());
+            glob.appendProfile(da3);
+          }
+        MCAuto<DataArrayInt> da4(DataArrayInt::New());
+        _nval=da3->getNbOfElems();
+        da4->alloc(_nval*nbi,1);
+        int *da4Ptr(da4->getPointer());
+        for(int i=0;i<_nval;i++)
+          {
+            int ref=dai2Ptr[offset+da3Ptr[i]];
+            for(int j=0;j<nbi;j++)
+              *da4Ptr++=ref+j;
+          }
+        std::ostringstream oss2; oss2 << "Loc_" << nasc.getName() << "_" << INTERP_KERNEL::CellModel::GetCellModel(getGeoType()).getRepr() << "_" << _loc_id;
+        _localization=oss2.str();
+        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,da4);
+        _end=_start+_nval*nbi;
+        glob.appendLoc(_localization.c_str(),getGeoType(),gsLoc.getRefCoords(),gsLoc.getGaussCoords(),gsLoc.getWeights());
+        break;
+      }
+    default:
+      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::assignFieldNoProfile : not implemented yet for such discretization type of field !");
+  }
+  start=_end;
+}
+
+/*!
+ * Leaf method of field with profile assignment. This method is the most general one. No optimization is done here.
+ * \param [in] pflName input containing name of profile if any. 0 if no profile (except for GAUSS_PT where a no profile can hide a profile when split by loc_id).
+ * \param [in] multiTypePfl is the end user profile specified in high level API
+ * \param [in] idsInPfl is the selection into the \a multiTypePfl whole profile that corresponds to the current geometric type.
+ * \param [in] locIds is the profile needed to be created for MED file format. It can be null if all cells of current geometric type are fetched in \a multiTypePfl.
+ *             \b WARNING if not null the MED file profile can be subdivided again in case of Gauss points.
+ * \param [in] mesh is the mesh coming from the MEDFileMesh instance in correspondence with the MEDFileField. The mesh inside the \a field is simply ignored.
+ */
+void MEDFileFieldPerMeshPerTypePerDisc::assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arrr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  _profile.clear();
+  _type=field->getTypeOfField();
+  std::string pflName(multiTypePfl->getName());
+  std::ostringstream oss; oss << pflName;
+  if(_type!=ON_NODES)
+    {
+      if(!isPflAlone)
+        { const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType()); oss << "_" <<  cm.getRepr(); }
+    }
+  else
+    { oss << "_NODE"; }
+  if(locIds)
+    {
+      if(pflName.empty())
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::assignFieldProfile : existing profile with empty name !");
+      if(_type!=ON_GAUSS_PT)
+        {
+          locIds->setName(oss.str());
+          glob.appendProfile(locIds);
+          _profile=oss.str();
+        }
+    }
+  _start=start;
+  switch(_type)
+  {
+    case ON_NODES:
+      {
+        _nval=idsInPfl->getNumberOfTuples();
+        getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,0,arrr->getNumberOfTuples(),1);
+        _end=_start+_nval;
+        break;
+      }
+    case ON_CELLS:
+      {
+        _nval=idsInPfl->getNumberOfTuples();
+        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,idsInPfl);
+        _end=_start+_nval;
+        break;
+      }
+    case ON_GAUSS_NE:
+      {
+        MCAuto<DataArrayInt> arr=field->getDiscretization()->getOffsetArr(mesh);
+        MCAuto<DataArrayInt> arr2=arr->deltaShiftIndex();
+        MCAuto<DataArrayInt> arr3=arr2->selectByTupleId(multiTypePfl->begin(),multiTypePfl->end());
+        arr3->computeOffsetsFull();
+        MCAuto<DataArrayInt> tmp=idsInPfl->buildExplicitArrByRanges(arr3);
+        int trueNval=tmp->getNumberOfTuples();
+        _nval=idsInPfl->getNumberOfTuples();
+        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,tmp);
+        _end=_start+trueNval;
+        break;
+      }
+    case ON_GAUSS_PT:
+      {
+        const MEDCouplingFieldDiscretizationGauss *disc2=dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(field->getDiscretization());
+        if(!disc2)
+          throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : invalid call to this method ! Internal Error !");
+        const DataArrayInt *da1=disc2->getArrayOfDiscIds();
+        const MEDCouplingGaussLocalization& gsLoc=field->getGaussLocalization(_loc_id);
+        MCAuto<DataArrayInt> da2=da1->selectByTupleId(idsInPfl->begin(),idsInPfl->end());
+        MCAuto<DataArrayInt> da3=da2->findIdsEqual(_loc_id);
+        MCAuto<DataArrayInt> da4=idsInPfl->selectByTupleId(da3->begin(),da3->end());
+        //
+        MCAuto<MEDCouplingMesh> mesh2=mesh->buildPart(multiTypePfl->begin(),multiTypePfl->end());
+        MCAuto<DataArrayInt> arr=disc2->getOffsetArr(mesh2);
+        //
+        MCAuto<DataArrayInt> tmp=DataArrayInt::New();
+        int trueNval=0;
+        for(const int *pt=da4->begin();pt!=da4->end();pt++)
+          trueNval+=arr->getIJ(*pt+1,0)-arr->getIJ(*pt,0);
+        tmp->alloc(trueNval,1);
+        int *tmpPtr=tmp->getPointer();
+        for(const int *pt=da4->begin();pt!=da4->end();pt++)
+          for(int j=arr->getIJ(*pt,0);j<arr->getIJ(*pt+1,0);j++)
+            *tmpPtr++=j;
+        //
+        _nval=da4->getNumberOfTuples();
+        getOrCreateAndGetArray()->setContigPartOfSelectedValues(_start,arrr,tmp);
+        _end=_start+trueNval;
+        oss << "_loc_" << _loc_id;
+        if(locIds)
+          {
+            MCAuto<DataArrayInt> da5=locIds->selectByTupleId(da3->begin(),da3->end());
+            da5->setName(oss.str());
+            glob.appendProfile(da5);
+            _profile=oss.str();
+          }
+        else
+          {
+            if(!da3->isIota(nbOfEltsInWholeMesh))
+              {
+                da3->setName(oss.str());
+                glob.appendProfile(da3);
+                _profile=oss.str();
+              }
+          }
+        std::ostringstream oss2; oss2 << "Loc_" << nasc.getName() << "_" << INTERP_KERNEL::CellModel::GetCellModel(getGeoType()).getRepr() << "_" << _loc_id;
+        _localization=oss2.str();
+        glob.appendLoc(_localization.c_str(),getGeoType(),gsLoc.getRefCoords(),gsLoc.getGaussCoords(),gsLoc.getWeights());
+        break;
+      }
+    default:
+      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::assignFieldProfile : not implemented yet for such discretization type of field !");
+  }
+  start=_end;
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob)
+{
+  _start=start;
+  _nval=arrr->getNumberOfTuples();
+  getOrCreateAndGetArray()->setContigPartOfSelectedValuesSlice(_start,arrr,0,_nval,1);
+  _end=_start+_nval;
+  start=_end;
+}
+
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const PartDefinition *pd)
+{
+  return new MEDFileFieldPerMeshPerTypePerDisc(fath,type,profileIt,pd);
+}
+
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::New(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int locId)
+{
+  return new MEDFileFieldPerMeshPerTypePerDisc(fath,type,locId,std::string());
+}
+
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::New(const MEDFileFieldPerMeshPerTypePerDisc& other)
+{
+  return new MEDFileFieldPerMeshPerTypePerDisc(other);
+}
+
+std::size_t MEDFileFieldPerMeshPerTypePerDisc::getHeapMemorySizeWithoutChildren() const
+{
+  return _profile.capacity()+_localization.capacity()+sizeof(MEDFileFieldPerMeshPerTypePerDisc);
+}
+
+std::vector<const BigMemoryObject *> MEDFileFieldPerMeshPerTypePerDisc::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret(1);
+  ret[0]=(const PartDefinition*)_pd;
+  return ret;
+}
+
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::deepCopy(MEDFileFieldPerMeshPerTypeCommon *father) const
+{
+  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> ret(new MEDFileFieldPerMeshPerTypePerDisc(*this));
+  ret->_father=father;
+  return ret.retn();
+}
+
+MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField atype, int profileIt, const PartDefinition *pd)
+try:_type(atype),_father(fath),_profile_it(profileIt),_pd(const_cast<PartDefinition *>(pd))
+{
+  if(pd)
+    pd->incrRef();
+}
+catch(INTERP_KERNEL::Exception& e)
+{
+    throw e;
+}
+
+MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int locId, const std::string& dummy):_type(type),_father(fath),_loc_id(locId)
+{
+}
+
+MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc(const MEDFileFieldPerMeshPerTypePerDisc& other):RefCountObject(other),_type(other._type),_father(0),_start(other._start),_end(other._end),_nval(other._nval),_profile(other._profile),_localization(other._localization),_loc_id(other._loc_id),_profile_it(other._profile_it),_pd(other._pd),_tmp_work1(other._tmp_work1)
+{
+}
+
+MEDFileFieldPerMeshPerTypePerDisc::MEDFileFieldPerMeshPerTypePerDisc():_type(ON_CELLS),_father(0),_start(-std::numeric_limits<int>::max()),_end(-std::numeric_limits<int>::max()),
+    _nval(-std::numeric_limits<int>::max()),_loc_id(-std::numeric_limits<int>::max())
+{
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile(med_idt fid, const std::string& fieldName, int nbOfCompo, int iteration, int order, med_entity_type menti, med_geometry_type mgeoti, unsigned char *startFeedingPtr)
+{
+  const PartDefinition *pd(_pd);
+  if(!pd)
+    {
+      med_entity_type mentiCpy(menti);
+      INTERP_KERNEL::AutoPtr<char> locname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+      int nbi,tmp1;
+      med_int nbValsInFile(MEDfieldnValueWithProfileByName(fid,fieldName.c_str(),iteration,order,menti,mgeoti,_profile.c_str(),MED_COMPACT_PFLMODE,&tmp1,locname,&nbi));
+      if(nbValsInFile==0 && menti==MED_CELL)
+        {//
+          nbValsInFile=MEDfieldnValueWithProfileByName(fid,fieldName.c_str(),iteration,order,MED_DESCENDING_FACE,mgeoti,_profile.c_str(),MED_COMPACT_PFLMODE,&tmp1,locname,&nbi);
+          if(nbValsInFile==0)
+            {
+              nbValsInFile=MEDfieldnValueWithProfileByName(fid,fieldName.c_str(),iteration,order,MED_DESCENDING_EDGE,mgeoti,_profile.c_str(),MED_COMPACT_PFLMODE,&tmp1,locname,&nbi);
+              if(nbValsInFile!=0)
+                { mentiCpy=MED_DESCENDING_EDGE; }
+            }
+          else
+            { mentiCpy=MED_DESCENDING_FACE; }
+        }
+      if(_end-_start!=nbValsInFile*nbi)
+        {
+          std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile : The number of tuples to read is " << nbValsInFile << "*" << nbi <<  " (nb integration points) ! But in data structure it values " << _end-_start << " is expected !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      MEDFILESAFECALLERRD0(MEDfieldValueWithProfileRd,(fid,fieldName.c_str(),iteration,order,mentiCpy,mgeoti,MED_COMPACT_PFLMODE,_profile.c_str(),MED_FULL_INTERLACE,MED_ALL_CONSTITUENT,startFeedingPtr));
+    }
+  else
+    {
+      if(!_profile.empty())
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile : not implemented !");
+      INTERP_KERNEL::AutoPtr<char> pflname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE)),locname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+      int profilesize,nbi;
+      int overallNval(MEDfieldnValueWithProfile(fid,fieldName.c_str(),iteration,order,menti,mgeoti,_profile_it+1,MED_COMPACT_PFLMODE,pflname,&profilesize,locname,&nbi));
+      const SlicePartDefinition *spd(dynamic_cast<const SlicePartDefinition *>(pd));
+      if(spd)
+        {
+          int start,stop,step;
+          spd->getSlice(start,stop,step);
+          int nbOfEltsToLoad(DataArray::GetNumberOfItemGivenBES(start,stop,step,"MEDFileFieldPerMeshPerTypePerDisc::goReadZeValuesInFile"));
+          med_filter filter=MED_FILTER_INIT;
+          MEDFILESAFECALLERRD0(MEDfilterBlockOfEntityCr,(fid,/*nentity*/overallNval,/*nvaluesperentity*/nbi,/*nconstituentpervalue*/nbOfCompo,
+                                                         MED_ALL_CONSTITUENT,MED_FULL_INTERLACE,MED_COMPACT_STMODE,MED_NO_PROFILE,
+                                                         /*start*/start+1,/*stride*/step,/*count*/1,/*blocksize*/nbOfEltsToLoad,
+                                                         /*lastblocksize=useless because count=1*/0,&filter));
+          MEDFILESAFECALLERRD0(MEDfieldValueAdvancedRd,(fid,fieldName.c_str(),iteration,order,menti,mgeoti,&filter,startFeedingPtr));
+          MEDfilterClose(&filter);
+          return ;
+        }
+      const DataArrayPartDefinition *dpd(dynamic_cast<const DataArrayPartDefinition *>(pd));
+      if(dpd)
+        {
+          dpd->checkConsistencyLight();
+          MCAuto<DataArrayInt> myIds(dpd->toDAI());
+          int a(myIds->getMinValueInArray()),b(myIds->getMaxValueInArray());
+          myIds=myIds->deepCopy();// WARNING deep copy here because _pd is modified by applyLin !!!
+          myIds->applyLin(1,-a);
+          int nbOfEltsToLoad(b-a+1);
+          med_filter filter=MED_FILTER_INIT;
+          {//TODO : manage int32 !
+            MCAuto<DataArrayDouble> tmp(DataArrayDouble::New());
+            tmp->alloc(nbOfEltsToLoad,nbOfCompo);
+            MEDFILESAFECALLERRD0(MEDfilterBlockOfEntityCr,(fid,/*nentity*/overallNval,/*nvaluesperentity*/nbi,/*nconstituentpervalue*/nbOfCompo,
+                                                           MED_ALL_CONSTITUENT,MED_FULL_INTERLACE,MED_COMPACT_STMODE,MED_NO_PROFILE,
+                                                           /*start*/a+1,/*stride*/1,/*count*/1,/*blocksize*/nbOfEltsToLoad,
+                                                           /*lastblocksize=useless because count=1*/0,&filter));
+            MEDFILESAFECALLERRD0(MEDfieldValueAdvancedRd,(fid,fieldName.c_str(),iteration,order,menti,mgeoti,&filter,reinterpret_cast<unsigned char *>(tmp->getPointer())));
+            MCAuto<DataArrayDouble> feeder(DataArrayDouble::New());
+            feeder->useExternalArrayWithRWAccess(reinterpret_cast<double *>(startFeedingPtr),_nval,nbOfCompo);
+            feeder->setContigPartOfSelectedValues(0,tmp,myIds);
+          }
+          MEDfilterClose(&filter);
+        }
+      else
+        throw INTERP_KERNEL::Exception("Not implemented yet for not slices!");
+    }
+}
+
+const MEDFileFieldPerMeshPerTypeCommon *MEDFileFieldPerMeshPerTypePerDisc::getFather() const
+{
+  return _father;
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::loadOnlyStructureOfDataRecursively(med_idt fid, int& start, const MEDFileFieldNameScope& nasc)
+{
+  INTERP_KERNEL::AutoPtr<char> locname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> pflname(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  std::string fieldName(nasc.getName()),meshName(getMeshName());
+  int iteration(getIteration()),order(getOrder()),profilesize,nbi;
+  TypeOfField type(getType());
+  med_geometry_type mgeoti;
+  med_entity_type menti;
+  _father->entriesForMEDfile(type,mgeoti,menti);
+  int zeNVal(MEDfieldnValueWithProfile(fid,fieldName.c_str(),iteration,order,menti,mgeoti,_profile_it+1,MED_COMPACT_PFLMODE,pflname,&profilesize,locname,&nbi));
+  if(zeNVal==0 && type==ON_CELLS)
+    {//eheh maybe there's a surprise :)
+      int zeNVal1(MEDfieldnValueWithProfile(fid,fieldName.c_str(),iteration,order,MED_DESCENDING_FACE,mgeoti,_profile_it+1,MED_COMPACT_PFLMODE,pflname,&profilesize,locname,&nbi));
+      if(zeNVal1==0)
+        {
+          int zeNVal2(MEDfieldnValueWithProfile(fid,fieldName.c_str(),iteration,order,MED_DESCENDING_EDGE,mgeoti,_profile_it+1,MED_COMPACT_PFLMODE,pflname,&profilesize,locname,&nbi));
+          if(zeNVal2!=0)
+            zeNVal=zeNVal2;
+        }
+      else
+        {
+          zeNVal=zeNVal1;
+        }
+    }
+  _profile=MEDLoaderBase::buildStringFromFortran(pflname,MED_NAME_SIZE);
+  _localization=MEDLoaderBase::buildStringFromFortran(locname,MED_NAME_SIZE);
+  const PartDefinition *pd(_pd);
+  if(!pd)
+    {
+      _nval=zeNVal;
+    }
+  else
+    {
+      if(!_profile.empty())
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::loadOnlyStructureOfDataRecursively : profiles are not managed yet with part of def !");
+      _nval=pd->getNumberOfElems();
+    }
+  _start=start;
+  _end=start+_nval*nbi;
+  start=_end;
+  if(type==ON_CELLS && !_localization.empty())
+    {
+      if(_localization!="MED_GAUSS_ELNO")//For compatibility with MED2.3
+        setType(ON_GAUSS_PT);
+      else
+        {
+          setType(ON_GAUSS_NE);
+          _localization.clear();
+        }
+    }
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::loadBigArray(med_idt fid, const MEDFileFieldNameScope& nasc)
+{
+  std::string fieldName(nasc.getName()),meshName(getMeshName());
+  int iteration(getIteration()),order(getOrder());
+  TypeOfField type(getType());
+  med_geometry_type mgeoti;
+  med_entity_type menti;
+  _father->entriesForMEDfile(type,mgeoti,menti);
+  if(_start>_end)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::loadBigArray : internal error in range !");
+  if(_start==_end)
+    return ;
+  DataArray *arr(getOrCreateAndGetArray());//arr is not null due to the spec of getOrCreateAndGetArray
+  if(_start<0 || _start>=arr->getNumberOfTuples())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypePerDisc::loadBigArray : Invalid start ("<< _start << ") regarding admissible range of allocated array [0," << arr->getNumberOfTuples() << ") !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  if(_end<0 || _end>arr->getNumberOfTuples())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypePerDisc::loadBigArray : Invalid start ("<< _start << ") regarding admissible range of allocated array [0," << arr->getNumberOfTuples() << "] !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  int nbOfCompo(arr->getNumberOfComponents());
+  DataArrayDouble *arrD(dynamic_cast<DataArrayDouble *>(arr));
+  if(arrD)
+    {
+      double *startFeeding(arrD->getPointer()+_start*nbOfCompo);
+      goReadZeValuesInFile(fid,fieldName,nbOfCompo,iteration,order,menti,mgeoti,reinterpret_cast<unsigned char*>(startFeeding));
+      return ;
+    }
+  DataArrayInt *arrI(dynamic_cast<DataArrayInt *>(arr));
+  if(arrI)
+    {
+      int *startFeeding(arrI->getPointer()+_start*nbOfCompo);
+      goReadZeValuesInFile(fid,fieldName,nbOfCompo,iteration,order,menti,mgeoti,reinterpret_cast<unsigned char*>(startFeeding));
+      return ;
+    }
+  DataArrayFloat *arrF(dynamic_cast<DataArrayFloat *>(arr));
+  if(arrF)
+    {
+      float *startFeeding(arrF->getPointer()+_start*nbOfCompo);
+      goReadZeValuesInFile(fid,fieldName,nbOfCompo,iteration,order,menti,mgeoti,reinterpret_cast<unsigned char*>(startFeeding));
+      return ;
+    }
+  throw INTERP_KERNEL::Exception("Error on array reading ! Unrecognized type of field ! Should be in FLOAT64 FLOAT32 or INT32 !");
+}
+
+/*!
+ * Set a \c this->_start **and** \c this->_end keeping the same delta between the two.
+ */
+void MEDFileFieldPerMeshPerTypePerDisc::setNewStart(int newValueOfStart)
+{
+  int delta=_end-_start;
+  _start=newValueOfStart;
+  _end=_start+delta;
+}
+
+int MEDFileFieldPerMeshPerTypePerDisc::getIteration() const
+{
+  return _father->getIteration();
+}
+
+int MEDFileFieldPerMeshPerTypePerDisc::getOrder() const
+{
+  return _father->getOrder();
+}
+
+double MEDFileFieldPerMeshPerTypePerDisc::getTime() const
+{
+  return _father->getTime();
+}
+
+std::string MEDFileFieldPerMeshPerTypePerDisc::getMeshName() const
+{
+  return _father->getMeshName();
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::simpleRepr(int bkOffset, std::ostream& oss, int id) const
+{
+  const char startLine[]="    ## ";
+  std::string startLine2(bkOffset,' ');
+  startLine2+=startLine;
+  INTERP_KERNEL::AutoCppPtr<MEDCouplingFieldDiscretization> tmp(MEDCouplingFieldDiscretization::New(_type));
+  oss << startLine2 << "Localization #" << id << "." << std::endl;
+  oss << startLine2 << "  Type=" << tmp->getRepr() << "." << std::endl;
+  oss << startLine2 << "  This type discretization lies on profile : \"" << _profile << "\" and on the following localization : \"" << _localization << "\"." << std::endl;
+  oss << startLine2 << "  This type discretization has " << _end-_start << " tuples (start=" << _start << ", end=" << _end << ")." << std::endl;
+  oss << startLine2 << "  This type discretization has " << (_end-_start)/_nval << " integration points." << std::endl;
+}
+
+TypeOfField MEDFileFieldPerMeshPerTypePerDisc::getType() const
+{
+  return _type;
+}
+
+INTERP_KERNEL::NormalizedCellType MEDFileFieldPerMeshPerTypePerDisc::getGeoType() const
+{
+  return _father->getGeoType();
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const
+{
+  types.insert(_type);
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::setType(TypeOfField newType)
+{
+  _type=newType;
+}
+
+int MEDFileFieldPerMeshPerTypePerDisc::getNumberOfComponents() const
+{
+  return _father->getNumberOfComponents();
+}
+
+int MEDFileFieldPerMeshPerTypePerDisc::getNumberOfTuples() const
+{
+  return _end-_start;
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::incrementNbOfVals(int deltaNbVal)
+{
+  int nbi((_end-_start)/_nval);
+  _nval+=deltaNbVal;
+  _end+=nbi*deltaNbVal;
+}
+
+DataArray *MEDFileFieldPerMeshPerTypePerDisc::getOrCreateAndGetArray()
+{
+  return _father->getOrCreateAndGetArray();
+}
+
+const DataArray *MEDFileFieldPerMeshPerTypePerDisc::getOrCreateAndGetArray() const
+{
+  const MEDFileFieldPerMeshPerTypeCommon *fath=_father;
+  return fath->getOrCreateAndGetArray();
+}
+
+const std::vector<std::string>& MEDFileFieldPerMeshPerTypePerDisc::getInfo() const
+{
+  return _father->getInfo();
+}
+
+std::string MEDFileFieldPerMeshPerTypePerDisc::getProfile() const
+{
+  return _profile;
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::setProfile(const std::string& newPflName)
+{
+  _profile=newPflName;
+}
+
+std::string MEDFileFieldPerMeshPerTypePerDisc::getLocalization() const
+{
+  return _localization;
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::setLocalization(const std::string& newLocName)
+{
+  _localization=newLocName;
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
+    {
+      if(std::find((*it2).first.begin(),(*it2).first.end(),_profile)!=(*it2).first.end())
+        {
+          _profile=(*it2).second;
+          return;
+        }
+    }
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< std::pair<std::vector<std::string>, std::string > >::const_iterator it2=mapOfModif.begin();it2!=mapOfModif.end();it2++)
+    {
+      if(std::find((*it2).first.begin(),(*it2).first.end(),_localization)!=(*it2).first.end())
+        {
+          _localization=(*it2).second;
+          return;
+        }
+    }
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::getFieldAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const
+{
+  if(type!=_type)
+    return ;
+  dads.push_back(std::pair<int,int>(_start,_end));
+  geoTypes.push_back(getGeoType());
+  if(_profile.empty())
+    pfls.push_back(0);
+  else
+    {
+      pfls.push_back(glob->getProfile(_profile.c_str()));
+    }
+  if(_localization.empty())
+    locs.push_back(-1);
+  else
+    {
+      locs.push_back(glob->getLocalizationId(_localization.c_str()));
+    }
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::fillValues(int discId, int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  entries[startEntryId]=std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int> ,std::pair<int,int> >(std::pair<INTERP_KERNEL::NormalizedCellType,int>(getGeoType(),discId),std::pair<int,int>(_start,_end));
+  startEntryId++;
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const
+{
+  TypeOfField type=getType();
+  INTERP_KERNEL::NormalizedCellType geoType(getGeoType());
+  med_geometry_type mgeoti;
+  med_entity_type menti;
+  _father->entriesForMEDfile(getType(),mgeoti,menti);
+  const DataArray *arr(getOrCreateAndGetArray());
+  if(!arr)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::writeLL : no array set !");
+  if(!arr->isAllocated())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::writeLL : the array to be written is not allocated !");
+  const DataArrayDouble *arrD(dynamic_cast<const DataArrayDouble *>(arr));
+  const DataArrayInt *arrI(dynamic_cast<const DataArrayInt *>(arr));
+  const DataArrayFloat *arrF(dynamic_cast<const DataArrayFloat *>(arr));
+  const unsigned char *locToWrite=0;
+  if(arrD)
+    locToWrite=reinterpret_cast<const unsigned char *>(arrD->getConstPointer()+_start*arr->getNumberOfComponents());
+  else if(arrI)
+    locToWrite=reinterpret_cast<const unsigned char *>(arrI->getConstPointer()+_start*arr->getNumberOfComponents());
+  else if(arrF)
+    locToWrite=reinterpret_cast<const unsigned char *>(arrF->getConstPointer()+_start*arr->getNumberOfComponents());
+  else
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::writeLL : not recognized type of values ! Supported are FLOAT64 FLOAT32 and INT32 !");
+  MEDFILESAFECALLERWR0(MEDfieldValueWithProfileWr,(fid,nasc.getName().c_str(),getIteration(),getOrder(),getTime(),menti,mgeoti,
+                                                   MED_COMPACT_PFLMODE,_profile.c_str(),_localization.c_str(),MED_FULL_INTERLACE,MED_ALL_CONSTITUENT,_nval,
+                                                   locToWrite));
+}
+
+void MEDFileFieldPerMeshPerTypePerDisc::getCoarseData(TypeOfField& type, std::pair<int,int>& dad, std::string& pfl, std::string& loc) const
+{
+  type=_type;
+  pfl=_profile;
+  loc=_localization;
+  dad.first=_start; dad.second=_end;
+}
+
+/*!
+ * \param [in] codeOfMesh is of format returned by MEDCouplingUMesh::getDistributionOfTypes. And for each *i* oldCode[3*i+2] gives the position (MEDFileUMesh::PutInThirdComponentOfCodeOffset).
+ *             This code corresponds to the distribution of types in the corresponding mesh.
+ * \param [out] ptToFill memory zone where the output will be stored.
+ * \return the size of data pushed into output param \a ptToFill
+ */
+int MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode(int offset, const std::vector<int>& codeOfMesh, const MEDFileFieldGlobsReal& glob, int *ptToFill) const
+{
+  _loc_id=offset;
+  std::ostringstream oss;
+  std::size_t nbOfType=codeOfMesh.size()/3;
+  int found=-1;
+  for(std::size_t i=0;i<nbOfType && found==-1;i++)
+    if(getGeoType()==(INTERP_KERNEL::NormalizedCellType)codeOfMesh[3*i])
+      found=(int)i;
+  if(found==-1)
+    {
+      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType());
+      oss << "MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode : not found geometric type " << cm.getRepr() << " in the referenced mesh of field !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  int *work=ptToFill;
+  if(_profile.empty())
+    {
+      if(_nval!=codeOfMesh[3*found+1])
+        {
+          const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType());
+          oss << "MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode : for geometric type " << cm.getRepr() << " number of elt ids in mesh is equal to " << _nval;
+          oss << " whereas mesh has " << codeOfMesh[3*found+1] << " for this geometric type !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      for(int ii=codeOfMesh[3*found+2];ii<codeOfMesh[3*found+2]+_nval;ii++)
+        *work++=ii;
+    }
+  else
+    {
+      const DataArrayInt *pfl=glob.getProfile(_profile.c_str());
+      if(pfl->getNumberOfTuples()!=_nval)
+        {
+          const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(getGeoType());
+          oss << "MEDFileFieldPerMeshPerTypePerDisc::fillEltIdsFromCode : for geometric type " << cm.getRepr() << ", field is defined on profile \"" << _profile << "\" and size of profile is ";
+          oss << _nval;
+          oss << pfl->getNumberOfTuples() << " whereas the number of ids is set to " << _nval << " for this geometric type !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      int offset2=codeOfMesh[3*found+2];
+      for(const int *pflId=pfl->begin();pflId!=pfl->end();pflId++)
+        {
+          if(*pflId<codeOfMesh[3*found+1])
+            *work++=offset2+*pflId;
+        }
+    }
+  return _nval;
+}
+
+int MEDFileFieldPerMeshPerTypePerDisc::fillTupleIds(int *ptToFill) const
+{
+  for(int i=_start;i<_end;i++)
+    *ptToFill++=i;
+  return _end-_start;
+}
+
+int MEDFileFieldPerMeshPerTypePerDisc::ConvertType(TypeOfField type, int locId)
+{
+  switch(type)
+  {
+    case ON_CELLS:
+      return -2;
+    case ON_GAUSS_NE:
+      return -1;
+    case ON_GAUSS_PT:
+      return locId;
+    default:
+      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::ConvertType : not managed type of field !");
+  }
+}
+
+std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > MEDFileFieldPerMeshPerTypePerDisc::SplitPerDiscretization(const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entries)
+{
+  int id=0;
+  std::map<std::pair<std::string,TypeOfField>,int> m;
+  std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > ret;
+  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entries.begin();it!=entries.end();it++)
+    if(m.find(std::pair<std::string,TypeOfField>((*it)->getLocalization(),(*it)->getType()))==m.end())
+      m[std::pair<std::string,TypeOfField>((*it)->getLocalization(),(*it)->getType())]=id++;
+  ret.resize(id);
+  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entries.begin();it!=entries.end();it++)
+    ret[m[std::pair<std::string,TypeOfField>((*it)->getLocalization(),(*it)->getType())]].push_back(*it);
+  return ret;
+}
+
+/*!
+ * - \c this->_loc_id mutable attribute is used for elt id in mesh offsets.
+ * 
+ * \param [in] offset the offset id used to take into account that \a result is not compulsory empty in input
+ * \param [in] entriesOnSameDisc some entries **on same localization** if not the result can be invalid. The _start and _end on them are relative to \a arr parameter.
+ * \param [in] explicitIdsInMesh ids in mesh of the considered chunk.
+ * \param [in] newCode one of the input parameter to explicit the new geo type dispatch (in classical format same than those asked by MEDFileFields::renumberEntitiesLyingOnMesh)
+ * \param [in,out] glob if necessary by the method, new profiles can be added to it
+ * \param [in,out] arr after the call of this method \a arr is renumbered to be compliant with added entries to \a result.
+ * \param [out] result All new entries will be appended on it.
+ * \return false if the configuration of renumbering leads to an unnecessary resplit of input \a entriesOnSameDisc. If not true is returned (the most general case !)
+ */
+bool MEDFileFieldPerMeshPerTypePerDisc::RenumberChunks(int offset, const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
+                                                       const DataArrayInt *explicitIdsInMesh,
+                                                       const std::vector<int>& newCode,
+                                                       MEDFileFieldGlobsReal& glob, DataArrayDouble *arr,
+                                                       std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >& result)
+{
+  if(entriesOnSameDisc.empty())
+    return false;
+  TypeOfField type=entriesOnSameDisc[0]->getType();
+  int szEntities=0,szTuples=0;
+  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entriesOnSameDisc.begin();it!=entriesOnSameDisc.end();it++)
+    { szEntities+=(*it)->_nval; szTuples+=(*it)->_end-(*it)->_start; }
+  int nbi=szTuples/szEntities;
+  if(szTuples%szEntities!=0)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::RenumberChunks : internal error the splitting into same dicretization failed !");
+  MCAuto<DataArrayInt> renumTuples=DataArrayInt::New(); renumTuples->alloc(szTuples,1);
+  MCAuto<DataArrayInt> ranges=MEDCouplingUMesh::ComputeRangesFromTypeDistribution(newCode);
+  std::vector< MCAuto<DataArrayInt> > newGeoTypesPerChunk(entriesOnSameDisc.size());
+  std::vector< const DataArrayInt * > newGeoTypesPerChunk2(entriesOnSameDisc.size());
+  std::vector< MCAuto<DataArrayInt> > newGeoTypesPerChunk_bis(entriesOnSameDisc.size());
+  std::vector< const DataArrayInt * > newGeoTypesPerChunk3(entriesOnSameDisc.size());
+  MCAuto<DataArrayInt> newGeoTypesPerChunk4=DataArrayInt::New(); newGeoTypesPerChunk4->alloc(szEntities,nbi);
+  int id=0;
+  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entriesOnSameDisc.begin();it!=entriesOnSameDisc.end();it++,id++)
+    {
+      int startOfEltIdOfChunk=(*it)->_start;
+      MCAuto<DataArrayInt> newEltIds=explicitIdsInMesh->subArray(startOfEltIdOfChunk,startOfEltIdOfChunk+(*it)->_nval);
+      MCAuto<DataArrayInt> rangeIdsForChunk=newEltIds->findRangeIdForEachTuple(ranges);
+      MCAuto<DataArrayInt> idsInRrangeForChunk=newEltIds->findIdInRangeForEachTuple(ranges);
+      //
+      MCAuto<DataArrayInt> tmp=rangeIdsForChunk->duplicateEachTupleNTimes(nbi); rangeIdsForChunk->rearrange(nbi);
+      newGeoTypesPerChunk4->setPartOfValues1(tmp,(*it)->_tmp_work1-offset,(*it)->_tmp_work1+(*it)->_nval*nbi-offset,1,0,nbi,1);
+      //
+      newGeoTypesPerChunk[id]=rangeIdsForChunk; newGeoTypesPerChunk2[id]=rangeIdsForChunk;
+      newGeoTypesPerChunk_bis[id]=idsInRrangeForChunk; newGeoTypesPerChunk3[id]=idsInRrangeForChunk;
+    }
+  MCAuto<DataArrayInt> newGeoTypesEltIdsAllGather=DataArrayInt::Aggregate(newGeoTypesPerChunk2); newGeoTypesPerChunk.clear(); newGeoTypesPerChunk2.clear();
+  MCAuto<DataArrayInt> newGeoTypesEltIdsAllGather2=DataArrayInt::Aggregate(newGeoTypesPerChunk3); newGeoTypesPerChunk_bis.clear(); newGeoTypesPerChunk3.clear();
+  MCAuto<DataArrayInt> diffVals=newGeoTypesEltIdsAllGather->getDifferentValues();
+  MCAuto<DataArrayInt> renumEltIds=newGeoTypesEltIdsAllGather->buildPermArrPerLevel();
+  //
+  MCAuto<DataArrayInt> renumTupleIds=newGeoTypesPerChunk4->buildPermArrPerLevel();
+  //
+  MCAuto<DataArrayDouble> arrPart=arr->subArray(offset,offset+szTuples);
+  arrPart->renumberInPlace(renumTupleIds->begin());
+  arr->setPartOfValues1(arrPart,offset,offset+szTuples,1,0,arrPart->getNumberOfComponents(),1);
+  bool ret=false;
+  const int *idIt=diffVals->begin();
+  std::list<const MEDFileFieldPerMeshPerTypePerDisc *> li(entriesOnSameDisc.begin(),entriesOnSameDisc.end());
+  int offset2=0;
+  for(int i=0;i<diffVals->getNumberOfTuples();i++,idIt++)
+    {
+      MCAuto<DataArrayInt> ids=newGeoTypesEltIdsAllGather->findIdsEqual(*idIt);
+      MCAuto<DataArrayInt> subIds=newGeoTypesEltIdsAllGather2->selectByTupleId(ids->begin(),ids->end());
+      int nbEntityElts=subIds->getNumberOfTuples();
+      bool ret2;
+      MCAuto<MEDFileFieldPerMeshPerTypePerDisc> eltToAdd=MEDFileFieldPerMeshPerTypePerDisc::
+          NewObjectOnSameDiscThanPool(type,(INTERP_KERNEL::NormalizedCellType)newCode[3*(*idIt)],subIds,!subIds->isIota(newCode[3*(*idIt)+1]),nbi,
+                                      offset+offset2,
+                                      li,glob,ret2);
+      ret=ret || ret2;
+      result.push_back(eltToAdd);
+      offset2+=nbEntityElts*nbi;
+    }
+  ret=ret || li.empty();
+  return ret;
+}
+
+/*!
+ * \param [in] typeF type of field of new chunk
+ * \param [in] geoType the geometric type of the chunk
+ * \param [in] idsOfMeshElt the entity ids of mesh (cells or nodes) of the new chunk.
+ * \param [in] isPfl specifies if a profile is requested regarding size of \a idsOfMeshElt and the number of such entities regarding underlying mesh.
+ * \param [in] nbi number of integration points
+ * \param [in] offset The offset in the **global array of data**.
+ * \param [in,out] entriesOnSameDisc the pool **on the same discretization** inside which it will be attempted to find an existing entry corresponding exactly
+ *                 to the new chunk to create.
+ * \param [in,out] glob the global shared info that will be requested for existing profiles or to append a new profile if needed.
+ * \param [out] notInExisting If false the return newly allocated entry is not coming from \a entriesOnSameDisc. If true the output comes from copy of \a entriesOnSameDisc
+ *              and corresponding entry erased from \a entriesOnSameDisc.
+ * \return a newly allocated chunk
+ */
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypePerDisc::NewObjectOnSameDiscThanPool(TypeOfField typeF, INTERP_KERNEL::NormalizedCellType geoType, DataArrayInt *idsOfMeshElt,
+                                                                                                  bool isPfl, int nbi, int offset,
+                                                                                                  std::list< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
+                                                                                                  MEDFileFieldGlobsReal& glob,
+                                                                                                  bool &notInExisting)
+{
+  int nbMeshEntities=idsOfMeshElt->getNumberOfTuples();
+  std::list< const MEDFileFieldPerMeshPerTypePerDisc *>::iterator it=entriesOnSameDisc.begin();
+  for(;it!=entriesOnSameDisc.end();it++)
+    {
+      if(((INTERP_KERNEL::NormalizedCellType)(*it)->_loc_id)==geoType && (*it)->_nval==nbMeshEntities)
+        {
+          if(!isPfl)
+            {
+              if((*it)->_profile.empty())
+                break;
+              else
+                if(!(*it)->_profile.empty())
+                  {
+                    const DataArrayInt *pfl=glob.getProfile((*it)->_profile.c_str());
+                    if(pfl->isEqualWithoutConsideringStr(*idsOfMeshElt))
+                      break;
+                  }
+            }
+        }
+    }
+  if(it==entriesOnSameDisc.end())
+    {
+      notInExisting=true;
+      MEDFileFieldPerMeshPerTypePerDisc *ret=new MEDFileFieldPerMeshPerTypePerDisc;
+      ret->_type=typeF;
+      ret->_loc_id=(int)geoType;
+      ret->_nval=nbMeshEntities;
+      ret->_start=offset;
+      ret->_end=ret->_start+ret->_nval*nbi;
+      if(isPfl)
+        {
+          idsOfMeshElt->setName(glob.createNewNameOfPfl().c_str());
+          glob.appendProfile(idsOfMeshElt);
+          ret->_profile=idsOfMeshElt->getName();
+        }
+      //tony treatment of localization
+      return ret;
+    }
+  else
+    {
+      notInExisting=false;
+      MEDFileFieldPerMeshPerTypePerDisc *ret=MEDFileFieldPerMeshPerTypePerDisc::New(*(*it));
+      ret->_loc_id=(int)geoType;
+      ret->setNewStart(offset);
+      entriesOnSameDisc.erase(it);
+      return ret;
+    }
+
+}
+
+////////////////////////////////////
+
+MEDFileFieldPerMeshPerTypeCommon::~MEDFileFieldPerMeshPerTypeCommon()
+{
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::setFather(MEDFileFieldPerMesh *father)
+{
+  _father=father;
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::accept(MEDFileFieldVisitor& visitor) const
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    if((*it).isNotNull())
+      {
+        visitor.newPerMeshPerTypePerDisc(*it);
+      }
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::deepCopyElements()
+{
+  std::size_t i=0;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
+    {
+      if((const MEDFileFieldPerMeshPerTypePerDisc *)*it)
+        _field_pm_pt_pd[i]=(*it)->deepCopy(this);
+    }
+}
+
+std::size_t MEDFileFieldPerMeshPerTypeCommon::getHeapMemorySizeWithoutChildren() const
+{
+  return _field_pm_pt_pd.capacity()*sizeof(MCAuto<MEDFileFieldPerMeshPerTypePerDisc>);
+}
+
+std::vector<const BigMemoryObject *> MEDFileFieldPerMeshPerTypeCommon::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    ret.push_back((const MEDFileFieldPerMeshPerTypePerDisc *)*it);
+  return ret;
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  std::vector<int> pos=addNewEntryIfNecessary(field,offset,nbOfCells);
+  for(std::vector<int>::const_iterator it=pos.begin();it!=pos.end();it++)
+    _field_pm_pt_pd[*it]->assignFieldNoProfile(start,offset,nbOfCells,field,arr,glob,nasc);
+}
+
+/*!
+ * This method is the most general one. No optimization is done here.
+ * \param [in] multiTypePfl is the end user profile specified in high level API
+ * \param [in] idsInPfl is the selection into the \a multiTypePfl whole profile that corresponds to the current geometric type.
+ * \param [in] locIds is the profile needed to be created for MED file format. It can be null if all cells of current geometric type are fetched in \a multiTypePfl.
+ *             \b WARNING if not null the MED file profile can be subdivided again in case of Gauss points.
+ * \param [in] nbOfEltsInWholeMesh nb of elts of type \a this->_geo_type in \b WHOLE mesh
+ * \param [in] mesh is the mesh coming from the MEDFileMesh instance in correspondence with the MEDFileField. The mesh inside the \a field is simply ignored.
+ */
+void MEDFileFieldPerMeshPerTypeCommon::assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  std::vector<int> pos=addNewEntryIfNecessary(field,idsInPfl);
+  for(std::vector<int>::const_iterator it=pos.begin();it!=pos.end();it++)
+    _field_pm_pt_pd[*it]->assignFieldProfile(isPflAlone,start,multiTypePfl,idsInPfl,locIds,nbOfEltsInWholeMesh,field,arr,mesh,glob,nasc);
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob)
+{
+  _field_pm_pt_pd.resize(1);
+  _field_pm_pt_pd[0]=MEDFileFieldPerMeshPerTypePerDisc::New(this,ON_NODES,-3);
+  _field_pm_pt_pd[0]->assignNodeFieldNoProfile(start,field,arr,glob);
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  MCAuto<DataArrayInt> pfl2=pfl->deepCopy();
+  if(!arr || !arr->isAllocated())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeCommon::assignNodeFieldProfile : input array is null, or not allocated !");
+  _field_pm_pt_pd.resize(1);
+  _field_pm_pt_pd[0]=MEDFileFieldPerMeshPerTypePerDisc::New(this,ON_NODES,-3);
+  _field_pm_pt_pd[0]->assignFieldProfile(true,start,pfl,pfl2,pfl2,-1,field,arr,0,glob,nasc);//mesh is not requested so 0 is send.
+}
+
+std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells)
+{
+  TypeOfField type=field->getTypeOfField();
+  if(type!=ON_GAUSS_PT)
+    {
+      int locIdToFind=MEDFileFieldPerMeshPerTypePerDisc::ConvertType(type,0);
+      int sz=_field_pm_pt_pd.size();
+      bool found=false;
+      for(int j=0;j<sz && !found;j++)
+        {
+          if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
+            {
+              _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+              found=true;
+            }
+        }
+      if(!found)
+        {
+          _field_pm_pt_pd.resize(sz+1);
+          _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+        }
+      std::vector<int> ret(1,(int)sz);
+      return ret;
+    }
+  else
+    {
+      std::vector<int> ret2=addNewEntryIfNecessaryGauss(field,offset,nbOfCells);
+      int sz2=ret2.size();
+      std::vector<int> ret3(sz2);
+      int k=0;
+      for(int i=0;i<sz2;i++)
+        {
+          int sz=_field_pm_pt_pd.size();
+          int locIdToFind=ret2[i];
+          bool found=false;
+          for(int j=0;j<sz && !found;j++)
+            {
+              if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
+                {
+                  _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+                  ret3[k++]=j;
+                  found=true;
+                }
+            }
+          if(!found)
+            {
+              _field_pm_pt_pd.resize(sz+1);
+              _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+              ret3[k++]=sz;
+            }
+        }
+      return ret3;
+    }
+}
+
+std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells)
+{
+  const MEDCouplingFieldDiscretization *disc=field->getDiscretization();
+  const MEDCouplingFieldDiscretizationGauss *disc2=dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(disc);
+  if(!disc2)
+    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : invalid call to this method ! Internal Error !");
+  const DataArrayInt *da=disc2->getArrayOfDiscIds();
+  if(!da)
+    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss (no profile) : no localization ids per cell array available ! The input Gauss node field is maybe invalid !");
+  MCAuto<DataArrayInt> da2=da->selectByTupleIdSafeSlice(offset,offset+nbOfCells,1);
+  MCAuto<DataArrayInt> retTmp=da2->getDifferentValues();
+  if(retTmp->presenceOfValue(-1))
+    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : some cells have no dicretization description !");
+  std::vector<int> ret(retTmp->begin(),retTmp->end());
+  return ret;
+}
+
+std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells)
+{
+  TypeOfField type=field->getTypeOfField();
+  if(type!=ON_GAUSS_PT)
+    {
+      int locIdToFind=MEDFileFieldPerMeshPerTypePerDisc::ConvertType(type,0);
+      int sz=_field_pm_pt_pd.size();
+      bool found=false;
+      for(int j=0;j<sz && !found;j++)
+        {
+          if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
+            {
+              _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+              found=true;
+            }
+        }
+      if(!found)
+        {
+          _field_pm_pt_pd.resize(sz+1);
+          _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+        }
+      std::vector<int> ret(1,0);
+      return ret;
+    }
+  else
+    {
+      std::vector<int> ret2=addNewEntryIfNecessaryGauss(field,subCells);
+      int sz2=ret2.size();
+      std::vector<int> ret3(sz2);
+      int k=0;
+      for(int i=0;i<sz2;i++)
+        {
+          int sz=_field_pm_pt_pd.size();
+          int locIdToFind=ret2[i];
+          bool found=false;
+          for(int j=0;j<sz && !found;j++)
+            {
+              if(_field_pm_pt_pd[j]->getLocId()==locIdToFind)
+                {
+                  _field_pm_pt_pd[j]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+                  ret3[k++]=j;
+                  found=true;
+                }
+            }
+          if(!found)
+            {
+              _field_pm_pt_pd.resize(sz+1);
+              _field_pm_pt_pd[sz]=MEDFileFieldPerMeshPerTypePerDisc::New(this,type,locIdToFind);
+              ret3[k++]=sz;
+            }
+        }
+      return ret3;
+    }
+}
+
+std::vector<int> MEDFileFieldPerMeshPerTypeCommon::addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells)
+{
+  const MEDCouplingFieldDiscretization *disc=field->getDiscretization();
+  const MEDCouplingFieldDiscretizationGauss *disc2=dynamic_cast<const MEDCouplingFieldDiscretizationGauss *>(disc);
+  if(!disc2)
+    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : invalid call to this method ! Internal Error !");
+  const DataArrayInt *da=disc2->getArrayOfDiscIds();
+  if(!da)
+    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : no localization ids per cell array available ! The input Gauss node field is maybe invalid !");
+  MCAuto<DataArrayInt> da2=da->selectByTupleIdSafe(subCells->getConstPointer(),subCells->getConstPointer()+subCells->getNumberOfTuples());
+  MCAuto<DataArrayInt> retTmp=da2->getDifferentValues();
+  if(retTmp->presenceOfValue(-1))
+    throw INTERP_KERNEL::Exception("addNewEntryIfNecessaryGauss : some cells have no dicretization description !");
+  std::vector<int> ret(retTmp->begin(),retTmp->end());
+  return ret;
+}
+
+const MEDFileFieldPerMesh *MEDFileFieldPerMeshPerTypeCommon::getFather() const
+{
+  return _father;
+}
+
+bool MEDFileFieldPerMeshPerTypeCommon::isUniqueLevel(int& dim) const
+{
+  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(getGeoType()));
+  int curDim((int)cm.getDimension());
+  if(dim!=std::numeric_limits<int>::max())
+    {
+      if(dim!=curDim)
+        return false;
+    }
+  else
+    dim=curDim;
+  return true;
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    {
+      (*it)->fillTypesOfFieldAvailable(types);
+    }
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::fillFieldSplitedByType(std::vector< std::pair<int,int> >& dads, std::vector<TypeOfField>& types, std::vector<std::string>& pfls, std::vector<std::string>& locs) const
+{
+  int sz=_field_pm_pt_pd.size();
+  dads.resize(sz); types.resize(sz); pfls.resize(sz); locs.resize(sz);
+  for(int i=0;i<sz;i++)
+    {
+      _field_pm_pt_pd[i]->getCoarseData(types[i],dads[i],pfls[i],locs[i]);
+    }
+}
+
+int MEDFileFieldPerMeshPerTypeCommon::getIteration() const
+{
+  return _father->getIteration();
+}
+
+int MEDFileFieldPerMeshPerTypeCommon::getOrder() const
+{
+  return _father->getOrder();
+}
+
+double MEDFileFieldPerMeshPerTypeCommon::getTime() const
+{
+  return _father->getTime();
+}
+
+std::string MEDFileFieldPerMeshPerTypeCommon::getMeshName() const
+{
+  return _father->getMeshName();
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::getSizes(int& globalSz, int& nbOfEntries) const
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    {
+      globalSz+=(*it)->getNumberOfTuples();
+    }
+  nbOfEntries+=(int)_field_pm_pt_pd.size();
+}
+
+int MEDFileFieldPerMeshPerTypeCommon::getNumberOfComponents() const
+{
+  return _father->getNumberOfComponents();
+}
+
+bool MEDFileFieldPerMeshPerTypeCommon::presenceOfMultiDiscPerGeoType() const
+{
+  std::size_t nb(0);
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    {
+      const MEDFileFieldPerMeshPerTypePerDisc *fmtd(*it);
+      if(fmtd)
+        nb++;
+    }
+  return nb>1;
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::pushDiscretization(MEDFileFieldPerMeshPerTypePerDisc *disc)
+{
+  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> elt;
+  elt.takeRef(disc);
+  _field_pm_pt_pd.push_back(elt);
+}
+
+DataArray *MEDFileFieldPerMeshPerTypeCommon::getOrCreateAndGetArray()
+{
+  return _father->getOrCreateAndGetArray();
+}
+
+const DataArray *MEDFileFieldPerMeshPerTypeCommon::getOrCreateAndGetArray() const
+{
+  const MEDFileFieldPerMesh *fath=_father;
+  return fath->getOrCreateAndGetArray();
+}
+
+const std::vector<std::string>& MEDFileFieldPerMeshPerTypeCommon::getInfo() const
+{
+  return _father->getInfo();
+}
+
+std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getPflsReallyUsed() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
+    {
+      std::string tmp=(*it1)->getProfile();
+      if(!tmp.empty())
+        if(ret2.find(tmp)==ret2.end())
+          {
+            ret.push_back(tmp);
+            ret2.insert(tmp);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getLocsReallyUsed() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
+    {
+      std::string tmp=(*it1)->getLocalization();
+      if(!tmp.empty() && tmp!=MED_GAUSS_ELNO)
+        if(ret2.find(tmp)==ret2.end())
+          {
+            ret.push_back(tmp);
+            ret2.insert(tmp);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getPflsReallyUsedMulti() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
+    {
+      std::string tmp=(*it1)->getProfile();
+      if(!tmp.empty())
+        ret.push_back(tmp);
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldPerMeshPerTypeCommon::getLocsReallyUsedMulti() const
+{
+  std::vector<std::string> ret;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
+    {
+      std::string tmp=(*it1)->getLocalization();
+      if(!tmp.empty() && tmp!=MED_GAUSS_ELNO)
+        ret.push_back(tmp);
+    }
+  return ret;
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
+    (*it1)->changePflsRefsNamesGen(mapOfModif);
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it1=_field_pm_pt_pd.begin();it1!=_field_pm_pt_pd.end();it1++)
+    (*it1)->changeLocsRefsNamesGen(mapOfModif);
+}
+
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId(int locId)
+{
+  if(_field_pm_pt_pd.empty())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no localizations for geotype \"" << getGeoTypeRepr() << "\" !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  if(locId>=0 && locId<(int)_field_pm_pt_pd.size())
+    return _field_pm_pt_pd[locId];
+  std::ostringstream oss2; oss2 << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no such locId available (" << locId;
+  oss2 << ") for geometric type \"" << getGeoTypeRepr() << "\" It should be in [0," << _field_pm_pt_pd.size() << ") !";
+  throw INTERP_KERNEL::Exception(oss2.str().c_str());
+  return static_cast<MEDFileFieldPerMeshPerTypePerDisc*>(0);
+}
+
+const MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId(int locId) const
+{
+  if(_field_pm_pt_pd.empty())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no localizations for geotype \"" << getGeoTypeRepr() << "\" !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  if(locId>=0 && locId<(int)_field_pm_pt_pd.size())
+    return _field_pm_pt_pd[locId];
+  std::ostringstream oss2; oss2 << "MEDFileFieldPerMeshPerTypeCommon::getLeafGivenLocId : no such locId available (" << locId;
+  oss2 << ") for geometric type \"" << getGeoTypeRepr() << "\" It should be in [0," << _field_pm_pt_pd.size() << ") !";
+  throw INTERP_KERNEL::Exception(oss2.str().c_str());
+  return static_cast<const MEDFileFieldPerMeshPerTypePerDisc*>(0);
+}
+
+int MEDFileFieldPerMeshPerTypeCommon::locIdOfLeaf(const MEDFileFieldPerMeshPerTypePerDisc *leaf) const
+{
+  int ret(0);
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,ret++)
+    {
+      const MEDFileFieldPerMeshPerTypePerDisc *cand(*it);
+      if(cand==leaf)
+        return ret;
+    }
+  throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeCommon::locIdOfLeaf : not found such a leaf in this !");
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::fillValues(int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  int i=0;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
+    {
+      (*it)->fillValues(i,startEntryId,entries);
+    }
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::setLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves)
+{
+  _field_pm_pt_pd=leaves;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    (*it)->setFather(this);
+}
+
+/*!
+ *  \param [in,out] globalNum a global numbering counter for the renumbering. 
+ *  \param [out] its - list of pair (start,stop) kept
+ *  \return bool - false if the type of field \a tof is not contained in \a this.
+ */
+bool MEDFileFieldPerMeshPerTypeCommon::keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its)
+{
+  bool ret(false);
+  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > newPmPtPd;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    if((*it)->getType()==tof)
+      {
+        newPmPtPd.push_back(*it);
+        std::pair<int,int> bgEnd; bgEnd.first=(*it)->getStart(); bgEnd.second=(*it)->getEnd();
+        (*it)->setNewStart(globalNum);
+        globalNum=(*it)->getEnd();
+        its.push_back(bgEnd);
+        ret=true;
+      }
+  if(ret)
+    _field_pm_pt_pd=newPmPtPd;
+  return ret;
+}
+
+/*!
+ *  \param [in,out] globalNum a global numbering counter for the renumbering.
+ *  \param [out] its - list of pair (start,stop) kept
+ *  \return bool - false if the type of field \a tof is not contained in \a this.
+ */
+bool MEDFileFieldPerMeshPerTypeCommon::keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its)
+{
+  if(_field_pm_pt_pd.size()<=idOfDisc)
+    return false;
+  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> elt(_field_pm_pt_pd[idOfDisc]);
+  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > newPmPtPd(1,elt);
+  std::pair<int,int> bgEnd; bgEnd.first=_field_pm_pt_pd[idOfDisc]->getStart(); bgEnd.second=_field_pm_pt_pd[idOfDisc]->getEnd();
+  elt->setNewStart(globalNum);
+  globalNum=elt->getEnd();
+  its.push_back(bgEnd);
+  _field_pm_pt_pd=newPmPtPd;
+  return true;
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::loadOnlyStructureOfDataRecursively(med_idt fid, int &start, const MEDFileFieldNameScope& nasc)
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    (*it)->loadOnlyStructureOfDataRecursively(fid,start,nasc);
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    (*it)->loadBigArray(fid,nasc);
+}
+
+void MEDFileFieldPerMeshPerTypeCommon::writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const
+{
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    {
+      (*it)->copyOptionsFrom(*this);
+      (*it)->writeLL(fid,nasc);
+    }
+}
+
+med_entity_type MEDFileFieldPerMeshPerTypeCommon::ConvertIntoMEDFileType(TypeOfField ikType, INTERP_KERNEL::NormalizedCellType ikGeoType, med_geometry_type& medfGeoType)
+{
+  switch(ikType)
+  {
+    case ON_CELLS:
+      medfGeoType=typmai3[(int)ikGeoType];
+      return MED_CELL;
+    case ON_NODES:
+      medfGeoType=MED_NONE;
+      return MED_NODE;
+    case ON_GAUSS_NE:
+      medfGeoType=typmai3[(int)ikGeoType];
+      return MED_NODE_ELEMENT;
+    case ON_GAUSS_PT:
+      medfGeoType=typmai3[(int)ikGeoType];
+      return MED_CELL;
+    default:
+      throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeCommon::ConvertIntoMEDFileType : unexpected entity type ! internal error");
+  }
+  return MED_UNDEF_ENTITY_TYPE;
+}
+
+//////////////////////////////////////////////////
+
+MEDFileFieldPerMeshPerType *MEDFileFieldPerMeshPerType::NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd)
+{
+  return new MEDFileFieldPerMeshPerType(fid,fath,type,geoType,nasc,pd);
+}
+
+MEDFileFieldPerMeshPerType *MEDFileFieldPerMeshPerType::New(MEDFileFieldPerMesh *fath, INTERP_KERNEL::NormalizedCellType geoType)
+{
+  return new MEDFileFieldPerMeshPerType(fath,geoType);
+}
+
+MEDFileFieldPerMeshPerType *MEDFileFieldPerMeshPerType::deepCopy(MEDFileFieldPerMesh *father) const
+{
+  MCAuto<MEDFileFieldPerMeshPerType> ret=new MEDFileFieldPerMeshPerType(*this);
+  ret->setFather(father);
+  ret->deepCopyElements();
+  return ret.retn();
+}
+
+void MEDFileFieldPerMeshPerType::getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const
+{
+  if(_geo_type!=INTERP_KERNEL::NORM_ERROR)
+    {
+      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(_geo_type);
+      if(meshDim!=(int)cm.getDimension())
+        return ;
+    }
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++)
+    (*it)->getFieldAtLevel(type,glob,dads,pfls,locs,geoTypes);
+}
+
+INTERP_KERNEL::NormalizedCellType MEDFileFieldPerMeshPerType::getGeoType() const
+{
+  return _geo_type;
+}
+
+void MEDFileFieldPerMeshPerType::entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const
+{
+  ent=MEDFileFieldPerMeshPerTypeCommon::ConvertIntoMEDFileType(mct,_geo_type,gt);
+}
+
+void MEDFileFieldPerMeshPerType::getDimension(int& dim) const
+{
+  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(_geo_type));
+  int curDim((int)cm.getDimension());
+  dim=std::max(dim,curDim);
+}
+
+void MEDFileFieldPerMeshPerType::simpleRepr(int bkOffset, std::ostream& oss, int id) const
+{
+  const char startLine[]="  ## ";
+  std::string startLine2(bkOffset,' ');
+  std::string startLine3(startLine2);
+  startLine3+=startLine;
+  if(_geo_type!=INTERP_KERNEL::NORM_ERROR)
+    {
+      const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(_geo_type);
+      oss << startLine3 << "Entry geometry type #" << id << " is lying on geometry types " << cm.getRepr() << "." << std::endl;
+    }
+  else
+    oss << startLine3 << "Entry geometry type #" << id << " is lying on NODES." << std::endl;
+  oss << startLine3 << "Entry is defined on " <<  _field_pm_pt_pd.size() << " localizations." << std::endl;
+  int i=0;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
+    {
+      const MEDFileFieldPerMeshPerTypePerDisc *cur=(*it);
+      if(cur)
+        cur->simpleRepr(bkOffset,oss,i);
+      else
+        {
+          oss << startLine2 << "    ## " << "Localization #" << i << " is empty !" << std::endl;
+        }
+    }
+}
+
+std::string MEDFileFieldPerMeshPerType::getGeoTypeRepr() const
+{
+  const INTERP_KERNEL::CellModel& cm(INTERP_KERNEL::CellModel::GetCellModel(_geo_type));
+  return std::string(cm.getRepr());
+}
+
+MEDFileFieldPerMeshPerType::MEDFileFieldPerMeshPerType(MEDFileFieldPerMesh *father, INTERP_KERNEL::NormalizedCellType gt):MEDFileFieldPerMeshPerTypeCommon(father),_geo_type(gt)
+{
+}
+
+MEDFileFieldPerMeshPerType::MEDFileFieldPerMeshPerType(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd):MEDFileFieldPerMeshPerTypeCommon(fath),_geo_type(geoType)
+{
+  INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
+  INTERP_KERNEL::AutoPtr<char> locName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
+  med_geometry_type mgeoti;
+  med_entity_type menti(ConvertIntoMEDFileType(type,geoType,mgeoti));
+  int nbProfiles(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),menti,mgeoti,pflName,locName));
+  _field_pm_pt_pd.resize(nbProfiles);
+  for(int i=0;i<nbProfiles;i++)
+    {
+      _field_pm_pt_pd[i]=MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(this,type,i,pd);
+    }
+  if(type==ON_CELLS)
+    {
+      int nbProfiles2(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_NODE_ELEMENT,mgeoti,pflName,locName));
+      for(int i=0;i<nbProfiles2;i++)
+        _field_pm_pt_pd.push_back(MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(this,ON_GAUSS_NE,i,pd));
+    }
+  if(!_field_pm_pt_pd.empty() || type!=ON_CELLS)
+    return ;
+  // dark side of the force.
+  {
+    int nbProfiles1(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_DESCENDING_FACE,mgeoti,pflName,locName));
+    int nbProfiles2(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_DESCENDING_EDGE,mgeoti,pflName,locName));
+    if(nbProfiles1==0 && nbProfiles2==0)
+      return ;// OK definitely nothing in field
+    menti=nbProfiles1>=nbProfiles2?MED_DESCENDING_FACE:MED_DESCENDING_EDGE;//not enough words to describe the beauty
+    nbProfiles=std::max(nbProfiles1,nbProfiles2);
+    _field_pm_pt_pd.resize(nbProfiles);
+    for(int i=0;i<nbProfiles;i++)
+      _field_pm_pt_pd[i]=MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(this,ON_CELLS,i,pd);
+  }
+}
+
+MCAuto<MEDFileFieldPerMeshPerType> MEDFileFieldPerMeshPerType::Aggregate(int &start, const std::vector<std::pair<int,const MEDFileFieldPerMeshPerType *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, INTERP_KERNEL::NormalizedCellType gt, MEDFileFieldPerMesh *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo)
+{
+  MCAuto<MEDFileFieldPerMeshPerType> ret(MEDFileFieldPerMeshPerType::New(father,gt));
+  std::map<TypeOfField, std::vector< std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc * > > > m;
+  for(std::vector<std::pair<int,const MEDFileFieldPerMeshPerType *> >::const_iterator it=pms.begin();it!=pms.end();it++)
+    {
+      for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it2=(*it).second->_field_pm_pt_pd.begin();it2!=(*it).second->_field_pm_pt_pd.end();it2++)
+        m[(*it2)->getType()].push_back(std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc * >((*it).first,*it2));
+    }
+  for(std::map<TypeOfField, std::vector< std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc * > > >::const_iterator it=m.begin();it!=m.end();it++)
+    {
+      MCAuto<MEDFileFieldPerMeshPerTypePerDisc> agg(MEDFileFieldPerMeshPerTypePerDisc::Aggregate(start,(*it).second,dts,(*it).first,ret,extractInfo));
+      ret->_field_pm_pt_pd.push_back(agg);
+    }
+  return ret;
+}
+
+//////////////////////////////////////////////////
+
+MEDFileFieldPerMeshPerTypeDyn *MEDFileFieldPerMeshPerTypeDyn::NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileEntities *entities, int idGT, const MEDFileFieldNameScope& nasc)
+{
+  if(!entities)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeDyn::NewOnRead : null pointer !");
+  const MEDFileAllStaticEntitiesPlusDyn *entities2(dynamic_cast<const MEDFileAllStaticEntitiesPlusDyn *>(entities));
+  if(!entities2)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypeDyn::NewOnRead : invalid type of entities !");
+  const MEDFileStructureElement *se(entities2->getWithGT(idGT));
+  return new MEDFileFieldPerMeshPerTypeDyn(fid,fath,se,nasc);
+}
+
+MEDFileFieldPerMeshPerTypeDyn::MEDFileFieldPerMeshPerTypeDyn(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileStructureElement *se, const MEDFileFieldNameScope& nasc):MEDFileFieldPerMeshPerTypeCommon(fath)
+{
+  _se.takeRef(se);
+  INTERP_KERNEL::AutoPtr<char> pflName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
+  INTERP_KERNEL::AutoPtr<char> locName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
+  int nbProfiles(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_STRUCT_ELEMENT,_se->getDynGT(),pflName,locName));
+  _field_pm_pt_pd.resize(nbProfiles);
+  for(int i=0;i<nbProfiles;i++)
+    {
+      _field_pm_pt_pd[i]=MEDFileFieldPerMeshPerTypePerDisc::NewOnRead(this,_se->getEntity(),i,NULL);
+    }
+}
+
+int MEDFileFieldPerMeshPerTypeDyn::getDynGT() const
+{
+  return _se->getDynGT();
+}
+
+std::string MEDFileFieldPerMeshPerTypeDyn::getModelName() const
+{
+  return _se->getName();
+}
+
+void MEDFileFieldPerMeshPerTypeDyn::getDimension(int& dim) const
+{
+  throw INTERP_KERNEL::Exception("not implemented yet !");
+}
+
+void MEDFileFieldPerMeshPerTypeDyn::entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const
+{
+  gt=getDynGT();
+  ent=MED_STRUCT_ELEMENT;
+}
+
+INTERP_KERNEL::NormalizedCellType MEDFileFieldPerMeshPerTypeDyn::getGeoType() const
+{
+  throw INTERP_KERNEL::Exception("not implemented yet !");
+}
+
+void MEDFileFieldPerMeshPerTypeDyn::simpleRepr(int bkOffset, std::ostream& oss, int id) const
+{
+  const char startLine[]="  ## ";
+  std::string startLine2(bkOffset,' ');
+  std::string startLine3(startLine2);
+  startLine3+=startLine;
+  oss << startLine3 << "Entry geometry type #" << id << " is lying on geometry STRUCTURE_ELEMENT type " << getDynGT() << "." << std::endl;
+  oss << startLine3 << "Entry is defined on " <<  _field_pm_pt_pd.size() << " localizations." << std::endl;
+  int i=0;
+  for(std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >::const_iterator it=_field_pm_pt_pd.begin();it!=_field_pm_pt_pd.end();it++,i++)
+    {
+      if((*it).isNotNull())
+        (*it)->simpleRepr(bkOffset,oss,i);
+      else
+        {
+          oss << startLine2 << "    ## " << "Localization #" << i << " is empty !" << std::endl;
+        }
+    }
+}
+
+std::string MEDFileFieldPerMeshPerTypeDyn::getGeoTypeRepr() const
+{
+  throw INTERP_KERNEL::Exception("not implemented yet !");
+}
+
+MEDFileFieldPerMeshPerTypeDyn *MEDFileFieldPerMeshPerTypeDyn::deepCopy(MEDFileFieldPerMesh *father) const
+{
+  MCAuto<MEDFileFieldPerMeshPerTypeDyn> ret(new MEDFileFieldPerMeshPerTypeDyn(*this));
+  ret->setFather(father);
+  ret->deepCopyElements();
+  return ret.retn();
+}
+
+void MEDFileFieldPerMeshPerTypeDyn::getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const
+{
+  throw INTERP_KERNEL::Exception("not implemented yet !");
+}
+
+//////////////////////////////////////////////////
+
+MEDFileFieldPerMesh *MEDFileFieldPerMesh::NewOnRead(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities)
+{
+  return new MEDFileFieldPerMesh(fid,fath,meshCsit,meshIteration,meshOrder,nasc,mm,entities);
+}
+
+MEDFileFieldPerMesh *MEDFileFieldPerMesh::New(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh)
+{
+  return new MEDFileFieldPerMesh(fath,mesh);
+}
+
+std::size_t MEDFileFieldPerMesh::getHeapMemorySizeWithoutChildren() const
+{
+  return _field_pm_pt.capacity()*sizeof(MCAuto< MEDFileFieldPerMeshPerType >);
+}
+
+std::vector<const BigMemoryObject *> MEDFileFieldPerMesh::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    ret.push_back(*it);
+  return ret;
+}
+
+MEDFileFieldPerMesh *MEDFileFieldPerMesh::deepCopy(MEDFileAnyTypeField1TSWithoutSDA *father) const
+{
+  MCAuto< MEDFileFieldPerMesh > ret=new MEDFileFieldPerMesh(*this);
+  ret->_father=father;
+  std::size_t i=0;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++,i++)
+    {
+      if((*it).isNotNull())
+        ret->_field_pm_pt[i]=(*it)->deepCopy((MEDFileFieldPerMesh *)(ret));
+    }
+  return ret.retn();
+}
+
+void MEDFileFieldPerMesh::simpleRepr(int bkOffset, std::ostream& oss, int id) const
+{
+  std::string startLine(bkOffset,' ');
+  oss << startLine << "## Field part (" << id << ") lying on mesh \"" << getMeshName() << "\", Mesh iteration=" << _mesh_iteration << ". Mesh order=" << _mesh_order << "." << std::endl;
+  oss << startLine << "## Field is defined on " << _field_pm_pt.size() << " types." << std::endl;
+  int i=0;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++,i++)
+    {
+      if((*it).isNotNull())
+        (*it)->simpleRepr(bkOffset,oss,i);
+      else
+        {
+          oss << startLine << "  ## Entry geometry type #" << i << " is empty !" << std::endl;
+        }
+    }
+}
+
+void MEDFileFieldPerMesh::copyTinyInfoFrom(const MEDCouplingMesh *mesh)
+{
+  mesh->getTime(_mesh_iteration,_mesh_order);
+}
+
+void MEDFileFieldPerMesh::assignFieldNoProfileNoRenum(int& start, const std::vector<int>& code, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  int nbOfTypes=code.size()/3;
+  int offset=0;
+  for(int i=0;i<nbOfTypes;i++)
+    {
+      INTERP_KERNEL::NormalizedCellType type=(INTERP_KERNEL::NormalizedCellType)code[3*i];
+      int nbOfCells=code[3*i+1];
+      int pos=addNewEntryIfNecessary(type);
+      _field_pm_pt[pos]->assignFieldNoProfile(start,offset,nbOfCells,field,arr,glob,nasc);
+      offset+=nbOfCells;
+    }
+}
+
+/*!
+ * This method is the most general one. No optimization is done here.
+ * \param [in] multiTypePfl is the end user profile specified in high level API
+ * \param [in] code is the code of \a mesh[multiTypePfl] mesh. It is of size of number of different geometric types into \a mesh[multiTypePfl].
+ * \param [in] code2 is the code of the \b WHOLE mesh on the same level. So all types in \a code are in \a code2.
+ * \param [in] idsInPflPerType is the selection into the \a multiTypePfl whole profile that corresponds to the given geometric type. This vector is always 3 times smaller than \a code.
+ * \param [in] idsPerType is a vector containing the profiles needed to be created for MED file format. \b WARNING these processed MED file profiles can be subdivided again in case of Gauss points.
+ * \param [in] mesh is the mesh coming from the MEDFileMesh instance in correspondence with the MEDFileField. The mesh inside the \a field is simply ignored.
+ */
+void MEDFileFieldPerMesh::assignFieldProfile(int& start, const DataArrayInt *multiTypePfl, const std::vector<int>& code, const std::vector<int>& code2, const std::vector<DataArrayInt *>& idsInPflPerType, const std::vector<DataArrayInt *>& idsPerType, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  int nbOfTypes(code.size()/3);
+  for(int i=0;i<nbOfTypes;i++)
+    {
+      INTERP_KERNEL::NormalizedCellType type=(INTERP_KERNEL::NormalizedCellType)code[3*i];
+      int pos=addNewEntryIfNecessary(type);
+      DataArrayInt *pfl=0;
+      if(code[3*i+2]!=-1)
+        pfl=idsPerType[code[3*i+2]];
+      int nbOfTupes2=code2.size()/3;
+      int found=0;
+      for(;found<nbOfTupes2;found++)
+        if(code[3*i]==code2[3*found])
+          break;
+      if(found==nbOfTupes2)
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::assignFieldProfile : internal problem ! Should never happen ! Please report bug to anthony.geay@cea.fr !");
+      _field_pm_pt[pos]->assignFieldProfile(nbOfTypes==1,start,multiTypePfl,idsInPflPerType[i],pfl,code2[3*found+1],field,arr,mesh,glob,nasc);
+    }
+}
+
+void MEDFileFieldPerMesh::assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob)
+{
+  int pos=addNewEntryIfNecessary(INTERP_KERNEL::NORM_ERROR);
+  _field_pm_pt[pos]->assignNodeFieldNoProfile(start,field,arr,glob);
+}
+
+void MEDFileFieldPerMesh::assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc)
+{
+  int pos=addNewEntryIfNecessary(INTERP_KERNEL::NORM_ERROR);
+  _field_pm_pt[pos]->assignNodeFieldProfile(start,pfl,field,arr,glob,nasc);
+}
+
+void MEDFileFieldPerMesh::loadOnlyStructureOfDataRecursively(med_idt fid, int& start, const MEDFileFieldNameScope& nasc)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->loadOnlyStructureOfDataRecursively(fid,start,nasc);
+}
+
+void MEDFileFieldPerMesh::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->loadBigArraysRecursively(fid,nasc);
+}
+
+void MEDFileFieldPerMesh::writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const
+{
+  int nbOfTypes=_field_pm_pt.size();
+  for(int i=0;i<nbOfTypes;i++)
+    {
+      _field_pm_pt[i]->copyOptionsFrom(*this);
+      _field_pm_pt[i]->writeLL(fid,nasc);
+    }
+}
+
+void MEDFileFieldPerMesh::getDimension(int& dim) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->getDimension(dim);
+}
+
+bool MEDFileFieldPerMesh::isUniqueLevel(int& dim) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    if(!(*it)->isUniqueLevel(dim))
+      return false;
+  return true;
+}
+
+void MEDFileFieldPerMesh::fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->fillTypesOfFieldAvailable(types);
+}
+
+std::vector< std::vector< std::pair<int,int> > > MEDFileFieldPerMesh::getFieldSplitedByType(std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> > & locs) const
+{
+  int sz=_field_pm_pt.size();
+  std::vector< std::vector<std::pair<int,int> > > ret(sz);
+  types.resize(sz); typesF.resize(sz); pfls.resize(sz); locs.resize(sz);
+  for(int i=0;i<sz;i++)
+    {
+      types[i]=_field_pm_pt[i]->getGeoType();
+      _field_pm_pt[i]->fillFieldSplitedByType(ret[i],typesF[i],pfls[i],locs[i]);
+    }
+  return ret;
+}
+
+double MEDFileFieldPerMesh::getTime() const
+{
+  int tmp1,tmp2;
+  return _father->getTime(tmp1,tmp2);
+}
+
+int MEDFileFieldPerMesh::getIteration() const
+{
+  return _father->getIteration();
+}
+
+int MEDFileFieldPerMesh::getOrder() const
+{
+  return _father->getOrder();
+}
+
+int MEDFileFieldPerMesh::getNumberOfComponents() const
+{
+  return _father->getNumberOfComponents();
+}
+
+std::string MEDFileFieldPerMesh::getMeshName() const
+{
+  return _father->getMeshName();
+}
+
+void MEDFileFieldPerMesh::setMeshName(const std::string& meshName)
+{
+  _father->setMeshName(meshName);
+}
+
+bool MEDFileFieldPerMesh::presenceOfMultiDiscPerGeoType() const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      if((*it).isNull())
+        continue;
+      if((*it)->presenceOfMultiDiscPerGeoType())
+        return true;
+    }
+  return false;
+}
+
+bool MEDFileFieldPerMesh::presenceOfStructureElements() const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    if((*it).isNotNull())
+      {
+        const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
+        if(pt)
+          return true;
+      }
+  return false;
+}
+
+bool MEDFileFieldPerMesh::onlyStructureElements() const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    if((*it).isNotNull())
+      {
+        const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
+        if(!pt)
+          return false;
+      }
+  return true;
+}
+
+void MEDFileFieldPerMesh::killStructureElements()
+{
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > res;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      if((*it).isNotNull())
+        {
+          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
+          if(!pt)
+            res.push_back(*it);
+        }
+    }
+  _field_pm_pt=res;
+}
+
+void MEDFileFieldPerMesh::keepOnlyStructureElements()
+{
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > res;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      if((*it).isNotNull())
+        {
+          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
+          if(pt)
+            res.push_back(*it);
+        }
+    }
+  _field_pm_pt=res;
+}
+
+void MEDFileFieldPerMesh::keepOnlyOnSE(const std::string& seName)
+{
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > res;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      if((*it).isNotNull())
+        {
+          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
+          if(!pt)
+            throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::keepOnlyOnSE : presence of non SE !");
+          if(pt->getModelName()==seName)
+            res.push_back(*it);
+        }
+    }
+  _field_pm_pt=res;
+}
+
+void MEDFileFieldPerMesh::getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      if((*it).isNotNull())
+        {
+          const MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<const MEDFileFieldPerMeshPerTypeDyn *>((const MEDFileFieldPerMeshPerTypeCommon *)*it));
+          if(pt)
+            {
+              ps.push_back(std::pair<std::string,std::string>(getMeshName(),pt->getModelName()));
+            }
+          else
+            throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getMeshSENames : presence of a non structure element part !");
+        }
+    }
+}
+
+DataArray *MEDFileFieldPerMesh::getOrCreateAndGetArray()
+{
+  if(!_father)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getOrCreateAndGetArray : no father ! internal error !");
+  return _father->getOrCreateAndGetArray();
+}
+
+const DataArray *MEDFileFieldPerMesh::getOrCreateAndGetArray() const
+{
+  if(!_father)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getOrCreateAndGetArray : no father ! internal error !");
+  return _father->getOrCreateAndGetArray();
+}
+
+const std::vector<std::string>& MEDFileFieldPerMesh::getInfo() const
+{
+  return _father->getInfo();
+}
+
+/*!
+ * type,geoTypes,dads,pfls,locs are input parameters. They should have the same size.
+ * Before the call of this method 'geoTypes','dads','pfls','locs' must be reorganized so that types in geoTypes are contiguous and ordered following typmai2 array.
+ * It returns 2 output vectors :
+ * - 'code' of size 3*sz where sz is the number of different values into 'geoTypes'
+ * - 'notNullPfls' contains sz2 values that are extracted from 'pfls' in which null profiles have been removed.
+ * 'code' and 'notNullPfls' are in MEDCouplingUMesh::checkTypeConsistencyAndContig format.
+ */
+void MEDFileFieldPerMesh::SortArraysPerType(const MEDFileFieldGlobsReal *glob, TypeOfField type, const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<const DataArrayInt *>& pfls, const std::vector<int>& locs, std::vector<int>& code, std::vector<DataArrayInt *>& notNullPfls)
+{
+  int notNullPflsSz=0;
+  int nbOfArrs=geoTypes.size();
+  for(int i=0;i<nbOfArrs;i++)
+    if(pfls[i])
+      notNullPflsSz++;
+  std::set<INTERP_KERNEL::NormalizedCellType> geoTypes3(geoTypes.begin(),geoTypes.end());
+  int nbOfDiffGeoTypes=geoTypes3.size();
+  code.resize(3*nbOfDiffGeoTypes);
+  notNullPfls.resize(notNullPflsSz);
+  notNullPflsSz=0;
+  int j=0;
+  for(int i=0;i<nbOfDiffGeoTypes;i++)
+    {
+      int startZone=j;
+      INTERP_KERNEL::NormalizedCellType refType=geoTypes[j];
+      std::vector<const DataArrayInt *> notNullTmp;
+      if(pfls[j])
+        notNullTmp.push_back(pfls[j]);
+      j++;
+      for(;j<nbOfArrs;j++)
+        if(geoTypes[j]==refType)
+          {
+            if(pfls[j])
+              notNullTmp.push_back(pfls[j]);
+          }
+        else
+          break;
+      std::vector< std::pair<int,int> > tmpDads(dads.begin()+startZone,dads.begin()+j);
+      std::vector<const DataArrayInt *> tmpPfls(pfls.begin()+startZone,pfls.begin()+j);
+      std::vector<int> tmpLocs(locs.begin()+startZone,locs.begin()+j);
+      code[3*i]=(int)refType;
+      std::vector<INTERP_KERNEL::NormalizedCellType> refType2(1,refType);
+      code[3*i+1]=ComputeNbOfElems(glob,type,refType2,tmpDads,tmpLocs);
+      if(notNullTmp.empty())
+        code[3*i+2]=-1;
+      else
+        {
+          notNullPfls[notNullPflsSz]=DataArrayInt::Aggregate(notNullTmp);
+          code[3*i+2]=notNullPflsSz++;
+        }
+    }
+}
+
+/*!
+ * 'dads' 'geoTypes' and 'locs' are input parameters that should have same size sz. sz should be >=1.
+ */
+int MEDFileFieldPerMesh::ComputeNbOfElems(const MEDFileFieldGlobsReal *glob, TypeOfField type, const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs)
+{
+  int sz=dads.size();
+  int ret=0;
+  for(int i=0;i<sz;i++)
+    {
+      if(locs[i]==-1)
+        {
+          if(type!=ON_GAUSS_NE)
+            ret+=dads[i].second-dads[i].first;
+          else
+            {
+              const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(geoTypes[i]);
+              ret+=(dads[i].second-dads[i].first)/cm.getNumberOfNodes();
+            }
+        }
+      else
+        {
+          int nbOfGaussPtPerCell=glob->getNbOfGaussPtPerCell(locs[i]);
+          ret+=(dads[i].second-dads[i].first)/nbOfGaussPtPerCell;
+        }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldPerMesh::getPflsReallyUsed() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getPflsReallyUsed();
+      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
+        if(ret2.find(*it2)==ret2.end())
+          {
+            ret.push_back(*it2);
+            ret2.insert(*it2);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldPerMesh::getPflsReallyUsedMulti() const
+{
+  std::vector<std::string> ret;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getPflsReallyUsedMulti();
+      ret.insert(ret.end(),tmp.begin(),tmp.end());
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldPerMesh::getLocsReallyUsed() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getLocsReallyUsed();
+      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
+        if(ret2.find(*it2)==ret2.end())
+          {
+            ret.push_back(*it2);
+            ret2.insert(*it2);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileFieldPerMesh::getLocsReallyUsedMulti() const
+{
+  std::vector<std::string> ret;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getLocsReallyUsedMulti();
+      ret.insert(ret.end(),tmp.begin(),tmp.end());
+    }
+  return ret;
+}
+
+bool MEDFileFieldPerMesh::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
+{
+  for(std::vector< std::pair<std::string,std::string> >::const_iterator it=modifTab.begin();it!=modifTab.end();it++)
+    {
+      if((*it).first==getMeshName())
+        {
+          setMeshName((*it).second);
+          return true;
+        }
+    }
+  return false;
+}
+
+void MEDFileFieldPerMesh::convertMedBallIntoClassic()
+{
+  if(_field_pm_pt.size()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : Only managed for single mesh !");
+  if(_field_pm_pt[0].isNull())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : null pointer !");
+  MEDFileFieldPerMeshPerTypeDyn *pt(dynamic_cast<MEDFileFieldPerMeshPerTypeDyn *>((MEDFileFieldPerMeshPerTypeCommon *)_field_pm_pt[0]));
+  if(!pt)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : this is expected to be marked as structure element !");
+  if(pt->getNumberOfLoc()!=1)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : only one loc managed !");
+  const MEDFileFieldPerMeshPerTypePerDisc *disc(pt->getLeafGivenLocId(0));
+  if(!disc)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::convertMedBallIntoClassic : internal error !");
+  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> disc2(MEDFileFieldPerMeshPerTypePerDisc::New(*disc));
+  disc2->setType(ON_NODES);
+  MCAuto<MEDFileFieldPerMeshPerType> pt2(MEDFileFieldPerMeshPerType::New(this,INTERP_KERNEL::NORM_ERROR));
+  disc2->setFather(pt2);
+  pt2->setFather(this);
+  pt2->pushDiscretization(disc2);
+  _field_pm_pt[0]=DynamicCast<MEDFileFieldPerMeshPerType,MEDFileFieldPerMeshPerTypeCommon>(pt2);
+}
+
+bool MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N,
+                                                      MEDFileFieldGlobsReal& glob)
+{
+  if(getMeshName()!=meshName)
+    return false;
+  std::set<INTERP_KERNEL::NormalizedCellType> typesToKeep;
+  for(std::size_t i=0;i<oldCode.size()/3;i++) typesToKeep.insert((INTERP_KERNEL::NormalizedCellType)oldCode[3*i]);
+  std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > > entries;
+  std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> entriesKept;
+  std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> otherEntries;
+  getUndergroundDataArrayExt(entries);
+  DataArray *arr0(getOrCreateAndGetArray());//tony
+  if(!arr0)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh : DataArray storing values of field is null !");
+  DataArrayDouble *arr(dynamic_cast<DataArrayDouble *>(arr0));//tony
+  if(!arr0)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh : DataArray storing values is double ! Not managed for the moment !");
+  int sz=0;
+  if(!arr)
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::renumberEntitiesLyingOnMesh : DataArrayDouble storing values of field is null !");
+  for(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >::const_iterator it=entries.begin();it!=entries.end();it++)
+    {
+      if(typesToKeep.find((*it).first.first)!=typesToKeep.end())
+        {
+          entriesKept.push_back(getLeafGivenTypeAndLocId((*it).first.first,(*it).first.second));
+          sz+=(*it).second.second-(*it).second.first;
+        }
+      else
+        otherEntries.push_back(getLeafGivenTypeAndLocId((*it).first.first,(*it).first.second));
+    }
+  MCAuto<DataArrayInt> renumDefrag=DataArrayInt::New(); renumDefrag->alloc(arr->getNumberOfTuples(),1); renumDefrag->fillWithZero();
+  ////////////////////
+  MCAuto<DataArrayInt> explicitIdsOldInMesh=DataArrayInt::New(); explicitIdsOldInMesh->alloc(sz,1);//sz is a majorant of the real size. A realloc will be done after
+  int *workI2=explicitIdsOldInMesh->getPointer();
+  int sz1=0,sz2=0,sid=1;
+  std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > entriesKeptML=MEDFileFieldPerMeshPerTypePerDisc::SplitPerDiscretization(entriesKept);
+  // std::vector<int> tupleIdOfStartOfNewChuncksV(entriesKeptML.size());
+  for(std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator itL1=entriesKeptML.begin();itL1!=entriesKeptML.end();itL1++,sid++)
+    {
+      //  tupleIdOfStartOfNewChuncksV[sid-1]=sz2;
+      MCAuto<DataArrayInt> explicitIdsOldInArr=DataArrayInt::New(); explicitIdsOldInArr->alloc(sz,1);
+      int *workI=explicitIdsOldInArr->getPointer();
+      for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator itL2=(*itL1).begin();itL2!=(*itL1).end();itL2++)
+        {
+          int delta1=(*itL2)->fillTupleIds(workI); workI+=delta1; sz1+=delta1;
+          (*itL2)->setLocId(sz2);
+          (*itL2)->_tmp_work1=(*itL2)->getStart();
+          int delta2=(*itL2)->fillEltIdsFromCode(sz2,oldCode,glob,workI2); workI2+=delta2; sz2+=delta2;
+        }
+      renumDefrag->setPartOfValuesSimple3(sid,explicitIdsOldInArr->begin(),explicitIdsOldInArr->end(),0,1,1);
+    }
+  explicitIdsOldInMesh->reAlloc(sz2);
+  int tupleIdOfStartOfNewChuncks=arr->getNumberOfTuples()-sz2;
+  ////////////////////
+  MCAuto<DataArrayInt> permArrDefrag=renumDefrag->buildPermArrPerLevel(); renumDefrag=0;
+  // perform redispatching of non concerned MEDFileFieldPerMeshPerTypePerDisc
+  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > otherEntriesNew;
+  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=otherEntries.begin();it!=otherEntries.end();it++)
+    {
+      otherEntriesNew.push_back(MEDFileFieldPerMeshPerTypePerDisc::New(*(*it)));
+      otherEntriesNew.back()->setNewStart(permArrDefrag->getIJ((*it)->getStart(),0));
+      otherEntriesNew.back()->setLocId((*it)->getGeoType());
+    }
+  std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > entriesKeptNew;
+  std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> entriesKeptNew2;
+  for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator it=entriesKept.begin();it!=entriesKept.end();it++)
+    {
+      MCAuto<MEDFileFieldPerMeshPerTypePerDisc> elt=MEDFileFieldPerMeshPerTypePerDisc::New(*(*it));
+      int newStart=elt->getLocId();
+      elt->setLocId((*it)->getGeoType());
+      elt->setNewStart(newStart);
+      elt->_tmp_work1=permArrDefrag->getIJ(elt->_tmp_work1,0);
+      entriesKeptNew.push_back(elt);
+      entriesKeptNew2.push_back(elt);
+    }
+  MCAuto<DataArrayDouble> arr2=arr->renumber(permArrDefrag->getConstPointer());
+  // perform redispatching of concerned MEDFileFieldPerMeshPerTypePerDisc -> values are in arr2
+  MCAuto<DataArrayInt> explicitIdsNewInMesh=renumO2N->selectByTupleId(explicitIdsOldInMesh->begin(),explicitIdsOldInMesh->end());
+  std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > entriesKeptPerDisc=MEDFileFieldPerMeshPerTypePerDisc::SplitPerDiscretization(entriesKeptNew2);
+  bool ret=false;
+  for(std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator it4=entriesKeptPerDisc.begin();it4!=entriesKeptPerDisc.end();it4++)
+    {
+      sid=0;
+      /*for(std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>::const_iterator itL2=(*it4).begin();itL2!=(*it4).end();itL2++)
+        {
+          MEDFileFieldPerMeshPerTypePerDisc *curNC=const_cast<MEDFileFieldPerMeshPerTypePerDisc *>(*itL2);
+          curNC->setNewStart(permArrDefrag->getIJ((*itL2)->getStart(),0)-tupleIdOfStartOfNewChuncks+tupleIdOfStartOfNewChuncksV[sid]);
+          }*/
+      ret=MEDFileFieldPerMeshPerTypePerDisc::RenumberChunks(tupleIdOfStartOfNewChuncks,*it4,explicitIdsNewInMesh,newCode,
+                                                            glob,arr2,otherEntriesNew) || ret;
+    }
+  if(!ret)
+    return false;
+  // Assign new dispatching
+  assignNewLeaves(otherEntriesNew);
+  arr->deepCopyFrom(*arr2);
+  return true;
+}
+
+/*!
+ * \param [in,out] globalNum a global numbering counter for the renumbering.
+ * \param [out] its - list of pair (start,stop) kept
+ */
+void MEDFileFieldPerMesh::keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its)
+{
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > ret;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      std::vector< std::pair<int,int> > its2;
+      if((*it)->keepOnlySpatialDiscretization(tof,globalNum,its2))
+        {
+          ret.push_back(*it);
+          its.insert(its.end(),its2.begin(),its2.end());
+        }
+    }
+  _field_pm_pt=ret;
+}
+
+/*!
+ * \param [in,out] globalNum a global numbering counter for the renumbering.
+ * \param [out] its - list of pair (start,stop) kept
+ */
+void MEDFileFieldPerMesh::keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its)
+{
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > ret;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      std::vector< std::pair<int,int> > its2;
+      if((*it)->keepOnlyGaussDiscretization(idOfDisc,globalNum,its2))
+        {
+          ret.push_back(*it);
+          its.insert(its.end(),its2.begin(),its2.end());
+        }
+    }
+  _field_pm_pt=ret;
+}
+
+void MEDFileFieldPerMesh::assignNewLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves)
+{
+  std::map<INTERP_KERNEL::NormalizedCellType,std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc> > > types;
+  for( std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >::const_iterator it=leaves.begin();it!=leaves.end();it++)
+    types[(INTERP_KERNEL::NormalizedCellType)(*it)->getLocId()].push_back(*it);
+  //
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > fieldPmPt(types.size());
+  std::map<INTERP_KERNEL::NormalizedCellType,std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc> > >::const_iterator it1=types.begin();
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it2=fieldPmPt.begin();
+  for(;it1!=types.end();it1++,it2++)
+    {
+      MCAuto<MEDFileFieldPerMeshPerType> elt=MEDFileFieldPerMeshPerType::New(this,(INTERP_KERNEL::NormalizedCellType)((*it1).second[0]->getLocId()));
+      elt->setLeaves((*it1).second);
+      MCAuto<MEDFileFieldPerMeshPerTypeCommon> elt2(DynamicCast<MEDFileFieldPerMeshPerType,MEDFileFieldPerMeshPerTypeCommon>(elt));
+      *it2=elt2;
+    }
+  _field_pm_pt=fieldPmPt;
+}
+
+void MEDFileFieldPerMesh::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->changePflsRefsNamesGen(mapOfModif);
+}
+
+void MEDFileFieldPerMesh::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->changeLocsRefsNamesGen(mapOfModif);
+}
+
+/*!
+ * \param [in] mesh is the whole mesh
+ */
+MEDCouplingFieldDouble *MEDFileFieldPerMesh::getFieldOnMeshAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  if(_field_pm_pt.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : no types field set !");
+  //
+  std::vector< std::pair<int,int> > dads;
+  std::vector<const DataArrayInt *> pfls;
+  std::vector<DataArrayInt *> notNullPflsPerGeoType;
+  std::vector<int> locs,code;
+  std::vector<INTERP_KERNEL::NormalizedCellType> geoTypes;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->getFieldAtLevel(mesh->getMeshDimension(),type,glob,dads,pfls,locs,geoTypes);
+  // Sort by types
+  SortArraysPerType(glob,type,geoTypes,dads,pfls,locs,code,notNullPflsPerGeoType);
+  if(code.empty())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevel : " << "The field \"" << nasc.getName() << "\" exists but not with such spatial discretization or such dimension specified !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  //
+  std::vector< MCAuto<DataArrayInt> > notNullPflsPerGeoType2(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
+  std::vector< const DataArrayInt *> notNullPflsPerGeoType3(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
+  if(type!=ON_NODES)
+    {
+      DataArrayInt *arr=mesh->checkTypeConsistencyAndContig(code,notNullPflsPerGeoType3);
+      if(!arr)
+        return finishField(type,glob,dads,locs,mesh,isPfl,arrOut,nasc);
+      else
+        {
+          MCAuto<DataArrayInt> arr2(arr);
+          return finishField2(type,glob,dads,locs,geoTypes,mesh,arr,isPfl,arrOut,nasc);
+        }
+    }
+  else
+    {
+      if(code.size()!=3)
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : internal error #1 !");
+      int nb=code[1];
+      if(code[2]==-1)
+        {
+          if(nb!=mesh->getNumberOfNodes())
+            {
+              std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevel : There is a problem there is " << nb << " nodes in field whereas there is " << mesh->getNumberOfNodes();
+              oss << " nodes in mesh !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+          return finishField(type,glob,dads,locs,mesh,isPfl,arrOut,nasc);
+        }
+      else
+        return finishFieldNode2(glob,dads,locs,mesh,notNullPflsPerGeoType3[0],isPfl,arrOut,nasc);
+    }
+}
+
+DataArray *MEDFileFieldPerMesh::getFieldOnMeshAtLevelWithPfl(TypeOfField type, const MEDCouplingMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const
+{
+  if(_field_pm_pt.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : no types field set !");
+  //
+  std::vector<std::pair<int,int> > dads;
+  std::vector<const DataArrayInt *> pfls;
+  std::vector<DataArrayInt *> notNullPflsPerGeoType;
+  std::vector<int> locs,code;
+  std::vector<INTERP_KERNEL::NormalizedCellType> geoTypes;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    (*it)->getFieldAtLevel(mesh->getMeshDimension(),type,glob,dads,pfls,locs,geoTypes);
+  // Sort by types
+  SortArraysPerType(glob,type,geoTypes,dads,pfls,locs,code,notNullPflsPerGeoType);
+  if(code.empty())
+    {
+      std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevelWithPfl : " << "The field \"" << nasc.getName() << "\" exists but not with such spatial discretization or such dimension specified !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  std::vector< MCAuto<DataArrayInt> > notNullPflsPerGeoType2(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
+  std::vector< const DataArrayInt *> notNullPflsPerGeoType3(notNullPflsPerGeoType.begin(),notNullPflsPerGeoType.end());
+  if(type!=ON_NODES)
+    {
+      MCAuto<DataArrayInt> arr=mesh->checkTypeConsistencyAndContig(code,notNullPflsPerGeoType3);
+      return finishField4(dads,arr,mesh->getNumberOfCells(),pfl);
+    }
+  else
+    {
+      if(code.size()!=3)
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::getFieldOnMeshAtLevel : internal error #1 !");
+      int nb=code[1];
+      if(code[2]==-1)
+        {
+          if(nb!=mesh->getNumberOfNodes())
+            {
+              std::ostringstream oss; oss << "MEDFileFieldPerMesh::getFieldOnMeshAtLevel : There is a problem there is " << nb << " nodes in field whereas there is " << mesh->getNumberOfNodes();
+              oss << " nodes in mesh !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+        }
+      return finishField4(dads,code[2]==-1?0:notNullPflsPerGeoType3[0],mesh->getNumberOfNodes(),pfl);
+    }
+  //
+  return 0;
+}
+
+void MEDFileFieldPerMesh::accept(MEDFileFieldVisitor& visitor) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    if((*it).isNotNull())
+      {
+        visitor.newPerMeshPerTypeEntry(*it);
+        (*it)->accept(visitor);
+        visitor.endPerMeshPerTypeEntry(*it);
+      }
+}
+
+void MEDFileFieldPerMesh::getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  int globalSz=0;
+  int nbOfEntries=0;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      (*it)->getSizes(globalSz,nbOfEntries);
+    }
+  entries.resize(nbOfEntries);
+  nbOfEntries=0;
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      (*it)->fillValues(nbOfEntries,entries);
+    }
+}
+
+MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMesh::getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId)
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      if((*it)->getGeoType()==typ)
+        return (*it)->getLeafGivenLocId(locId);
+    }
+  const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(typ);
+  std::ostringstream oss; oss << "MEDFileFieldPerMesh::getLeafGivenTypeAndLocId : no such geometric type \"" << cm.getRepr() << "\" in this !" << std::endl;
+  oss << "Possibilities are : ";
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      const INTERP_KERNEL::CellModel& cm2=INTERP_KERNEL::CellModel::GetCellModel((*it)->getGeoType());
+      oss << "\"" << cm2.getRepr() << "\", ";
+    }
+  throw INTERP_KERNEL::Exception(oss.str());
+}
+
+const MEDFileFieldPerMeshPerTypePerDisc *MEDFileFieldPerMesh::getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId) const
+{
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      if((*it)->getGeoType()==typ)
+        return (*it)->getLeafGivenLocId(locId);
+    }
+  const INTERP_KERNEL::CellModel& cm=INTERP_KERNEL::CellModel::GetCellModel(typ);
+  std::ostringstream oss; oss << "MEDFileFieldPerMesh::getLeafGivenTypeAndLocId : no such geometric type \"" << cm.getRepr() << "\" in this !" << std::endl;
+  oss << "Possibilities are : ";
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++)
+    {
+      const INTERP_KERNEL::CellModel& cm2=INTERP_KERNEL::CellModel::GetCellModel((*it)->getGeoType());
+      oss << "\"" << cm2.getRepr() << "\", ";
+    }
+  throw INTERP_KERNEL::Exception(oss.str());
+}
+
+/*!
+ * \param [in,out] start - Integer that gives the current position in the final aggregated array
+ * \param [in] pms - list of elements to aggregate. integer gives the mesh id 
+ * \param [in] dts - (Distribution of types) = level 1 : meshes to aggregate. Level 2 : all geo type. Level 3 pair specifying geo type and number of elem in geotype.
+ * \param [out] extractInfo - Gives information about the where the data comes from. It is a vector of triplet. First element in the triplet the mesh pos. The 2nd one the start pos. The 3rd the end pos.
+ */
+MCAuto<MEDFileFieldPerMeshPerTypePerDisc> MEDFileFieldPerMeshPerTypePerDisc::Aggregate(int &start, const std::vector< std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, TypeOfField tof, MEDFileFieldPerMeshPerType *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo)
+{
+  MCAuto<MEDFileFieldPerMeshPerTypePerDisc> ret(new MEDFileFieldPerMeshPerTypePerDisc(father,tof));
+  if(pms.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : empty input vector !");
+  for(std::vector<std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator it=pms.begin();it!=pms.end();it++)
+    {
+      if(!(*it).second)
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : presence of null pointer !");
+      if(!(*it).second->getProfile().empty())
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for profiles !");
+      if(!(*it).second->getLocalization().empty())
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for gauss pts !");
+    }
+  INTERP_KERNEL::NormalizedCellType gt(pms[0].second->getGeoType());
+  std::size_t i(0);
+  std::vector< std::pair<int,int> > filteredDTS;
+  for(std::vector< std::vector< std::pair<int,int> > >::const_iterator it=dts.begin();it!=dts.end();it++,i++)
+    for(std::vector< std::pair<int,int> >::const_iterator it2=(*it).begin();it2!=(*it).end();it2++)
+      if((*it2).first==gt)
+        filteredDTS.push_back(std::pair<int,int>(i,(*it2).second));
+  if(pms.size()!=filteredDTS.size())
+    throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for generated profiles !");
+  std::vector<std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >::const_iterator it1(pms.begin());
+  std::vector< std::pair<int,int> >::const_iterator it2(filteredDTS.begin());
+  int zeStart(start),nval(0);
+  for(;it1!=pms.end();it1++,it2++)
+    {
+      if((*it1).first!=(*it2).first)
+        throw INTERP_KERNEL::Exception("MEDFileFieldPerMeshPerTypePerDisc::Aggregate : not implemented yet for generated profiles 2 !");
+      int s1((*it1).second->getStart()),e1((*it1).second->getEnd());
+      extractInfo.push_back(std::pair<int, std::pair<int,int> >((*it1).first,std::pair<int,int>(s1,e1)));
+      start+=e1-s1;
+      nval+=((*it1).second)->getNumberOfVals();
+    }
+  ret->_start=zeStart; ret->_end=start; ret->_nval=nval;
+  return ret;
+}
+
+MCAuto<MEDFileFieldPerMesh> MEDFileFieldPerMesh::Aggregate(int &start, const std::vector<const MEDFileFieldPerMesh *>& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, MEDFileAnyTypeField1TSWithoutSDA *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo)
+{
+  MCAuto<MEDFileFieldPerMesh> ret(new MEDFileFieldPerMesh(father,pms[0]->getMeshName(),pms[0]->getMeshIteration(),pms[0]->getMeshOrder()));
+  std::map<INTERP_KERNEL::NormalizedCellType, std::vector< std::pair<int,const MEDFileFieldPerMeshPerType *> > > m;
+  std::size_t i(0);
+  for(std::vector<const MEDFileFieldPerMesh *>::const_iterator it=pms.begin();it!=pms.end();it++,i++)
+    {
+      const std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >& v((*it)->_field_pm_pt);
+      for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::const_iterator it2=v.begin();it2!=v.end();it2++)
+        {
+          INTERP_KERNEL::NormalizedCellType gt((*it2)->getGeoType());
+          const MEDFileFieldPerMeshPerType *elt(dynamic_cast<const MEDFileFieldPerMeshPerType *>((const MEDFileFieldPerMeshPerTypeCommon *)(*it2)));
+          if(!elt)
+            throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::Aggregate : not managed for structelement !");
+          m[gt].push_back(std::pair<int,const MEDFileFieldPerMeshPerType *>(i,elt));
+        }
+    }
+  for(std::map<INTERP_KERNEL::NormalizedCellType, std::vector< std::pair<int,const MEDFileFieldPerMeshPerType *> > >::const_iterator it=m.begin();it!=m.end();it++)
+    {
+      MCAuto<MEDFileFieldPerMeshPerType> agg(MEDFileFieldPerMeshPerType::Aggregate(start,(*it).second,dts,(*it).first,ret,extractInfo));
+      MCAuto<MEDFileFieldPerMeshPerTypeCommon> agg2(DynamicCast<MEDFileFieldPerMeshPerType,MEDFileFieldPerMeshPerTypeCommon>(agg));
+      ret->_field_pm_pt.push_back(agg2);
+    }
+  return ret;
+}
+
+int MEDFileFieldPerMesh::addNewEntryIfNecessary(INTERP_KERNEL::NormalizedCellType type)
+{
+  int i=0;
+  int pos=std::distance(typmai2,std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,type));
+  std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it2=_field_pm_pt.begin();
+  for(std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > >::iterator it=_field_pm_pt.begin();it!=_field_pm_pt.end();it++,i++)
+    {
+      INTERP_KERNEL::NormalizedCellType curType=(*it)->getGeoType();
+      if(type==curType)
+        return i;
+      else
+        {
+          int pos2=std::distance(typmai2,std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,curType));
+          if(pos>pos2)
+            it2=it+1;
+        }
+    }
+  int ret=std::distance(_field_pm_pt.begin(),it2);
+  _field_pm_pt.insert(it2,MEDFileFieldPerMeshPerType::New(this,type));
+  return ret;
+}
+
+/*!
+ * 'dads' and 'locs' input parameters have the same number of elements
+ * \param [in] mesh is \b NOT the global mesh, but the possibly reduced mesh. \a mesh parameter will be directly aggregated in the returned field
+ */
+MEDCouplingFieldDouble *MEDFileFieldPerMesh::finishField(TypeOfField type, const MEDFileFieldGlobsReal *glob,
+                                                         const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs,
+                                                         const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  isPfl=false;
+  MCAuto<MEDCouplingFieldDouble> ret=MEDCouplingFieldDouble::New(type,ONE_TIME);
+  ret->setMesh(mesh); ret->setName(nasc.getName().c_str()); ret->setTime(getTime(),getIteration(),getOrder()); ret->setTimeUnit(nasc.getDtUnit().c_str());
+  MCAuto<DataArray> da=getOrCreateAndGetArray()->selectByTupleRanges(dads);
+  const std::vector<std::string>& infos=getInfo();
+  da->setInfoOnComponents(infos);
+  da->setName("");
+  if(type==ON_GAUSS_PT)
+    {
+      int offset=0;
+      int nbOfArrs=dads.size();
+      for(int i=0;i<nbOfArrs;i++)
+        {
+          std::vector<std::pair<int,int> > dads2(1,dads[i]); const std::vector<int> locs2(1,locs[i]);
+          const std::vector<INTERP_KERNEL::NormalizedCellType> geoTypes2(1,INTERP_KERNEL::NORM_ERROR);
+          int nbOfElems=ComputeNbOfElems(glob,type,geoTypes2,dads2,locs2);
+          MCAuto<DataArrayInt> di=DataArrayInt::New();
+          di->alloc(nbOfElems,1);
+          di->iota(offset);
+          const MEDFileFieldLoc& fl=glob->getLocalizationFromId(locs[i]);
+          ret->setGaussLocalizationOnCells(di->getConstPointer(),di->getConstPointer()+nbOfElems,fl.getRefCoords(),fl.getGaussCoords(),fl.getGaussWeights());
+          offset+=nbOfElems;
+        }
+    }
+  arrOut=da;
+  return ret.retn();
+}
+
+/*!
+ * This method is an extension of MEDFileFieldPerMesh::finishField method. It deals with profiles. This method should be called when type is different from ON_NODES.
+ * 'dads', 'locs' and 'geoTypes' input parameters have the same number of elements.
+ * No check of this is performed. 'da' array contains an array in old2New style to be applyied to mesh to obtain the right support.
+ * The order of cells in the returned field is those imposed by the profile.
+ * \param [in] mesh is the global mesh.
+ */
+MEDCouplingFieldDouble *MEDFileFieldPerMesh::finishField2(TypeOfField type, const MEDFileFieldGlobsReal *glob,
+                                                          const std::vector<std::pair<int,int> >& dads, const std::vector<int>& locs,
+                                                          const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes,
+                                                          const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  if(da->isIota(mesh->getNumberOfCells()))
+    return finishField(type,glob,dads,locs,mesh,isPfl,arrOut,nasc);
+  MCAuto<MEDCouplingMesh> m2=mesh->buildPart(da->getConstPointer(),da->getConstPointer()+da->getNbOfElems());
+  m2->setName(mesh->getName().c_str());
+  MCAuto<MEDCouplingFieldDouble> ret=finishField(type,glob,dads,locs,m2,isPfl,arrOut,nasc);
+  isPfl=true;
+  return ret.retn();
+}
+
+/*!
+ * This method is the complement of MEDFileFieldPerMesh::finishField2 method except that this method works for node profiles.
+ */
+MEDCouplingFieldDouble *MEDFileFieldPerMesh::finishFieldNode2(const MEDFileFieldGlobsReal *glob,
+                                                              const std::vector<std::pair<int,int> >& dads, const std::vector<int>& locs,
+                                                              const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray>& arrOut, const MEDFileFieldNameScope& nasc) const
+{
+  if(da->isIota(mesh->getNumberOfNodes()))
+    return finishField(ON_NODES,glob,dads,locs,mesh,isPfl,arrOut,nasc);
+  // Treatment of particular case where nodal field on pfl is requested with a meshDimRelToMax=1.
+  const MEDCouplingUMesh *meshu=dynamic_cast<const MEDCouplingUMesh *>(mesh);
+  if(meshu)
+    {
+      if(meshu->getNodalConnectivity()==0)
+        {
+          MCAuto<MEDCouplingFieldDouble> ret=finishField(ON_CELLS,glob,dads,locs,mesh,isPfl,arrOut,nasc);
+          int nb=da->getNbOfElems();
+          const int *ptr=da->getConstPointer();
+          MEDCouplingUMesh *meshuc=const_cast<MEDCouplingUMesh *>(meshu);
+          meshuc->allocateCells(nb);
+          for(int i=0;i<nb;i++)
+            meshuc->insertNextCell(INTERP_KERNEL::NORM_POINT1,1,ptr+i);
+          meshuc->finishInsertingCells();
+          ret->setMesh(meshuc);
+          const MEDCouplingFieldDiscretization *disc=ret->getDiscretization();
+          if(!disc) throw INTERP_KERNEL::Exception("MEDFileFieldPerMesh::finishFieldNode2 : internal error, no discretization on field !");
+          disc->checkCoherencyBetween(meshuc,arrOut);
+          return ret.retn();
+        }
+    }
+  //
+  MCAuto<MEDCouplingFieldDouble> ret=finishField(ON_NODES,glob,dads,locs,mesh,isPfl,arrOut,nasc);
+  isPfl=true;
+  DataArrayInt *arr2=0;
+  MCAuto<DataArrayInt> cellIds=mesh->getCellIdsFullyIncludedInNodeIds(da->getConstPointer(),da->getConstPointer()+da->getNbOfElems());
+  MCAuto<MEDCouplingMesh> mesh2=mesh->buildPartAndReduceNodes(cellIds->getConstPointer(),cellIds->getConstPointer()+cellIds->getNbOfElems(),arr2);
+  MCAuto<DataArrayInt> arr3(arr2);
+  int nnodes=mesh2->getNumberOfNodes();
+  if(nnodes==(int)da->getNbOfElems())
+    {
+      MCAuto<DataArrayInt> da3=da->transformWithIndArrR(arr2->begin(),arr2->end());
+      arrOut->renumberInPlace(da3->getConstPointer());
+      mesh2->setName(mesh->getName().c_str());
+      ret->setMesh(mesh2);
+      return ret.retn();
+    }
+  else
+    {
+      std::ostringstream oss; oss << "MEDFileFieldPerMesh::finishFieldNode2 : The field on nodes lies on a node profile so that it is impossible to find a submesh having exactly the same nodes of that profile !!!";
+      oss << "So it is impossible to return a well definied MEDCouplingFieldDouble instance on specified mesh on a specified meshDim !" << std::endl;
+      oss << "To retrieve correctly such a field you have 3 possibilities :" << std::endl;
+      oss << " - use an another meshDim compatible with the field on nodes (MED file does not have such information)" << std::endl;
+      oss << " - use an another a meshDimRelToMax equal to 1 -> it will return a mesh with artificial cell POINT1 containing the profile !" << std::endl;
+      oss << " - if definitely the node profile has no link with mesh connectivity use MEDFileField1TS::getFieldWithProfile or MEDFileFieldMultiTS::getFieldWithProfile methods instead !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  return 0;
+}
+
+/*!
+ * This method is the most light method of field retrieving.
+ */
+DataArray *MEDFileFieldPerMesh::finishField4(const std::vector<std::pair<int,int> >& dads, const DataArrayInt *pflIn, int nbOfElems, DataArrayInt *&pflOut) const
+{
+  if(!pflIn)
+    {
+      pflOut=DataArrayInt::New();
+      pflOut->alloc(nbOfElems,1);
+      pflOut->iota(0);
+    }
+  else
+    {
+      pflOut=const_cast<DataArrayInt*>(pflIn);
+      pflOut->incrRef();
+    }
+  MCAuto<DataArrayInt> safePfl(pflOut);
+  MCAuto<DataArray> da=getOrCreateAndGetArray()->selectByTupleRanges(dads);
+  const std::vector<std::string>& infos=getInfo();
+  int nbOfComp=infos.size();
+  for(int i=0;i<nbOfComp;i++)
+    da->setInfoOnComponent(i,infos[i].c_str());
+  safePfl->incrRef();
+  return da.retn();
+}
+
+
+/// @cond INTERNAL
+
+class MFFPMIter
+{
+public:
+  static MFFPMIter *NewCell(const MEDFileEntities *entities);
+  static bool IsPresenceOfNode(const MEDFileEntities *entities);
+  virtual ~MFFPMIter() { }
+  virtual void begin() = 0;
+  virtual bool finished() const = 0;
+  virtual void next() = 0;
+  virtual int current() const = 0;
+};
+
+class MFFPMIterSimple : public MFFPMIter
+{
+public:
+  MFFPMIterSimple():_pos(0) { }
+  void begin() { _pos=0; }
+  bool finished() const { return _pos>=MED_N_CELL_FIXED_GEO; }
+  void next() { _pos++; }
+  int current() const { return _pos; }
+private:
+  int _pos;
+};
+
+class MFFPMIter2 : public MFFPMIter
+{
+public:
+  MFFPMIter2(const std::vector<INTERP_KERNEL::NormalizedCellType>& cts);
+  void begin() { _it=_ids.begin(); }
+  bool finished() const { return _it==_ids.end(); }
+  void next() { _it++; }
+  int current() const { return *_it; }
+private:
+  std::vector<int> _ids;
+  std::vector<int>::const_iterator _it;
+};
+
+MFFPMIter *MFFPMIter::NewCell(const MEDFileEntities *entities)
+{
+  if(!entities)
+    return new MFFPMIterSimple;
+  else
+    {
+      const MEDFileStaticEntities *entities2(dynamic_cast<const MEDFileStaticEntities *>(entities));
+      if(entities2)
+        {
+          std::vector<INTERP_KERNEL::NormalizedCellType> tmp;
+          const std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >& myEnt(entities2->getEntries());
+          for(std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >::const_iterator it=myEnt.begin();it!=myEnt.end();it++)
+            {
+              if((*it).first==ON_CELLS || (*it).first==ON_GAUSS_NE || (*it).first==ON_GAUSS_PT)
+                tmp.push_back((*it).second);
+            }
+          return new MFFPMIter2(tmp);
+        }
+      return new MFFPMIterSimple;// for MEDFileAllStaticEntites and MEDFileAllStaticEntitiesPlusDyn cells are in
+    }
+}
+
+bool MFFPMIter::IsPresenceOfNode(const MEDFileEntities *entities)
+{
+  if(!entities)
+    return true;
+  else
+    {
+      const MEDFileStaticEntities *entities2(dynamic_cast<const MEDFileStaticEntities *>(entities));
+      if(entities2)
+        {
+          const std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >& myEnt(entities2->getEntries());
+          for(std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >::const_iterator it=myEnt.begin();it!=myEnt.end();it++)
+            if((*it).first==ON_NODES)
+              return true;
+          return false;
+        }
+      return true;// for MEDFileAllStaticEntites and MEDFileAllStaticEntitiesPlusDyn nodes are in
+    }
+}
+
+MFFPMIter2::MFFPMIter2(const std::vector<INTERP_KERNEL::NormalizedCellType>& cts)
+{
+  std::size_t sz(cts.size());
+  _ids.resize(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      INTERP_KERNEL::NormalizedCellType *loc(std::find(typmai2,typmai2+MED_N_CELL_FIXED_GEO,cts[i]));
+      if(loc!=typmai2+MED_N_CELL_FIXED_GEO)
+        _ids[i]=(int)std::distance(typmai2,loc);
+      else
+        throw INTERP_KERNEL::Exception("MFFPMIter2 : The specified geo type does not exists !");
+    }
+}
+
+/// @endcond
+
+MEDFileFieldPerMesh::MEDFileFieldPerMesh(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities):_mesh_iteration(meshIteration),_mesh_order(meshOrder),
+    _father(fath)
+{
+  INTERP_KERNEL::AutoPtr<char> meshName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> pflName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  INTERP_KERNEL::AutoPtr<char> locName(MEDLoaderBase::buildEmptyString(MED_NAME_SIZE));
+  const MEDFileUMesh *mmu(dynamic_cast<const MEDFileUMesh *>(mm));
+  INTERP_KERNEL::AutoCppPtr<MFFPMIter> iter0(MFFPMIter::NewCell(entities));
+  for(iter0->begin();!iter0->finished();iter0->next())
+    {
+      int nbProfile (MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_CELL        ,typmai[iter0->current()],meshCsit+1,meshName,pflName,locName));
+      std::string name0(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE+1));
+      int nbProfile2(MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_NODE_ELEMENT,typmai[iter0->current()],meshCsit+1,meshName,pflName,locName));
+      std::string name1(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE+1));
+      if(nbProfile>0 || nbProfile2>0)
+        {
+          const PartDefinition *pd(0);
+          if(mmu)
+            pd=mmu->getPartDefAtLevel(mmu->getRelativeLevOnGeoType(typmai2[iter0->current()]),typmai2[iter0->current()]);
+          _field_pm_pt.push_back(MEDFileFieldPerMeshPerType::NewOnRead(fid,this,ON_CELLS,typmai2[iter0->current()],nasc,pd));
+          if(nbProfile>0)
+            setMeshName(name0);
+          else
+            setMeshName(name1);
+        }
+    }
+  if(MFFPMIter::IsPresenceOfNode(entities))
+    {
+      int nbProfile(MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_NODE,MED_NONE,meshCsit+1,meshName,pflName,locName));
+      if(nbProfile>0)
+        {
+          const PartDefinition *pd(0);
+          if(mmu)
+            pd=mmu->getPartDefAtLevel(1,INTERP_KERNEL::NORM_ERROR);
+          _field_pm_pt.push_back(MEDFileFieldPerMeshPerType::NewOnRead(fid,this,ON_NODES,INTERP_KERNEL::NORM_ERROR,nasc,pd));
+          setMeshName(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE));
+        }
+    }
+  if(!entities)
+    return ;
+  std::vector<int> dynGT(entities->getDynGTAvail());
+  for(std::vector<int>::const_iterator it=dynGT.begin();it!=dynGT.end();it++)
+    {
+      int nbPfl(MEDfieldnProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_STRUCT_ELEMENT,*it,pflName,locName));
+      if(nbPfl>0)
+        {
+          _field_pm_pt.push_back(MEDFileFieldPerMeshPerTypeDyn::NewOnRead(fid,this,entities,*it,nasc));
+          setMeshName(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE));
+        }
+    }
+  if(!_field_pm_pt.empty())
+    return;
+  //for vicious users using MED_ARETE MED_FACE in fields. the last try. For Others not overhead to pay.
+  iter0=MFFPMIter::NewCell(entities);
+  for(iter0->begin();!iter0->finished();iter0->next())
+    {
+      int nbProfile (MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_DESCENDING_FACE,typmai[iter0->current()],meshCsit+1,meshName,pflName,locName));
+      std::string name0(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE+1));
+      int nbProfile2(MEDfield23nProfile(fid,nasc.getName().c_str(),getIteration(),getOrder(),MED_DESCENDING_EDGE,typmai[iter0->current()],meshCsit+1,meshName,pflName,locName));
+      std::string name1(MEDLoaderBase::buildStringFromFortran(meshName,MED_NAME_SIZE+1));
+      if(nbProfile>0 || nbProfile2>0)
+        {
+          _field_pm_pt.push_back(MEDFileFieldPerMeshPerType::NewOnRead(fid,this,ON_CELLS,typmai2[iter0->current()],nasc,NULL));
+          if(nbProfile>0)
+            setMeshName(name0);
+          else
+            setMeshName(name1);
+        }
+    }
+}
+
+MEDFileFieldPerMesh::MEDFileFieldPerMesh(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh):_father(fath)
+{
+  copyTinyInfoFrom(mesh);
+}
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldInternal.hxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldInternal.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldInternal.hxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldInternal.hxx	2018-04-19 17:25:17.859799768 +0200
@@ -0,0 +1,416 @@
+// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#ifndef __MEDFILEFIELDINTERNAL_HXX__
+#define __MEDFILEFIELDINTERNAL_HXX__
+
+#include "MEDLoaderDefines.hxx"
+#include "MEDFileUtilities.hxx"
+#include "NormalizedGeometricTypes"
+#include "InterpKernelAutoPtr.hxx"
+#include "MCAuto.hxx"
+
+#include "med.h"
+
+#include <string>
+#include <list>
+
+namespace MEDCoupling
+{
+  class MEDFileGTKeeper
+  {
+  public:
+    virtual MEDFileGTKeeper *deepCopy() const = 0;
+    virtual INTERP_KERNEL::NormalizedCellType getGeoType() const = 0;
+    virtual std::string getRepr() const = 0;
+    virtual bool isEqual(const MEDFileGTKeeper *other) const = 0;
+    virtual ~MEDFileGTKeeper();
+  };
+
+  class MEDFileGTKeeperSta : public MEDFileGTKeeper
+  {
+  public:
+    MEDFileGTKeeperSta(INTERP_KERNEL::NormalizedCellType gt):_geo_type(gt) { }
+    MEDFileGTKeeper *deepCopy() const;
+    INTERP_KERNEL::NormalizedCellType getGeoType() const;
+    std::string getRepr() const;
+    bool isEqual(const MEDFileGTKeeper *other) const;
+  private:
+    INTERP_KERNEL::NormalizedCellType _geo_type;
+  };
+
+  
+  class MEDFileStructureElement;
+  class MEDFileUMesh;
+  
+  class MEDFileGTKeeperDyn : public MEDFileGTKeeper
+  {
+  public:
+    MEDFileGTKeeperDyn(const MEDFileUMesh *mesh, const MEDFileUMesh *section, const MEDFileStructureElement *se);
+    MEDFileGTKeeper *deepCopy() const;
+    INTERP_KERNEL::NormalizedCellType getGeoType() const;
+    std::string getRepr() const;
+    bool isEqual(const MEDFileGTKeeper *other) const;
+    const MEDFileUMesh *getMesh() const { return _mesh; }
+    const MEDFileUMesh *getSection() const { return _section; }
+    const MEDFileStructureElement *getSE() const { return _se; }
+  private:
+    MCConstAuto<MEDFileUMesh> _mesh;
+    MCConstAuto<MEDFileUMesh> _section;
+    MCConstAuto<MEDFileStructureElement> _se;
+  };
+
+  class MEDFileEntities;
+  
+  class MEDFileFieldLoc : public RefCountObject
+  {
+  public:
+    MEDLOADER_EXPORT void simpleRepr(std::ostream& oss) const;
+    MEDLOADER_EXPORT std::string getName() const { return _name; }
+    MEDLOADER_EXPORT void setName(const std::string& name);
+    static MEDFileFieldLoc *New(med_idt fid, const std::string& locName);
+    static MEDFileFieldLoc *New(med_idt fid, int i, const MEDFileEntities *entities);
+    static MEDFileFieldLoc *New(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
+    std::size_t getHeapMemorySizeWithoutChildren() const;
+    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDFileFieldLoc *deepCopy() const;
+    bool isOnStructureElement() const;
+    const MEDFileGTKeeper *getUndergroundGTKeeper() const { return _gt; }
+    MEDLOADER_EXPORT int getNbOfGaussPtPerCell() const { return _nb_gauss_pt; }
+    MEDLOADER_EXPORT void writeLL(med_idt fid) const;
+    MEDLOADER_EXPORT std::string repr() const;
+    MEDLOADER_EXPORT bool isName(const std::string& name) const { return _name==name; }
+    MEDLOADER_EXPORT int getDimension() const { return _dim; }
+    MEDLOADER_EXPORT int getNumberOfGaussPoints() const { return _nb_gauss_pt; }
+    MEDLOADER_EXPORT int getNumberOfPointsInCells() const { return _nb_node_per_cell; }
+    MEDLOADER_EXPORT const std::vector<double>& getRefCoords() const { return _ref_coo; }
+    MEDLOADER_EXPORT const std::vector<double>& getGaussCoords() const { return _gs_coo; }
+    MEDLOADER_EXPORT const std::vector<double>& getGaussWeights() const { return _w; }
+    MEDLOADER_EXPORT INTERP_KERNEL::NormalizedCellType getGeoType() const { return _gt->getGeoType(); }
+    MEDLOADER_EXPORT bool isEqual(const MEDFileFieldLoc& other, double eps) const;
+  private:
+    MEDFileFieldLoc(const MEDFileFieldLoc& other);
+    MEDFileFieldLoc(med_idt fid, const std::string& locName);
+    MEDFileFieldLoc(med_idt fid, int id, const MEDFileEntities *entities);
+    MEDFileFieldLoc(const std::string& locName, INTERP_KERNEL::NormalizedCellType geoType, const std::vector<double>& refCoo, const std::vector<double>& gsCoo, const std::vector<double>& w);
+  private:
+    int _dim;
+    int _nb_gauss_pt;
+    INTERP_KERNEL::AutoCppPtr<MEDFileGTKeeper> _gt;
+    int _nb_node_per_cell;
+    std::string _name;
+    std::vector<double> _ref_coo;
+    std::vector<double> _gs_coo;
+    std::vector<double> _w;
+  };
+
+  /// @cond INTERNAL
+  class MEDFileFieldPerMeshPerTypeCommon;
+  class MEDFileFieldPerMeshPerType;
+  class MEDCouplingFieldTemplate;
+  class MEDFileFieldNameScope;
+  class MEDFileFieldGlobsReal;
+  class MEDCouplingMesh;
+  
+  class MEDFileFieldPerMeshPerTypePerDisc : public RefCountObject, public MEDFileWritable
+  {
+  public:
+    static MEDFileFieldPerMeshPerTypePerDisc *NewOnRead(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const PartDefinition *pd);
+    static MEDFileFieldPerMeshPerTypePerDisc *New(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int locId);
+    static MEDFileFieldPerMeshPerTypePerDisc *New(const MEDFileFieldPerMeshPerTypePerDisc& other);
+    std::size_t getHeapMemorySizeWithoutChildren() const;
+    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDFileFieldPerMeshPerTypePerDisc *deepCopy(MEDFileFieldPerMeshPerTypeCommon *father) const;
+    void assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    void assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arrr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    void assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arrr, MEDFileFieldGlobsReal& glob);
+    void getCoarseData(TypeOfField& type, std::pair<int,int>& dad, std::string& pfl, std::string& loc) const;
+    void writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const;
+    const MEDFileFieldPerMeshPerTypeCommon *getFather() const;
+    void loadOnlyStructureOfDataRecursively(med_idt fid, int& start, const MEDFileFieldNameScope& nasc);
+    void loadBigArray(med_idt fid, const MEDFileFieldNameScope& nasc);
+    void setNewStart(int newValueOfStart);
+    int getIteration() const;
+    int getOrder() const;
+    double getTime() const;
+    std::string getMeshName() const;
+    TypeOfField getType() const;
+    void simpleRepr(int bkOffset, std::ostream& oss, int id) const;
+    void fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const;
+    void setType(TypeOfField newType);
+    INTERP_KERNEL::NormalizedCellType getGeoType() const;
+    int getNumberOfComponents() const;
+    int getNumberOfTuples() const;
+    int getStart() const { return _start; }
+    int getEnd() const { return _end; }
+    void setEnd(int endd) { _end=endd; }
+    int getNumberOfVals() const { return _nval; }
+    void incrementNbOfVals(int deltaNbVal);
+    DataArray *getOrCreateAndGetArray();
+    const DataArray *getOrCreateAndGetArray() const;
+    const std::vector<std::string>& getInfo() const;
+    std::string getProfile() const;
+    void setProfile(const std::string& newPflName);
+    std::string getLocalization() const;
+    void setLocalization(const std::string& newLocName);
+    int getLocId() const { return _loc_id; }
+    void setLocId(int newId) const { _loc_id=newId; }
+    void setFather(MEDFileFieldPerMeshPerTypeCommon *newFather) { _father=newFather; }
+    void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    void getFieldAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs,
+                         std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const;
+    void fillValues(int discId, int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    int fillEltIdsFromCode(int offset, const std::vector<int>& codeOfMesh, const MEDFileFieldGlobsReal& glob, int *ptToFill) const;
+    int fillTupleIds(int *ptToFill) const;
+    static int ConvertType(TypeOfField type, int locId);
+    static std::vector< std::vector< const MEDFileFieldPerMeshPerTypePerDisc *> > SplitPerDiscretization(const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entries);
+    static bool RenumberChunks(int offset, const std::vector< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
+                               const DataArrayInt *explicitIdsInMesh, const std::vector<int>& newCode,
+                               MEDFileFieldGlobsReal& glob, DataArrayDouble *arr, std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> >& result);
+    static MEDFileFieldPerMeshPerTypePerDisc *NewObjectOnSameDiscThanPool(TypeOfField typeF, INTERP_KERNEL::NormalizedCellType geoType, DataArrayInt *idsOfMeshElt,
+                                                                          bool isPfl, int nbi, int offset, std::list< const MEDFileFieldPerMeshPerTypePerDisc *>& entriesOnSameDisc,
+                                                                          MEDFileFieldGlobsReal& glob, bool &notInExisting);
+    static MCAuto<MEDFileFieldPerMeshPerTypePerDisc> Aggregate(int &start, const std::vector<std::pair<int,const MEDFileFieldPerMeshPerTypePerDisc *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, TypeOfField tof, MEDFileFieldPerMeshPerType *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo);
+    MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type):_type(type),_father(fath),_start(-1),_end(-1),_nval(-1),_loc_id(-5),_profile_it(-1) { }
+  private:
+    MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const PartDefinition *pd);
+    MEDFileFieldPerMeshPerTypePerDisc(MEDFileFieldPerMeshPerTypeCommon *fath, TypeOfField type, int profileIt, const std::string& dummy);
+    MEDFileFieldPerMeshPerTypePerDisc(const MEDFileFieldPerMeshPerTypePerDisc& other);
+    MEDFileFieldPerMeshPerTypePerDisc();
+  private:
+    void goReadZeValuesInFile(med_idt fid, const std::string& fieldName, int nbOfCompo, int iteration, int order, med_entity_type menti, med_geometry_type mgeoti, unsigned char *startFeedingPtr);
+  private:
+    TypeOfField _type;
+    MEDFileFieldPerMeshPerTypeCommon *_father;
+    int _start;
+    int _end;
+    //! _nval is different than end-start in case of ON_GAUSS_PT and ON_GAUSS_NE ! (_nval=(_end-_start)/nbi)
+    int _nval;
+    std::string _profile;
+    std::string _localization;
+    //! only on assignment -3 : ON_NODES, -2 : ON_CELLS, -1 : ON_GAUSS_NE, 0..* : ON_GAUSS_PT
+    mutable int _loc_id;
+    mutable int _profile_it;
+    MCAuto<PartDefinition> _pd;
+  public:
+    mutable int _tmp_work1;
+  };
+
+  class MEDFileFieldVisitor;
+  class MEDFileFieldPerMesh;
+  
+  class MEDFileFieldPerMeshPerTypeCommon : public RefCountObject, public MEDFileWritable
+  {
+  public:
+    std::size_t getHeapMemorySizeWithoutChildren() const;
+    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    void assignFieldNoProfile(int& start, int offset, int nbOfCells, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    void assignFieldProfile(bool isPflAlone, int& start, const DataArrayInt *multiTypePfl, const DataArrayInt *idsInPfl, DataArrayInt *locIds, int nbOfEltsInWholeMesh, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    void assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob);
+    void assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    const MEDFileFieldPerMesh *getFather() const;
+    void loadOnlyStructureOfDataRecursively(med_idt fid, int &start, const MEDFileFieldNameScope& nasc);
+    void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
+    void writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const;
+    bool isUniqueLevel(int& dim) const;
+    void fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const;
+    void fillFieldSplitedByType(std::vector< std::pair<int,int> >& dads, std::vector<TypeOfField>& types, std::vector<std::string>& pfls, std::vector<std::string>& locs) const;
+    int getIteration() const;
+    int getOrder() const;
+    double getTime() const;
+    std::string getMeshName() const;
+    void getSizes(int& globalSz, int& nbOfEntries) const;
+    int getNumberOfComponents() const;
+    bool presenceOfMultiDiscPerGeoType() const;
+    void pushDiscretization(MEDFileFieldPerMeshPerTypePerDisc *disc);
+    DataArray *getOrCreateAndGetArray();
+    const DataArray *getOrCreateAndGetArray() const;
+    const std::vector<std::string>& getInfo() const;
+    std::vector<std::string> getPflsReallyUsed() const;
+    std::vector<std::string> getLocsReallyUsed() const;
+    std::vector<std::string> getPflsReallyUsedMulti() const;
+    std::vector<std::string> getLocsReallyUsedMulti() const;
+    void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenLocId(int locId);
+    const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenLocId(int locId) const;
+    int getNumberOfLoc() const { return _field_pm_pt_pd.size(); }
+    int locIdOfLeaf(const MEDFileFieldPerMeshPerTypePerDisc *leaf) const;
+    void fillValues(int& startEntryId, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    void setLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves);
+    bool keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its);
+    bool keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its);
+    static med_entity_type ConvertIntoMEDFileType(TypeOfField ikType, INTERP_KERNEL::NormalizedCellType ikGeoType, med_geometry_type& medfGeoType);
+    MEDFileFieldPerMeshPerTypeCommon(MEDFileFieldPerMesh *father):_father(father) { }
+    void setFather(MEDFileFieldPerMesh *father);
+    void accept(MEDFileFieldVisitor& visitor) const;
+  public:
+    virtual ~MEDFileFieldPerMeshPerTypeCommon();
+    virtual void getDimension(int& dim) const = 0;
+    virtual INTERP_KERNEL::NormalizedCellType getGeoType() const = 0;
+    virtual void entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const = 0;
+    virtual void simpleRepr(int bkOffset, std::ostream& oss, int id) const = 0;
+    virtual std::string getGeoTypeRepr() const = 0;
+    virtual MEDFileFieldPerMeshPerTypeCommon *deepCopy(MEDFileFieldPerMesh *father) const = 0;
+    virtual void getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const = 0;
+  protected:
+    void deepCopyElements();
+    std::vector<int> addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells);
+    std::vector<int> addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, int offset, int nbOfCells);
+    std::vector<int> addNewEntryIfNecessary(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells);
+    std::vector<int> addNewEntryIfNecessaryGauss(const MEDCouplingFieldTemplate *field, const DataArrayInt *subCells);
+  private:
+    MEDFileFieldPerMesh *_father;
+  protected:
+    std::vector< MCAuto<MEDFileFieldPerMeshPerTypePerDisc> > _field_pm_pt_pd;
+  };
+
+  class MEDFileFieldPerMeshPerType : public MEDFileFieldPerMeshPerTypeCommon
+  {
+  public:
+    static MEDFileFieldPerMeshPerType *New(MEDFileFieldPerMesh *fath, INTERP_KERNEL::NormalizedCellType geoType);
+    static MEDFileFieldPerMeshPerType *NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd);
+    static MCAuto<MEDFileFieldPerMeshPerType> Aggregate(int &start, const std::vector< std::pair<int,const MEDFileFieldPerMeshPerType *> >& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, INTERP_KERNEL::NormalizedCellType gt, MEDFileFieldPerMesh *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo);
+  public:// overload of abstract methods
+    void getDimension(int& dim) const;
+    INTERP_KERNEL::NormalizedCellType getGeoType() const;
+    void entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const;
+    void simpleRepr(int bkOffset, std::ostream& oss, int id) const;
+    std::string getGeoTypeRepr() const;
+    MEDFileFieldPerMeshPerType *deepCopy(MEDFileFieldPerMesh *father) const;
+    void getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const;
+  private:
+    MEDFileFieldPerMeshPerType(med_idt fid, MEDFileFieldPerMesh *fath, TypeOfField type, INTERP_KERNEL::NormalizedCellType geoType, const MEDFileFieldNameScope& nasc, const PartDefinition *pd);
+    MEDFileFieldPerMeshPerType(MEDFileFieldPerMesh *father, INTERP_KERNEL::NormalizedCellType gt);
+  private:
+    INTERP_KERNEL::NormalizedCellType _geo_type;
+  };
+
+  class MEDFileFieldPerMeshPerTypeDyn : public MEDFileFieldPerMeshPerTypeCommon
+  {
+  public:
+    static MEDFileFieldPerMeshPerTypeDyn *NewOnRead(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileEntities *entities, int idGT, const MEDFileFieldNameScope& nasc);
+    int getDynGT() const;
+    std::string getModelName() const;
+  public:
+    void getDimension(int& dim) const;
+    INTERP_KERNEL::NormalizedCellType getGeoType() const;
+    void entriesForMEDfile(TypeOfField mct, med_geometry_type& gt, med_entity_type& ent) const;
+    void simpleRepr(int bkOffset, std::ostream& oss, int id) const;
+    std::string getGeoTypeRepr() const;
+    MEDFileFieldPerMeshPerTypeDyn *deepCopy(MEDFileFieldPerMesh *father) const;
+    void getFieldAtLevel(int meshDim, TypeOfField type, const MEDFileFieldGlobsReal *glob, std::vector< std::pair<int,int> >& dads, std::vector<const DataArrayInt *>& pfls, std::vector<int>& locs, std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes) const;
+  private:
+    MEDFileFieldPerMeshPerTypeDyn(med_idt fid, MEDFileFieldPerMesh *fath, const MEDFileStructureElement *se, const MEDFileFieldNameScope& nasc);
+  private:
+    MCConstAuto<MEDFileStructureElement> _se;
+  };
+  
+  class MEDFileMesh;
+  class MEDFileAnyTypeField1TSWithoutSDA;
+  class MEDFileField1TSWithoutSDA;
+  
+  class MEDFileFieldPerMesh : public RefCountObject, public MEDFileWritable
+  {
+  public:
+    static MEDFileFieldPerMesh *New(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh);
+    static MEDFileFieldPerMesh *NewOnRead(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities);
+    std::size_t getHeapMemorySizeWithoutChildren() const;
+    std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDFileFieldPerMesh *deepCopy(MEDFileAnyTypeField1TSWithoutSDA *father) const;
+    void simpleRepr(int bkOffset,std::ostream& oss, int id) const;
+    void copyTinyInfoFrom(const MEDCouplingMesh *mesh);
+    void assignFieldProfile(int& start, const DataArrayInt *multiTypePfl, const std::vector<int>& code, const std::vector<int>& code2, const std::vector<DataArrayInt *>& idsInPflPerType, const std::vector<DataArrayInt *>& idsPerType, const MEDCouplingFieldTemplate *field, const DataArray *arr, const MEDCouplingMesh *mesh, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    void assignFieldNoProfileNoRenum(int& start, const std::vector<int>& code, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    void assignNodeFieldNoProfile(int& start, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob);
+    void assignNodeFieldProfile(int& start, const DataArrayInt *pfl, const MEDCouplingFieldTemplate *field, const DataArray *arr, MEDFileFieldGlobsReal& glob, const MEDFileFieldNameScope& nasc);
+    void loadOnlyStructureOfDataRecursively(med_idt fid, int &start, const MEDFileFieldNameScope& nasc);
+    void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
+    void writeLL(med_idt fid, const MEDFileFieldNameScope& nasc) const;
+    void fillTypesOfFieldAvailable(std::set<TypeOfField>& types) const;
+    std::vector< std::vector< std::pair<int,int> > > getFieldSplitedByType(std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    void accept(MEDFileFieldVisitor& visitor) const;
+    void getDimension(int& dim) const;
+    bool isUniqueLevel(int& dim) const;
+    double getTime() const;
+    int getIteration() const;
+    int getOrder() const;
+    int getMeshIteration() const { return _mesh_iteration; }
+    int getMeshOrder() const { return _mesh_order; }
+    std::string getMeshName() const;
+    void setMeshName(const std::string& meshName);
+    int getNumberOfComponents() const;
+    bool presenceOfMultiDiscPerGeoType() const;
+    bool presenceOfStructureElements() const;
+    bool onlyStructureElements() const;
+    void killStructureElements();
+    void keepOnlyStructureElements();
+    void keepOnlyOnSE(const std::string& seName);
+    void getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const;
+    DataArray *getOrCreateAndGetArray();
+    const DataArray *getOrCreateAndGetArray() const;
+    const std::vector<std::string>& getInfo() const;
+    std::vector<std::string> getPflsReallyUsed() const;
+    std::vector<std::string> getLocsReallyUsed() const;
+    std::vector<std::string> getPflsReallyUsedMulti() const;
+    std::vector<std::string> getLocsReallyUsedMulti() const;
+    void convertMedBallIntoClassic();
+    bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
+    bool renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N, MEDFileFieldGlobsReal& glob);
+    void keepOnlySpatialDiscretization(TypeOfField tof, int &globalNum, std::vector< std::pair<int,int> >& its);
+    void keepOnlyGaussDiscretization(std::size_t idOfDisc, int &globalNum, std::vector< std::pair<int,int> >& its);
+    void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDCouplingFieldDouble *getFieldOnMeshAtLevel(TypeOfField type, const MEDFileFieldGlobsReal *glob, const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    DataArray *getFieldOnMeshAtLevelWithPfl(TypeOfField type, const MEDCouplingMesh *mesh, DataArrayInt *&pfl, const MEDFileFieldGlobsReal *glob, const MEDFileFieldNameScope& nasc) const;
+    void getUndergroundDataArrayExt(std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId);
+    const MEDFileFieldPerMeshPerTypePerDisc *getLeafGivenTypeAndLocId(INTERP_KERNEL::NormalizedCellType typ, int locId) const;
+    static MCAuto<MEDFileFieldPerMesh> Aggregate(int &start, const std::vector<const MEDFileFieldPerMesh *>& pms, const std::vector< std::vector< std::pair<int,int> > >& dts, MEDFileAnyTypeField1TSWithoutSDA *father, std::vector<std::pair< int, std::pair<int,int> > >& extractInfo);
+  private:
+    int addNewEntryIfNecessary(INTERP_KERNEL::NormalizedCellType type);
+    MEDCouplingFieldDouble *finishField(TypeOfField type, const MEDFileFieldGlobsReal *glob,
+                                        const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs, const MEDCouplingMesh *mesh, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    MEDCouplingFieldDouble *finishField2(TypeOfField type, const MEDFileFieldGlobsReal *glob,
+                                         const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs,
+                                         const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes,
+                                         const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    MEDCouplingFieldDouble *finishFieldNode2(const MEDFileFieldGlobsReal *glob,
+                                             const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs,
+                                             const MEDCouplingMesh *mesh, const DataArrayInt *da, bool& isPfl, MCAuto<DataArray> &arrOut, const MEDFileFieldNameScope& nasc) const;
+    DataArray *finishField4(const std::vector< std::pair<int,int> >& dads, const DataArrayInt *pflIn, int nbOfElems, DataArrayInt *&pflOut) const;
+    void assignNewLeaves(const std::vector< MCAuto< MEDFileFieldPerMeshPerTypePerDisc > >& leaves);
+    static void SortArraysPerType(const MEDFileFieldGlobsReal *glob, TypeOfField type, 
+                                  const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<const DataArrayInt *>& pfls, const std::vector<int>& locs,
+                                  std::vector<int>& code, std::vector<DataArrayInt *>& notNullPfls);
+    static int ComputeNbOfElems(const MEDFileFieldGlobsReal *glob, TypeOfField type, const std::vector<INTERP_KERNEL::NormalizedCellType>& geoTypes, const std::vector< std::pair<int,int> >& dads, const std::vector<int>& locs);
+    MEDFileFieldPerMesh(med_idt fid, MEDFileAnyTypeField1TSWithoutSDA *fath, int meshCsit, int meshIteration, int meshOrder, const MEDFileFieldNameScope& nasc, const MEDFileMesh *mm, const MEDFileEntities *entities);
+    MEDFileFieldPerMesh(MEDFileAnyTypeField1TSWithoutSDA *fath, const MEDCouplingMesh *mesh);
+    MEDFileFieldPerMesh(MEDFileAnyTypeField1TSWithoutSDA *fath, const std::string& meshName, int meshIt, int meshOrd):_father(fath),_mesh_iteration(meshIt),_mesh_order(meshOrd) { }
+  private:
+    int _mesh_iteration;
+    int _mesh_order;
+    MEDFileAnyTypeField1TSWithoutSDA *_father;
+    std::vector< MCAuto< MEDFileFieldPerMeshPerTypeCommon > > _field_pm_pt;
+  };
+}
+
+#endif
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldMultiTS.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldMultiTS.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldMultiTS.cxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldMultiTS.cxx	2018-04-19 17:25:17.727797159 +0200
@@ -0,0 +1,2137 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#include "MEDFileFieldMultiTS.hxx"
+#include "MEDFileFieldVisitor.hxx"
+#include "MEDFileSafeCaller.txx"
+#include "MEDLoaderBase.hxx"
+#include "MEDFileField.txx"
+
+#include "MEDCouplingFieldDouble.hxx"
+#include "MEDCouplingFieldTemplate.hxx"
+
+#include <sstream>
+
+using namespace MEDCoupling;
+
+template class MEDCoupling::MEDFileTemplateFieldMultiTSWithoutSDA<int>;
+template class MEDCoupling::MEDFileTemplateFieldMultiTSWithoutSDA<float>;
+template class MEDCoupling::MEDFileTemplateFieldMultiTSWithoutSDA<double>;
+template class MEDCoupling::MEDFileNDTemplateFieldMultiTSWithoutSDA<int>;
+template class MEDCoupling::MEDFileNDTemplateFieldMultiTSWithoutSDA<float>;
+template class MEDCoupling::MEDFileTemplateFieldMultiTS<int>;
+template class MEDCoupling::MEDFileTemplateFieldMultiTS<float>;
+template class MEDCoupling::MEDFileTemplateFieldMultiTS<double>;
+template class MEDCoupling::MEDFileNDTemplateFieldMultiTS<int>;
+template class MEDCoupling::MEDFileNDTemplateFieldMultiTS<float>;
+
+//= MEDFileAnyTypeFieldMultiTSWithoutSDA
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA()
+{
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileFieldNameScope(fieldName,meshName)
+{
+}
+
+/*!
+ * \param [in] fieldId field id in C mode
+ */
+MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  med_field_type typcha;
+  std::string dtunitOut,meshName;
+  int nbOfStep(MEDFileAnyTypeField1TS::LocateField2(fid,fieldId,false,_name,typcha,_infos,dtunitOut,meshName));
+  setMeshName(meshName);
+  setDtUnit(dtunitOut.c_str());
+  loadStructureOrStructureAndBigArraysRecursively(fid,nbOfStep,typcha,loadAll,ms,entities);
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA::MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+try:MEDFileFieldNameScope(fieldName,meshName),_infos(infos)
+{
+  setDtUnit(dtunit.c_str());
+  loadStructureOrStructureAndBigArraysRecursively(fid,nbOfStep,fieldTyp,loadAll,ms,entities);
+}
+catch(INTERP_KERNEL::Exception& e)
+{
+    throw e;
+}
+
+std::size_t MEDFileAnyTypeFieldMultiTSWithoutSDA::getHeapMemorySizeWithoutChildren() const
+{
+  std::size_t ret(_mesh_name.capacity()+_name.capacity()+_infos.capacity()*sizeof(std::string)+_time_steps.capacity()*sizeof(MCAuto<MEDFileField1TSWithoutSDA>));
+  for(std::vector<std::string>::const_iterator it=_infos.begin();it!=_infos.end();it++)
+    ret+=(*it).capacity();
+  return ret;
+}
+
+std::vector<const BigMemoryObject *> MEDFileAnyTypeFieldMultiTSWithoutSDA::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    ret.push_back((const MEDFileAnyTypeField1TSWithoutSDA *)*it);
+  return ret;
+}
+
+/*!
+ * If one of the id in [ \a startIds , \a endIds ) points to a null element, there is not throw. Simply, this empty element is added as if it were not
+ * NULL.
+ */
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds(const int *startIds, const int *endIds) const
+{
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret=createNew();
+  ret->setInfo(_infos);
+  int sz=(int)_time_steps.size();
+  for(const int *id=startIds;id!=endIds;id++)
+    {
+      if(*id>=0 && *id<sz)
+        {
+          const MEDFileAnyTypeField1TSWithoutSDA *tse=_time_steps[*id];
+          MCAuto<MEDFileAnyTypeField1TSWithoutSDA> tse2;
+          if(tse)
+            {
+              tse->incrRef();
+              tse2=(const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(tse));
+            }
+          ret->pushBackTimeStep(tse2);
+        }
+      else
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds : At pos #" << std::distance(startIds,id) << " value is " << *id;
+          oss << " ! Should be in [0," << sz << ") !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  if(ret->getNumberOfTS()>0)
+    ret->synchronizeNameScope();
+  ret->copyNameScope(*this);
+  return ret.retn();
+}
+
+/*!
+ * If one of the id in the input range points to a null element, there is not throw. Simply, this empty element is added as if it were not
+ * NULL.
+ */
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds2(int bg, int end, int step) const
+{
+  static const char msg[]="MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds2";
+  int nbOfEntriesToKeep=DataArrayInt::GetNumberOfItemGivenBESRelative(bg,end,step,msg);
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret=createNew();
+  ret->setInfo(_infos);
+  int sz=(int)_time_steps.size();
+  int j=bg;
+  for(int i=0;i<nbOfEntriesToKeep;i++,j+=step)
+    {
+      if(j>=0 && j<sz)
+        {
+          const MEDFileAnyTypeField1TSWithoutSDA *tse=_time_steps[j];
+          MCAuto<MEDFileAnyTypeField1TSWithoutSDA> tse2;
+          if(tse)
+            {
+              tse->incrRef();
+              tse2=(const_cast<MEDFileAnyTypeField1TSWithoutSDA *>(tse));
+            }
+          ret->pushBackTimeStep(tse2);
+        }
+      else
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::buildFromTimeStepIds : At pos #" << i << " value is " << j;
+          oss << " ! Should be in [0," << sz << ") !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  if(ret->getNumberOfTS()>0)
+    ret->synchronizeNameScope();
+  ret->copyNameScope(*this);
+  return ret.retn();
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::partOfThisLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const
+{
+  int id=0;
+  MCAuto<DataArrayInt> ids=DataArrayInt::New(); ids->alloc(0,1);
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,id++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
+      if(!cur)
+        continue;
+      std::pair<int,int> p(cur->getIteration(),cur->getOrder());
+      if(std::find(timeSteps.begin(),timeSteps.end(),p)!=timeSteps.end())
+        ids->pushBackSilent(id);
+    }
+  return buildFromTimeStepIds(ids->begin(),ids->end());
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::partOfThisNotLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const
+{
+  int id=0;
+  MCAuto<DataArrayInt> ids=DataArrayInt::New(); ids->alloc(0,1);
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,id++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
+      if(!cur)
+        continue;
+      std::pair<int,int> p(cur->getIteration(),cur->getOrder());
+      if(std::find(timeSteps.begin(),timeSteps.end(),p)==timeSteps.end())
+        ids->pushBackSilent(id);
+    }
+  return buildFromTimeStepIds(ids->begin(),ids->end());
+}
+
+bool MEDFileAnyTypeFieldMultiTSWithoutSDA::presenceOfStructureElements() const
+{
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      if((*it)->presenceOfStructureElements())
+        return true;
+  return false;
+}
+
+bool MEDFileAnyTypeFieldMultiTSWithoutSDA::onlyStructureElements() const
+{
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      if(!(*it)->onlyStructureElements())
+        return false;
+  return true;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::killStructureElements()
+{
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      {
+        if((*it)->presenceOfStructureElements())
+          {
+            if(!(*it)->onlyStructureElements())
+              {
+                (*it)->killStructureElements();
+                ret.push_back(*it);
+              }
+          }
+        else
+          {
+            ret.push_back(*it);
+          }
+      }
+  _time_steps=ret;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::keepOnlyStructureElements()
+{
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      {
+        if((*it)->presenceOfStructureElements())
+          {
+            if(!(*it)->onlyStructureElements())
+              (*it)->keepOnlyStructureElements();
+            ret.push_back(*it);
+          }
+      }
+  _time_steps=ret;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::keepOnlyOnSE(const std::string& seName)
+{
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      (*it)->keepOnlyOnSE(seName);
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const
+{
+  std::vector< std::pair<std::string,std::string> > ps2;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      {
+        (*it)->getMeshSENames(ps2);
+        break;
+      }
+  if(ps2.empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::getMeshSENames : this appears to not contain SE only !");
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      {
+        std::vector< std::pair<std::string,std::string> > ps3;
+        (*it)->getMeshSENames(ps3);
+        if(ps2!=ps3)
+          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::getMeshSENames : For the moment only homogeneous SE def through time managed !");
+      }
+  for(std::vector< std::pair<std::string,std::string> >::const_iterator it=ps2.begin();it!=ps2.end();it++)
+    {
+      std::vector< std::pair<std::string,std::string> >::iterator it2(std::find(ps.begin(),ps.end(),*it));
+      if(it2==ps.end())
+        ps.push_back(*it);
+    }
+}
+
+bool MEDFileAnyTypeFieldMultiTSWithoutSDA::presenceOfMultiDiscPerGeoType() const
+{
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
+      if(!cur)
+        continue;
+      if(cur->presenceOfMultiDiscPerGeoType())
+        return true;
+    }
+  return false;
+}
+
+const std::vector<std::string>& MEDFileAnyTypeFieldMultiTSWithoutSDA::getInfo() const
+{
+  return _infos;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::setInfo(const std::vector<std::string>& info)
+{
+  _infos=info;
+}
+
+int MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepPos(int iteration, int order) const
+{
+  int ret=0;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,ret++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *pt(*it);
+      if(pt->isDealingTS(iteration,order))
+        return ret;
+    }
+  std::ostringstream oss; oss << "MEDFileFieldMultiTS::getTimeStepPos : Muli timestep field on time (" << iteration << "," << order << ") does not exist ! Available (iteration,order) are :\n";
+  std::vector< std::pair<int,int> > vp=getIterations();
+  for(std::vector< std::pair<int,int> >::const_iterator it2=vp.begin();it2!=vp.end();it2++)
+    oss << "(" << (*it2).first << "," << (*it2).second << ") ";
+  throw INTERP_KERNEL::Exception(oss.str());
+}
+
+const MEDFileAnyTypeField1TSWithoutSDA& MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepEntry(int iteration, int order) const
+{
+  return *_time_steps[getTimeStepPos(iteration,order)];
+}
+
+MEDFileAnyTypeField1TSWithoutSDA& MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepEntry(int iteration, int order)
+{
+  return *_time_steps[getTimeStepPos(iteration,order)];
+}
+
+bool MEDFileAnyTypeFieldMultiTSWithoutSDA::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
+{
+  bool ret(false);
+  for(std::vector< std::pair<std::string,std::string> >::const_iterator it=modifTab.begin();it!=modifTab.end();it++)
+    {
+      if((*it).first==getMeshName())
+        {
+          setMeshName((*it).second);
+          ret=true;
+        }
+    }
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      MEDFileAnyTypeField1TSWithoutSDA *cur(*it);
+      if(cur)
+        ret=cur->changeMeshNames(modifTab) || ret;
+    }
+  return ret;
+}
+
+/*!
+ * See doc at MEDFileField1TSWithoutSDA::getUndergroundDataArray
+ */
+DataArray *MEDFileAnyTypeFieldMultiTSWithoutSDA::getUndergroundDataArray(int iteration, int order) const
+{
+  return getTimeStepEntry(iteration,order).getUndergroundDataArray();
+}
+
+/*!
+ * See doc at MEDFileField1TSWithoutSDA::getUndergroundDataArrayExt
+ */
+DataArray *MEDFileAnyTypeFieldMultiTSWithoutSDA::getUndergroundDataArrayExt(int iteration, int order, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const
+{
+  return getTimeStepEntry(iteration,order).getUndergroundDataArrayExt(entries);
+}
+
+bool MEDFileAnyTypeFieldMultiTSWithoutSDA::renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N,
+                                                                       MEDFileFieldGlobsReal& glob)
+{
+  bool ret=false;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      MEDFileAnyTypeField1TSWithoutSDA *f1ts(*it);
+      if(f1ts)
+        ret=f1ts->renumberEntitiesLyingOnMesh(meshName,oldCode,newCode,renumO2N,glob) || ret;
+    }
+  return ret;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::accept(MEDFileFieldVisitor& visitor) const
+{
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    if((*it).isNotNull())
+      {
+        visitor.newTimeStepEntry(*it);
+        (*it)->accept(visitor);
+        visitor.endTimeStepEntry(*it);
+      }
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const
+{
+  std::string startLine(bkOffset,' ');
+  oss << startLine << "Field multi time steps [Type=" << getTypeStr() << "]";
+  if(fmtsId>=0)
+    oss << " (" << fmtsId << ")";
+  oss << " has the following name: \"" << _name << "\"." << std::endl;
+  oss << startLine << "Field multi time steps has " << _infos.size() << " components with the following infos :" << std::endl;
+  for(std::vector<std::string>::const_iterator it=_infos.begin();it!=_infos.end();it++)
+    {
+      oss << startLine << "  -  \"" << *it << "\"" << std::endl;
+    }
+  int i=0;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,i++)
+    {
+      std::string chapter(17,'0'+i);
+      oss << startLine << chapter << std::endl;
+      const MEDFileAnyTypeField1TSWithoutSDA *cur=(*it);
+      if(cur)
+        cur->simpleRepr(bkOffset+2,oss,i);
+      else
+        oss << startLine << "  Field on one time step #" << i << " is not defined !" << std::endl;
+      oss << startLine << chapter << std::endl;
+    }
+}
+
+std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeSteps(std::vector<double>& ret1) const
+{
+  std::size_t sz=_time_steps.size();
+  std::vector< std::pair<int,int> > ret(sz);
+  ret1.resize(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *f1ts=_time_steps[i];
+      if(f1ts)
+        {
+          ret1[i]=f1ts->getTime(ret[i].first,ret[i].second);
+        }
+      else
+        {
+          std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::getTimeSteps : At rank #" << i << " time step is not defined. Invoke eraseEmptyTS method !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  return ret;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep(MCAuto<MEDFileAnyTypeField1TSWithoutSDA>& tse)
+{
+  MEDFileAnyTypeField1TSWithoutSDA *tse2(tse);
+  if(!tse2)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep : input content object is null !");
+  checkCoherencyOfType(tse2);
+  if(_time_steps.empty())
+    {
+      setName(tse2->getName());
+      setMeshName(tse2->getMeshName());
+      setInfo(tse2->getInfo());
+    }
+  checkThatComponentsMatch(tse2->getInfo());
+  if(getDtUnit().empty() && !tse->getDtUnit().empty())
+    setDtUnit(tse->getDtUnit());
+  _time_steps.push_back(tse);
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::synchronizeNameScope()
+{
+  std::size_t nbOfCompo=_infos.size();
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      MEDFileAnyTypeField1TSWithoutSDA *cur=(*it);
+      if(cur)
+        {
+          if((cur->getInfo()).size()!=nbOfCompo)
+            {
+              std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::synchronizeNameScope : Mismatch in the number of components of parts ! Should be " << nbOfCompo;
+              oss << " ! but the field at iteration=" << cur->getIteration() << " order=" << cur->getOrder() << " has " << (cur->getInfo()).size() << " components !";
+              throw INTERP_KERNEL::Exception(oss.str());
+            }
+          cur->copyNameScope(*this);
+        }
+    }
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::loadStructureOrStructureAndBigArraysRecursively(med_idt fid, int nbPdt, med_field_type fieldTyp, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  _time_steps.resize(nbPdt);
+  for(int i=0;i<nbPdt;i++)
+    {
+      std::vector< std::pair<int,int> > ts;
+      med_int numdt=0,numo=0;
+      med_float dt=0.0;
+      MEDFILESAFECALLERRD0(MEDfieldComputingStepInfo,(fid,_name.c_str(),i+1,&numdt,&numo,&dt));
+      switch(fieldTyp)
+      {
+        case MED_FLOAT64:
+          {
+            _time_steps[i]=MEDFileField1TSWithoutSDA::New(getName(),getMeshName(),i+1,numdt,numo,_infos);
+            break;
+          }
+        case MED_INT32:
+          {
+            _time_steps[i]=MEDFileIntField1TSWithoutSDA::New(getName(),getMeshName(),i+1,numdt,numo,_infos);
+            break;
+          }
+        case MED_FLOAT32:
+          {
+            _time_steps[i]=MEDFileFloatField1TSWithoutSDA::New(getName(),getMeshName(),i+1,numdt,numo,_infos);
+            break;
+          }
+        case MED_INT:
+          {
+            if(sizeof(med_int)==sizeof(int))
+              {
+                _time_steps[i]=MEDFileIntField1TSWithoutSDA::New(getName(),getMeshName(),i+1,numdt,numo,_infos);
+                break;
+              }
+          }
+        default:
+          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::loadStructureOrStructureAndBigArraysRecursively : managed field type are : FLOAT64, INT32, FLOAT32 !");
+      }
+      if(loadAll)
+        _time_steps[i]->loadStructureAndBigArraysRecursively(fid,*this,ms,entities);
+      else
+        _time_steps[i]->loadOnlyStructureOfDataRecursively(fid,*this,ms,entities);
+      synchronizeNameScope();
+    }
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::writeLL(med_idt fid, const MEDFileWritable& opts) const
+{
+  if(_time_steps.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::writeLL : no time steps set !");
+  checkThatNbOfCompoOfTSMatchThis();
+  std::vector<std::string> infos(getInfo());
+  int nbComp=infos.size();
+  INTERP_KERNEL::AutoPtr<char> comp=MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE);
+  INTERP_KERNEL::AutoPtr<char> unit=MEDLoaderBase::buildEmptyString(nbComp*MED_SNAME_SIZE);
+  for(int i=0;i<nbComp;i++)
+    {
+      std::string info=infos[i];
+      std::string c,u;
+      MEDLoaderBase::splitIntoNameAndUnit(info,c,u);
+      MEDLoaderBase::safeStrCpy2(c.c_str(),MED_SNAME_SIZE,comp+i*MED_SNAME_SIZE,opts.getTooLongStrPolicy());
+      MEDLoaderBase::safeStrCpy2(u.c_str(),MED_SNAME_SIZE,unit+i*MED_SNAME_SIZE,opts.getTooLongStrPolicy());
+    }
+  if(_name.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::write : MED file does not accept field with empty name !");
+  MEDFILESAFECALLERWR0(MEDfieldCr,(fid,_name.c_str(),getMEDFileFieldType(),nbComp,comp,unit,getDtUnit().c_str(),getMeshName().c_str()));
+  int nbOfTS=_time_steps.size();
+  for(int i=0;i<nbOfTS;i++)
+    _time_steps[i]->writeLL(fid,opts,*this);
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc)
+{
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
+      if(elt)
+        elt->loadBigArraysRecursively(fid,nasc);
+    }
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc)
+{
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
+      if(elt)
+        elt->loadBigArraysRecursivelyIfNecessary(fid,nasc);
+    }
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::unloadArrays()
+{
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
+      if(elt)
+        elt->unloadArrays();
+    }
+}
+
+int MEDFileAnyTypeFieldMultiTSWithoutSDA::getNumberOfTS() const
+{
+  return _time_steps.size();
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseEmptyTS()
+{
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  > newTS;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *tmp=(*it);
+      if(tmp)
+        newTS.push_back(*it);
+    }
+  _time_steps=newTS;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseTimeStepIds(const int *startIds, const int *endIds)
+{
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > newTS;
+  int maxId=(int)_time_steps.size();
+  int ii=0;
+  std::set<int> idsToDel;
+  for(const int *id=startIds;id!=endIds;id++,ii++)
+    {
+      if(*id>=0 && *id<maxId)
+        {
+          idsToDel.insert(*id);
+        }
+      else
+        {
+          std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::eraseTimeStepIds : At pos #" << ii << " request for id=" << *id << " not in [0," << maxId << ") !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  for(int iii=0;iii<maxId;iii++)
+    if(idsToDel.find(iii)==idsToDel.end())
+      newTS.push_back(_time_steps[iii]);
+  _time_steps=newTS;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseTimeStepIds2(int bg, int end, int step)
+{
+  static const char msg[]="MEDFileAnyTypeFieldMultiTSWithoutSDA::eraseTimeStepIds2";
+  int nbOfEntriesToKill=DataArrayInt::GetNumberOfItemGivenBESRelative(bg,end,step,msg);
+  if(nbOfEntriesToKill==0)
+    return ;
+  std::size_t sz=_time_steps.size();
+  std::vector<bool> b(sz,true);
+  int j=bg;
+  for(int i=0;i<nbOfEntriesToKill;i++,j+=step)
+    b[j]=false;
+  std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > newTS;
+  for(std::size_t i=0;i<sz;i++)
+    if(b[i])
+      newTS.push_back(_time_steps[i]);
+  _time_steps=newTS;
+}
+
+int MEDFileAnyTypeFieldMultiTSWithoutSDA::getPosOfTimeStep(int iteration, int order) const
+{
+  int ret=0;
+  std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::getPosOfTimeStep : No such time step (" << iteration << "," << order << ") !\nPossibilities are : "; 
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,ret++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *tmp(*it);
+      if(tmp)
+        {
+          int it2,ord;
+          tmp->getTime(it2,ord);
+          if(it2==iteration && order==ord)
+            return ret;
+          else
+            oss << "(" << it2 << ","  << ord << "), ";
+        }
+    }
+  throw INTERP_KERNEL::Exception(oss.str());
+}
+
+int MEDFileAnyTypeFieldMultiTSWithoutSDA::getPosGivenTime(double time, double eps) const
+{
+  int ret=0;
+  std::ostringstream oss; oss << "MEDFileFieldMultiTSWithoutSDA::getPosGivenTime : No such time step " << time << "! \nPossibilities are : ";
+  oss.precision(15);
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA>  >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,ret++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *tmp(*it);
+      if(tmp)
+        {
+          int it2,ord;
+          double ti=tmp->getTime(it2,ord);
+          if(fabs(time-ti)<eps)
+            return ret;
+          else
+            oss << ti << ", ";
+        }
+    }
+  throw INTERP_KERNEL::Exception(oss.str());
+}
+
+std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTSWithoutSDA::getIterations() const
+{
+  int lgth=_time_steps.size();
+  std::vector< std::pair<int,int> > ret(lgth);
+  for(int i=0;i<lgth;i++)
+    _time_steps[i]->fillIteration(ret[i]);
+  return ret;
+}
+
+/*!
+ * This method has 3 inputs 'iteration' 'order' 'mname'. 'mname' can be null if the user is the general case where there is only one meshName lying on 'this'
+ * This method returns two things.
+ * - The absolute dimension of 'this' in first parameter. 
+ * - The available ext levels relative to the absolute dimension returned in first parameter. These relative levels are relative
+ *   to the first output parameter. The values in 'levs' will be returned in decreasing order.
+ *
+ * This method is designed for MEDFileFieldMultiTS instances that have a discritization ON_CELLS, ON_GAUSS_NE and ON_GAUSS.
+ * Only these 3 discretizations will be taken into account here.
+ *
+ * If 'this' is empty this method will throw an INTERP_KERNEL::Exception.
+ * If there is \b only node fields defined in 'this' -1 is returned and 'levs' output parameter will be empty. In this
+ * case the caller has to know the underlying mesh it refers to. By default it is the level 0 of the corresponding mesh.
+ *
+ * This method is useful to make the link between meshDimension of the underlying mesh in 'this' and the levels on 'this'.
+ * It is possible (even if it is not common) that the highest level in 'this' were not equal to the meshDimension of the underlying mesh in 'this'.
+ * 
+ * Let's consider the typical following case :
+ * - a mesh 'm1' has a meshDimension 3 and has the following non empty levels
+ * [0,-1,-2] for example 'm1' lies on TETRA4, HEXA8 TRI3 and SEG2
+ * - 'f1' lies on 'm1' and is defined on 3D and 1D cells for example
+ *   TETRA4 and SEG2
+ * - 'f2' lies on 'm1' too and is defined on 2D and 1D cells for example TRI3 and SEG2
+ *
+ * In this case f1->getNonEmptyLevelsExt will return (3,[0,-2]) and f2->getNonEmptyLevelsExt will return (2,[0,-1])
+ * 
+ * To retrieve the highest level of f1 it should be done, f1->getFieldAtLevel(ON_CELLS,3-3+0);//absDim-meshDim+relativeLev
+ * To retrieve the lowest level of f1 it should be done, f1->getFieldAtLevel(ON_CELLS,3-3+(-2));//absDim-meshDim+relativeLev
+ * To retrieve the highest level of f2 it should be done, f1->getFieldAtLevel(ON_CELLS,2-3+0);//absDim-meshDim+relativeLev
+ * To retrieve the lowest level of f2 it should be done, f1->getFieldAtLevel(ON_CELLS,2-3+(-1));//absDim-meshDim+relativeLev
+ */
+int MEDFileAnyTypeFieldMultiTSWithoutSDA::getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const
+{
+  return getTimeStepEntry(iteration,order).getNonEmptyLevels(mname,levs);
+}
+
+const MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2(int pos) const
+{
+  if(pos<0 || pos>=(int)_time_steps.size())
+    {
+      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << " whereas should be in [0," << _time_steps.size() << ") !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  const MEDFileAnyTypeField1TSWithoutSDA *item=_time_steps[pos];
+  if(item==0)
+    {
+      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << ", this pos id exists but the underlying Field1TS is null !";
+      oss << "\nTry to use following method eraseEmptyTS !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  return item;
+}
+
+MEDFileAnyTypeField1TSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2(int pos)
+{
+  if(pos<0 || pos>=(int)_time_steps.size())
+    {
+      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << " whereas should be in [0," << _time_steps.size() << ") !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  MEDFileAnyTypeField1TSWithoutSDA *item=_time_steps[pos];
+  if(item==0)
+    {
+      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::getTimeStepAtPos2 : request for pos #" << pos << ", this pos id exists but the underlying Field1TS is null !";
+      oss << "\nTry to use following method eraseEmptyTS !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  return item;
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getPflsReallyUsed2() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getPflsReallyUsed2();
+      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
+        if(ret2.find(*it2)==ret2.end())
+          {
+            ret.push_back(*it2);
+            ret2.insert(*it2);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getLocsReallyUsed2() const
+{
+  std::vector<std::string> ret;
+  std::set<std::string> ret2;
+  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getLocsReallyUsed2();
+      for(std::vector<std::string>::const_iterator it2=tmp.begin();it2!=tmp.end();it2++)
+        if(ret2.find(*it2)==ret2.end())
+          {
+            ret.push_back(*it2);
+            ret2.insert(*it2);
+          }
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getPflsReallyUsedMulti2() const
+{
+  std::vector<std::string> ret;
+  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getPflsReallyUsedMulti2();
+      ret.insert(ret.end(),tmp.begin(),tmp.end());
+    }
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTSWithoutSDA::getLocsReallyUsedMulti2() const
+{
+  std::vector<std::string> ret;
+  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    {
+      std::vector<std::string> tmp=(*it)->getLocsReallyUsedMulti2();
+      ret.insert(ret.end(),tmp.begin(),tmp.end());
+    }
+  return ret;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    (*it)->changePflsRefsNamesGen2(mapOfModif);
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  for(std::vector< MCAuto< MEDFileAnyTypeField1TSWithoutSDA > >::iterator it=_time_steps.begin();it!=_time_steps.end();it++)
+    (*it)->changeLocsRefsNamesGen2(mapOfModif);
+}
+
+std::vector< std::vector<TypeOfField> > MEDFileAnyTypeFieldMultiTSWithoutSDA::getTypesOfFieldAvailable() const
+{
+  int lgth=_time_steps.size();
+  std::vector< std::vector<TypeOfField> > ret(lgth);
+  for(int i=0;i<lgth;i++)
+    _time_steps[i]->fillTypesOfFieldAvailable(ret[i]);
+  return ret;
+}
+
+/*!
+ * entry point for users that want to iterate into MEDFile DataStructure without any overhead.
+ */
+std::vector< std::vector< std::pair<int,int> > > MEDFileAnyTypeFieldMultiTSWithoutSDA::getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  return getTimeStepEntry(iteration,order).getFieldSplitedByType(mname,types,typesF,pfls,locs);
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTSWithoutSDA::deepCopy() const
+{
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret=shallowCpy();
+  std::size_t i=0;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,i++)
+    {
+      if((const MEDFileAnyTypeField1TSWithoutSDA *)*it)
+        ret->_time_steps[i]=(*it)->deepCopy();
+    }
+  return ret.retn();
+}
+
+std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > MEDFileAnyTypeFieldMultiTSWithoutSDA::splitComponents() const
+{
+  std::size_t sz(_infos.size()),sz2(_time_steps.size());
+  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > ret(sz);
+  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > ts(sz2);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      ret[i]=shallowCpy();
+      ret[i]->_infos.resize(1); ret[i]->_infos[0]=_infos[i];
+    }
+  for(std::size_t i=0;i<sz2;i++)
+    {
+      std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > ret1=_time_steps[i]->splitComponents();
+      if(ret1.size()!=sz)
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::splitComponents : At rank #" << i << " number of components is " << ret1.size() << " whereas it should be for all time steps " << sz << " !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      ts[i]=ret1;
+    }
+  for(std::size_t i=0;i<sz;i++)
+    for(std::size_t j=0;j<sz2;j++)
+      ret[i]->_time_steps[j]=ts[j][i];
+  return ret;
+}
+
+/*!
+ * This method splits into discretization each time steps in \a this.
+ * ** WARNING ** the returned instances are not compulsory defined on the same time steps series !
+ */
+std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > MEDFileAnyTypeFieldMultiTSWithoutSDA::splitDiscretizations() const
+{
+  std::size_t sz(_time_steps.size());
+  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > items(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *timeStep(_time_steps[i]);
+      if(!timeStep)
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::splitDiscretizations : time step #" << i << " is null !"; 
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      items[i]=timeStep->splitDiscretizations();  
+    }
+  //
+  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > ret;
+  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > ret2;
+  std::vector< TypeOfField > types;
+  for(std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > >::const_iterator it0=items.begin();it0!=items.end();it0++)
+    for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it1=(*it0).begin();it1!=(*it0).end();it1++)
+      {
+        std::vector<TypeOfField> ts=(*it1)->getTypesOfFieldAvailable();
+        if(ts.size()!=1)
+          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::splitDiscretizations : it appears that the splitting of MEDFileAnyTypeField1TSWithoutSDA::splitDiscretizations has returned invalid result !");
+        std::vector< TypeOfField >::iterator it2=std::find(types.begin(),types.end(),ts[0]);
+        if(it2==types.end())
+          types.push_back(ts[0]);
+      }
+  ret.resize(types.size()); ret2.resize(types.size());
+  for(std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > >::const_iterator it0=items.begin();it0!=items.end();it0++)
+    for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it1=(*it0).begin();it1!=(*it0).end();it1++)
+      {
+        TypeOfField typ=(*it1)->getTypesOfFieldAvailable()[0];
+        std::size_t pos=std::distance(types.begin(),std::find(types.begin(),types.end(),typ));
+        ret2[pos].push_back(*it1);
+      }
+  for(std::size_t i=0;i<types.size();i++)
+    {
+      MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> elt(createNew());
+      for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::iterator it1=ret2[i].begin();it1!=ret2[i].end();it1++)
+        elt->pushBackTimeStep(*it1);//also updates infos in elt
+      ret[i]=elt;
+      elt->MEDFileFieldNameScope::operator=(*this);
+    }
+  return ret;
+}
+
+/*!
+ * Contrary to splitDiscretizations method this method makes the hypothesis that the times series are **NOT** impacted by the splitting of multi discretization.
+ */
+std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes() const
+{
+  std::size_t sz(_time_steps.size());
+  std::vector< std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > > items(sz);
+  std::size_t szOut(std::numeric_limits<std::size_t>::max());
+  for(std::size_t i=0;i<sz;i++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *timeStep(_time_steps[i]);
+      if(!timeStep)
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes : time step #" << i << " is null !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      items[i]=timeStep->splitMultiDiscrPerGeoTypes();
+      if(szOut==std::numeric_limits<std::size_t>::max())
+        szOut=items[i].size();
+      else
+        if(items[i].size()!=szOut)
+          throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes : The splitting per discretization is expected to be same among time steps !");
+    }
+  if(szOut==std::numeric_limits<std::size_t>::max())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::splitMultiDiscrPerGeoTypes : empty field !");
+  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > ret(szOut);
+  for(std::size_t i=0;i<szOut;i++)
+    {
+      MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> elt(createNew());
+      for(std::size_t j=0;j<sz;j++)
+        elt->pushBackTimeStep(items[j][i]);
+      ret[i]=elt;
+      elt->MEDFileFieldNameScope::operator=(*this);
+    }
+  return ret;
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr)
+{
+  setName(field->getName());
+  if(field->getMesh())
+    setMeshName(field->getMesh()->getName());
+  if(_name.empty())
+    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::copyTinyInfoFrom : unsupported fields with no name in MED file !");
+  if(!arr)
+    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::copyTinyInfoFrom : no array set !");
+  _infos=arr->getInfoOnComponents();
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::checkCoherencyOfTinyInfo(const MEDCouplingFieldDouble *field, const DataArray *arr) const
+{
+  static const char MSG[]="MEDFileFieldMultiTSWithoutSDA::checkCoherencyOfTinyInfo : invalid ";
+  if(_name!=field->getName())
+    {
+      std::ostringstream oss; oss << MSG << "name ! should be \"" << _name;
+      oss << "\" and it is set in input field to \"" << field->getName() << "\" !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  if(!arr)
+    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::checkCoherencyOfTinyInfo : no array set !");
+  checkThatComponentsMatch(arr->getInfoOnComponents());
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::checkThatComponentsMatch(const std::vector<std::string>& compos) const
+{
+  static const char MSG[]="MEDFileFieldMultiTSWithoutSDA::checkThatComponentsMatch : ";
+  if(getInfo().size()!=compos.size())
+    {
+      std::ostringstream oss; oss << MSG << "mismatch of number of components between this (" << getInfo().size() << ") and ";
+      oss << " number of components of element to append (" << compos.size() << ") !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  if(_infos!=compos)
+    {
+      std::ostringstream oss; oss << MSG << "components have same size but are different ! should be \"";
+      std::copy(_infos.begin(),_infos.end(),std::ostream_iterator<std::string>(oss,", "));
+      oss << " But compo in input fields are : ";
+      std::copy(compos.begin(),compos.end(),std::ostream_iterator<std::string>(oss,", "));
+      oss << " !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::checkThatNbOfCompoOfTSMatchThis() const
+{
+  std::size_t sz=_infos.size();
+  int j=0;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,j++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *elt(*it);
+      if(elt)
+        if(elt->getInfo().size()!=sz)
+          {
+            std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::checkThatNbOfCompoOfTSMatchThis : At pos #" << j << " the number of components is equal to ";
+            oss << elt->getInfo().size() << " whereas it is expected to be equal to " << sz << " !";
+            throw INTERP_KERNEL::Exception(oss.str());
+          }
+    }
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::appendFieldNoProfileSBT(const MEDCouplingFieldDouble *field, const DataArray *arr, MEDFileFieldGlobsReal& glob)
+{
+  if(!field)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::appendFieldNoProfileSBT : input field is NULL !");
+  if(!_time_steps.empty())
+    checkCoherencyOfTinyInfo(field,arr);
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> obj(createNew1TSWithoutSDAEmptyInstance());
+  {
+    MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::New(*field));
+    obj->setFieldNoProfileSBT(field->timeDiscrSafe(),ft,arr,glob,*this);
+  }
+  copyTinyInfoFrom(field,arr);
+  _time_steps.push_back(obj);
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::appendFieldProfile(const MEDCouplingFieldDouble *field, const DataArray *arr, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob, bool smartPflKiller)
+{
+  if(!field)
+    throw INTERP_KERNEL::Exception("MEDFileIntFieldMultiTSWithoutSDA::appendFieldNoProfileSBT : input field is NULL !");
+  if(!_time_steps.empty())
+    checkCoherencyOfTinyInfo(field,arr);
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> obj(createNew1TSWithoutSDAEmptyInstance());
+  {
+    MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::NewWithoutCheck(*field));
+    obj->setFieldProfile(field->timeDiscrSafe(),ft,arr,mesh,meshDimRelToMax,profile,glob,*this,smartPflKiller);
+  }
+  copyTinyInfoFrom(field,arr);
+  setMeshName(obj->getMeshName());
+  _time_steps.push_back(obj);
+}
+
+void MEDFileAnyTypeFieldMultiTSWithoutSDA::setIteration(int i, MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ts)
+{
+  int sz=(int)_time_steps.size();
+  if(i<0 || i>=sz)
+    {
+      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::setIteration : trying to set element at place #" << i << " should be in [0," << sz << ") !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  const MEDFileAnyTypeField1TSWithoutSDA *tsPtr(ts);
+  if(tsPtr)
+    {
+      if(tsPtr->getNumberOfComponents()!=(int)_infos.size())
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTSWithoutSDA::setIteration : trying to set element with " << tsPtr->getNumberOfComponents() << " components ! Should be " << _infos.size() <<  " !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  _time_steps[i]=ts;
+}
+
+//= MEDFileFieldMultiTSWithoutSDA
+
+/*!
+ * entry point for users that want to iterate into MEDFile DataStructure with a reduced overhead because output arrays are extracted (created) specially
+ * for the call of this method. That's why the DataArrayDouble instance in returned vector of vector should be dealed by the caller.
+ */
+std::vector< std::vector<DataArrayDouble *> > MEDFileFieldMultiTSWithoutSDA::getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  const MEDFileAnyTypeField1TSWithoutSDA& myF1TS=getTimeStepEntry(iteration,order);
+  const MEDFileField1TSWithoutSDA *myF1TSC=dynamic_cast<const MEDFileField1TSWithoutSDA *>(&myF1TS);
+  if(!myF1TSC)
+    throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::getFieldSplitedByType2 : mismatch of type of field expecting FLOAT64 !");
+  return myF1TSC->getFieldSplitedByType2(mname,types,typesF,pfls,locs);
+}
+
+MEDFileIntFieldMultiTSWithoutSDA *MEDFileFieldMultiTSWithoutSDA::convertToInt() const
+{
+  MCAuto<MEDFileIntFieldMultiTSWithoutSDA> ret(new MEDFileIntFieldMultiTSWithoutSDA);
+  ret->MEDFileAnyTypeFieldMultiTSWithoutSDA::operator =(*this);
+  int i=0;
+  for(std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> >::const_iterator it=_time_steps.begin();it!=_time_steps.end();it++,i++)
+    {
+      const MEDFileAnyTypeField1TSWithoutSDA *eltToConv(*it);
+      if(eltToConv)
+        {
+          const MEDFileField1TSWithoutSDA *eltToConvC=dynamic_cast<const MEDFileField1TSWithoutSDA *>(eltToConv);
+          if(!eltToConvC)
+            throw INTERP_KERNEL::Exception("MEDFileFieldMultiTSWithoutSDA::convertToInt : presence of an invalid 1TS type ! Should be of type FLOAT64 !");
+          MCAuto<MEDFileAnyTypeField1TSWithoutSDA> elt=eltToConvC->convertToInt();
+          ret->setIteration(i,elt);
+        }
+    }
+  return ret.retn();
+}
+
+//= MEDFileAnyTypeFieldMultiTS
+
+MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS()
+{
+}
+
+MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
+try:MEDFileFieldGlobsReal(fid)
+{
+  _content=BuildContentFrom(fid,loadAll,ms);
+  loadGlobals(fid);
+}
+catch(INTERP_KERNEL::Exception& e)
+{
+    throw e;
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+{
+  med_field_type typcha;
+  std::vector<std::string> infos;
+  std::string dtunit;
+  std::string meshName;
+  int i(-1);
+  MEDFileAnyTypeField1TS::LocateField(fid,fieldName,i,typcha,infos,dtunit,meshName);
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret;
+  switch(typcha)
+  {
+    case MED_FLOAT64:
+      {
+        ret=new MEDFileFieldMultiTSWithoutSDA(fid,i,loadAll,ms,entities);
+        break;
+      }
+    case MED_INT32:
+      {
+        ret=new MEDFileIntFieldMultiTSWithoutSDA(fid,i,loadAll,ms,entities);
+        break;
+      }
+    case MED_FLOAT32:
+      {
+        ret=new MEDFileFloatFieldMultiTSWithoutSDA(fid,i,loadAll,ms,entities);
+        break;
+      }
+    case MED_INT:
+      {
+        if(sizeof(med_int)==sizeof(int))
+          {
+            ret=new MEDFileIntFieldMultiTSWithoutSDA(fid,i,loadAll,ms,entities);
+            break;
+          }
+      }
+    default:
+      {
+        std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::BuildContentFrom(fid,fieldName) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
+        throw INTERP_KERNEL::Exception(oss.str());
+      }
+  }
+  ret->setMeshName(meshName);
+  ret->setDtUnit(dtunit.c_str());
+  return ret.retn();
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
+{
+  med_field_type typcha;
+  //
+  std::vector<std::string> infos;
+  std::string dtunit,fieldName,meshName;
+  MEDFileAnyTypeField1TS::LocateField2(fid,0,true,fieldName,typcha,infos,dtunit,meshName);
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> ret;
+  switch(typcha)
+  {
+    case MED_FLOAT64:
+      {
+        ret=new MEDFileFieldMultiTSWithoutSDA(fid,0,loadAll,ms,0);
+        break;
+      }
+    case MED_INT32:
+      {
+        ret=new MEDFileIntFieldMultiTSWithoutSDA(fid,0,loadAll,ms,0);
+        break;
+      }
+    case MED_FLOAT32:
+      {
+        ret=new MEDFileFloatFieldMultiTSWithoutSDA(fid,0,loadAll,ms,0);
+        break;
+      }
+    case MED_INT:
+      {
+        if(sizeof(med_int)==sizeof(int))
+          {
+            ret=new MEDFileIntFieldMultiTSWithoutSDA(fid,0,loadAll,ms,0);
+            break;
+          }
+      }
+    default:
+      {
+        std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::BuildContentFrom(fid) : file \'" << FileNameFromFID(fid) << "\' contains field with name \'" << fieldName << "\' but the type of the first field is not in [MED_FLOAT64, MED_INT32, MED_FLOAT32] !";
+        throw INTERP_KERNEL::Exception(oss.str());
+      }
+  }
+  ret->setMeshName(meshName);
+  ret->setDtUnit(dtunit.c_str());
+  return ret.retn();
+}
+
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c)
+{
+  if(!c)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent : empty content in input : unable to build a new instance !");
+  if(dynamic_cast<const MEDFileFieldMultiTSWithoutSDA *>(c))
+    {
+      MCAuto<MEDFileFieldMultiTS> ret(MEDFileFieldMultiTS::New());
+      ret->_content=c;  c->incrRef();
+      return ret.retn();
+    }
+  if(dynamic_cast<const MEDFileIntFieldMultiTSWithoutSDA *>(c))
+    {
+      MCAuto<MEDFileIntFieldMultiTS> ret(MEDFileIntFieldMultiTS::New());
+      ret->_content=c;  c->incrRef();
+      return ret.retn();
+    }
+  if(dynamic_cast<const MEDFileFloatFieldMultiTSWithoutSDA *>(c))
+    {
+      MCAuto<MEDFileFloatFieldMultiTS> ret(MEDFileFloatFieldMultiTS::New());
+      ret->_content=c;  c->incrRef();
+      return ret.retn();
+    }
+  throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent : internal error ! a content of type different from FLOAT64 FLOAT32 and INT32 has been built but not intercepted !");
+}
+
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c, med_idt fid)
+{
+  MEDFileAnyTypeFieldMultiTS *ret(BuildNewInstanceFromContent(c));
+  std::string fileName(FileNameFromFID(fid));
+  ret->setFileName(fileName);
+  return ret;
+}
+
+MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+try:MEDFileFieldGlobsReal(fid)
+{
+  _content=BuildContentFrom(fid,fieldName,loadAll,ms,entities);
+  loadGlobals(fid);
+}
+catch(INTERP_KERNEL::Exception& e)
+{
+    throw e;
+}
+
+//= MEDFileAnyTypeFieldMultiTS
+
+/*!
+ * Returns a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS holding data of the first field
+ * that has been read from a specified MED file.
+ *  \param [in] fileName - the name of the MED file to read.
+ *  \return MEDFileFieldMultiTS * - a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS. The caller
+ *          is to delete this field using decrRef() as it is no more needed.
+ *  \throw If reading the file fails.
+ */
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(const std::string& fileName, bool loadAll)
+{
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
+  return New(fid,loadAll);
+}
+
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(med_idt fid, bool loadAll)
+{
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c(BuildContentFrom(fid,loadAll,0));
+  MCAuto<MEDFileAnyTypeFieldMultiTS> ret(BuildNewInstanceFromContent(c,fid));
+  ret->loadGlobals(fid);
+  return ret.retn();
+}
+
+/*!
+ * Returns a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS holding data of a given field
+ * that has been read from a specified MED file.
+ *  \param [in] fileName - the name of the MED file to read.
+ *  \param [in] fieldName - the name of the field to read.
+ *  \return MEDFileFieldMultiTS * - a new instance of MEDFileFieldMultiTS or MEDFileIntFieldMultiTS. The caller
+ *          is to delete this field using decrRef() as it is no more needed.
+ *  \throw If reading the file fails.
+ *  \throw If there is no field named \a fieldName in the file.
+ */
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(const std::string& fileName, const std::string& fieldName, bool loadAll)
+{
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(fileName));
+  return New(fid,fieldName,loadAll);
+}
+
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::New(med_idt fid, const std::string& fieldName, bool loadAll)
+{
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c(BuildContentFrom(fid,fieldName,loadAll,0,0));
+  MCAuto<MEDFileAnyTypeFieldMultiTS> ret(BuildNewInstanceFromContent(c,fid));
+  ret->loadGlobals(fid);
+  return ret.retn();
+}
+
+/*!
+ * This constructor is a shallow copy constructor. If \a shallowCopyOfContent is true the content of \a other is shallow copied.
+ * If \a shallowCopyOfContent is false, \a other is taken to be the content of \a this.
+ *
+ * \warning this is a shallow copy constructor
+ */
+MEDFileAnyTypeFieldMultiTS::MEDFileAnyTypeFieldMultiTS(const MEDFileAnyTypeFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent)
+{
+  if(!shallowCopyOfContent)
+    {
+      const MEDFileAnyTypeFieldMultiTSWithoutSDA *otherPtr(&other);
+      otherPtr->incrRef();
+      _content=const_cast<MEDFileAnyTypeFieldMultiTSWithoutSDA *>(otherPtr);
+    }
+  else
+    {
+      _content=other.shallowCpy();
+    }
+}
+
+MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::contentNotNullBase()
+{
+  MEDFileAnyTypeFieldMultiTSWithoutSDA *ret=_content;
+  if(!ret)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS : content is expected to be not null !");
+  return ret;
+}
+
+const MEDFileAnyTypeFieldMultiTSWithoutSDA *MEDFileAnyTypeFieldMultiTS::contentNotNullBase() const
+{
+  const MEDFileAnyTypeFieldMultiTSWithoutSDA *ret=_content;
+  if(!ret)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS : const content is expected to be not null !");
+  return ret;
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getPflsReallyUsed() const
+{
+  return contentNotNullBase()->getPflsReallyUsed2();
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getLocsReallyUsed() const
+{
+  return contentNotNullBase()->getLocsReallyUsed2();
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getPflsReallyUsedMulti() const
+{
+  return contentNotNullBase()->getPflsReallyUsedMulti2();
+}
+
+std::vector<std::string> MEDFileAnyTypeFieldMultiTS::getLocsReallyUsedMulti() const
+{
+  return contentNotNullBase()->getLocsReallyUsedMulti2();
+}
+
+void MEDFileAnyTypeFieldMultiTS::changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  contentNotNullBase()->changePflsRefsNamesGen2(mapOfModif);
+}
+
+void MEDFileAnyTypeFieldMultiTS::changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif)
+{
+  contentNotNullBase()->changeLocsRefsNamesGen2(mapOfModif);
+}
+
+int MEDFileAnyTypeFieldMultiTS::getNumberOfTS() const
+{
+  return contentNotNullBase()->getNumberOfTS();
+}
+
+void MEDFileAnyTypeFieldMultiTS::eraseEmptyTS()
+{
+  contentNotNullBase()->eraseEmptyTS();
+}
+
+void MEDFileAnyTypeFieldMultiTS::eraseTimeStepIds(const int *startIds, const int *endIds)
+{
+  contentNotNullBase()->eraseTimeStepIds(startIds,endIds);
+}
+
+void MEDFileAnyTypeFieldMultiTS::eraseTimeStepIds2(int bg, int end, int step)
+{
+  contentNotNullBase()->eraseTimeStepIds2(bg,end,step);
+}
+
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::buildSubPart(const int *startIds, const int *endIds) const
+{
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c=contentNotNullBase()->buildFromTimeStepIds(startIds,endIds);
+  MCAuto<MEDFileAnyTypeFieldMultiTS> ret=shallowCpy();
+  ret->_content=c;
+  return ret.retn();
+}
+
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::buildSubPartSlice(int bg, int end, int step) const
+{
+  MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> c=contentNotNullBase()->buildFromTimeStepIds2(bg,end,step);
+  MCAuto<MEDFileAnyTypeFieldMultiTS> ret=shallowCpy();
+  ret->_content=c;
+  return ret.retn();
+}
+
+std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTS::getIterations() const
+{
+  return contentNotNullBase()->getIterations();
+}
+
+void MEDFileAnyTypeFieldMultiTS::pushBackTimeSteps(const std::vector<MEDFileAnyTypeField1TS *>& f1ts)
+{
+  for(std::vector<MEDFileAnyTypeField1TS *>::const_iterator it=f1ts.begin();it!=f1ts.end();it++)
+    pushBackTimeStep(*it);
+}
+
+void MEDFileAnyTypeFieldMultiTS::pushBackTimeSteps(MEDFileAnyTypeFieldMultiTS *fmts)
+{
+  if(!fmts)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::pushBackTimeSteps : Input fmts is NULL !");
+  int nbOfTS(fmts->getNumberOfTS());
+  for(int i=0;i<nbOfTS;i++)
+    {
+      MCAuto<MEDFileAnyTypeField1TS> elt(fmts->getTimeStepAtPos(i));
+      pushBackTimeStep(elt);
+    }
+}
+
+void MEDFileAnyTypeFieldMultiTS::pushBackTimeStep(MEDFileAnyTypeField1TS *f1ts)
+{
+  if(!f1ts)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep : input pointer is NULL !");
+  checkCoherencyOfType(f1ts);
+  f1ts->incrRef();
+  MCAuto<MEDFileAnyTypeField1TS> f1tsSafe(f1ts);
+  MEDFileAnyTypeField1TSWithoutSDA *c=f1ts->contentNotNullBase();
+  c->incrRef();
+  MCAuto<MEDFileAnyTypeField1TSWithoutSDA> cSafe(c);
+  if(!((MEDFileAnyTypeFieldMultiTSWithoutSDA *)_content))
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTSWithoutSDA::pushBackTimeStep : no content in this !");
+  _content->pushBackTimeStep(cSafe);
+  appendGlobs(*f1ts,1e-12);
+}
+
+void MEDFileAnyTypeFieldMultiTS::synchronizeNameScope()
+{
+  contentNotNullBase()->synchronizeNameScope();
+}
+
+int MEDFileAnyTypeFieldMultiTS::getPosOfTimeStep(int iteration, int order) const
+{
+  return contentNotNullBase()->getPosOfTimeStep(iteration,order);
+}
+
+int MEDFileAnyTypeFieldMultiTS::getPosGivenTime(double time, double eps) const
+{
+  return contentNotNullBase()->getPosGivenTime(time,eps);
+}
+
+int MEDFileAnyTypeFieldMultiTS::getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const
+{
+  return contentNotNullBase()->getNonEmptyLevels(iteration,order,mname,levs);
+}
+
+std::vector< std::vector<TypeOfField> > MEDFileAnyTypeFieldMultiTS::getTypesOfFieldAvailable() const
+{
+  return contentNotNullBase()->getTypesOfFieldAvailable();
+}
+
+std::vector< std::vector< std::pair<int,int> > > MEDFileAnyTypeFieldMultiTS::getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  return contentNotNullBase()->getFieldSplitedByType(iteration,order,mname,types,typesF,pfls,locs);
+}
+
+std::string MEDFileAnyTypeFieldMultiTS::getName() const
+{
+  return contentNotNullBase()->getName();
+}
+
+void MEDFileAnyTypeFieldMultiTS::setName(const std::string& name)
+{
+  contentNotNullBase()->setName(name);
+}
+
+std::string MEDFileAnyTypeFieldMultiTS::getDtUnit() const
+{
+  return contentNotNullBase()->getDtUnit();
+}
+
+void MEDFileAnyTypeFieldMultiTS::setDtUnit(const std::string& dtUnit)
+{
+  contentNotNullBase()->setDtUnit(dtUnit);
+}
+
+void MEDFileAnyTypeFieldMultiTS::simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const
+{
+  contentNotNullBase()->simpleRepr(bkOffset,oss,fmtsId);
+}
+
+std::vector< std::pair<int,int> > MEDFileAnyTypeFieldMultiTS::getTimeSteps(std::vector<double>& ret1) const
+{
+  return contentNotNullBase()->getTimeSteps(ret1);
+}
+
+std::string MEDFileAnyTypeFieldMultiTS::getMeshName() const
+{
+  return contentNotNullBase()->getMeshName();
+}
+
+void MEDFileAnyTypeFieldMultiTS::setMeshName(const std::string& newMeshName)
+{
+  contentNotNullBase()->setMeshName(newMeshName);
+}
+
+bool MEDFileAnyTypeFieldMultiTS::changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab)
+{
+  return contentNotNullBase()->changeMeshNames(modifTab);
+}
+
+const std::vector<std::string>& MEDFileAnyTypeFieldMultiTS::getInfo() const
+{
+  return contentNotNullBase()->getInfo();
+}
+
+bool MEDFileAnyTypeFieldMultiTS::presenceOfMultiDiscPerGeoType() const
+{
+  return contentNotNullBase()->presenceOfMultiDiscPerGeoType();
+}
+
+void MEDFileAnyTypeFieldMultiTS::setInfo(const std::vector<std::string>& info)
+{
+  return contentNotNullBase()->setInfo(info);
+}
+
+int MEDFileAnyTypeFieldMultiTS::getNumberOfComponents() const
+{
+  const std::vector<std::string> ret=getInfo();
+  return (int)ret.size();
+}
+
+void MEDFileAnyTypeFieldMultiTS::writeLL(med_idt fid) const
+{
+  writeGlobals(fid,*this);
+  contentNotNullBase()->writeLL(fid,*this);
+}
+
+/*!
+ * This method alloc the arrays and load potentially huge arrays contained in this field.
+ * This method should be called when a MEDFileAnyTypeFieldMultiTS::New constructor has been with false as the last parameter.
+ * This method can be also called to refresh or reinit values from a file.
+ * 
+ * \throw If the fileName is not set or points to a non readable MED file.
+ */
+void MEDFileAnyTypeFieldMultiTS::loadArrays()
+{
+  if(getFileName().empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::loadArrays : the structure does not come from a file !");
+  MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
+  contentNotNullBase()->loadBigArraysRecursively(fid,*contentNotNullBase());
+}
+
+/*!
+ * This method behaves as MEDFileAnyTypeFieldMultiTS::loadArrays does, the first call, if \a this was built using a file without loading big arrays.
+ * But once data loaded once, this method does nothing.
+ * 
+ * \throw If the fileName is not set or points to a non readable MED file.
+ * \sa MEDFileAnyTypeFieldMultiTS::loadArrays, MEDFileAnyTypeFieldMultiTS::unloadArrays
+ */
+void MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary()
+{
+  if(!getFileName().empty())
+    {
+      MEDFileUtilities::AutoFid fid(OpenMEDFileForRead(getFileName()));
+      contentNotNullBase()->loadBigArraysRecursivelyIfNecessary(fid,*contentNotNullBase());
+    }
+}
+
+/*!
+ * This method releases potentially big data arrays and so returns to the same heap memory than status loaded with 'loadAll' parameter set to false.
+ * \b WARNING, this method does release arrays even if \a this does not come from a load of a MED file.
+ * So this method can lead to a loss of data. If you want to unload arrays safely call MEDFileAnyTypeFieldMultiTS::unloadArraysWithoutDataLoss instead.
+ * 
+ * \sa MEDFileAnyTypeFieldMultiTS::loadArrays, MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary, MEDFileAnyTypeFieldMultiTS::unloadArraysWithoutDataLoss
+ */
+void MEDFileAnyTypeFieldMultiTS::unloadArrays()
+{
+  contentNotNullBase()->unloadArrays();
+}
+
+/*!
+ * This method potentially releases big data arrays if \a this is coming from a file. If \a this has been built from scratch this method will have no effect.
+ * This method is the symmetrical method of MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary.
+ * This method is useful to reduce \b safely amount of heap memory necessary for \a this by using MED file as database.
+ * 
+ * \sa MEDFileAnyTypeFieldMultiTS::loadArraysIfNecessary
+ */
+void MEDFileAnyTypeFieldMultiTS::unloadArraysWithoutDataLoss()
+{
+  if(!getFileName().empty())
+    contentNotNullBase()->unloadArrays();
+}
+
+std::string MEDFileAnyTypeFieldMultiTS::simpleRepr() const
+{
+  std::ostringstream oss;
+  contentNotNullBase()->simpleRepr(0,oss,-1);
+  simpleReprGlobs(oss);
+  return oss.str();
+}
+
+std::size_t MEDFileAnyTypeFieldMultiTS::getHeapMemorySizeWithoutChildren() const
+{
+  return MEDFileFieldGlobsReal::getHeapMemorySizeWithoutChildren();
+}
+
+std::vector<const BigMemoryObject *> MEDFileAnyTypeFieldMultiTS::getDirectChildrenWithNull() const
+{
+  std::vector<const BigMemoryObject *> ret(MEDFileFieldGlobsReal::getDirectChildrenWithNull());
+  ret.push_back((const MEDFileAnyTypeFieldMultiTSWithoutSDA *)_content);
+  return ret;
+}
+
+/*!
+ * This method returns as MEDFileAnyTypeFieldMultiTS new instances as number of components in \a this.
+ * The returned instances are deep copy of \a this except that for globals that are shared with those contained in \a this.
+ * ** WARNING ** do no forget to rename the output instances to avoid to write n-times in the same MED file field !
+ */
+std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > MEDFileAnyTypeFieldMultiTS::splitComponents() const
+{
+  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
+  if(!content)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::splitComponents : no content in this ! Unable to split components !");
+  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > contentsSplit=content->splitComponents();
+  std::size_t sz(contentsSplit.size());
+  std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > ret(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      ret[i]=shallowCpy();
+      ret[i]->_content=contentsSplit[i];
+    }
+  return ret;
+}
+
+/*!
+ * This method returns as MEDFileAnyTypeFieldMultiTS new instances as number of discretizations over time steps in \a this.
+ * The returned instances are shallow copied of \a this included globals that are shared with those contained in \a this.
+ */
+std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > MEDFileAnyTypeFieldMultiTS::splitDiscretizations() const
+{
+  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
+  if(!content)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::splitDiscretizations : no content in this ! Unable to split discretizations !");
+  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > contentsSplit(content->splitDiscretizations());
+  std::size_t sz(contentsSplit.size());
+  std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > ret(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      ret[i]=shallowCpy();
+      ret[i]->_content=contentsSplit[i];
+    }
+  return ret;
+}
+
+/*!
+ * This method returns as MEDFileAnyTypeFieldMultiTS new instances as number of sub-discretizations over time steps in \a this.
+ * The returned instances are shallow copied of \a this included globals that are shared with those contained in \a this.
+ */
+std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > MEDFileAnyTypeFieldMultiTS::splitMultiDiscrPerGeoTypes() const
+{
+  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
+  if(!content)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::splitMultiDiscrPerGeoTypes : no content in this ! Unable to split discretizations !");
+  std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > contentsSplit(content->splitMultiDiscrPerGeoTypes());
+  std::size_t sz(contentsSplit.size());
+  std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > ret(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      ret[i]=shallowCpy();
+      ret[i]->_content=contentsSplit[i];
+    }
+  return ret;
+}
+
+MEDFileAnyTypeFieldMultiTS *MEDFileAnyTypeFieldMultiTS::deepCopy() const
+{
+  MCAuto<MEDFileAnyTypeFieldMultiTS> ret=shallowCpy();
+  if((const MEDFileAnyTypeFieldMultiTSWithoutSDA *)_content)
+    ret->_content=_content->deepCopy();
+  ret->deepCpyGlobs(*this);
+  return ret.retn();
+}
+
+MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> MEDFileAnyTypeFieldMultiTS::getContent()
+{
+  return _content;
+}
+
+/*!
+ * Returns a new MEDFileField1TS or MEDFileIntField1TS holding data of a given time step of \a this field.
+ *  \param [in] iteration - the iteration number of a required time step.
+ *  \param [in] order - the iteration order number of required time step.
+ *  \return MEDFileField1TS * or MEDFileIntField1TS *- a new instance of MEDFileField1TS or MEDFileIntField1TS. The caller is to
+ *          delete this field using decrRef() as it is no more needed.
+ *  \throw If there is no required time step in \a this field.
+ */
+MEDFileAnyTypeField1TS *MEDFileAnyTypeFieldMultiTS::getTimeStep(int iteration, int order) const
+{
+  int pos=getPosOfTimeStep(iteration,order);
+  return getTimeStepAtPos(pos);
+}
+
+/*!
+ * Returns a new MEDFileField1TS or MEDFileIntField1TS holding data of a given time step of \a this field.
+ *  \param [in] time - the time of the time step of interest.
+ *  \param [in] eps - a precision used to compare time values.
+ *  \return MEDFileField1TS * - a new instance of MEDFileField1TS. The caller is to
+ *          delete this field using decrRef() as it is no more needed.
+ *  \throw If there is no required time step in \a this field.
+ */
+MEDFileAnyTypeField1TS *MEDFileAnyTypeFieldMultiTS::getTimeStepGivenTime(double time, double eps) const
+{
+  int pos=getPosGivenTime(time,eps);
+  return getTimeStepAtPos(pos);
+}
+
+/*!
+ * This method groups not null items in \a vectFMTS per time step series. Two time series are considered equal if the list of their pair of integers iteration,order are equal.
+ * The float64 value of time attached to the pair of integers are not considered here.
+ * WARNING the returned pointers are not incremented. The caller is \b not responsible to deallocate them ! This method only reorganizes entries in \a vectFMTS.
+ *
+ * \param [in] vectFMTS - vector of not null fields defined on a same global data pointer.
+ * \throw If there is a null pointer in \a vectFMTS.
+ */
+std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > MEDFileAnyTypeFieldMultiTS::SplitIntoCommonTimeSeries(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS)
+{
+  static const char msg[]="MEDFileAnyTypeFieldMultiTS::SplitIntoCommonTimeSeries : presence of null instance in input vector !";
+  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > ret;
+  std::list<MEDFileAnyTypeFieldMultiTS *> lstFMTS(vectFMTS.begin(),vectFMTS.end());
+  while(!lstFMTS.empty())
+    {
+      std::list<MEDFileAnyTypeFieldMultiTS *>::iterator it(lstFMTS.begin());
+      MEDFileAnyTypeFieldMultiTS *curIt(*it);
+      if(!curIt)
+        throw INTERP_KERNEL::Exception(msg);
+      std::vector< std::pair<int,int> > refIts=curIt->getIterations();
+      std::vector<MEDFileAnyTypeFieldMultiTS *> elt;
+      elt.push_back(curIt); it=lstFMTS.erase(it);
+      while(it!=lstFMTS.end())
+        {
+          curIt=*it;
+          if(!curIt)
+            throw INTERP_KERNEL::Exception(msg);
+          std::vector< std::pair<int,int> > curIts=curIt->getIterations();
+          if(refIts==curIts)
+            { elt.push_back(curIt); it=lstFMTS.erase(it); }
+          else
+            it++;
+        }
+      ret.push_back(elt);
+    }
+  return ret;
+}
+
+/*!
+ * This method splits the input list \a vectFMTS considering the aspect of the geometrical support over time.
+ * All returned instances in a subvector can be safely loaded, rendered along time
+ * All items must be defined on the same time step ids ( see MEDFileAnyTypeFieldMultiTS::SplitIntoCommonTimeSeries method ).
+ * Each item in \a vectFMTS is expected to have one and exactly one spatial discretization along time.
+ * All items in \a vectFMTS must lie on the mesh (located by meshname and time step) and compatible with the input mesh \a mesh (having the same name than those in items).
+ * All items in \a vectFMTS whose spatial discretization is not ON_NODES will appear once.
+ * For items in \a vectFMTS that are ON_NODES it is possible to appear several times (more than once or once) in the returned vector.
+ *
+ * \param [in] vectFMTS - list of multi times step part all defined each on a same spatial discretization along time and pointing to a mesh whose name is equal to \c mesh->getName().
+ * \param [in] mesh - the mesh shared by all items in \a vectFMTS across time.
+ * \param [out] fsc - A vector having same size than returned vector. It specifies the support comporator of the corresponding vector of MEDFileAnyTypeFieldMultiTS in returned vector of vector.
+ * \return - A vector of vector of objects that contains the same pointers (objects) than thoose in \a vectFMTS except that there are organized differently. So pointers included in returned vector of vector should \b not been dealt by the caller.
+ *
+ * \throw If an element in \a vectFMTS has not only one spatial discretization set.
+ * \throw If an element in \a vectFMTS change of spatial discretization along time.
+ * \throw If an element in \a vectFMTS lies on a mesh with meshname different from those in \a mesh.
+ * \thorw If some elements in \a vectFMTS do not have the same times steps.
+ * \throw If mesh is null.
+ * \throw If an element in \a vectFMTS is null.
+ * \sa MEDFileAnyTypeFieldMultiTS::AreOnSameSupportAcrossTime
+ */
+std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& fsc)
+{
+  static const char msg[]="MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport : presence of a null instance in the input vector !";
+  if(!mesh)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport : input mesh is null !");
+  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > ret;
+  if(vectFMTS.empty())
+    return ret;
+  std::vector<MEDFileAnyTypeFieldMultiTS *>::const_iterator it(vectFMTS.begin());
+  MEDFileAnyTypeFieldMultiTS *frstElt(*it);
+  if(!frstElt)
+    throw INTERP_KERNEL::Exception(msg);
+  std::size_t i=0;
+  std::vector<MEDFileAnyTypeFieldMultiTS *> vectFMTSNotNodes;
+  std::vector<MEDFileAnyTypeFieldMultiTS *> vectFMTSNodes;
+  for(;it!=vectFMTS.end();it++,i++)
+    {
+      if(!(*it))
+        throw INTERP_KERNEL::Exception(msg);
+      TypeOfField tof0,tof1;
+      if(CheckSupportAcrossTime(frstElt,*it,mesh,tof0,tof1)>0)
+        {
+          if(tof1!=ON_NODES)
+            vectFMTSNotNodes.push_back(*it);
+          else
+            vectFMTSNodes.push_back(*it);
+        }
+      else
+        vectFMTSNotNodes.push_back(*it);
+    }
+  std::vector< MCAuto<MEDFileFastCellSupportComparator> > cmps;
+  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > retCell=SplitPerCommonSupportNotNodesAlg(vectFMTSNotNodes,mesh,cmps);
+  ret=retCell;
+  for(std::vector<MEDFileAnyTypeFieldMultiTS *>::const_iterator it2=vectFMTSNodes.begin();it2!=vectFMTSNodes.end();it2++)
+    {
+      i=0;
+      bool isFetched(false);
+      for(std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> >::const_iterator it0=retCell.begin();it0!=retCell.end();it0++,i++)
+        {
+          if((*it0).empty())
+            throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport : internal error !");
+          if(cmps[i]->isCompatibleWithNodesDiscr(*it2))
+            { ret[i].push_back(*it2); isFetched=true; }
+        }
+      if(!isFetched)
+        {
+          std::vector<MEDFileAnyTypeFieldMultiTS *> tmp(1,*it2);
+          MCAuto<MEDFileMeshStruct> tmp2(MEDFileMeshStruct::New(mesh));
+          ret.push_back(tmp); retCell.push_back(tmp); cmps.push_back(MEDFileFastCellSupportComparator::New(tmp2,*it2));
+        }
+    }
+  fsc=cmps;
+  return ret;
+}
+
+/*!
+ * WARNING no check here. The caller must be sure that all items in vectFMTS are coherent each other in time steps, only one same spatial discretization and not ON_NODES.
+ * \param [out] cmps - same size than the returned vector.
+ */
+std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupportNotNodesAlg(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& cmps)
+{
+  std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > ret;
+  std::list<MEDFileAnyTypeFieldMultiTS *> lstFMTS(vectFMTS.begin(),vectFMTS.end());
+  while(!lstFMTS.empty())
+    {
+      std::list<MEDFileAnyTypeFieldMultiTS *>::iterator it(lstFMTS.begin());
+      MEDFileAnyTypeFieldMultiTS *ref(*it);
+      std::vector<MEDFileAnyTypeFieldMultiTS *> elt;
+      elt.push_back(ref); it=lstFMTS.erase(it);
+      MCAuto<MEDFileMeshStruct> mst(MEDFileMeshStruct::New(mesh));
+      MCAuto<MEDFileFastCellSupportComparator> cmp(MEDFileFastCellSupportComparator::New(mst,ref));
+      while(it!=lstFMTS.end())
+        {
+          MEDFileAnyTypeFieldMultiTS *curIt(*it);
+          if(cmp->isEqual(curIt))
+            { elt.push_back(curIt); it=lstFMTS.erase(it); }
+          else
+            it++;
+        }
+      ret.push_back(elt); cmps.push_back(cmp);
+    }
+  return ret;
+}
+
+/*!
+ * This method scan the two main structs along time of \a f0 and \a f1 to see if there are all lying on the same mesh along time than those in \a mesh.
+ * \a f0 and \a f1 must be defined each only on a same spatial discretization even if this can be different each other.
+ *
+ * \throw If \a f0 or \a f1 has not only one spatial discretization set.
+ * \throw If \a f0 or \a f1 change of spatial discretization along time.
+ * \throw If \a f0 or \a f1 on a mesh with meshname different from those in \a mesh.
+ * \thorw If \a f0 and \a f1 do not have the same times steps.
+ * \throw If mesh is null.
+ * \throw If \a f0 or \a f1 is null.
+ * \sa MEDFileAnyTypeFieldMultiTS::SplitPerCommonSupport
+ */
+int MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime(MEDFileAnyTypeFieldMultiTS *f0, MEDFileAnyTypeFieldMultiTS *f1, const MEDFileMesh *mesh, TypeOfField& tof0, TypeOfField& tof1)
+{
+  if(!mesh)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : input mesh is null !");
+  if(!f0 || !f1)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : presence of null instance in fields over time !");
+  if(f0->getMeshName()!=mesh->getName())
+    {
+      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : first field points to mesh \""<< f0->getMeshName() << "\" and input mesh to compare has name \"" << mesh->getName() << "\" !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  if(f1->getMeshName()!=mesh->getName())
+    {
+      std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : second field points to mesh \""<< f1->getMeshName() << "\" and input mesh to compare has name \"" << mesh->getName() << "\" !";
+      throw INTERP_KERNEL::Exception(oss.str());
+    }
+  int nts=f0->getNumberOfTS();
+  if(nts!=f1->getNumberOfTS())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : number of time steps are not the same !");
+  if(nts==0)
+    return nts;
+  for(int i=0;i<nts;i++)
+    {
+      MCAuto<MEDFileAnyTypeField1TS> f0cur=f0->getTimeStepAtPos(i);
+      MCAuto<MEDFileAnyTypeField1TS> f1cur=f1->getTimeStepAtPos(i);
+      std::vector<TypeOfField> tofs0(f0cur->getTypesOfFieldAvailable()),tofs1(f1cur->getTypesOfFieldAvailable());
+      if(tofs0.size()!=1 || tofs1.size()!=1)
+        throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : All time steps must be defined on only one spatial discretization !");
+      if(i!=0)
+        {
+          if(tof0!=tofs0[0] || tof1!=tofs1[0])
+            throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : Across times steps MEDFileAnyTypeFieldMultiTS instances have to keep the same unique spatial discretization !");
+        }
+      else
+        { tof0=tofs0[0]; tof1=tofs1[0]; }
+      if(f0cur->getMeshIteration()!=mesh->getIteration() || f0cur->getMeshOrder()!=mesh->getOrder())
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : first field points to mesh time step (" << f0cur->getMeshIteration() << ","<< f0cur->getMeshOrder() << ") whereas input mesh points to time step (" << mesh->getIteration() << "," << mesh->getOrder() << ") !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      if(f1cur->getMeshIteration()!=mesh->getIteration() || f1cur->getMeshOrder()!=mesh->getOrder())
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : second field points to mesh time step (" << f1cur->getMeshIteration() << ","<< f1cur->getMeshOrder() << ") whereas input mesh points to time step (" << mesh->getIteration() << "," << mesh->getOrder() << ") !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+      if(f0cur->getIteration()!=f1cur->getIteration() || f0cur->getOrder()!=f1cur->getOrder())
+        {
+          std::ostringstream oss; oss << "MEDFileAnyTypeFieldMultiTS::CheckSupportAcrossTime : all the time steps must be the same ! it is not the case (" << f0cur->getIteration() << "," << f0cur->getOrder() << ")!=(" << f1cur->getIteration() << "," << f1cur->getOrder() << ") !";
+          throw INTERP_KERNEL::Exception(oss.str());
+        }
+    }
+  return nts;
+}
+
+template<class T>
+MCAuto<MEDFileAnyTypeField1TS> AggregateHelperF1TS(const std::vector< typename MLFieldTraits<T>::F1TSType const *>& f1tss, const std::vector< std::vector< std::pair<int,int> > >& dts)
+{
+  MCAuto< typename MLFieldTraits<T>::F1TSType > ret(MLFieldTraits<T>::F1TSType::New());
+  if(f1tss.empty())
+    throw INTERP_KERNEL::Exception("AggregateHelperF1TS : empty vector !");
+  std::size_t sz(f1tss.size()),i(0);
+  std::vector< typename MLFieldTraits<T>::F1TSWSDAType const *> f1tsw(sz);
+  for(typename std::vector< typename MLFieldTraits<T>::F1TSType const *>::const_iterator it=f1tss.begin();it!=f1tss.end();it++,i++)
+    {
+      typename MLFieldTraits<T>::F1TSType const *elt(*it);
+      if(!elt)
+        throw INTERP_KERNEL::Exception("AggregateHelperF1TS : presence of a null pointer !");
+      f1tsw[i]=dynamic_cast<typename MLFieldTraits<T>::F1TSWSDAType const *>(elt->contentNotNullBase());
+    }
+  typename MLFieldTraits<T>::F1TSWSDAType *retc(dynamic_cast<typename MLFieldTraits<T>::F1TSWSDAType *>(ret->contentNotNullBase()));
+  if(!retc)
+    throw INTERP_KERNEL::Exception("AggregateHelperF1TS : internal error 1 !");
+  retc->aggregate(f1tsw,dts);
+  ret->setDtUnit(f1tss[0]->getDtUnit());
+  return DynamicCast<typename MLFieldTraits<T>::F1TSType , MEDFileAnyTypeField1TS>(ret);
+}
+
+template<class T>
+MCAuto< MEDFileAnyTypeFieldMultiTS > AggregateHelperFMTS(const std::vector< typename MLFieldTraits<T>::FMTSType const *>& fmtss, const std::vector< std::vector< std::pair<int,int> > >& dts)
+{
+  MCAuto< typename MLFieldTraits<T>::FMTSType > ret(MLFieldTraits<T>::FMTSType::New());
+  if(fmtss.empty())
+    throw INTERP_KERNEL::Exception("AggregateHelperFMTS : empty vector !");
+  std::size_t sz(fmtss.size());
+  for(typename std::vector< typename MLFieldTraits<T>::FMTSType const *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++)
+    {
+      typename MLFieldTraits<T>::FMTSType const *elt(*it);
+      if(!elt)
+        throw INTERP_KERNEL::Exception("AggregateHelperFMTS : presence of null pointer !");
+    }
+  int nbTS(fmtss[0]->getNumberOfTS());
+  for(typename std::vector< typename MLFieldTraits<T>::FMTSType const *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++)
+    if((*it)->getNumberOfTS()!=nbTS)
+      throw INTERP_KERNEL::Exception("AggregateHelperFMTS : all fields must have the same number of TS !");
+  for(int iterTS=0;iterTS<nbTS;iterTS++)
+    {
+      std::size_t i(0);
+      std::vector< typename MLFieldTraits<T>::F1TSType const *> f1tss(sz);
+      std::vector< MCAuto<typename MLFieldTraits<T>::F1TSType> > f1tss2(sz);
+      for(typename std::vector< typename MLFieldTraits<T>::FMTSType const *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++,i++)
+        { f1tss2[i]=(*it)->getTimeStepAtPos(iterTS); f1tss[i]=f1tss2[i]; }
+      MCAuto<MEDFileAnyTypeField1TS> f1ts(AggregateHelperF1TS<T>(f1tss,dts));
+      ret->pushBackTimeStep(f1ts);
+      ret->setDtUnit(f1ts->getDtUnit());
+    }
+  return DynamicCast<typename MLFieldTraits<T>::FMTSType , MEDFileAnyTypeFieldMultiTS>(ret);
+}
+
+/*!
+ * \a dts and \a ftmss are expected to have same size.
+ */
+MCAuto<MEDFileAnyTypeFieldMultiTS> MEDFileAnyTypeFieldMultiTS::Aggregate(const std::vector<const MEDFileAnyTypeFieldMultiTS *>& fmtss, const std::vector< std::vector< std::pair<int,int> > >& dts)
+{
+  if(fmtss.empty())
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : input vector is empty !");
+  std::size_t sz(fmtss.size());
+  std::vector<const MEDFileFieldMultiTS *> fmtss1;
+  std::vector<const MEDFileIntFieldMultiTS *> fmtss2;
+  for(std::vector<const MEDFileAnyTypeFieldMultiTS *>::const_iterator it=fmtss.begin();it!=fmtss.end();it++)
+    {
+      if(!(*it))
+        throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : presence of null instance in input vector !");
+      const MEDFileFieldMultiTS *elt1(dynamic_cast<const MEDFileFieldMultiTS *>(*it));
+      if(elt1)
+        {
+          fmtss1.push_back(elt1);
+          continue;
+        }
+      const MEDFileIntFieldMultiTS *elt2(dynamic_cast<const MEDFileIntFieldMultiTS *>(*it));
+      if(elt2)
+        {
+          fmtss2.push_back(elt2);
+          continue;
+        }
+      throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : not recognized type !");
+    }
+  if(fmtss1.size()!=sz && fmtss2.size()!=sz)
+    throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : type of data is not homogeneous !");
+  if(fmtss1.size()==sz)
+    return AggregateHelperFMTS<double>(fmtss1,dts);
+  if(fmtss2.size()!=sz)
+    return AggregateHelperFMTS<int>(fmtss2,dts);
+  throw INTERP_KERNEL::Exception("MEDFileAnyTypeFieldMultiTS::Aggregate : not implemented yet !");
+}
+
+MEDFileAnyTypeFieldMultiTSIterator *MEDFileAnyTypeFieldMultiTS::iterator()
+{
+  return new MEDFileAnyTypeFieldMultiTSIterator(this);
+}
+
+//= MEDFileFieldMultiTS
+
+MEDFileAnyTypeFieldMultiTS *MEDFileFieldMultiTS::shallowCpy() const
+{
+  return new MEDFileFieldMultiTS(*this);
+}
+
+/*!
+ * This method performs a copy with datatype modification ( float64->int32 ) of \a this. The globals information are copied
+ * following the given input policy.
+ *
+ * \param [in] isDeepCpyGlobs - a boolean that indicates the behaviour concerning globals (profiles and localizations)
+ *                            By default (true) the globals are deeply copied.
+ * \return MEDFileIntFieldMultiTS * - a new object that is the result of the conversion of \a this to int32 field.
+ */
+MEDFileIntFieldMultiTS *MEDFileFieldMultiTS::convertToInt(bool isDeepCpyGlobs) const
+{
+  MCAuto<MEDFileIntFieldMultiTS> ret;
+  const MEDFileAnyTypeFieldMultiTSWithoutSDA *content(_content);
+  if(content)
+    {
+      const MEDFileFieldMultiTSWithoutSDA *contc=dynamic_cast<const MEDFileFieldMultiTSWithoutSDA *>(content);
+      if(!contc)
+        throw INTERP_KERNEL::Exception("MEDFileFieldMultiTS::convertToInt : the content inside this is not FLOAT64 ! This is incoherent !");
+      MCAuto<MEDFileIntFieldMultiTSWithoutSDA> newc(contc->convertToInt());
+      ret=static_cast<MEDFileIntFieldMultiTS *>(MEDFileAnyTypeFieldMultiTS::BuildNewInstanceFromContent((MEDFileIntFieldMultiTSWithoutSDA *)newc));
+    }
+  else
+    ret=MEDFileIntFieldMultiTS::New();
+  if(isDeepCpyGlobs)
+    ret->deepCpyGlobs(*this);
+  else
+    ret->shallowCpyGlobs(*this);
+  return ret.retn();
+}
+
+MEDFileFieldMultiTS::MEDFileFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms)
+try:MEDFileTemplateFieldMultiTS<double>(fid,loadAll,ms)
+{
+}
+catch(INTERP_KERNEL::Exception& e)
+{ throw e; }
+
+MEDFileFieldMultiTS::MEDFileFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities)
+try:MEDFileTemplateFieldMultiTS<double>(fid,fieldName,loadAll,ms,entities)
+{
+}
+catch(INTERP_KERNEL::Exception& e)
+{ throw e; }
+
+MEDFileFieldMultiTS::MEDFileFieldMultiTS(const MEDFileFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent):MEDFileTemplateFieldMultiTS<double>(other,shallowCopyOfContent)
+{
+}
+
+std::vector< std::vector<DataArrayDouble *> > MEDFileFieldMultiTS::getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const
+{
+  return contentNotNull()->getFieldSplitedByType2(iteration,order,mname,types,typesF,pfls,locs);
+}
+
+//= MEDFileAnyTypeFieldMultiTSIterator
+
+MEDFileAnyTypeFieldMultiTSIterator::MEDFileAnyTypeFieldMultiTSIterator(MEDFileAnyTypeFieldMultiTS *fmts):_fmts(fmts),_iter_id(0),_nb_iter(0)
+{
+  if(fmts)
+    {
+      fmts->incrRef();
+      _nb_iter=fmts->getNumberOfTS();
+    }
+}
+
+MEDFileAnyTypeFieldMultiTSIterator::~MEDFileAnyTypeFieldMultiTSIterator() 
+{
+}
+
+MEDFileAnyTypeField1TS *MEDFileAnyTypeFieldMultiTSIterator::nextt()
+{
+  if(_iter_id<_nb_iter)
+    {
+      MEDFileAnyTypeFieldMultiTS *fmts(_fmts);
+      if(fmts)
+        return fmts->getTimeStepAtPos(_iter_id++);
+      else
+        return 0;
+    }
+  else
+    return 0;
+}
+
+//= MEDFileIntFieldMultiTS
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldMultiTS.hxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldMultiTS.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldMultiTS.hxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldMultiTS.hxx	2018-04-19 17:25:17.739797396 +0200
@@ -0,0 +1,417 @@
+// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+#ifndef __MEDFILEFIELDMULTITS_HXX__
+#define __MEDFILEFIELDMULTITS_HXX__
+
+#include "MEDLoaderDefines.hxx"
+#include "MEDFileField1TS.hxx"
+#include "MEDFileFieldGlobs.hxx"
+#include "MEDLoaderTraits.hxx"
+#include "MEDFileUtilities.hxx"
+
+namespace MEDCoupling
+{
+  class MEDFileMesh;
+  class MEDFileMeshes;
+  class MEDCouplingMesh;
+  class MEDFileFieldVisitor;
+  class MEDFileAnyTypeField1TS;
+  class MEDFileAnyTypeField1TSWithoutSDA;
+  
+  class MEDFileAnyTypeFieldMultiTSWithoutSDA : public RefCountObject, public MEDFileFieldNameScope
+  {
+  protected:
+    MEDFileAnyTypeFieldMultiTSWithoutSDA();
+    MEDFileAnyTypeFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName);
+    MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDFileAnyTypeFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+  public:
+    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
+    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTSWithoutSDA *deepCopy() const;
+    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > splitComponents() const;
+    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > splitDiscretizations() const;
+    MEDLOADER_EXPORT virtual std::vector< MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> > splitMultiDiscrPerGeoTypes() const;
+    MEDLOADER_EXPORT virtual const char *getTypeStr() const = 0;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const = 0;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTSWithoutSDA *createNew() const = 0;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TSWithoutSDA *createNew1TSWithoutSDAEmptyInstance() const = 0;
+    MEDLOADER_EXPORT virtual void checkCoherencyOfType(const MEDFileAnyTypeField1TSWithoutSDA *f1ts) const = 0;
+    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
+    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
+    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& info);
+    MEDLOADER_EXPORT int getTimeStepPos(int iteration, int order) const;
+    MEDLOADER_EXPORT const MEDFileAnyTypeField1TSWithoutSDA& getTimeStepEntry(int iteration, int order) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA& getTimeStepEntry(int iteration, int order);
+    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
+    MEDLOADER_EXPORT int getNumberOfTS() const;
+    MEDLOADER_EXPORT void eraseEmptyTS();
+    MEDLOADER_EXPORT void eraseTimeStepIds(const int *startIds, const int *endIds);
+    MEDLOADER_EXPORT void eraseTimeStepIds2(int bg, int end, int step);
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *buildFromTimeStepIds(const int *startIds, const int *endIds) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *buildFromTimeStepIds2(int bg, int end, int step) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *partOfThisLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *partOfThisNotLyingOnSpecifiedTimeSteps(const std::vector< std::pair<int,int> >& timeSteps) const;
+    MEDLOADER_EXPORT bool presenceOfStructureElements() const;
+    MEDLOADER_EXPORT bool onlyStructureElements() const;
+    MEDLOADER_EXPORT void killStructureElements();
+    MEDLOADER_EXPORT void keepOnlyStructureElements();
+    MEDLOADER_EXPORT void keepOnlyOnSE(const std::string& seName);
+    MEDLOADER_EXPORT void getMeshSENames(std::vector< std::pair<std::string,std::string> >& ps) const;
+    MEDLOADER_EXPORT int getPosOfTimeStep(int iteration, int order) const;
+    MEDLOADER_EXPORT int getPosGivenTime(double time, double eps=1e-8) const;
+    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getIterations() const;
+    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getTimeSteps(std::vector<double>& ret1) const;
+    MEDLOADER_EXPORT void pushBackTimeStep(MCAuto<MEDFileAnyTypeField1TSWithoutSDA>& tse);
+    MEDLOADER_EXPORT void synchronizeNameScope();
+    MEDLOADER_EXPORT void simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const;
+    MEDLOADER_EXPORT int getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const;
+    MEDLOADER_EXPORT void appendFieldNoProfileSBT(const MEDCouplingFieldDouble *field, const DataArray *arr, MEDFileFieldGlobsReal& glob);
+    MEDLOADER_EXPORT void appendFieldProfile(const MEDCouplingFieldDouble *field, const DataArray *arr, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, MEDFileFieldGlobsReal& glob, bool smartPflKiller);
+    MEDLOADER_EXPORT std::vector< std::vector< std::pair<int,int> > > getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    MEDLOADER_EXPORT std::vector< std::vector<TypeOfField> > getTypesOfFieldAvailable() const;
+    MEDLOADER_EXPORT DataArray *getUndergroundDataArray(int iteration, int order) const;
+    MEDLOADER_EXPORT DataArray *getUndergroundDataArrayExt(int iteration, int order, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDLOADER_EXPORT bool renumberEntitiesLyingOnMesh(const std::string& meshName, const std::vector<int>& oldCode, const std::vector<int>& newCode, const DataArrayInt *renumO2N, MEDFileFieldGlobsReal& glob);
+    MEDLOADER_EXPORT void accept(MEDFileFieldVisitor& visitor) const;
+    MEDLOADER_EXPORT void loadStructureOrStructureAndBigArraysRecursively(med_idt fid, int nbPdt, med_field_type fieldTyp, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT void writeLL(med_idt fid, const MEDFileWritable& opts) const;
+    MEDLOADER_EXPORT void loadBigArraysRecursively(med_idt fid, const MEDFileFieldNameScope& nasc);
+    MEDLOADER_EXPORT void loadBigArraysRecursivelyIfNecessary(med_idt fid, const MEDFileFieldNameScope& nasc);
+    MEDLOADER_EXPORT void unloadArrays();
+  public:
+    MEDLOADER_EXPORT const MEDFileAnyTypeField1TSWithoutSDA *getTimeStepAtPos2(int pos) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA *getTimeStepAtPos2(int pos);
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed2() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed2() const;
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti2() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti2() const;
+    MEDLOADER_EXPORT void changePflsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changeLocsRefsNamesGen2(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void setIteration(int i, MCAuto<MEDFileAnyTypeField1TSWithoutSDA> ts);
+  protected:
+    virtual med_field_type getMEDFileFieldType() const = 0;
+    void copyTinyInfoFrom(const MEDCouplingFieldDouble *field, const DataArray *arr);
+    void checkCoherencyOfTinyInfo(const MEDCouplingFieldDouble *field, const DataArray *arr) const;
+    void checkThatComponentsMatch(const std::vector<std::string>& compos) const;
+    void checkThatNbOfCompoOfTSMatchThis() const;
+  protected:
+    std::vector<std::string> _infos;
+    std::vector< MCAuto<MEDFileAnyTypeField1TSWithoutSDA> > _time_steps;
+  };
+
+  class MEDFileIntFieldMultiTSWithoutSDA;
+
+  template<class T>
+  class MEDFileTemplateFieldMultiTSWithoutSDA : public MEDFileAnyTypeFieldMultiTSWithoutSDA
+  {
+  public:
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSWSDAType *New(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+    MEDLOADER_EXPORT const char *getTypeStr() const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *createNew() const;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TSWithoutSDA *createNew1TSWithoutSDAEmptyInstance() const;
+  protected:
+    MEDFileTemplateFieldMultiTSWithoutSDA() { }
+    MEDFileTemplateFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileAnyTypeFieldMultiTSWithoutSDA(fieldName,meshName) { }
+    /** \param [in] fieldId field id in C mode */
+    MEDFileTemplateFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileAnyTypeFieldMultiTSWithoutSDA(fid,fieldId,loadAll,ms,entities) { }
+    MEDFileTemplateFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileAnyTypeFieldMultiTSWithoutSDA(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
+    void checkCoherencyOfType(const MEDFileAnyTypeField1TSWithoutSDA *f1ts) const;
+  };
+  
+  class MEDFileFieldMultiTSWithoutSDA : public MEDFileTemplateFieldMultiTSWithoutSDA<double>
+  {
+    friend class MEDFileTemplateFieldMultiTSWithoutSDA<double>;
+  public:
+    MEDLOADER_EXPORT MEDFileFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<double>(fid,fieldId,loadAll,ms,entities) { }
+    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    MEDLOADER_EXPORT MEDFileIntFieldMultiTSWithoutSDA *convertToInt() const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const { return new MEDFileFieldMultiTSWithoutSDA(*this); }
+  protected:
+    MEDFileFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileTemplateFieldMultiTSWithoutSDA<double>(fieldName,meshName) { }
+    MEDFileFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<double>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
+    med_field_type getMEDFileFieldType() const { return MED_FLOAT64; }
+  public:
+    MEDLOADER_EXPORT MEDFileFieldMultiTSWithoutSDA() { }
+  };
+
+  template<class T>
+  class MEDFileNDTemplateFieldMultiTSWithoutSDA : public MEDFileTemplateFieldMultiTSWithoutSDA<T>
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileFieldMultiTSWithoutSDA *convertToDouble() const;
+  protected:
+    MEDFileNDTemplateFieldMultiTSWithoutSDA() { }
+    MEDFileNDTemplateFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<T>(fid,fieldId,loadAll,ms,entities) { }
+    MEDFileNDTemplateFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileTemplateFieldMultiTSWithoutSDA<T>(fieldName,meshName) { }
+    MEDFileNDTemplateFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTSWithoutSDA<T>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
+  };
+
+  class MEDFileIntFieldMultiTSWithoutSDA : public MEDFileNDTemplateFieldMultiTSWithoutSDA<int>
+  {
+    friend class MEDFileTemplateFieldMultiTSWithoutSDA<int>;
+  public:
+    MEDLOADER_EXPORT MEDFileIntFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<int>(fid,fieldId,loadAll,ms,entities) { }
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const { return new MEDFileIntFieldMultiTSWithoutSDA(*this); }
+  protected:
+    MEDFileIntFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileNDTemplateFieldMultiTSWithoutSDA<int>(fieldName,meshName) { }
+    MEDFileIntFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<int>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
+    med_field_type getMEDFileFieldType() const { return MED_INT32; }
+  public:
+    MEDLOADER_EXPORT MEDFileIntFieldMultiTSWithoutSDA() { }
+  };
+
+  class MEDFileFloatFieldMultiTSWithoutSDA : public MEDFileNDTemplateFieldMultiTSWithoutSDA<float>
+  {
+    friend class MEDFileTemplateFieldMultiTSWithoutSDA<float>;
+  public:
+    MEDLOADER_EXPORT MEDFileFloatFieldMultiTSWithoutSDA(med_idt fid, int fieldId, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<float>(fid,fieldId,loadAll,ms,entities) { }
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSWithoutSDA *shallowCpy() const { return new MEDFileFloatFieldMultiTSWithoutSDA(*this); }
+  protected:
+    MEDFileFloatFieldMultiTSWithoutSDA(const std::string& fieldName, const std::string& meshName):MEDFileNDTemplateFieldMultiTSWithoutSDA<float>(fieldName,meshName) { }
+    MEDFileFloatFieldMultiTSWithoutSDA(med_idt fid, const std::string& fieldName, const std::string& meshName, med_field_type fieldTyp, const std::vector<std::string>& infos, int nbOfStep, const std::string& dtunit, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileNDTemplateFieldMultiTSWithoutSDA<float>(fid,fieldName,meshName,fieldTyp,infos,nbOfStep,dtunit,loadAll,ms,entities) { }
+    med_field_type getMEDFileFieldType() const { return MED_FLOAT32; }
+  public:
+    MEDLOADER_EXPORT MEDFileFloatFieldMultiTSWithoutSDA() { }
+  };
+
+  class MEDFileAnyTypeFieldMultiTSIterator;
+  class MEDFileFastCellSupportComparator;
+  /*!
+   * User class.
+   */
+  class MEDFileAnyTypeFieldMultiTS : public RefCountObject, public MEDFileWritableStandAlone, public MEDFileFieldGlobsReal
+  {
+  protected:
+    MEDFileAnyTypeFieldMultiTS();
+    MEDFileAnyTypeFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
+    MEDFileAnyTypeFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
+    MEDFileAnyTypeFieldMultiTS(const MEDFileAnyTypeFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent);
+    static MEDFileAnyTypeFieldMultiTS *BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c, med_idt fid);
+    static MEDFileAnyTypeFieldMultiTSWithoutSDA *BuildContentFrom(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
+    static MEDFileAnyTypeFieldMultiTSWithoutSDA *BuildContentFrom(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities);
+  public:
+    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(const std::string& fileName, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(med_idt fid, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static MEDFileAnyTypeFieldMultiTS *BuildNewInstanceFromContent(MEDFileAnyTypeFieldMultiTSWithoutSDA *c);
+    MEDLOADER_EXPORT void loadArrays();
+    MEDLOADER_EXPORT void loadArraysIfNecessary();
+    MEDLOADER_EXPORT void unloadArrays();
+    MEDLOADER_EXPORT void unloadArraysWithoutDataLoss();
+    MEDLOADER_EXPORT void writeLL(med_idt fid) const;
+    MEDLOADER_EXPORT std::size_t getHeapMemorySizeWithoutChildren() const;
+    MEDLOADER_EXPORT std::vector<const BigMemoryObject *> getDirectChildrenWithNull() const;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *deepCopy() const;
+    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > splitComponents() const;
+    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > splitDiscretizations() const;
+    MEDLOADER_EXPORT std::vector< MCAuto< MEDFileAnyTypeFieldMultiTS > > splitMultiDiscrPerGeoTypes() const;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *shallowCpy() const = 0;
+    MEDLOADER_EXPORT virtual void checkCoherencyOfType(const MEDFileAnyTypeField1TS *f1ts) const = 0;
+    //
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeField1TS *getTimeStepAtPos(int pos) const = 0;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *getTimeStep(int iteration, int order) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *getTimeStepGivenTime(double time, double eps=1e-8) const;
+    MEDLOADER_EXPORT static std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > SplitIntoCommonTimeSeries(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS);
+    MEDLOADER_EXPORT static std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > SplitPerCommonSupport(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& fsc);
+    MEDLOADER_EXPORT static int CheckSupportAcrossTime(MEDFileAnyTypeFieldMultiTS *f0, MEDFileAnyTypeFieldMultiTS *f1, const MEDFileMesh *mesh, TypeOfField& tof0, TypeOfField& tof1);
+  public:// direct forwarding to MEDFileField1TSWithoutSDA instance _content
+    MEDLOADER_EXPORT std::string getName() const;
+    MEDLOADER_EXPORT void setName(const std::string& name);
+    MEDLOADER_EXPORT std::string getDtUnit() const;
+    MEDLOADER_EXPORT void setDtUnit(const std::string& dtUnit);
+    MEDLOADER_EXPORT std::string getMeshName() const;
+    MEDLOADER_EXPORT void setMeshName(const std::string& newMeshName);
+    MEDLOADER_EXPORT std::string simpleRepr() const;
+    MEDLOADER_EXPORT void simpleRepr(int bkOffset, std::ostream& oss, int fmtsId) const;
+    MEDLOADER_EXPORT int getNumberOfTS() const;
+    MEDLOADER_EXPORT void eraseEmptyTS();
+    MEDLOADER_EXPORT void eraseTimeStepIds(const int *startIds, const int *endIds);
+    MEDLOADER_EXPORT void eraseTimeStepIds2(int bg, int end, int step);
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *buildSubPart(const int *startIds, const int *endIds) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *buildSubPartSlice(int bg, int end, int step) const;
+    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getTimeSteps(std::vector<double>& ret1) const;
+    MEDLOADER_EXPORT std::vector< std::pair<int,int> > getIterations() const;
+    MEDLOADER_EXPORT void pushBackTimeSteps(const std::vector<MEDFileAnyTypeField1TS *>& f1ts);
+    MEDLOADER_EXPORT void pushBackTimeSteps(MEDFileAnyTypeFieldMultiTS *fmts);
+    MEDLOADER_EXPORT void pushBackTimeStep(MEDFileAnyTypeField1TS *f1ts);
+    MEDLOADER_EXPORT void synchronizeNameScope();
+    MEDLOADER_EXPORT int getPosOfTimeStep(int iteration, int order) const;
+    MEDLOADER_EXPORT int getPosGivenTime(double time, double eps=1e-8) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSIterator *iterator();
+    MEDLOADER_EXPORT bool changeMeshNames(const std::vector< std::pair<std::string,std::string> >& modifTab);
+    MEDLOADER_EXPORT const std::vector<std::string>& getInfo() const;
+    MEDLOADER_EXPORT bool presenceOfMultiDiscPerGeoType() const;
+    MEDLOADER_EXPORT void setInfo(const std::vector<std::string>& info);
+    MEDLOADER_EXPORT int getNumberOfComponents() const;
+    MEDLOADER_EXPORT int getNonEmptyLevels(int iteration, int order, const std::string& mname, std::vector<int>& levs) const;
+    MEDLOADER_EXPORT std::vector< std::vector<TypeOfField> > getTypesOfFieldAvailable() const;
+    MEDLOADER_EXPORT std::vector< std::vector< std::pair<int,int> > > getFieldSplitedByType(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    MEDLOADER_EXPORT MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> getContent();
+  public:
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *buildNewEmpty() const = 0;
+    MEDLOADER_EXPORT virtual MEDFileAnyTypeFieldMultiTS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const = 0;
+    MEDLOADER_EXPORT static MCAuto<MEDFileAnyTypeFieldMultiTS> Aggregate(const std::vector<const MEDFileAnyTypeFieldMultiTS *>& fmtss, const std::vector< std::vector< std::pair<int,int> > >& dts);
+  public:
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsed() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsed() const;
+    MEDLOADER_EXPORT std::vector<std::string> getPflsReallyUsedMulti() const;
+    MEDLOADER_EXPORT std::vector<std::string> getLocsReallyUsedMulti() const;
+    MEDLOADER_EXPORT void changePflsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+    MEDLOADER_EXPORT void changeLocsRefsNamesGen(const std::vector< std::pair<std::vector<std::string>, std::string > >& mapOfModif);
+  protected:
+    MEDFileAnyTypeFieldMultiTSWithoutSDA *contentNotNullBase();
+    const MEDFileAnyTypeFieldMultiTSWithoutSDA *contentNotNullBase() const;
+  private:
+    static std::vector< std::vector<MEDFileAnyTypeFieldMultiTS *> > SplitPerCommonSupportNotNodesAlg(const std::vector<MEDFileAnyTypeFieldMultiTS *>& vectFMTS, const MEDFileMesh *mesh, std::vector< MCAuto<MEDFileFastCellSupportComparator> >& cmps);
+  protected:
+    MCAuto<MEDFileAnyTypeFieldMultiTSWithoutSDA> _content;
+  };
+
+  template<class T>
+  class MEDFileTemplateFieldMultiTS : public MEDFileAnyTypeFieldMultiTS
+  {
+  public:
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New();
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(const std::string& fileName, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(med_idt fid, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(DataArrayByte *db) { return BuildFromMemoryChunk<typename MLFieldTraits<T>::FMTSType>(db); }
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(const std::string& fileName, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(med_idt fid, const std::string& fieldName, bool loadAll=true);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *New(const typename MLFieldTraits<T>::FMTSWSDAType& other, bool shallowCopyOfContent);
+    MEDLOADER_EXPORT static typename MLFieldTraits<T>::FMTSType *LoadSpecificEntities(const std::string& fileName, const std::string& fieldName, const std::vector< std::pair<TypeOfField,INTERP_KERNEL::NormalizedCellType> >& entities, bool loadAll=true);
+    MEDLOADER_EXPORT typename MLFieldTraits<T>::FMTSType *extractPartImpl(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const;
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *extractPart(const std::map<int, MCAuto<DataArrayInt> >& extractDef, MEDFileMesh *mm) const { return this->extractPartImpl(extractDef,mm); }
+    //
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *field(int iteration, int order, const MEDFileMesh *mesh) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtTopLevel(TypeOfField type, int iteration, int order, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, const MEDFileMesh *mesh, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldOnMeshAtLevel(TypeOfField type, int iteration, int order, const MEDCouplingMesh *mesh, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::FieldType *getFieldAtLevelOld(TypeOfField type, int iteration, int order, const std::string& mname, int meshDimRelToMax, int renumPol=0) const;
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getFieldWithProfile(TypeOfField type, int iteration, int order, int meshDimRelToMax, const MEDFileMesh *mesh, DataArrayInt *&pfl) const;
+    //
+    MEDLOADER_EXPORT void appendFieldNoProfileSBT(const typename Traits<T>::FieldType *field);
+    MEDLOADER_EXPORT void appendFieldProfile(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile);
+    MEDLOADER_EXPORT void appendFieldProfileFlatly(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile);
+    //
+    MEDLOADER_EXPORT typename MLFieldTraits<T>::F1TSType *getTimeStepAtPos(int pos) const;
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArray(int iteration, int order) const;
+    MEDLOADER_EXPORT typename Traits<T>::ArrayType *getUndergroundDataArrayExt(int iteration, int order, std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > >& entries) const;
+    MEDLOADER_EXPORT typename MLFieldTraits<T>::FMTSType *buildNewEmptyImpl() const;
+    MEDLOADER_EXPORT void checkCoherencyOfType(const MEDFileAnyTypeField1TS *f1ts) const;
+  protected:
+    const typename MLFieldTraits<T>::FMTSWSDAType *contentNotNull() const;
+    typename MLFieldTraits<T>::FMTSWSDAType *contentNotNull();
+    void appendFieldProfileGeneral(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, bool smartPflKiller);
+  protected:
+    ~MEDFileTemplateFieldMultiTS() { }
+    MEDFileTemplateFieldMultiTS();
+    MEDFileTemplateFieldMultiTS(const typename MLFieldTraits<T>::FMTSWSDAType& other, bool shallowCopyOfContent);
+    MEDFileTemplateFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
+    MEDFileTemplateFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
+  };
+  
+  class MEDFileIntFieldMultiTS;
+
+  /*!
+   * User class.
+   */
+  class MEDFileFieldMultiTS : public MEDFileTemplateFieldMultiTS<double>
+  {
+    friend class MEDFileTemplateFieldMultiTS<double>;
+  public:
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *shallowCpy() const;
+    MEDLOADER_EXPORT MEDFileIntFieldMultiTS *convertToInt(bool isDeepCpyGlobs=true) const;
+    //
+    MEDLOADER_EXPORT std::vector< std::vector<DataArrayDouble *> > getFieldSplitedByType2(int iteration, int order, const std::string& mname, std::vector<INTERP_KERNEL::NormalizedCellType>& types, std::vector< std::vector<TypeOfField> >& typesF, std::vector< std::vector<std::string> >& pfls, std::vector< std::vector<std::string> >& locs) const;
+    MEDLOADER_EXPORT MEDFileFieldMultiTS *buildNewEmpty() const { return buildNewEmptyImpl(); }
+  public:
+  private:
+    ~MEDFileFieldMultiTS() { }
+    MEDFileFieldMultiTS() { }
+    MEDFileFieldMultiTS(const MEDFileFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent);
+    MEDFileFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms);
+    MEDFileFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0);
+  };
+
+  template<class T>
+  class MEDFileNDTemplateFieldMultiTS : public MEDFileTemplateFieldMultiTS<T>
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileFieldMultiTS *convertToDouble(bool isDeepCpyGlobs=true) const;
+  protected:
+    ~MEDFileNDTemplateFieldMultiTS() { }
+    MEDFileNDTemplateFieldMultiTS() { }
+    MEDFileNDTemplateFieldMultiTS(const typename MLFieldTraits<T>::FMTSWSDAType& other, bool shallowCopyOfContent):MEDFileTemplateFieldMultiTS<T>(other,shallowCopyOfContent) { }
+    MEDFileNDTemplateFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileTemplateFieldMultiTS<T>(fid,loadAll,ms) { }
+    MEDFileNDTemplateFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities):MEDFileTemplateFieldMultiTS<T>(fid,fieldName,loadAll,ms,entities) { }
+  };
+
+  /*!
+   * User class.
+   */
+  class MEDFileIntFieldMultiTS : public MEDFileNDTemplateFieldMultiTS<int>
+  {
+    friend class MEDFileTemplateFieldMultiTS<int>;
+  public:
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *shallowCpy() const { return new MEDFileIntFieldMultiTS(*this); }
+    MEDLOADER_EXPORT MEDFileIntFieldMultiTS *buildNewEmpty() const { return buildNewEmptyImpl(); }
+  private:
+    ~MEDFileIntFieldMultiTS() { }
+    MEDFileIntFieldMultiTS() { }
+    MEDFileIntFieldMultiTS(const MEDFileIntFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateFieldMultiTS<int>(other,shallowCopyOfContent) { }
+    MEDFileIntFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateFieldMultiTS<int>(fid,loadAll,ms) { }
+    MEDFileIntFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0):MEDFileNDTemplateFieldMultiTS<int>(fid,fieldName,loadAll,ms,entities) { }
+  };
+
+  /*!
+   * User class.
+   */
+  class MEDFileFloatFieldMultiTS : public MEDFileNDTemplateFieldMultiTS<float>
+  {
+    friend class MEDFileTemplateFieldMultiTS<float>;
+  public:
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTS *shallowCpy() const { return new MEDFileFloatFieldMultiTS(*this); }
+    MEDLOADER_EXPORT MEDFileFloatFieldMultiTS *buildNewEmpty() const { return buildNewEmptyImpl(); }
+  private:
+    ~MEDFileFloatFieldMultiTS() { }
+    MEDFileFloatFieldMultiTS() { }
+    MEDFileFloatFieldMultiTS(const MEDFileFloatFieldMultiTSWithoutSDA& other, bool shallowCopyOfContent):MEDFileNDTemplateFieldMultiTS<float>(other,shallowCopyOfContent) { }
+    MEDFileFloatFieldMultiTS(med_idt fid, bool loadAll, const MEDFileMeshes *ms):MEDFileNDTemplateFieldMultiTS<float>(fid,loadAll,ms) { }
+    MEDFileFloatFieldMultiTS(med_idt fid, const std::string& fieldName, bool loadAll, const MEDFileMeshes *ms, const MEDFileEntities *entities=0):MEDFileNDTemplateFieldMultiTS<float>(fid,fieldName,loadAll,ms,entities) { }
+  };
+
+  class MEDFileAnyTypeFieldMultiTSIterator
+  {
+  public:
+    MEDLOADER_EXPORT MEDFileAnyTypeFieldMultiTSIterator(MEDFileAnyTypeFieldMultiTS *fmts);
+    MEDLOADER_EXPORT ~MEDFileAnyTypeFieldMultiTSIterator();
+    MEDLOADER_EXPORT MEDFileAnyTypeField1TS *nextt();
+  private:
+    MCAuto<MEDFileAnyTypeFieldMultiTS> _fmts;
+    int _iter_id;
+    int _nb_iter;
+  };
+}
+
+#endif
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldOverView.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldOverView.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldOverView.cxx	2018-04-19 17:04:36.758223141 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldOverView.cxx	2018-04-19 17:25:17.828799155 +0200
@@ -28,7 +28,7 @@
 using namespace MEDCoupling;
 
 const unsigned char MEDMeshMultiLev::PARAMEDMEM_2_VTKTYPE[MEDMeshMultiLev::PARAMEDMEM_2_VTKTYPE_LGTH]=
-{1,3,21,5,9,7,22,34,23,28,255,255,255,255,10,14,13,255,12,255,24,255,16,27,255,26,255,29,255,255,25,42,36,4};
+{1,3,21,5,9,7,22,34,23,28,35,255,255,255,10,14,13,255,12,255,24,255,16,27,255,26,255,29,32,255,25,42,36,4};
 
 const unsigned char MEDMeshMultiLev::HEXA27_PERM_ARRAY[27]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,24,22,21,23,20,25,26};
 
@@ -1360,7 +1360,7 @@
   if(!m)
     throw INTERP_KERNEL::Exception("MEDCMeshMultiLev constructor 2 : null input pointer !");
   if(gts.size()!=1 || pfls.size()!=1)
-    throw INTERP_KERNEL::Exception("MEDCMeshMultiLev constructor 2 : lengthes of gts and pfls must be equal to one !");
+    throw INTERP_KERNEL::Exception("MEDCMeshMultiLev constructor 2 : lengths of gts and pfls must be equal to one !");
   int mdim(m->getMeshDimension());
   INTERP_KERNEL::NormalizedCellType gt(MEDCouplingStructuredMesh::GetGeoTypeGivenMeshDimension(mdim));
   if(gt==gts[0])
@@ -1456,7 +1456,7 @@
 }
 
 /*!
- * \a param [out] isInternal if true the returned pointers are those in main data structure. If false those pointers have been built espacially for that method.
+ * \a param [out] isInternal if true the returned pointers are those in main data structure. If false those pointers have been built especially for that method.
  */
 std::vector< DataArrayDouble * > MEDCMeshMultiLev::buildVTUArrays(bool& isInternal) const
 {
@@ -1502,7 +1502,7 @@
   if(!m)
     throw INTERP_KERNEL::Exception("MEDCurveLinearMeshMultiLev constructor 2 : null input pointer !");
   if(gts.size()!=1 || pfls.size()!=1)
-    throw INTERP_KERNEL::Exception("MEDCurveLinearMeshMultiLev constructor 2 : lengthes of gts and pfls must be equal to one !");
+    throw INTERP_KERNEL::Exception("MEDCurveLinearMeshMultiLev constructor 2 : lengths of gts and pfls must be equal to one !");
   INTERP_KERNEL::NormalizedCellType gt(MEDCouplingStructuredMesh::GetGeoTypeGivenMeshDimension(m->getMeshDimension()));
   if(gt==gts[0])
     {
@@ -1680,7 +1680,7 @@
 }
 
 /*!
- * \param [in] nbOfEntity - number of entity that can be either cells or nodes. Not other possiblity.
+ * \param [in] nbOfEntity - number of entity that can be either cells or nodes. Not other possibility.
  * \param [in] nip - number of integration points. 1 for ON_CELLS and NO_NODES
  */
 void MEDFileField1TSStructItem2::checkInRange(int nbOfEntity, int nip, const MEDFileFieldGlobsReal *globs)
@@ -2272,7 +2272,7 @@
 
 /*!
  * Returns true if presence in \a this of discretization ON_CELLS, ON_GAUSS_PT, ON_GAUSS_NE.
- * If true is returned the pos of the easiest is returned. The easiest is the first element in \a this having the less splitted subparts.
+ * If true is returned the pos of the easiest is returned. The easiest is the first element in \a this having the less split subparts.
  */
 bool MEDFileField1TSStruct::presenceOfCellDiscr(int& pos) const
 {
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileField.txx MEDCOUPLING_new/src/MEDLoader/MEDFileField.txx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileField.txx	2018-04-19 17:04:36.757223122 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileField.txx	2018-04-19 17:25:17.824799076 +0200
@@ -199,6 +199,16 @@
       }
   }
 
+  template<class T>
+  void MEDFileField1TSTemplateWithoutSDA<T>::copyTimeInfoFrom(const typename Traits<T>::FieldType *mcf)
+  {
+    if(!mcf)
+      throw INTERP_KERNEL::Exception("MEDFileField1TSTemplateWithoutSDA<T>::copyTimeInfoFrom : input field is nullptr !");
+    int b(0),c(0);
+    double a(mcf->getTime(b,c));
+    setTime(b,c,a);
+  }
+
   ///////////////////////////////////////////////////////
 
   template<class T>
@@ -398,6 +408,12 @@
   }
 
   template<class T>
+  void MEDFileTemplateField1TS<T>::setArray(DataArray *arr)
+  {
+    return contentNotNull()->setArray(arr);
+  }
+
+  template<class T>
   typename Traits<T>::ArrayType *MEDFileTemplateField1TS<T>::getUndergroundDataArray() const
   {
     return contentNotNull()->getUndergroundDataArrayTemplate();
@@ -438,6 +454,12 @@
     return ret.retn();
   }
 
+  template<class T>
+  void MEDFileTemplateField1TS<T>::copyTimeInfoFrom(const typename Traits<T>::FieldType *mcf)
+  {
+    contentNotNull()->copyTimeInfoFrom(mcf);
+  }
+
   /*!
    * This is the simplest version to fetch a field for MED structure. One drawback : if \a this is a complex field (multi spatial discretization inside a same field) this method will throw exception and more advance
    * method should be called (getFieldOnMeshAtLevel for example).
@@ -660,16 +682,32 @@
    *  \throw If the data array of \a this is already allocated but has different number of
    *         components than \a field.
    *  \throw If elements in \a mesh are not in the order suitable for writing to the MED file.
-   *  \sa setFieldNoProfileSBT()
+   *  \sa setFieldNoProfileSBT, setFieldProfileFlatly
    */
   template<class T>
   void MEDFileTemplateField1TS<T>::setFieldProfile(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile)
   {
+    setFieldProfileGeneral(field,mesh,meshDimRelToMax,profile,true);
+  }
+
+  /*!
+   * Same as setFieldProfile except that here profile will be created unconditionally
+   * \sa setFieldProfile
+   */
+  template<class T>
+  void MEDFileTemplateField1TS<T>::setFieldProfileFlatly(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile)
+  {
+    setFieldProfileGeneral(field,mesh,meshDimRelToMax,profile,false);
+  }
+
+  template<class T>
+  void MEDFileTemplateField1TS<T>::setFieldProfileGeneral(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, bool smartPflKiller)
+  {
     setFileName("");
     MCAuto<MEDCouplingFieldTemplate> ft(MEDCouplingFieldTemplate::NewWithoutCheck(*field));
-    contentNotNull()->setFieldProfile(field->timeDiscrSafe(),ft,field->getArray(),mesh,meshDimRelToMax,profile,*this,*contentNotNull());
+    contentNotNull()->setFieldProfile(field->timeDiscrSafe(),ft,field->getArray(),mesh,meshDimRelToMax,profile,*this,*contentNotNull(),smartPflKiller);
   }
-
+  
   /*!
    * Return an extraction of \a this using \a extractDef map to specify the extraction.
    * The keys of \a extractDef is level relative to max ext of \a mm mesh.
@@ -1200,18 +1238,33 @@
    *  \throw If the data array of \a this is already allocated but has different number of
    *         components than \a field.
    *  \throw If elements in \a mesh are not in the order suitable for writing to the MED file.
-   *  \sa setFieldNoProfileSBT()
+   *  \sa setFieldNoProfileSBT, appendFieldProfileFlatly
    */
   template<class T>
   void MEDFileTemplateFieldMultiTS<T>::appendFieldProfile(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile)
   {
+    appendFieldProfileGeneral(field,mesh,meshDimRelToMax,profile,true);
+  }
+
+  /*!
+   * same as appendFieldProfile except that here profile is created unconditionaly
+   */
+  template<class T>
+  void MEDFileTemplateFieldMultiTS<T>::appendFieldProfileFlatly(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile)
+  {
+    appendFieldProfileGeneral(field,mesh,meshDimRelToMax,profile,false);
+  }
+
+  template<class T>
+  void MEDFileTemplateFieldMultiTS<T>::appendFieldProfileGeneral(const typename Traits<T>::FieldType *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile, bool smartPflKiller)
+  {
     const typename Traits<T>::ArrayType *arr(NULL);
     if(field)
       arr=field->getArray();
     MCAuto<MEDCouplingFieldDouble> field2(MEDFileTemplateField1TS<T>::ToFieldTemplateWithTime(field));
-    contentNotNull()->appendFieldProfile(field2,arr,mesh,meshDimRelToMax,profile,*this);
+    contentNotNull()->appendFieldProfile(field2,arr,mesh,meshDimRelToMax,profile,*this,smartPflKiller);
   }
-
+  
   template<class T>
   const typename MLFieldTraits<T>::FMTSWSDAType *MEDFileTemplateFieldMultiTS<T>::contentNotNull() const
   {
@@ -1272,7 +1325,7 @@
     typename Traits<T>::ArrayType *ret2(dynamic_cast<typename Traits<T>::ArrayType *>(ret));
     if(!ret2)
       {
-        std::ostringstream oss; oss << "MEDFileTemplateFieldMultiTS<T>::getUndergroundDataArray : invalid type of data dectected ! Expecting " << MLFieldTraits<T>::F1TSWSDAType::TYPE_STR;
+        std::ostringstream oss; oss << "MEDFileTemplateFieldMultiTS<T>::getUndergroundDataArray : invalid type of data detected ! Expecting " << MLFieldTraits<T>::F1TSWSDAType::TYPE_STR;
         throw INTERP_KERNEL::Exception(oss.str());
       }
     return ret2;
@@ -1287,7 +1340,7 @@
     typename Traits<T>::ArrayType *ret2(dynamic_cast<typename Traits<T>::ArrayType *>(ret));
     if(!ret2)
       {
-        std::ostringstream oss; oss << "MEDFileTemplateFieldMultiTS<T>::getUndergroundDataArrayExt : invalid type of data dectected ! Expecting " << MLFieldTraits<T>::F1TSWSDAType::TYPE_STR;
+        std::ostringstream oss; oss << "MEDFileTemplateFieldMultiTS<T>::getUndergroundDataArrayExt : invalid type of data detected ! Expecting " << MLFieldTraits<T>::F1TSWSDAType::TYPE_STR;
         throw INTERP_KERNEL::Exception(oss.str());
       }
     return ret2;
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileFieldVisitor.hxx MEDCOUPLING_new/src/MEDLoader/MEDFileFieldVisitor.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileFieldVisitor.hxx	2018-04-19 17:04:36.759223161 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileFieldVisitor.hxx	2018-04-19 17:25:17.860799788 +0200
@@ -48,6 +48,7 @@
     virtual void endPerMeshPerTypeEntry(const MEDFileFieldPerMeshPerTypeCommon *pmpt) = 0;
     //
     virtual void newPerMeshPerTypePerDisc(const MEDFileFieldPerMeshPerTypePerDisc *pmptpd) = 0;
+    virtual ~MEDFileFieldVisitor() { }
   };
 }
 
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileJoint.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileJoint.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileJoint.cxx	2018-04-19 17:04:36.759223161 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileJoint.cxx	2018-04-19 17:25:17.863799847 +0200
@@ -357,7 +357,7 @@
   if ( getNumberOfCorrespondences() != other->getNumberOfCorrespondences() )
     return false;
 
-  std::vector<int> found( getNumberOfCorrespondences(), false );
+  std::vector<bool> found( getNumberOfCorrespondences(), false );
   for(int i=0; i<getNumberOfCorrespondences(); i++)
     {
       int j;
@@ -410,6 +410,7 @@
     }
   return oss.str();
 }
+
 INTERP_KERNEL::NormalizedCellType MEDFileJointOneStep::convertGeometryType(med_geometry_type geotype)
 {
   INTERP_KERNEL::NormalizedCellType result=INTERP_KERNEL::NORM_ERROR;
@@ -423,6 +424,7 @@
     }
   return result;
 }
+
 std::size_t MEDFileJoint::getHeapMemorySizeWithoutChildren() const
 {
   return _joint.capacity()*sizeof(MCAuto<MEDFileJointOneStep>);
@@ -545,20 +547,22 @@
     return false;
   if(_domain_number!=other->_domain_number)
     return false;
-  std::vector<int> found( getNumberOfSteps(), false );
-  for(int i=0; i<getNumberOfSteps(); i++)
+  int nbTS(getNumberOfSteps());
+  if(nbTS!=other->getNumberOfSteps())
+    return false;
+  std::vector<bool> found(nbTS,false);
+  for(int i=0;i<nbTS;i++)
     {
       int j;
-      for(j=0; j<getNumberOfSteps(); j++)
+      for(j=0;j<nbTS;j++)
         {
-          if ( !found[ j ] &&
-            getStepAtPos(i)->isEqual(other->getStepAtPos(j)))
+          if(!found[j] && getStepAtPos(i)->isEqual(other->getStepAtPos(j)))
             {
-              found[ j ] = true;
+              found[j]=true;
               break;
             }
         }
-      if ( j == getNumberOfSteps() )
+      if(j==nbTS)
         return false;
     }
   return true;
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileMesh.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileMesh.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileMesh.cxx	2018-04-19 17:04:36.760223181 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileMesh.cxx	2018-04-19 17:25:17.810798800 +0200
@@ -673,6 +673,35 @@
   return ret;
 }
 
+void MEDFileMesh::removeGroupAtLevel(int meshDimRelToMaxExt, const std::string& name)
+{
+  std::map<std::string, std::vector<std::string> >::iterator it(_groups.find(name));
+  std::vector<std::string> grps(getGroupsNames());
+  if(it==_groups.end())
+    {
+      std::ostringstream oss; oss << "No such groupname \"" << name << "\" !\nAvailable groups are :";
+      std::copy(grps.begin(),grps.end(),std::ostream_iterator<std::string>(oss," "));
+      throw INTERP_KERNEL::Exception(oss.str().c_str());
+    }
+  const std::vector<std::string> &famsOnGrp((*it).second);
+  std::vector<int> famIds(getFamiliesIdsOnGroup(name));
+  const DataArrayInt *famArr(getFamilyFieldAtLevel(meshDimRelToMaxExt));
+  if(!famArr)
+    return ;
+  MCAuto<DataArrayInt> vals(famArr->getDifferentValues());
+  MCAuto<DataArrayInt> famIds2(DataArrayInt::NewFromStdVector(famIds));
+  MCAuto<DataArrayInt> idsToKill(famIds2->buildIntersection(vals));
+  if(idsToKill->empty())
+    return ;
+  std::vector<std::string> newFamsOnGrp;
+  for(std::vector<std::string>::const_iterator it=famsOnGrp.begin();it!=famsOnGrp.end();it++)
+    {
+      if(!idsToKill->presenceOfValue(getFamilyId(*it)))
+         newFamsOnGrp.push_back(*it);
+    }
+  (*it).second=newFamsOnGrp;
+}
+
 /*!
  * Removes a group from \a this mesh.
  *  \param [in] name - the name of the group to remove.
@@ -680,9 +709,8 @@
  */
 void MEDFileMesh::removeGroup(const std::string& name)
 {
-  std::string oname(name);
-  std::map<std::string, std::vector<std::string> >::iterator it=_groups.find(oname);
-  std::vector<std::string> grps=getGroupsNames();
+  std::map<std::string, std::vector<std::string> >::iterator it=_groups.find(name);
+  std::vector<std::string> grps(getGroupsNames());
   if(it==_groups.end())
     {
       std::ostringstream oss; oss << "No such groupname \"" << name << "\" !\nAvailable groups are :";
@@ -795,7 +823,7 @@
 }
 
 /*!
- * This method has no impact on groups. This method only works on families. This method firstly removes families not refered by any groups in \a this, then all unused entities
+ * This method has no impact on groups. This method only works on families. This method firstly removes families not referred by any groups in \a this, then all unused entities
  * are put as belonging to family 0 ("FAMILLE_ZERO"). Finally, all orphanFamilies are killed.
  * This method raises an exception if "FAMILLE_ZERO" is already belonging to a group.
  *
@@ -1256,6 +1284,19 @@
     }
 }
 
+void MEDFileMesh::checkNoGroupClash(const DataArrayInt *famArr, const std::string& grpName) const
+{
+  std::vector<std::string> grpsNames(getGroupsNames());
+  if(std::find(grpsNames.begin(),grpsNames.end(),grpName)==grpsNames.end())
+    return ;
+  std::vector<int> famIds(getFamiliesIdsOnGroup(grpName));
+  if(famArr->presenceOfValue(famIds))
+    {
+      std::ostringstream oss; oss << "MEDFileUMesh::addGroup : Group with name \"" << grpName << "\" already exists at specified level ! Destroy it before calling this method !";
+      throw INTERP_KERNEL::Exception(oss.str().c_str());
+    }
+}
+
 /*!
  * \param [in] ids ids and group name of the new group to add. The ids should be sorted and different each other (MED file norm).
  * \parma [in,out] famArr family array on level of interest to be renumbered. The input pointer should be not \c NULL (no check of that will be performed)
@@ -1268,13 +1309,8 @@
   if(grpName.empty())
     throw INTERP_KERNEL::Exception("MEDFileUMesh::addGroup : empty group name ! MED file format do not accept empty group name !");
   ids->checkStrictlyMonotonic(true);
-  famArr->incrRef(); MCAuto<DataArrayInt> famArrTmp(famArr);
-  std::vector<std::string> grpsNames=getGroupsNames();
-  if(std::find(grpsNames.begin(),grpsNames.end(),grpName)!=grpsNames.end())
-    {
-      std::ostringstream oss; oss << "MEDFileUMesh::addGroup : Group with name \"" << grpName << "\" already exists ! Destroy it before calling this method !";
-      throw INTERP_KERNEL::Exception(oss.str().c_str());
-    }
+  checkNoGroupClash(famArr,grpName);
+  MCAuto<DataArrayInt> famArrTmp; famArrTmp.takeRef(famArr);
   std::list< MCAuto<DataArrayInt> > allFamIds(getAllNonNullFamilyIds());
   allFamIds.erase(std::find(allFamIds.begin(),allFamIds.end(),famArrTmp));
   MCAuto<DataArrayInt> famIds=famArr->selectByTupleIdSafe(ids->begin(),ids->end());
@@ -1331,8 +1367,15 @@
       famArr->setPartOfValuesSimple3(familyIds[i],da->begin(),da->end(),0,1,1);
     }
   _families=families;
+  std::map<std::string, std::vector<std::string> >::iterator itt(groups.find(grpName));
+  if(itt!=groups.end())
+    {
+      std::vector<std::string>& famsOnGrp((*itt).second);
+      famsOnGrp.insert(famsOnGrp.end(),fams.begin(),fams.end());
+    }
+  else
+    groups[grpName]=fams;
   _groups=groups;
-  _groups[grpName]=fams;
 }
 
 void MEDFileMesh::changeAllGroupsContainingFamily(const std::string& familyNameToChange, const std::vector<std::string>& newFamiliesNames)
@@ -2282,7 +2325,7 @@
 }
 
 /*!
- * \b WARNING this implementation is dependant from MEDCouplingMappedExtrudedMesh::buildUnstructured !
+ * \b WARNING this implementation is dependent from MEDCouplingMappedExtrudedMesh::buildUnstructured !
  * \sa MEDCouplingMappedExtrudedMesh::buildUnstructured , MEDCouplingMappedExtrudedMesh::build3DUnstructuredMesh
  */
 MEDFileUMesh *MEDFileUMesh::New(const MEDCouplingMappedExtrudedMesh *mem)
@@ -2776,7 +2819,7 @@
   if(getAxisType()!=AX_CART)
     {
       std::ostringstream oss; oss << "MEDFileMesh::checkCartesian : request for method that is dedicated to a cartesian convention ! But you are not in cartesian convention (" << DataArray::GetAxisTypeRepr(getAxisType()) << ").";
-      oss << std::endl << "To perform operation you have two possiblities :" << std::endl;
+      oss << std::endl << "To perform operation you have two possibilities :" << std::endl;
       oss << " - call setAxisType(AX_CART)" << std::endl;
       oss << " - call cartesianize()";
       throw INTERP_KERNEL::Exception(oss.str().c_str());
@@ -3635,7 +3678,7 @@
 /*!
  * This method is for advanced users. There is two storing strategy of mesh in \a this.
  * Either MEDCouplingUMesh, or vector of MEDCoupling1GTUMesh instances.
- * When assignement is done the first one is done, which is not optimal in write mode for MED file.
+ * When assignment is done the first one is done, which is not optimal in write mode for MED file.
  * This method allows to switch from MEDCouplingUMesh mode to MEDCoupling1GTUMesh mode.
  */
 void MEDFileUMesh::forceComputationOfParts() const
@@ -4133,12 +4176,12 @@
 /*! \endcond */
 
 /*!
- * Array returned is the correspondance in \b old \b to \b new format. The returned array is newly created and should be dealt by the caller.
+ * Array returned is the correspondence in \b old \b to \b new format. The returned array is newly created and should be dealt by the caller.
  * The maximum value stored in returned array is the number of nodes of \a this minus 1 after call of this method.
  * The size of returned array is the number of nodes of the old (previous to the call of this method) number of nodes.
  * -1 values in returned array means that the corresponding old node is no more used.
  *
- * \return newly allocated array containing correspondance in \b old \b to \b new format. If all nodes in \a this are fetched \c NULL pointer is returned and nothing
+ * \return newly allocated array containing correspondence in \b old \b to \b new format. If all nodes in \a this are fetched \c NULL pointer is returned and nothing
  *         is modified in \a this.
  * \throw If no coordinates are set in \a this or if there is in any available mesh in \a this a cell having a nodal connectivity containing a node id not in the range of
  *  set coordinates.
@@ -4874,7 +4917,7 @@
   if(!coords)
     throw INTERP_KERNEL::Exception("MEDFileUMesh::addNodeGroup : no coords set !");
   int nbOfNodes(coords->getNumberOfTuples());
-  if(!((DataArrayInt *)_fam_coords))
+  if(_fam_coords.isNull())
     { _fam_coords=DataArrayInt::New(); _fam_coords->alloc(nbOfNodes,1); _fam_coords->fillWithZero(); }
   //
   addGroupUnderground(true,ids,_fam_coords);
@@ -5005,7 +5048,7 @@
  *
  * \param [in] ms - List of unstructured meshes lying on the same coordinates and having different mesh dimesnion.
  * \param [in] renum - the parameter (set to false by default) that tells the beheviour if there is a mesh on \a ms that is not geo type sorted.
- *                     If false, an exception ois thrown. If true the mesh is reordered automatically. It is highly recommanded to let this parameter to false.
+ *                     If false, an exception is thrown. If true the mesh is reordered automatically. It is highly recommended to let this parameter to false.
  *
  * \throw If \a there is a null pointer in \a ms.
  * \sa MEDFileUMesh::setMeshAtLevel
@@ -6095,7 +6138,7 @@
 }
 
 /*!
- * Returns a pointer to mesh at the specified level (here 0 is compulsary for cartesian mesh).
+ * Returns a pointer to mesh at the specified level (here 0 is compulsory for cartesian mesh).
  * 
  * \return a pointer to cartesian mesh that need to be managed by the caller.
  * \warning the returned pointer has to be managed by the caller.
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileMeshElt.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileMeshElt.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileMeshElt.cxx	2018-04-19 17:04:36.761223201 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileMeshElt.cxx	2018-04-19 17:25:17.865799887 +0200
@@ -141,7 +141,7 @@
           nbOfElt=tmp;
           whichEntity=entities[i];
           if(i>0)
-            std::cerr << "WARNING : MEDFile has been detected to be no compilant with MED 3 : Please change entity in MEDFile for geotype " <<  geoElt << std::endl;
+            std::cerr << "WARNING : MEDFile has been detected to be noncompliant with MED 3 : Please change entity in MEDFile for geotype " <<  geoElt << std::endl;
         }
     }
   return nbOfElt>0;
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileMesh.hxx MEDCOUPLING_new/src/MEDLoader/MEDFileMesh.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileMesh.hxx	2018-04-19 17:04:36.761223201 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileMesh.hxx	2018-04-19 17:25:17.831799215 +0200
@@ -136,6 +136,7 @@
     MEDLOADER_EXPORT static std::string GetMagicFamilyStr();
     MEDLOADER_EXPORT void assignFamilyNameWithGroupName();
     MEDLOADER_EXPORT std::vector<std::string> removeEmptyGroups();
+    MEDLOADER_EXPORT void removeGroupAtLevel(int meshDimRelToMaxExt, const std::string& name);
     MEDLOADER_EXPORT void removeGroup(const std::string& name);
     MEDLOADER_EXPORT void removeFamily(const std::string& name);
     MEDLOADER_EXPORT std::vector<std::string> removeOrphanGroups();
@@ -227,6 +228,7 @@
     bool areEquivalencesEqual(const MEDFileMesh *other, std::string& what) const;
     void getEquivalencesRepr(std::ostream& oss) const;
     void checkCartesian() const;
+    void checkNoGroupClash(const DataArrayInt *famArr, const std::string& grpName) const;
   private:
     virtual void writeMeshLL(med_idt fid) const = 0;
   protected:
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileMeshLL.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileMeshLL.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileMeshLL.cxx	2018-04-19 17:04:36.761223201 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileMeshLL.cxx	2018-04-19 17:25:17.851799610 +0200
@@ -331,7 +331,7 @@
       INTERP_KERNEL::AutoPtr<char> groName=MEDLoaderBase::buildEmptyString(MED_LNAME_SIZE*ngro);
       int i=0;
       for(std::vector<std::string>::const_iterator it2=(*it).second.second.begin();it2!=(*it).second.second.end();it2++,i++)
-        MEDLoaderBase::safeStrCpy2((*it2).c_str(),MED_LNAME_SIZE-1,groName+i*MED_LNAME_SIZE,tooLongStrPol);
+        MEDLoaderBase::safeStrCpy2((*it2).c_str(),MED_LNAME_SIZE,groName+i*MED_LNAME_SIZE,tooLongStrPol);
       INTERP_KERNEL::AutoPtr<char> famName=MEDLoaderBase::buildEmptyString(MED_NAME_SIZE);
       MEDLoaderBase::safeStrCpy((*it).first.c_str(),MED_NAME_SIZE,famName,tooLongStrPol);
       int ret=MEDfamilyCr(fid,mname.c_str(),famName,(*it).second.first,ngro,groName);
@@ -354,7 +354,7 @@
 
 /*!
  * This method is dedicated to the killers that use a same family name to store different family ids. MED file API authorizes it.
- * So this method renames families (if needed generaly not !) in order to have a discriminant name for families.
+ * So this method renames families (if needed generally not !) in order to have a discriminant name for families.
  */
 void MEDFileMeshL2::RenameFamiliesFromFileToMemInternal(std::vector< std::pair<std::string,std::pair<int,std::vector<std::string> > > >& crudeFams)
 {
@@ -387,7 +387,7 @@
 
 /*!
  * This method is dedicated to the killers that use a same family name to store different family ids. MED file API authorizes it.
- * So this method renames families (if needed generaly not !) in order to have a discriminant name for families.
+ * So this method renames families (if needed generally not !) in order to have a discriminant name for families.
  */
 void MEDFileMeshL2::RenameFamiliesFromMemToFileInternal(std::vector< std::pair<std::string,std::pair<int,std::vector<std::string> > > >& crudeFams)
 {
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDFileUtilities.cxx MEDCOUPLING_new/src/MEDLoader/MEDFileUtilities.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDFileUtilities.cxx	2018-04-19 17:04:36.762223221 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDFileUtilities.cxx	2018-04-19 17:25:17.867799926 +0200
@@ -190,7 +190,7 @@
 void MEDCoupling::MEDFileWritableStandAlone::write30(const std::string& fileName, int mode) const
 {
   med_access_mode medmod(MEDFileUtilities::TraduceWriteMode(mode));
-#if MED_NUM_MAJEUR>=3 && MED_NUM_MINEUR>=2 && MED_NUM_RELEASE>=1
+#if MED_NUM_MAJEUR>3 || ( MED_NUM_MAJEUR==3 && ( (MED_NUM_MINEUR==2 && MED_NUM_RELEASE>=1) || MED_NUM_MINEUR>=3) )
   MEDFileUtilities::AutoFid fid(MEDfileVersionOpen(fileName.c_str(),medmod,3,0,0));
   writeLL(fid);
 #else
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDLoaderBase.cxx MEDCOUPLING_new/src/MEDLoader/MEDLoaderBase.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDLoaderBase.cxx	2018-04-19 17:04:36.762223221 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDLoaderBase.cxx	2018-04-19 17:25:17.862799828 +0200
@@ -130,7 +130,7 @@
 
 /*!
  * This method operates a safe copy from 'src' to 'dest' by checking the size of 'src' before trying to copy.
- * If size of 'src' string is higher than 'maxLgth' the behaviour is dependant from 'behaviour' parameter.
+ * If size of 'src' string is higher than 'maxLgth' the behaviour is dependent from 'behaviour' parameter.
  * If 'behaviour' equals 0 an exception is thrown. If 'behaviour' equals 1 an attempt of zipping of string will be done
  * ( see zipString to have more details).
  */
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDLoader.cxx MEDCOUPLING_new/src/MEDLoader/MEDLoader.cxx
--- MEDCOUPLING_old/src/MEDLoader/MEDLoader.cxx	2018-04-19 17:04:36.762223221 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDLoader.cxx	2018-04-19 17:25:17.735797317 +0200
@@ -29,7 +29,10 @@
 #include "MEDCouplingUMesh.hxx"
 #include "MEDCouplingMemArray.hxx"
 #include "MEDCouplingFieldDouble.hxx"
+#include "MEDCouplingFieldFloat.hxx"
+#include "MEDCouplingFieldInt.hxx"
 #include "MEDCouplingGaussLocalization.hxx"
+#include "MEDCouplingTraits.hxx"
 #include "MCAuto.hxx"
 
 #include "InterpKernelAutoPtr.hxx"
@@ -64,6 +67,7 @@
   MED_TETRA10,
   MED_PYRA13,
   MED_PENTA15,
+  MED_PENTA18,
   MED_HEXA20,
   MED_HEXA27,
   MED_POLYGON,
@@ -90,6 +94,7 @@
   INTERP_KERNEL::NORM_TETRA10,
   INTERP_KERNEL::NORM_PYRA13,
   INTERP_KERNEL::NORM_PENTA15,
+  INTERP_KERNEL::NORM_PENTA18,
   INTERP_KERNEL::NORM_HEXA20,
   INTERP_KERNEL::NORM_HEXA27,
   INTERP_KERNEL::NORM_POLYGON,
@@ -124,7 +129,7 @@
   MED_PENTA15,//25
   MED_NONE,//26
   MED_HEXA27,//27
-  MED_NONE,//28
+  MED_PENTA18,//28
   MED_NONE,//29
   MED_HEXA20,//30
   MED_POLYHEDRON,//31
@@ -308,7 +313,7 @@
 
 std::string MEDCoupling::MEDFileVersionOfFileStr(const std::string& fileName)
 {
-#if MED_NUM_MAJEUR>=3 && MED_NUM_MINEUR>=2 && MED_NUM_RELEASE>=1
+#if MED_NUM_MAJEUR>3 || ( MED_NUM_MAJEUR==3 && ( (MED_NUM_MINEUR==2 && MED_NUM_RELEASE>=1) || MED_NUM_MINEUR>=3) )
   MEDFileUtilities::AutoFid fid(MEDCoupling::OpenMEDFileForRead(fileName));
   const int SZ=20;
   const char START_EXPECTED[]="MED-";
@@ -341,7 +346,7 @@
 }
 
 /*!
- * This method sets the epsilon value used for node comparison when trying to buid a profile for a field on node/cell on an already written mesh.
+ * This method sets the epsilon value used for node comparison when trying to build a profile for a field on node/cell on an already written mesh.
  */
 void MEDCoupling::SetEpsilonForNodeComp(double val)
 {
@@ -1153,7 +1158,7 @@
   return mmuPtr->getGroups(meshDimRelToMax,grps,true);
 }
 
-MCAuto<MEDCoupling::MEDCouplingFieldDouble> MEDCoupling::ReadField(const std::string& fileName)
+MCAuto<MEDCoupling::MEDCouplingField> MEDCoupling::ReadField(const std::string& fileName)
 {
   std::vector<std::string> fieldNames(GetAllFieldNames(fileName));
   std::size_t sz(fieldNames.size());
@@ -1176,7 +1181,7 @@
   return ReadField(fileName,fieldNames[0]);
 }
 
-MCAuto<MEDCoupling::MEDCouplingFieldDouble> MEDCoupling::ReadField(const std::string& fileName, const std::string& fieldName)
+MCAuto<MEDCoupling::MEDCouplingField> MEDCoupling::ReadField(const std::string& fileName, const std::string& fieldName)
 {
   std::vector< std::pair< std::pair<int,int>, double> > iterations(GetAllFieldIterations(fileName,fieldName));
   std::size_t sz(iterations.size());
@@ -1199,12 +1204,38 @@
   return ReadField(fileName,fieldName,iterations[0].first.first,iterations[0].first.second);
 }
 
-MCAuto<MEDCoupling::MEDCouplingFieldDouble> MEDCoupling::ReadField(const std::string& fileName, const std::string& fieldName, int iteration, int order)
+MCAuto<MEDCoupling::MEDCouplingField> MEDCoupling::ReadField(const std::string& fileName, const std::string& fieldName, int iteration, int order)
 {
-  MCAuto<MEDFileField1TS> f(MEDFileField1TS::New(fileName,fieldName,iteration,order));
+  MCAuto<MEDFileAnyTypeField1TS> f(MEDFileAnyTypeField1TS::New(fileName,fieldName,iteration,order));
   MCAuto<MEDFileMesh> mesh(MEDFileMesh::New(fileName,f->getMeshName()));
-  MCAuto<MEDCoupling::MEDCouplingFieldDouble> ret(f->field(mesh));
-  return ret;
+  {
+    MCAuto<MEDFileField1TS> f1(MEDCoupling::DynamicCast<MEDFileAnyTypeField1TS,MEDFileField1TS>(f));
+    if(f1.isNotNull())
+      {
+        MCAuto<MEDCoupling::MEDCouplingFieldDouble> ret(f1->field(mesh));
+        return MEDCoupling::DynamicCast<MEDCouplingFieldDouble,MEDCouplingField>(ret);
+      }
+  }
+  {
+    MCAuto<MEDFileIntField1TS> f1(MEDCoupling::DynamicCast<MEDFileAnyTypeField1TS,MEDFileIntField1TS>(f));
+    if(f1.isNotNull())
+      {
+        MCAuto<MEDCoupling::MEDCouplingFieldInt> ret(f1->field(mesh));
+        return MEDCoupling::DynamicCast<MEDCouplingFieldInt,MEDCouplingField>(ret);
+      }
+  }
+  {
+    MCAuto<MEDFileFloatField1TS> f1(MEDCoupling::DynamicCast<MEDFileAnyTypeField1TS,MEDFileFloatField1TS>(f));
+    if(f1.isNotNull())
+      {
+        MCAuto<MEDCoupling::MEDCouplingFieldFloat> ret(f1->field(mesh));
+        return MEDCoupling::DynamicCast<MEDCouplingFieldFloat,MEDCouplingField>(ret);
+      }
+  }
+  throw INTERP_KERNEL::Exception("MEDCoupling::ReadField : only FLOAT32, FLOAT64 and INT32 supported for the moment !");
+  //MCAuto<MEDFileMesh> mesh(MEDFileMesh::New(fileName,f->getMeshName()));
+  //MCAuto<MEDCoupling::MEDCouplingFieldDouble> ret(f->field(mesh));
+  //return ret;
 }
 
 MCAuto<MEDCoupling::MEDCouplingFieldDouble> MEDCoupling::ReadField(MEDCoupling::TypeOfField type, const std::string& fileName, const std::string& meshName, int meshDimRelToMax, const std::string& fieldName, int iteration, int order)
@@ -1463,25 +1494,26 @@
 
 void MEDCoupling::WriteUMeshes(const std::string& fileName, const std::vector<const MEDCoupling::MEDCouplingUMesh *>& meshes, bool writeFromScratch)
 {
-  int mod=writeFromScratch?2:0;
+  int mod(writeFromScratch?2:0);
   MCAuto<MEDFileUMesh> m(MEDFileUMesh::New());
   AssignStaticWritePropertiesTo(*m);
   m->setMeshes(meshes,true);
   m->write(fileName,mod);
 }
 
-void MEDLoaderNS::writeFieldWithoutReadingAndMappingOfMeshInFile(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch)
+template<class T>
+void MEDLoaderNS::writeFieldWithoutReadingAndMappingOfMeshInFile(const std::string& fileName, const typename MEDCoupling::Traits<T>::FieldType *f, bool writeFromScratch)
 {
-  MCAuto<MEDFileField1TS> ff(MEDFileField1TS::New());
+  MCAuto< typename MLFieldTraits<T>::F1TSType > ff(MLFieldTraits<T>::F1TSType::New());
   AssignStaticWritePropertiesTo(*ff);
-  MCAuto<MEDCouplingFieldDouble> f2(f->deepCopy());
+  MCAuto<typename MEDCoupling::Traits<T>::FieldType> f2(f->deepCopy());
   const MEDCouplingMesh *m(f2->getMesh());
   const MEDCouplingUMesh *um(dynamic_cast<const MEDCouplingUMesh *>(m));
   const MEDCoupling1GTUMesh *um2(dynamic_cast<const MEDCoupling1GTUMesh *>(m));
   const MEDCouplingCMesh *um3(dynamic_cast<const MEDCouplingCMesh *>(m));
   const MEDCouplingCurveLinearMesh *um4(dynamic_cast<const MEDCouplingCurveLinearMesh *>(m));
   MCAuto<MEDFileMesh> mm;
-  int mod=writeFromScratch?2:0;
+  int mod(writeFromScratch?2:0);
   if(um)
     {
       MCAuto<MEDFileUMesh> mmu(MEDFileUMesh::New());
@@ -1523,12 +1555,13 @@
   ff->write(fileName,0);
 }
 
-void MEDCoupling::WriteField(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch)
+template<class T>
+void WriteFieldT(const std::string& fileName, const typename MEDCoupling::Traits<T>::FieldType *f, bool writeFromScratch)
 {
   if(!f)
     throw INTERP_KERNEL::Exception("WriteField : input field is NULL !");
   f->checkConsistencyLight();
-  int status=MEDLoaderBase::getStatusOfFile(fileName);
+  int status(MEDLoaderBase::getStatusOfFile(fileName));
   if(status!=MEDLoaderBase::EXIST_RW && status!=MEDLoaderBase::NOT_EXIST)
     {
       std::ostringstream oss; oss << "File with name \'" << fileName << "\' has not valid permissions !";
@@ -1536,44 +1569,44 @@
     }
   if(writeFromScratch || (!writeFromScratch && status==MEDLoaderBase::NOT_EXIST))
     {
-      MEDLoaderNS::writeFieldWithoutReadingAndMappingOfMeshInFile(fileName,f,true);
+      MEDLoaderNS::writeFieldWithoutReadingAndMappingOfMeshInFile<T>(fileName,f,true);
     }
   else
     {
-      std::vector<std::string> meshNames=GetMeshNames(fileName);
+      std::vector<std::string> meshNames(GetMeshNames(fileName));
       if(!f->getMesh())
         throw INTERP_KERNEL::Exception("WriteField : trying to write a field with no mesh !");
       std::string fileNameCpp(f->getMesh()->getName());
       if(std::find(meshNames.begin(),meshNames.end(),fileNameCpp)==meshNames.end())
-        MEDLoaderNS::writeFieldWithoutReadingAndMappingOfMeshInFile(fileName,f,false);
+        MEDLoaderNS::writeFieldWithoutReadingAndMappingOfMeshInFile<T>(fileName,f,false);
       else
         {
           MCAuto<MEDFileMesh> mm(MEDFileMesh::New(fileName,f->getMesh()->getName().c_str()));
           AssignStaticWritePropertiesTo(*mm);
           const MEDFileMesh *mmPtr(mm);
-          const MEDFileUMesh *mmuPtr=dynamic_cast<const MEDFileUMesh *>(mmPtr);
+          const MEDFileUMesh *mmuPtr(dynamic_cast<const MEDFileUMesh *>(mmPtr));
           if(!mmuPtr)
             throw INTERP_KERNEL::Exception("WriteField : only umeshes are supported now !");
-          MCAuto<MEDCouplingFieldDouble> f2(f->deepCopy());
-          MEDCouplingUMesh *m=dynamic_cast<MEDCouplingUMesh *>(const_cast<MEDCouplingMesh *>(f2->getMesh()));
+          MCAuto< typename MEDCoupling::Traits<T>::FieldType > f2(f->deepCopy());
+          MEDCouplingUMesh *m(dynamic_cast<MEDCouplingUMesh *>(const_cast<MEDCouplingMesh *>(f2->getMesh())));
           if(!m)
             throw INTERP_KERNEL::Exception("WriteField : only umesh in input field supported !");
-          MCAuto<DataArrayInt> o2n=m->getRenumArrForMEDFileFrmt();
+          MCAuto<DataArrayInt> o2n(m->getRenumArrForMEDFileFrmt());
           f2->renumberCells(o2n->begin(),false);
           m=static_cast<MEDCouplingUMesh *>(const_cast<MEDCouplingMesh *>(f2->getMesh()));
-          MCAuto<MEDCouplingUMesh> mread=mmuPtr->getMeshAtLevel(m->getMeshDimension()-mm->getMeshDimension());
+          MCAuto<MEDCouplingUMesh> mread(mmuPtr->getMeshAtLevel(m->getMeshDimension()-mm->getMeshDimension()));
           if(f2->getTypeOfField()!=ON_NODES)
             {
               m->tryToShareSameCoordsPermute(*mread,_EPS_FOR_NODE_COMP);
-              DataArrayInt *part=0;
-              bool b=mread->areCellsIncludedIn(m,_COMP_FOR_CELL,part);
+              DataArrayInt *part(NULL);
+              bool b(mread->areCellsIncludedIn(m,_COMP_FOR_CELL,part));
               MCAuto<DataArrayInt> partSafe(part);
               if(!b)
                 {
                   std::ostringstream oss; oss << "WriteField : The file \""<< fileName << "\" already contains a mesh named \""<< f->getMesh()->getName() << "\" and this mesh in the file is not compatible (a subpart) with the mesh you intend to write ! This is maybe due to a too strict policy ! Try with to lease it by calling SetCompPolicyForCell !";
                   throw INTERP_KERNEL::Exception(oss.str().c_str());
                 }
-              MCAuto<MEDFileField1TS> f1ts(MEDFileField1TS::New());
+              MCAuto< typename MLFieldTraits<T>::F1TSType > f1ts(MLFieldTraits<T>::F1TSType::New());
               AssignStaticWritePropertiesTo(*f1ts);
               if(part->isIota(mread->getNumberOfCells()))
                 f1ts->setFieldNoProfileSBT(f2);
@@ -1587,15 +1620,15 @@
             }
           else
             {
-              DataArrayInt *part=0;
-              bool b=mread->getCoords()->areIncludedInMe(m->getCoords(),_EPS_FOR_NODE_COMP,part);
+              DataArrayInt *part(NULL);
+              bool b(mread->getCoords()->areIncludedInMe(m->getCoords(),_EPS_FOR_NODE_COMP,part));
               MCAuto<DataArrayInt> partSafe(part);
               if(!b)
                 {
                   std::ostringstream oss; oss << "WriteField : The file \""<< fileName << "\" already contains a mesh named \""<< f->getMesh()->getName() << "\" and this mesh in the file is not compatible (a subpart regarding nodes) with the mesh you intend to write ! This is maybe due to a too strict epsilon ! Try with to lease it by calling SetEpsilonForNodeComp !";
                   throw INTERP_KERNEL::Exception(oss.str().c_str());
                 }
-              MCAuto<MEDFileField1TS> f1ts(MEDFileField1TS::New());
+              MCAuto< typename MLFieldTraits<T>::F1TSType > f1ts(MLFieldTraits<T>::F1TSType::New());
               AssignStaticWritePropertiesTo(*f1ts);
               if(part->isIota(mread->getNumberOfNodes()))
                 f1ts->setFieldNoProfileSBT(f2);
@@ -1610,29 +1643,61 @@
     }
 }
 
-void MEDCoupling::WriteFieldDep(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch)
+void MEDCoupling::WriteField(const std::string& fileName, const MEDCoupling::MEDCouplingField *f, bool writeFromScratch)
+{
+  if(!f)
+    throw INTERP_KERNEL::Exception("WriteField : input field is null !");
+  {
+    const MEDCoupling::MEDCouplingFieldDouble *f1(dynamic_cast<const MEDCoupling::MEDCouplingFieldDouble *>(f));
+    if(f1)
+      {
+        WriteFieldT<double>(fileName,f1,writeFromScratch);
+        return ;
+      }
+  }
+  {
+    const MEDCoupling::MEDCouplingFieldInt *f1(dynamic_cast<const MEDCoupling::MEDCouplingFieldInt *>(f));
+    if(f1)
+      {
+        WriteFieldT<int>(fileName,f1,writeFromScratch);
+        return ;
+      }
+  }
+  {
+    const MEDCoupling::MEDCouplingFieldFloat *f1(dynamic_cast<const MEDCoupling::MEDCouplingFieldFloat *>(f));
+    if(f1)
+      {
+        WriteFieldT<float>(fileName,f1,writeFromScratch);
+        return ;
+      }
+  }
+  throw INTERP_KERNEL::Exception("WriteField : input field is not in FLOAT32, FLOAT64, INT32 !");
+}
+
+void MEDCoupling::WriteFieldDep(const std::string& fileName, const MEDCoupling::MEDCouplingField *f, bool writeFromScratch)
 {
   WriteField(fileName,f,writeFromScratch);
 }
 
-void MEDCoupling::WriteFieldUsingAlreadyWrittenMesh(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f)
+template<class T>
+void WriteFieldUsingAlreadyWrittenMeshT(const std::string& fileName, const typename MEDCoupling::Traits<T>::FieldType *f)
 {
   if(!f)
-    throw INTERP_KERNEL::Exception("WriteFieldUsingAlreadyWrittenMesh : input field is null !");
+    throw INTERP_KERNEL::Exception("WriteFieldUsingAlreadyWrittenMeshT : input field is null !");
   f->checkConsistencyLight();
-  int status=MEDLoaderBase::getStatusOfFile(fileName);
+  int status(MEDLoaderBase::getStatusOfFile(fileName));
   if(status!=MEDLoaderBase::EXIST_RW)
     {
       std::ostringstream oss; oss << "File with name \'" << fileName << "\' has not valid permissions or not exists !";
       throw INTERP_KERNEL::Exception(oss.str().c_str());
     }
-  MCAuto<MEDFileField1TS> f1ts(MEDFileField1TS::New());
+  MCAuto< typename MLFieldTraits<T>::F1TSType > f1ts(MLFieldTraits<T>::F1TSType::New());
   AssignStaticWritePropertiesTo(*f1ts);
   MEDCouplingUMesh *m(dynamic_cast<MEDCouplingUMesh *>(const_cast<MEDCouplingMesh *>(f->getMesh())));
   if(m)
     {
       MCAuto<DataArrayInt> o2n(m->getRenumArrForMEDFileFrmt());
-      MCAuto<MEDCouplingFieldDouble> f2(f->deepCopy());
+      MCAuto< typename MEDCoupling::Traits<T>::FieldType > f2(f->deepCopy());
       f2->renumberCells(o2n->begin(),false);
       f1ts->setFieldNoProfileSBT(f2);
     }
@@ -1640,3 +1705,28 @@
     f1ts->setFieldNoProfileSBT(f);
   f1ts->write(fileName,0);
 }
+
+void MEDCoupling::WriteFieldUsingAlreadyWrittenMesh(const std::string& fileName, const MEDCoupling::MEDCouplingField *f)
+{
+  if(!f)
+    throw INTERP_KERNEL::Exception("WriteFieldUsingAlreadyWrittenMesh : input field is null !");
+  {
+    const MEDCoupling::MEDCouplingFieldDouble *f1(dynamic_cast<const MEDCoupling::MEDCouplingFieldDouble *>(f));
+    if(f1)
+      WriteFieldUsingAlreadyWrittenMeshT<double>(fileName,f1);
+    return ;
+  }
+  {
+    const MEDCoupling::MEDCouplingFieldInt *f1(dynamic_cast<const MEDCoupling::MEDCouplingFieldInt *>(f));
+    if(f1)
+      WriteFieldUsingAlreadyWrittenMeshT<int>(fileName,f1);
+    return ;
+  }
+  {
+    const MEDCoupling::MEDCouplingFieldFloat *f1(dynamic_cast<const MEDCoupling::MEDCouplingFieldFloat *>(f));
+    if(f1)
+      WriteFieldUsingAlreadyWrittenMeshT<float>(fileName,f1);
+    return ;
+  }
+  throw INTERP_KERNEL::Exception("WriteFieldUsingAlreadyWrittenMesh : input field is not in FLOAT32, FLOAT64, INT32 !");
+}
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDLoader.hxx MEDCOUPLING_new/src/MEDLoader/MEDLoader.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDLoader.hxx	2018-04-19 17:04:36.762223221 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDLoader.hxx	2018-04-19 17:25:17.802798642 +0200
@@ -35,6 +35,7 @@
   class DataArrayInt;
   class MEDCouplingMesh;
   class MEDCouplingUMesh;
+  class MEDCouplingField;
   class MEDCouplingFieldDouble;
   class MEDFileWritable;
 
@@ -72,9 +73,9 @@
   MEDLOADER_EXPORT MEDCoupling::MEDCouplingUMesh *ReadUMeshFromFile(const std::string& fileName, const std::string& meshName, int meshDimRelToMax=0);
   MEDLOADER_EXPORT MEDCoupling::MEDCouplingUMesh *ReadUMeshFromFile(const std::string& fileName, int meshDimRelToMax=0);
   MEDLOADER_EXPORT int ReadUMeshDimFromFile(const std::string& fileName, const std::string& meshName);
-  MEDLOADER_EXPORT MCAuto<MEDCoupling::MEDCouplingFieldDouble> ReadField(const std::string& fileName);
-  MEDLOADER_EXPORT MCAuto<MEDCoupling::MEDCouplingFieldDouble> ReadField(const std::string& fileName, const std::string& fieldName);
-  MEDLOADER_EXPORT MCAuto<MEDCoupling::MEDCouplingFieldDouble> ReadField(const std::string& fileName, const std::string& fieldName, int iteration, int order);
+  MEDLOADER_EXPORT MCAuto<MEDCoupling::MEDCouplingField> ReadField(const std::string& fileName);
+  MEDLOADER_EXPORT MCAuto<MEDCoupling::MEDCouplingField> ReadField(const std::string& fileName, const std::string& fieldName);
+  MEDLOADER_EXPORT MCAuto<MEDCoupling::MEDCouplingField> ReadField(const std::string& fileName, const std::string& fieldName, int iteration, int order);
   MEDLOADER_EXPORT MCAuto<MEDCoupling::MEDCouplingFieldDouble> ReadField(MEDCoupling::TypeOfField type, const std::string& fileName, const std::string& meshName, int meshDimRelToMax, const std::string& fieldName, int iteration, int order);
   MEDLOADER_EXPORT std::vector<MEDCoupling::MEDCouplingFieldDouble *> ReadFieldsOnSameMesh(MEDCoupling::TypeOfField type, const std::string& fileName, const std::string& meshName, int meshDimRelToMax, const std::string& fieldName,
                                                                                            const std::vector<std::pair<int,int> >& its);
@@ -96,9 +97,9 @@
   MEDLOADER_EXPORT void WriteUMeshesPartition(const std::string& fileName, const std::string& meshName, const std::vector<const MEDCoupling::MEDCouplingUMesh *>& meshes, bool writeFromScratch);
   MEDLOADER_EXPORT void WriteUMeshesPartitionDep(const std::string& fileName, const std::string& meshName, const std::vector<const MEDCoupling::MEDCouplingUMesh *>& meshes, bool writeFromScratch);
   MEDLOADER_EXPORT void WriteUMeshes(const std::string& fileName, const std::vector<const MEDCoupling::MEDCouplingUMesh *>& meshes, bool writeFromScratch);
-  MEDLOADER_EXPORT void WriteField(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch);
-  MEDLOADER_EXPORT void WriteFieldDep(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch);
-  MEDLOADER_EXPORT void WriteFieldUsingAlreadyWrittenMesh(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f);
+  MEDLOADER_EXPORT void WriteField(const std::string& fileName, const MEDCoupling::MEDCouplingField *f, bool writeFromScratch);
+  MEDLOADER_EXPORT void WriteFieldDep(const std::string& fileName, const MEDCoupling::MEDCouplingField *f, bool writeFromScratch);
+  MEDLOADER_EXPORT void WriteFieldUsingAlreadyWrittenMesh(const std::string& fileName, const MEDCoupling::MEDCouplingField *f);
 
   MEDLOADER_EXPORT void AssignStaticWritePropertiesTo(MEDCoupling::MEDFileWritable& obj);
 }
diff -Naur MEDCOUPLING_old/src/MEDLoader/MEDLoaderNS.hxx MEDCOUPLING_new/src/MEDLoader/MEDLoaderNS.hxx
--- MEDCOUPLING_old/src/MEDLoader/MEDLoaderNS.hxx	2018-04-19 17:04:36.763223241 +0200
+++ MEDCOUPLING_new/src/MEDLoader/MEDLoaderNS.hxx	2018-04-19 17:25:17.736797337 +0200
@@ -35,7 +35,8 @@
 {
   int readUMeshDimFromFile(const std::string& fileName, const std::string& meshName, std::vector<int>& possibilities);
   void dispatchElems(int nbOfElemCell, int nbOfElemFace, int& nbOfElem, med_entity_type& whichEntity);
-  void writeFieldWithoutReadingAndMappingOfMeshInFile(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch);
+  template<class T>
+  void writeFieldWithoutReadingAndMappingOfMeshInFile(const std::string& fileName, const typename MEDCoupling::Traits<T>::FieldType *f, bool writeFromScratch);
   med_int getIdFromMeshName(med_idt fid, const std::string& meshName, std::string& trueMeshName);
   std::vector<std::string> getMeshNamesFid(med_idt fid);
 }
diff -Naur MEDCOUPLING_old/src/MEDLoader/SauvMedConvertor.cxx MEDCOUPLING_new/src/MEDLoader/SauvMedConvertor.cxx
--- MEDCOUPLING_old/src/MEDLoader/SauvMedConvertor.cxx	2018-04-19 17:04:36.764223261 +0200
+++ MEDCOUPLING_new/src/MEDLoader/SauvMedConvertor.cxx	2018-04-19 17:25:17.733797278 +0200
@@ -1925,7 +1925,7 @@
   // 53619905   |       1       2       6       8
   // 53619906   |                                                                SCALAIRE
   // 53619907   |    -63312600499       1       0       0       0      -2       0       2
-  //   where -63312600499 is actualy -633 and 12600499
+  //   where -63312600499 is actually -633 and 12600499
   char hold=_curPos[_width];
   _curPos[_width] = '\0';
   int result = atoi( _curPos );
@@ -2311,7 +2311,7 @@
 
 Group* IntermediateMED::addNewGroup(std::vector<SauvUtilities::Group*>* groupsToFix)
 {
-  if ( _groups.size() == _groups.capacity() ) // re-allocation would occure
+  if ( _groups.size() == _groups.capacity() ) // re-allocation would occur
     {
       std::vector<Group> newGroups( _groups.size() );
       newGroups.push_back( Group() );
@@ -2741,7 +2741,7 @@
       //       if (( x = nodeCoords( elemIt->_nodes[ iNode ])[ 0 ]) < minX )
       //         minX = x, iLeft = iNode;
 
-      //     // indeces of the nodes neighboring the most left one
+      //     // indices of the nodes neighboring the most left one
       //     int iPrev = ( iLeft - 1 < 0 ) ? nbNodes - 1 : iLeft - 1;
       //     int iNext = ( iLeft + 1 == nbNodes ) ? 0 : iLeft + 1;
       //     // find components of prev-left and left-next vectors
@@ -3843,7 +3843,7 @@
   init( dimm );
 }
 /*!
- * \brief Initialize iteration on cells of given dimention
+ * \brief Initialize iteration on cells of given dimension
  */
 void CellsByDimIterator::init(const int  dimm)
 {
diff -Naur MEDCOUPLING_old/src/MEDLoader/SauvMedConvertor.hxx MEDCOUPLING_new/src/MEDLoader/SauvMedConvertor.hxx
--- MEDCOUPLING_old/src/MEDLoader/SauvMedConvertor.hxx	2018-04-19 17:04:36.764223261 +0200
+++ MEDCOUPLING_new/src/MEDLoader/SauvMedConvertor.hxx	2018-04-19 17:25:17.741797436 +0200
@@ -170,7 +170,7 @@
   };
   // ==============================================================================
   /*!
-   * \if developper
+   * \if developer
    * Iterator on set of Cell's of given dimension
    * \endif
    */
@@ -195,7 +195,7 @@
 
   // ==============================================================================
   /*!
-   * \if developper
+   * \if developer
    * Container of Node's. Prevents re-allocation at addition of Node's
    * \endif
    */
@@ -226,7 +226,7 @@
 
   // ==============================================================================
   /*!
-   * \if developper
+   * \if developer
    * Intermediate structure used to store data read from the Sauve format file.
    * The structure provides functions that transform the stored data to the MED format
    *
diff -Naur MEDCOUPLING_old/src/MEDLoader/SauvReader.cxx MEDCOUPLING_new/src/MEDLoader/SauvReader.cxx
--- MEDCOUPLING_old/src/MEDLoader/SauvReader.cxx	2018-04-19 17:04:36.764223261 +0200
+++ MEDCOUPLING_new/src/MEDLoader/SauvReader.cxx	2018-04-19 17:25:17.801798622 +0200
@@ -220,7 +220,7 @@
 
 int SauvReader::readPileNumber(int& nbNamedObjects, int& nbObjects)
 {
-  // FORMAT(' PILE NUMERO',I4,'NBRE ObjectS NOMMES',I8,'NBRE ObjectS',I8)
+  // FORMAT(' PILE NUMERO',I4,'NBRE OBJETS NOMMES',I8,'NBRE OBJETS',I8)
   int pileNumber;
   if ( !isASCII() )
     {
@@ -233,7 +233,7 @@
     {
       char* line;
       getNextLine(line);
-      const char *s1 = " PILE NUMERO", *s2 = "NBRE ObjectS NOMMES", *s3 = "NBRE ObjectS";
+      const char *s1 = " PILE NUMERO", *s2 = "NBRE OBJETS NOMMES", *s3 = "NBRE OBJETS";
       if ( ! GIBI_EQUAL( line, s1 ) )
         THROW_IK_EXCEPTION("Could not read the pile number " << lineNb() );
       line           = line + strlen(s1);
diff -Naur MEDCOUPLING_old/src/MEDLoader/SauvWriter.cxx MEDCOUPLING_new/src/MEDLoader/SauvWriter.cxx
--- MEDCOUPLING_old/src/MEDLoader/SauvWriter.cxx	2018-04-19 17:04:36.764223261 +0200
+++ MEDCOUPLING_new/src/MEDLoader/SauvWriter.cxx	2018-04-19 17:25:17.853799650 +0200
@@ -106,7 +106,7 @@
 
   //================================================================================
   /*!
-   * \brief Converts MED long names into SAUVE short ones, returnes a healed long name
+   * \brief Converts MED long names into SAUVE short ones, returns a healed long name
    */
   //================================================================================
 
@@ -559,7 +559,7 @@
 
 //================================================================================
 /*!
- * \brief Transorm a profile into ids of mesh elements
+ * \brief Transform a profile into ids of mesh elements
  */
 //================================================================================
 
@@ -725,7 +725,7 @@
 
   writeNames( nameNbMap );
 
-  TFieldCounter fcount( *_sauvFile, 10 ); // 10 intergers per line
+  TFieldCounter fcount( *_sauvFile, 10 ); // 10 integers per line
 
   for ( size_t iSub = 0; iSub < _subs.size(); ++iSub )
     {
@@ -832,7 +832,7 @@
              << zeroI8
              << zeroI8 << endl;
 
-  TFieldCounter fcount( *_sauvFile, 10 ); // 10 intergers per line
+  TFieldCounter fcount( *_sauvFile, 10 ); // 10 integers per line
   for ( size_t i = 0; i < subIDs.size(); ++i, fcount++ )
     *_sauvFile << setw(8) << subIDs[i];
 }
@@ -1170,7 +1170,7 @@
               fcount.stop();
             }
         }
-    } // loop on fiels
+    } // loop on files
 }
 
 //================================================================================
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/case2med MEDCOUPLING_new/src/MEDLoader/Swig/case2med
--- MEDCOUPLING_old/src/MEDLoader/Swig/case2med	2018-04-19 17:04:36.768223341 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/case2med	2018-04-19 17:25:17.796798523 +0200
@@ -46,7 +46,7 @@
 try:
     medfd=cr.loadInMEDFileDS()
 except:
-    print "An error occured during the conversion!"
+    print "An error occurred during the conversion!"
     print "#######################################"
     raise
 medfd.write(fOut,2)
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/CaseReader.py MEDCOUPLING_new/src/MEDLoader/Swig/CaseReader.py
--- MEDCOUPLING_old/src/MEDLoader/Swig/CaseReader.py	2018-04-19 17:04:36.765223281 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/CaseReader.py	2018-04-19 17:25:17.749797594 +0200
@@ -23,7 +23,7 @@
 import numpy as np
 from MEDLoader import *
 from CaseIO import CaseIO
-import sys,re
+import sys,re,os
 
 class CaseReader(CaseIO):
     """ Converting a file in the Case format (Ensight) to the MED format.
@@ -77,7 +77,7 @@
         arr0mc2=DataArrayInt(len(arr0),2) ; arr0mc2[:,0]=DataArrayInt(arr0)-1 ; arr0mc2[:,1]=1 ; arr0mc2.rearrange(1) ; arr0mc2.computeOffsetsFull()
         arr0mc3=DataArrayInt.Range(0,2*len(arr0),2).buildExplicitArrByRanges(arr0mc2)
         arr1mc0=DataArrayInt(arr1) ; arr1mc0.computeOffsetsFull()
-        arr1mc1=arr1mc0[arr0mc0] ; arr1mc1[1:]+=arr0mc0[1:] 
+        arr1mc1=arr1mc0[arr0mc0] ; arr1mc1[1:]+=arr0mc0[1:]
         arr1mc2=DataArrayInt(arr1).deepCopy() ; arr1mc2+=1 ; arr1mc2.computeOffsetsFull()
         arr2mc0=(arr1mc2[1:])[arr0mc3]
         #
@@ -109,7 +109,7 @@
         return m
 
     def __convertGeo2MED(self,geoFileName):
-        """ Convert all the geometry (all the meshes) contained in teh CASE file into MEDCouplingUMesh'es. """
+        """ Convert all the geometry (all the meshes) contained in the CASE file into MEDCouplingUMesh'es. """
         fd=open(os.path.join(self._dirName,geoFileName),"r+b") ; fd.seek(0,2) ; end=fd.tell() ; fd.seek(0) ; title=fd.read(80)
         title=title.strip().lower()
         if "binary" not in title:
@@ -182,7 +182,7 @@
             mcmeshes2.append(self.__traduceMesh(meshName,zeK,coo,nodalConn))
             pos+=nbNodesPerCell*nbCellsOfType*4
             if abs(pos-end)>8:
-                fd.seek(pos) ;elt=fd.read(80) ; typ=elt[:] ; pos+=80 
+                fd.seek(pos) ;elt=fd.read(80) ; typ=elt[:] ; pos+=80
                 pass
             nbOfTurn+=1
             pass
@@ -193,8 +193,10 @@
         return mcmeshes2
 
     def __convertGeo2MEDC(self,fd,end):
-        fd.readline()
-        name=fd.readline().strip() ; fd.readline() ; fd.readline()
+        #fd.readline()
+        #name=fd.readline().strip() ; fd.readline() ; fd.readline()
+        name=fd.read(80)
+        descrip=fd.read(80).strip() ; fd.read(80) ; fd.read(80)
         pos=fd.tell()
         mcmeshes=[]
         elt=fd.read(80) ; elt=elt.strip() ; pos+=80
@@ -254,15 +256,15 @@
                 mcmeshes.append(m)
             pass
         return mcmeshes
-        
-    
+
+
     def __convertField(self,mlfields, mcmeshes, fileName, fieldName, discr, nbCompo, locId, it):
         """ Convert the fields. """
         stars=re.search("[\*]+",fileName).group()
         st="%0"+str(len(stars))+"i"
         trueFileName=fileName.replace(stars,st%(it))
         fd=open(os.path.join(self._dirName,trueFileName),"r+b") ; fd.seek(0,2) ; end=fd.tell() ; fd.seek(0)
-        name=fd.readline().strip().split(" ")[0]
+        name=fd.read(80).strip().split(" ")[0]
         if name!=fieldName:
             raise Exception("ConvertField : mismatch")
         pos=fd.tell()
@@ -351,7 +353,7 @@
             nbTurn+=1
             pass
         pass
-    
+
     def loadInMEDFileDS(self):
         """ Load a CASE file into a MEDFileData object. """
         f=file(self._fileName)
@@ -368,16 +370,17 @@
             if "TIME\n" in lines:
                 end=lines.index("TIME\n")
                 pass
-            for i in range(ind + 1, end):
-                m=re.match("^([\w]+)[\s]+\per[\s]+([\w]+)[\s]*\:[\s]*([\w]+)[\s]+([\S]+)$",lines[i])
+            for i in range(ind + 1,end):
+                m=re.match("^([\w]+)[\s]+\per[\s]+([\w]+)[\s]*\:[\s]*[0-9]*[\s]*([\w]+)[\s]+([\S]+)$",lines[i])
                 if m:
                     if m.groups()[0]=="constant":
                         continue
                     spatialDisc=m.groups()[1] ; fieldName=m.groups()[2] ; nbOfCompo=self.dictCompo2[m.groups()[0]] ; fieldFileName=m.groups()[3]
-                    fieldsInfo.append((fieldName,spatialDisc,nbOfCompo,fieldFileName))
+                    if fieldFileName.endswith("*"):
+                      fieldsInfo.append((fieldName,spatialDisc,nbOfCompo,fieldFileName))
                     pass
                 pass
-            
+
             expr=re.compile("number[\s]+of[\s]+steps[\s]*\:[\s]*([\d]+)")
             tmp = [line for line in lines if expr.search(line)]
             if tmp:
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/CaseWriter.py MEDCOUPLING_new/src/MEDLoader/Swig/CaseWriter.py
--- MEDCOUPLING_old/src/MEDLoader/Swig/CaseWriter.py	2018-04-19 17:04:36.765223281 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/CaseWriter.py	2018-04-19 17:25:17.751797633 +0200
@@ -28,7 +28,7 @@
 
 class CaseWriter(CaseIO):
     """ Converting MED file format in memory to a the Case file format (Ensight).
-    A new file with the same base name and the .case extension is created with its depencies (.geo ...).
+    A new file with the same base name and the .case extension is created with its dependencies (.geo ...).
     """
 
     header="""FORMAT
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/CMakeLists.txt MEDCOUPLING_new/src/MEDLoader/Swig/CMakeLists.txt
--- MEDCOUPLING_old/src/MEDLoader/Swig/CMakeLists.txt	2018-04-19 17:04:36.764223261 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/CMakeLists.txt	2018-04-19 17:25:17.760797811 +0200
@@ -69,21 +69,22 @@
 ENDIF()
 
 SWIG_ADD_MODULE(MEDLoader python MEDLoader.i)
-SWIG_LINK_LIBRARIES(MEDLoader ${PYTHON_LIBRARIES} ${PLATFORM_LIBS} medloader medcoupling)
+SWIG_LINK_LIBRARIES(MEDLoader ${PYTHON_LIBRARIES} ${PLATFORM_LIBS} medloader medcouplingcpp )
 SWIG_CHECK_GENERATION(MEDLoader)
 IF(WIN32)
   SET_TARGET_PROPERTIES(_MEDLoader PROPERTIES DEBUG_OUTPUT_NAME _MEDLoader_d)
 ENDIF(WIN32)
 
 INSTALL(TARGETS _MEDLoader DESTINATION ${MEDCOUPLING_INSTALL_PYTHON})
-INSTALL(FILES MEDLoader.i MEDLoaderTypemaps.i MEDLoaderCommon.i DESTINATION ${MEDCOUPLING_INSTALL_HEADERS})
+INSTALL(FILES MEDLoader.i MEDLoaderTypemaps.i MEDLoaderCommon.i MEDLoaderFinalize.i DESTINATION ${MEDCOUPLING_INSTALL_HEADERS})
 
 SALOME_INSTALL_SCRIPTS(${CMAKE_CURRENT_BINARY_DIR}/MEDLoader.py ${MEDCOUPLING_INSTALL_PYTHON})
 
 INSTALL(FILES MEDLoaderSplitter.py DESTINATION ${MEDCOUPLING_INSTALL_PYTHON})
 
 
-INSTALL(FILES ${ALL_TESTS} MEDLoaderDataForTest.py MEDLoaderTest1.py MEDLoaderTest2.py MEDLoaderTest3.py CaseIO.py CaseReader.py CaseWriter.py VTKReader.py medutilities.py DESTINATION ${MEDCOUPLING_INSTALL_SCRIPT_SCRIPTS})
+INSTALL(FILES ${ALL_TESTS} MEDLoaderDataForTest.py MEDLoaderTest1.py MEDLoaderTest2.py MEDLoaderTest3.py CaseIO.py CaseReader.py CaseWriter.py VTKReader.py DESTINATION ${MEDCOUPLING_INSTALL_SCRIPT_SCRIPTS})
+INSTALL(FILES medutilities.py DESTINATION ${MEDCOUPLING_INSTALL_PYTHON})
 
 INSTALL(FILES med2sauv PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ WORLD_EXECUTE WORLD_READ DESTINATION ${MEDCOUPLING_INSTALL_BINS} )
 INSTALL(FILES sauv2med PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ WORLD_EXECUTE WORLD_READ DESTINATION ${MEDCOUPLING_INSTALL_BINS} )
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/ConvertMEDFileTo30.py MEDCOUPLING_new/src/MEDLoader/Swig/ConvertMEDFileTo30.py
--- MEDCOUPLING_old/src/MEDLoader/Swig/ConvertMEDFileTo30.py	2018-04-19 17:04:36.765223281 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/ConvertMEDFileTo30.py	2018-04-19 17:25:17.780798207 +0200
@@ -35,7 +35,7 @@
     #
     finalVersion=ml.MEDFileVersionOfFileStr(realFnOut)
     #
-    print(("File \"%s\" has been converted to 3.0 successfuly ( %s -> %s ) !\nOutput file is here : \"%s\" !"%(fn,initalVersion,finalVersion,realFnOut)))
+    print(("File \"%s\" has been converted to 3.0 successfully ( %s -> %s ) !\nOutput file is here : \"%s\" !"%(fn,initalVersion,finalVersion,realFnOut)))
     pass
 
 if __name__=="__main__":
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderCommon.i MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderCommon.i
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderCommon.i	2018-04-19 17:04:36.765223281 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderCommon.i	2018-04-19 17:25:17.755797713 +0200
@@ -1,4 +1,4 @@
-// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
+// Copyright (C) 2017  CEA/DEN, EDF R&D
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
@@ -18,8 +18,6 @@
 //
 // Author : Anthony Geay (EDF R&D)
 
-%module MEDLoader
-
 #define MEDCOUPLING_EXPORT
 #define MEDLOADER_EXPORT
 
@@ -162,6 +160,7 @@
 %newobject MEDCoupling::MEDFileFields::partOfThisOnStructureElements;
 %newobject MEDCoupling::MEDFileFields::__iter__;
 %newobject MEDCoupling::MEDFileFields::extractPart;
+%newobject MEDCoupling::MEDFileFields::linearToQuadratic;
 
 %newobject MEDCoupling::MEDFileWritableStandAlone::serialize;
 %newobject MEDCoupling::MEDFileAnyTypeFieldMultiTS::New;
@@ -372,9 +371,9 @@
   void WriteMesh(const std::string& fileName, const MEDCoupling::MEDCouplingMesh *mesh, bool writeFromScratch) throw(INTERP_KERNEL::Exception);
   void WriteUMesh(const std::string& fileName, const MEDCoupling::MEDCouplingUMesh *mesh, bool writeFromScratch) throw(INTERP_KERNEL::Exception);
   void WriteUMeshDep(const std::string& fileName, const MEDCoupling::MEDCouplingUMesh *mesh, bool writeFromScratch) throw(INTERP_KERNEL::Exception);
-  void WriteField(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch) throw(INTERP_KERNEL::Exception);
-  void WriteFieldDep(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f, bool writeFromScratch) throw(INTERP_KERNEL::Exception);
-  void WriteFieldUsingAlreadyWrittenMesh(const std::string& fileName, const MEDCoupling::MEDCouplingFieldDouble *f) throw(INTERP_KERNEL::Exception);
+  void WriteField(const std::string& fileName, const MEDCoupling::MEDCouplingField *f, bool writeFromScratch) throw(INTERP_KERNEL::Exception);
+  void WriteFieldDep(const std::string& fileName, const MEDCoupling::MEDCouplingField *f, bool writeFromScratch) throw(INTERP_KERNEL::Exception);
+  void WriteFieldUsingAlreadyWrittenMesh(const std::string& fileName, const MEDCoupling::MEDCouplingField *f) throw(INTERP_KERNEL::Exception);
 }
 
 %rename (MEDFileVersion) MEDFileVersionSwig;
@@ -406,21 +405,21 @@
     return ret;
   }
 
-  MEDCoupling::MEDCouplingFieldDouble *ReadFieldSwig(const std::string& fileName) throw(INTERP_KERNEL::Exception)
+  MEDCoupling::MEDCouplingField *ReadFieldSwig(const std::string& fileName) throw(INTERP_KERNEL::Exception)
   {
-    MCAuto<MEDCoupling::MEDCouplingFieldDouble> ret(MEDCoupling::ReadField(fileName));
+    MCAuto<MEDCoupling::MEDCouplingField> ret(MEDCoupling::ReadField(fileName));
     return ret.retn();
   }
 
-  MEDCoupling::MEDCouplingFieldDouble *ReadFieldSwig(const std::string& fileName, const std::string& fieldName) throw(INTERP_KERNEL::Exception)
+  MEDCoupling::MEDCouplingField *ReadFieldSwig(const std::string& fileName, const std::string& fieldName) throw(INTERP_KERNEL::Exception)
   {
-    MCAuto<MEDCoupling::MEDCouplingFieldDouble> ret(MEDCoupling::ReadField(fileName,fieldName));
+    MCAuto<MEDCoupling::MEDCouplingField> ret(MEDCoupling::ReadField(fileName,fieldName));
     return ret.retn();
   }
   
-  MEDCoupling::MEDCouplingFieldDouble *ReadFieldSwig(const std::string& fileName, const std::string& fieldName, int iteration, int order) throw(INTERP_KERNEL::Exception)
+  MEDCoupling::MEDCouplingField *ReadFieldSwig(const std::string& fileName, const std::string& fieldName, int iteration, int order) throw(INTERP_KERNEL::Exception)
   {
-    MCAuto<MEDCoupling::MEDCouplingFieldDouble> ret(MEDCoupling::ReadField(fileName,fieldName,iteration,order));
+    MCAuto<MEDCoupling::MEDCouplingField> ret(MEDCoupling::ReadField(fileName,fieldName,iteration,order));
     return ret.retn();
   }
   
@@ -622,24 +621,6 @@
          void __setstate__(PyObject *inp) throw(INTERP_KERNEL::Exception)
          {
          }
-
-         PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-         {
-#ifdef WITH_NUMPY
-           PyObject *ret(PyTuple_New(1));
-           PyObject *ret0(PyDict_New());
-           DataArrayByte *retCpp(MEDCoupling_MEDFileWritableStandAlone_serialize(self));
-           PyObject *numpyArryObj=SWIG_NewPointerObj(SWIG_as_voidptr(retCpp),SWIGTYPE_p_MEDCoupling__DataArrayByte, SWIG_POINTER_OWN | 0 );
-           {// create a dict to discriminite in __new__ if __init__ should be called. Not beautiful but not idea ...
-             PyObject *tmp1(PyInt_FromLong(0));
-             PyDict_SetItem(ret0,tmp1,numpyArryObj); Py_DECREF(tmp1); Py_DECREF(numpyArryObj);
-             PyTuple_SetItem(ret,0,ret0);
-           }
-           return ret;
-#else
-           throw INTERP_KERNEL::Exception("PyWrap of MEDFileData.__getnewargs__ : not implemented because numpy is not active in your configuration ! No serialization/unserialization available without numpy !");
-#endif
-         }
        }
   };
   
@@ -1130,6 +1111,7 @@
     static std::string GetMagicFamilyStr();
     void assignFamilyNameWithGroupName() throw(INTERP_KERNEL::Exception);
     std::vector<std::string> removeEmptyGroups() throw(INTERP_KERNEL::Exception);
+    void removeGroupAtLevel(int meshDimRelToMaxExt, const std::string& name) throw(INTERP_KERNEL::Exception);
     void removeGroup(const std::string& name) throw(INTERP_KERNEL::Exception);
     void removeFamily(const std::string& name) throw(INTERP_KERNEL::Exception);
     std::vector<std::string> removeOrphanGroups() throw(INTERP_KERNEL::Exception);
@@ -1440,12 +1422,6 @@
            return MEDFileUMesh::New();
          }
 
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfEmptyDictInInput(cls,args,"MEDFileUMesh");
-         }
-
          static MEDFileUMesh *LoadPartOf(const std::string& fileName, const std::string& mName, PyObject *types, const std::vector<int>& slicPerTyp, int dt=-1, int it=-1, MEDFileMeshReadSelector *mrs=0) throw(INTERP_KERNEL::Exception)
          {
            std::vector<int> typesCpp1;
@@ -1457,14 +1433,6 @@
            return MEDFileUMesh::LoadPartOf(fileName,mName,typesCpp2,slicPerTyp,dt,it,mrs);
          }
 
-         PyObject *__getnewargs__() throw(INTERP_KERNEL::Exception)
-         {// put an empty dict in input to say to __new__ to call __init__...
-           PyObject *ret(PyTuple_New(1));
-           PyObject *ret0(PyDict_New());
-           PyTuple_SetItem(ret,0,ret0);
-           return ret;
-         }
-
          PyObject *__getstate__() throw(INTERP_KERNEL::Exception)
          {
            std::vector<double> a0;
@@ -1724,12 +1692,6 @@
          {
            return MEDFileCMesh::New(db);
          }
-
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileCMesh");
-         }
          
          PyObject *getMesh() const throw(INTERP_KERNEL::Exception)
          {
@@ -1770,12 +1732,6 @@
          {
            return MEDFileCurveLinearMesh::New(db);
          }
-
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileCurveLinearMesh");
-         }
          
          PyObject *getMesh() const throw(INTERP_KERNEL::Exception)
          {
@@ -1879,12 +1835,6 @@
            return MEDFileMeshes::New(db);
          }
 
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileMeshes");
-         }
-
          std::string __str__() const throw(INTERP_KERNEL::Exception)
            {
              return self->simpleRepr();
@@ -1989,6 +1939,7 @@
     void changeLocName(const std::string& oldName, const std::string& newName) throw(INTERP_KERNEL::Exception);
     int getNbOfGaussPtPerCell(int locId) const throw(INTERP_KERNEL::Exception);
     int getLocalizationId(const std::string& loc) const throw(INTERP_KERNEL::Exception);
+    int getProfileId(const std::string& pfl) const throw(INTERP_KERNEL::Exception);
     void killStructureElementsInGlobs() throw(INTERP_KERNEL::Exception);
   %extend
      {
@@ -2273,6 +2224,7 @@
     static MEDFileField1TS *New(DataArrayByte *db) throw(INTERP_KERNEL::Exception);
     static MEDFileField1TS *New();
     MEDCoupling::MEDFileIntField1TS *convertToInt(bool isDeepCpyGlobs=true) const throw(INTERP_KERNEL::Exception);
+    void copyTimeInfoFrom(MEDCouplingFieldDouble *mcf) throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldDouble *field(const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldDouble *getFieldAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol=0) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldDouble *getFieldAtTopLevel(TypeOfField type, int renumPol=0) const throw(INTERP_KERNEL::Exception);
@@ -2282,6 +2234,7 @@
     //
     void setFieldNoProfileSBT(const MEDCouplingFieldDouble *field) throw(INTERP_KERNEL::Exception);
     void setFieldProfile(const MEDCouplingFieldDouble *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
+    void setFieldProfileFlatly(const MEDCouplingFieldDouble *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
     void setProfileNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newPflName, bool forceRenameOnGlob=false) throw(INTERP_KERNEL::Exception);
     void setLocNameOnLeaf(const std::string& mName, INTERP_KERNEL::NormalizedCellType typ, int locId, const std::string& newLocName, bool forceRenameOnGlob=false) throw(INTERP_KERNEL::Exception);
     %extend
@@ -2310,12 +2263,6 @@
          {
            return MEDFileField1TS::New();
          }
-
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileField1TS");
-         }
          
          void copyTinyInfoFrom(const MEDCouplingFieldDouble *field) throw(INTERP_KERNEL::Exception)
          {
@@ -2332,12 +2279,7 @@
          
          PyObject *getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception)
          {
-           DataArrayInt *ret1=0;
-           DataArrayDouble *ret0=self->getFieldWithProfile(type,meshDimRelToMax,mesh,ret1);
-           PyObject *ret=PyTuple_New(2);
-           PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(ret0),SWIGTYPE_p_MEDCoupling__DataArrayDouble, SWIG_POINTER_OWN | 0 ));
-           PyTuple_SetItem(ret,1,SWIG_NewPointerObj(SWIG_as_voidptr(ret1),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
-           return ret;
+           return MEDFileField1TS_getFieldWithProfile<double>(self,type,meshDimRelToMax,mesh);
          }
 
          PyObject *getFieldSplitedByType2(const std::string& mname=std::string()) const throw(INTERP_KERNEL::Exception)
@@ -2384,29 +2326,7 @@
 
          PyObject *getUndergroundDataArrayExt() const throw(INTERP_KERNEL::Exception)
          {
-           std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > > elt1Cpp;
-           DataArrayDouble *elt0=self->getUndergroundDataArrayExt(elt1Cpp);
-           if(elt0)
-             elt0->incrRef();
-           PyObject *ret=PyTuple_New(2);
-           PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(elt0),SWIGTYPE_p_MEDCoupling__DataArrayDouble, SWIG_POINTER_OWN | 0 ));
-           std::size_t sz=elt1Cpp.size();
-           PyObject *elt=PyList_New(sz);
-           for(std::size_t i=0;i<sz;i++)
-             {
-               PyObject *elt1=PyTuple_New(2);
-               PyObject *elt2=PyTuple_New(2);
-               PyTuple_SetItem(elt2,0,SWIG_From_int((int)elt1Cpp[i].first.first));
-               PyTuple_SetItem(elt2,1,SWIG_From_int(elt1Cpp[i].first.second));
-               PyObject *elt3=PyTuple_New(2);
-               PyTuple_SetItem(elt3,0,SWIG_From_int(elt1Cpp[i].second.first));
-               PyTuple_SetItem(elt3,1,SWIG_From_int(elt1Cpp[i].second.second));
-               PyTuple_SetItem(elt1,0,elt2);
-               PyTuple_SetItem(elt1,1,elt3);
-               PyList_SetItem(elt,i,elt1);
-             }
-           PyTuple_SetItem(ret,1,elt);
-           return ret;
+           return MEDFileField1TS_getUndergroundDataArrayExt<double>(self);
          }
        }
   };
@@ -2423,6 +2343,8 @@
     //
     void setFieldNoProfileSBT(const MEDCouplingFieldInt *field) throw(INTERP_KERNEL::Exception);
     void setFieldProfile(const MEDCouplingFieldInt *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
+    void setFieldProfileFlatly(const MEDCouplingFieldInt *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
+    void copyTimeInfoFrom(MEDCouplingFieldInt *mcf) throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldInt *field(const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldInt *getFieldAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol=0) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldInt *getFieldAtTopLevel(TypeOfField type, int renumPol=0) const throw(INTERP_KERNEL::Exception);
@@ -2456,12 +2378,6 @@
         return MEDFileIntField1TS::New(db);
       }
 
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileIntField1TS");
-      }
-
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -2469,12 +2385,7 @@
 
       PyObject *getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception)
       {
-         DataArrayInt *ret1=0;
-         DataArrayInt *ret0=self->getFieldWithProfile(type,meshDimRelToMax,mesh,ret1);
-         PyObject *ret=PyTuple_New(2);
-         PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(ret0),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
-         PyTuple_SetItem(ret,1,SWIG_NewPointerObj(SWIG_as_voidptr(ret1),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
-         return ret;
+         return MEDFileField1TS_getFieldWithProfile<int>(self,type,meshDimRelToMax,mesh);
       }
       
       DataArrayInt *getUndergroundDataArray() const throw(INTERP_KERNEL::Exception)
@@ -2484,6 +2395,11 @@
           ret->incrRef();
         return ret;
       }
+
+      PyObject *getUndergroundDataArrayExt() const throw(INTERP_KERNEL::Exception)
+      {
+        return MEDFileField1TS_getUndergroundDataArrayExt<int>(self);
+      }
     }
   };
 
@@ -2499,6 +2415,8 @@
     //
     void setFieldNoProfileSBT(const MEDCouplingFieldFloat *field) throw(INTERP_KERNEL::Exception);
     void setFieldProfile(const MEDCouplingFieldFloat *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
+    void setFieldProfileFlatly(const MEDCouplingFieldFloat *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
+    void copyTimeInfoFrom(MEDCouplingFieldFloat *mcf) throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldFloat *field(const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldFloat *getFieldAtLevel(TypeOfField type, int meshDimRelToMax, int renumPol=0) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldFloat *getFieldAtTopLevel(TypeOfField type, int renumPol=0) const throw(INTERP_KERNEL::Exception);
@@ -2532,12 +2450,6 @@
         return MEDFileFloatField1TS::New(db);
       }
 
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileFloatField1TS");
-      }
-
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
         return self->simpleRepr();
@@ -2545,12 +2457,7 @@
 
       PyObject *getFieldWithProfile(TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception)
       {
-         DataArrayInt *ret1=0;
-         DataArrayFloat *ret0=self->getFieldWithProfile(type,meshDimRelToMax,mesh,ret1);
-         PyObject *ret=PyTuple_New(2);
-         PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(ret0),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
-         PyTuple_SetItem(ret,1,SWIG_NewPointerObj(SWIG_as_voidptr(ret1),SWIGTYPE_p_MEDCoupling__DataArrayFloat, SWIG_POINTER_OWN | 0 ));
-         return ret;
+         return MEDFileField1TS_getFieldWithProfile<float>(self,type,meshDimRelToMax,mesh);
       }
       
       DataArrayFloat *getUndergroundDataArray() const throw(INTERP_KERNEL::Exception)
@@ -2560,6 +2467,11 @@
           ret->incrRef();
         return ret;
       }
+      
+      PyObject *getUndergroundDataArrayExt() const throw(INTERP_KERNEL::Exception)
+      {
+        return MEDFileField1TS_getUndergroundDataArrayExt<float>(self);
+      }
     }
   };
 
@@ -2992,12 +2904,6 @@
          {
            return MEDFileFieldMultiTS::New(db);
          }
-         
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileFieldMultiTS");
-         }
 
          static MEDFileFieldMultiTS *LoadSpecificEntities(const std::string& fileName, const std::string& fieldName, PyObject *entities, bool loadAll=true)
          {
@@ -3127,7 +3033,7 @@
     void appendFieldNoProfileSBT(const MEDCouplingFieldInt *field) throw(INTERP_KERNEL::Exception);
     void appendFieldProfile(const MEDCouplingFieldInt *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
     MEDCoupling::MEDFileFieldMultiTS *convertToDouble(bool isDeepCpyGlobs=true) const throw(INTERP_KERNEL::Exception);
-    MEDCouplingFieldDouble *field(int iteration, int order, const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception);
+    MEDCouplingFieldInt *field(int iteration, int order, const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldInt *getFieldAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, int renumPol=0) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldInt *getFieldAtTopLevel(TypeOfField type, int iteration, int order, int renumPol=0) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldInt *getFieldOnMeshAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, const MEDFileMesh *mesh, int renumPol=0) const throw(INTERP_KERNEL::Exception);
@@ -3155,12 +3061,6 @@
         return MEDFileIntFieldMultiTS::New(db);
       }
       
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileIntFieldMultiTS");
-      }
-      
       static MEDFileIntFieldMultiTS *LoadSpecificEntities(const std::string& fileName, const std::string& fieldName, PyObject *entities, bool loadAll=true)
       {
         std::vector<std::pair<int,int> > tmp(convertTimePairIdsFromPy(entities));
@@ -3204,7 +3104,7 @@
     void appendFieldNoProfileSBT(const MEDCouplingFieldFloat *field) throw(INTERP_KERNEL::Exception);
     void appendFieldProfile(const MEDCouplingFieldFloat *field, const MEDFileMesh *mesh, int meshDimRelToMax, const DataArrayInt *profile) throw(INTERP_KERNEL::Exception);
     MEDCoupling::MEDFileFieldMultiTS *convertToDouble(bool isDeepCpyGlobs=true) const throw(INTERP_KERNEL::Exception);
-    MEDCouplingFieldDouble *field(int iteration, int order, const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception);
+    MEDCouplingFieldFloat *field(int iteration, int order, const MEDFileMesh *mesh) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldFloat *getFieldAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, int renumPol=0) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldFloat *getFieldAtTopLevel(TypeOfField type, int iteration, int order, int renumPol=0) const throw(INTERP_KERNEL::Exception);
     MEDCouplingFieldFloat *getFieldOnMeshAtLevel(TypeOfField type, int iteration, int order, int meshDimRelToMax, const MEDFileMesh *mesh, int renumPol=0) const throw(INTERP_KERNEL::Exception);
@@ -3232,12 +3132,6 @@
         return MEDFileFloatFieldMultiTS::New(db);
       }
       
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileFloatFieldMultiTS");
-      }
-      
       static MEDFileFloatFieldMultiTS *LoadSpecificEntities(const std::string& fileName, const std::string& fieldName, PyObject *entities, bool loadAll=true)
       {
         std::vector<std::pair<int,int> > tmp(convertTimePairIdsFromPy(entities));
@@ -3352,12 +3246,6 @@
            return MEDFileFields::NewAdv(fileName,loadAll,entities);
          }
          
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileFields");
-         }
-         
          std::string __str__() const throw(INTERP_KERNEL::Exception)
          {
            return self->simpleRepr();
@@ -3529,6 +3417,12 @@
            convertToMapIntDataArrayInt(extractDef,extractDefCpp);
            return self->extractPart(extractDefCpp,mm);
          }
+
+         MEDFileFields *linearToQuadratic(const MEDFileMeshes *oldLin, const MEDFileMeshes *newQuad) const throw(INTERP_KERNEL::Exception)
+         {
+           MCAuto<MEDFileFields> ret(self->linearToQuadratic(oldLin,newQuad));
+           return ret.retn();
+         }
        }
   };
 
@@ -3847,12 +3741,6 @@
       {
         return MEDFileParameters::New(db);
       }
-
-      // serialization
-      static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-      {
-        return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileParameters");
-      }
       
       std::string __str__() const throw(INTERP_KERNEL::Exception)
       {
@@ -3989,12 +3877,6 @@
            MCAuto<MEDFileData> ret(MEDFileData::Aggregate(mfdsCpp));
            return ret.retn();
          }
-
-         // serialization
-         static PyObject *___new___(PyObject *cls, PyObject *args) throw(INTERP_KERNEL::Exception)
-         {
-           return NewMethWrapCallInitOnlyIfDictWithSingleEltInInput(cls,args,"MEDFileData");
-         }
        }
   };
 
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderDataForTest.pyc MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderDataForTest.pyc
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderDataForTest.pyc	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderDataForTest.pyc	2018-04-19 17:25:17.759797792 +0200
@@ -0,0 +1,211 @@
+
+;Zc           @   s=   d  d l  Td  d l m Z m Z m Z d d d     YZ d S(   i(   t   *(   t   pit   et   sqrtt   MEDLoaderDataForTestc           B   s  e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
+ d	   Z d
+   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z e e  Z e e  Z e e  Z e e  Z e e  Z e e  Z e e  Z e e	  Z	 e e  Z e e
+  Z
+ e e  Z e e  Z e e  Z e e  Z e e  Z e e  Z e e  Z e e  Z RS(   c      	   C   s  d d d d d d g } d d d d	 d	 d
+ d
+ d d g	 } t  j   } | j d  | j d  | j d  | j t d	 | d d	 ! | j t d	 | d	 d ! | j t d	 | d d ! | j t d
+ | d d ! | j   t	 j   } | j
+ | d d  | j d d  | j |  | S(   Ng        g333333?g      ?g      ?gffffff?g?i    i   i   i   i   i   t   1DMesh_1i   i	   s!   tototototototot [m*m*m*m*m*m*m*m](   t   MEDCouplingUMesht   Newt   setNamet   setMeshDimensiont   allocateCellst   insertNextCellt	   NORM_SEG2t	   NORM_SEG3t   finishInsertingCellst   DataArrayDoublet	   setValuest   setInfoOnComponentt	   setCoords(   t   clst   coordst   connt   mesht   myCoords(    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build1DMesh_1   s     !
+c         C   s   d d d d d d d d d d d d g } d d d d	 d	 d
+ d
+ d d g	 } t  j   } | j d  | j d  | j d  | j t d	 | d d	 ! | j t d	 | d	 d ! | j t d	 | d d ! | j t d
+ | d d ! | j   t	 j   } | j
+ | d d	  | j |  | S(   Ng        g333333?g      ?g      ?gffffff?g?i    i   i   i   i   i   t   2DCurveMesh_1i   i	   (   R   R   R   R	   R
+   R   R   R   R   R   R   R   (   R   R   R   R   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build2DCurveMesh_1,   s    *!
+c         C   s  d d d d d d d d d d d d d d d d d d d d d d d d g } d d	 d
+ d	 d d
+ d d d d d d d d d	 d d d d	 d d d d d	 g } t  j   } | j d
+  | j d  | j d  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d	 | d d ! | j t d	 | d d ! | j t	 d	 | d d ! | j
+   t j   } | j | d d
+  | j d d  | j d d  | j |  | S(   Ng333333ӿg?gffffff?ggffffff?g333333?g?i   i   i   i   i   i
+   i   i	   i   i   i    i   t   2DMesh_1i   i   i   i   s   tototototototot [m]s   energie [kW](   R   R   R	   R
+   R   R   t	   NORM_TRI3t	   NORM_TRI6t
+   NORM_QUAD4t   NORM_POLYGONR   R   R   R   R   (   R   t   targetCoordst
+   targetConnt
+   targetMeshR   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build2DMesh_1=   s(    6N
+c         C   s  d d d d d d d d d d d d d d d d d d d d d d d d g } d d	 d
+ d	 d d
+ d d d d d d d d d	 d d d d	 d d d d d	 g } t  j   } | j d
+  | j d  | j d  | j t d | d d ! | j t d | d d ! | j t d	 | d d ! | j t d	 | d d ! | j t d | d d ! | j	   t
+ j   } | j | d d
+  | j d d  | j d d  | j |  | S(   Ng333333ӿg?gffffff?ggffffff?g333333?g?i   i   i   i   i   i
+   i   i	   i   i   i    i   t   2DMesh_2i   i   i   s   toto [m]s   energie [kW](   R   R   R	   R
+   R   R   R   R   R   R   R   R   R   R   (   R   R    R!   R"   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build2DMesh_2S   s&    6N
+c         C   s{  d d d d d d d d d d d d d d d d d d d d d d d d g } d d	 d
+ d	 d d
+ d d d d d d d d d	 d d d d	 d d d d d	 g } t  j   } | j d
+  | j d  | j d  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d	 | d d ! | j t d	 | d d ! | j t d	 | d d ! | j t d	 | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j	   t
+ j   } | j | d d
+  | j d d  | j d d  | j |  | S(   Ng333333ӿg?gffffff?ggffffff?g333333?g?i   i   i   i   i   i
+   i   i	   i   i   i    i   i   t   2DMesh_3i   i   i   s   toto [m]s   energie [kW](   R   R   R	   R
+   R   R   R   R   R   R   R   R   R   R   (   R   R    R!   R"   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build2DMesh_3i   s6    6N
+c      b  C   s  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g } d d d	 d
+ d d d d d	 d d d d d d d	 d d d d d d d d d d d d d d d d d d d d d d d d d d	 d d d d d d d d d d	 d d d
+ d d d d d d d d d d d d d d  d d d d	 d d d d d	 d d	 d d d d d d d d d d d d d d d d  d! d d d  d d d! d d d d d d d! d d" d# d d d$ d% d d d d d d& d' d( d) d d d d d d d d d( d* d d d d* d+ d d d d d, d+ d d d d- d, d d d d. d- d d d d( d. d d( d* d+ d, d- d. d d d d d( d* d/ d) d d d d d+ d0 d1 d* d d! d d d d d d d' d( d d d d( d. d d d d. d- d d d d- d, d d d d! d2 d, d d! d d' d2 d d' d( d. d- d, d2 d d$ d% d d, d3 d4 d+ d& d' d( d) d5 d6 d7 d8 d( d. d- d, d+ d* d d( d7 d9 d* d d* d9 d: d+ d d+ d, d; d: d d, d- d< d; d d- d. d= d< d d. d( d7 d= d d7 d9 d: d; d< d= d( d* d/ d) d7 d9 d> d8 d+ d0 d1 d* d: d? d@ d9 d' d2 d, d- d. d( d d' d6 d7 d( d d( d7 d= d. d d. d= d< d- d d- d< d; d, d d, d2 dA d; d d2 d' d6 dA d d6 d7 d= d< d; dA d, d3 d4 d+ d; dB dC d: gb} t  j   } | j dD  | j d
+  | j d  | j t d  | d d  ! | j t d  | d9 dC ! | j t d  | dC dE ! | j t d  | dF dG ! | j t d  | dG dH ! | j t d  | dI dJ ! | j t d  | dJ dK ! | j t d  | dL dM ! | j t d  | dM dN ! | j t d  | dO dP ! | j t d  | dP dQ ! | j t d  | dR dS ! | j t d+ | d  d9 ! | j t d+ | dE dF ! | j t d+ | dH dI ! | j t d+ | dK dL ! | j t d+ | dN dO ! | j t d+ | dQ dR ! | j   t	 j   } | j
+ | dT d
+  | j d dU  | j d	 dV  | j d dW  | j |  | S(X   Ng        g      ?g      ?g      ?g       @g      @i    i   i   i   i   i   i   i   i   i   i   i   i   ii   i   i   i   i   i   i   i
+   i	   i   i   i   i   i   i   i   i   i   i)   i   i!   i$   i+   i%   i"   i    i#   i(   i'   i&   i*   i,   i-   i8   i.   i0   i3   i:   i4   i1   i/   i2   i7   i6   i5   i9   i;   t   3DMesh_1iC   in   iv   i~   i   i   i   i   i   i   i  i'  i/  iZ  ib  i<   s   titi [m]s   density power [MW/m^3]s   t [kW](   R   R   R   R	   R
+   R   t
+   NORM_HEXA8t   NORM_POLYHEDR   R   R   R   R   (   R   R   R   t   retR   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build3DMesh_1   sd    Z-Z-Z-Z3000
+c      $   C   s  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g$ } d d	 d
+ d	 d d
+ d d d d d d d d d	 d d d d	 d d d d d	 g } t  j   } | j d
+  | j d  | j d  | j t d | d d ! | j t d | d d ! | j t d	 | d d ! | j t d	 | d d ! | j t d | d d ! | j t	 d	 | d d ! | j
+   t j   } | j | d d  | j d d  | j d
+ d  | j |  | S(   Ng333333ӿg?gffffff?ggffffff?g333333?g?i   i   i   i   i   i
+   i   i	   i   i   i    i   t   3DSurfMesh_1i   i   i   i   s   toto [m]s   ff [km](   R   R   R	   R
+   R   R   R   R   R   R   R   R   R   R   R   (   R   R    R!   R"   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build3DSurfMesh_1   s(    Q!N
+c   
+      C   s   t  j   } d d d d d g } | j | t  } t  j   } d d d d g } | j | t  } | j d  d d d g } d d d g } | j | | t d  | j | d  }	 |	 S(	   Ni    i   i   i   i   g        g      ?g       @(	   R   R.   t   buildPartOfMySelft   FalseR   t   changeSpaceDimensiont   rotateR   t   buildExtrudedMesh(
+   R   t   m3dsurfBaset   numberst   m3dsurft   m1dBaset   numbers2t   m1dt   vect   ptR+   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   build3DMesh_2   s    c        C   sW  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d	 d d	 d d	 d d	 d d	 d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d
+ d d d d d d d d d d d d d d d	 d d d d d d d d d d d d d d d d d
+ d d d d d d d	 d d	 d d d d d d	 d d d d d d	 d d d d d d	 d d d d d d	 d d d d d d	 d d d d d
+ d	 d
+ d d
+ d d d d	 d d d d d d d d d d d d d	 d d d d d d d d d d d d d d d	 d d d d d d d d d	 d d	 d d d d d d	 d d d d d d	 d d d d d d	 d d d d d d	 d d d d d	 d	 d	 d d	 d d d	 d d d d g} t  j   } | j | d d  | j d d  } | j d d  | j d d  | j d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d  d! d d d  d d" d  d d d# d d# d" d d d# d d$ d# d! d  d% d! d% d& d  d" d% d" d' d% d" d# d( d" d( d' d# d$ d( d$ d) d( d& d% d* d& d* d+ d% d' d* d' d, d* d' d( d- d' d- d, d( d) d- d) d. d- d+ d* d/ d+ d/ d0 d* d, d/ d, d1 d/ d, d- d2 d, d2 d1 d- d. d2 d. d3 d2 d0 d/ d4 d0 d4 d5 d/ d1 d4 d1 d6 d4 d1 d2 d7 d1 d7 d6 d2 d3 d7 d3 d8 d7 d5 d4 d9 d5 d9 d: d4 d6 d9 d6 d; d9 d6 d7 d< d6 d< d; d7 d8 d< d8 d= d< d: d9 d> d: d> d? d9 d; d> d; d@ d> d; d< dA d; dA d@ d< d= dA d= dB dA g } dC dD dE dF dD dG dH dE dG dI dJ dH dI dK dL dJ dF dE dM dN dE dH dO dM dH dJ dP dO dJ dL dQ dP dN dM dR dS dM dO dT dR dO dP dU dT dP dQ dV dU dS dR dW dX dR dT dY dW dT dU dZ dY dU dV d[ dZ dX dW d\ d] dW dY d^ d\ dY dZ d_ d^ dZ d[ d` d_ d] d\ da db d\ d^ dc da d^ d_ dd dc d_ d` de dd db da df dg da dc dh df dc dd di dh dd de dj di dg df dk dl df dh dm dk dh di dn dm di dj do dn dp dq dr ds dq dt du dr dt dv dw du dv dx dy dw ds dr dz d{ dr du d| dz du dw d} d| dw dy d~ d} d{ dz d d dz d| d d d| d} d d d} d~ d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g } t j d d  } | j |  | j d_  t |  d } x: t	 |  D], } | j
+ t d | d | d | d ! q&	Wt |  d } x: t	 |  D], } | j
+ t d | d | d | d ! qs	W| j   | j d  t j d d  }	 |	 j |  d d d d d d d d d d d d$ d$ d) d) d. d. d3 d3 d8 d8 d= d= dB dB dA dA d@ d@ d> d> d? d? d: d: d5 d5 d0 d0 d+ d+ d& d& d! d! d d d dB d= d= d8 d8 d3 d3 d. d. d) d) d$ d$ d d d d d d d d d d d d d d d{ d{ ds ds dp dp dq dq dt dt dv dv dx dx dy dy d~ d~ d d d d d d d d d d d d d d d d d d d dl dg dg db db d] d] dX dX dS dS dN dN dF dF dC dC dD dD dG dG dI dI dK dK dL dL dQ dQ dV dV d[ d[ d` d` de de dj dj do do dn dn dm dm dk dk dl g }
+ |	 j d  x: t	 d  D], } |	 j
+ t d |
+ d | d | d ! qW|	 j   |	 j d  t j d d  } | j |  d? d d dK g } | j d  x. t	 d  D]  } | j
+ t d | | g  qkW| j   t j   } | j d_ d  d | d~ *d | d~ d] +d | d] )t j   } | j d d  d | d *d | d d" +d | d" d% +d | d% d. +d | d. d2 +d | d2 d6 +d | d6 d> +d | d> d? +d | d? dx +d | dx d +d | d d~ +d | d~ d +d | d dz +d | dz )t j   } | j d d d d g d d  t j   } | j d d  | j   t j   } | j d# d  | j d  | | d d d. dB d? d dC d dK dp dl do dx g <t j   } | j d_ d  | j d  t j   } | j d d  | j dh  t j   } | j d d  | j da  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g# } d d d d d d d d d d d d d d d d d d d! d d  d d" d d# d d d d d d d d d d g# } d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g& } d g d g d g d g d g d g d g d g d g d g d g d g d g d d d d g d g d g d g d g d g d g d g d g d! g d g d  g d g d" g d g d# g d g d g d g d d d g d g d g d g d d d d d d d g d g g& } | |	 | | | | | | | | | | | | f S(   Ng      $@g        g      ?g      @g      @g      @g     !@g      @g      @g      ?g      ?g      	@g     @g     @g     @g     @ @g     "@i   i   i   i    s   X [INCONNUE]i   s   Y [INCONNUE]s   Z [INCONNUE]i   i   i   i   i   i	   i   i
+   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i$   i#   i%   i&   i'   i(   i,   i)   i*   i+   i.   ie   ir   id   if   is   ig   it   i0   ih   iu   ic   iv   iw   ii   ix   ib   iy   iz   ij   i{   ia   i|   i}   ik   i~   i`   i   i   il   i   i_   i   i   im   i   i^   i   i   in   iq   i2   ip   io   i3   i1   i<   iI   i;   i=   iJ   i>   iK   i4   i?   iL   i:   iM   iN   i@   iO   i9   iP   iQ   iA   iR   i8   iS   iT   iB   iU   i7   iV   iW   iC   iX   i6   iY   iZ   iD   i[   i5   i\   i]   iE   iH   i-   iG   iF   i/   t   mas   CREE PAR CODE_ASTERiiiiiiiiiiiiiiiiiiiiit    A1A2____________________________t    A1______________________________t    A2A4____________________________t    A2______________________________t    A3A1____________________________t    A3C5____________________________t    A3______________________________t    A4A3____________________________t    A4______________________________t    B1C1____________________________t    B1______________________________t    B2B4____________________________t    B2______________________________t    B3B1____________________________t    B3______________________________t    B4C3____________________________t    B4______________________________t    C1C4____________________________t    C1______________________________t    C2B2____________________________t    C2______________________________t    C3C2____________________________t    C3______________________________t    C4B3____________________________t    C4______________________________t    C5A4____________________________t    C5______PMMA____________________t   FAMILLE_ZEROt    MESH____APPS____AP1_____________t    MESH____APPS____AP2_____________t    MESH____APPS____AP3_____________t    MESH____APPS____AP4_____________t    MESH____DALQ1___DALLE___________t    MESH____DALQ2___DALLE___________t    MESH____DALT3___DALLE___________t   A1t   A1A2t   A2t   A2A4t   A3t   A3A1t   A3C5t   A4t   A4A3t   AP1t   AP2t   AP3t   AP4t   APPSt   B1t   B1C1t   B2t   B2B4t   B3t   B3B1t   B4t   B4C3t   C1t   C1C4t   C2t   C2B2t   C3t   C3C2t   C4t   C4B3t   C5t   C5A4t   DALLEt   DALQ1t   DALQ2t   DALT3t   MESHt   PMMA(   R   R   R   t   changeNbOfComponentsR   R   R   R
+   t   lent   rangeR   R   R   R   t   setDescriptionR   t   NORM_POINT1t   DataArrayIntt   alloct   fillWithZerot   iota(   R   t   coot   coo2t   c2trit   c2quad4t   m2t   nbTrit   it   nbQuat   m1t   c1segt   m0t   c0ptt   f2t   f1t   f0t   pt   p1t   n2t   n1t   n0t   fnst   fidst   grpnst   famIdsPerGrp(    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildMultiLevelMesh_1   s       3  H   	&&
+ &
+
+
+
+
+
+
+1oox c      #   C   s  d } t  j d d  } | j d  | j d  | j d  | j d d d g  t | d  } t t t t t t t g } d	 d d
+ d g d d d d g d d d d d d g d d d d d d g d d d d d d  g d! d" d# d$ d! d% d" d$ d" d% d# d$ d# d% d! g d& d' d( d) d$ d* d+ d, d- d$ d& d* d- d' d$ d' d- d, d( d$ d( d, d+ d) d$ d) d+ d* d& g g } | j	 t
+ |   x- t | |  D] \ } } | j | |  qW| j   | j |  t | d
+  }	 t t t t t t t t t g	 }
+ d	 d d
+ g d d d g d d d d g d d d d g d d d d g d d d d d g d d d  d! d" g d# d% d& g d' d( d) d* d- d, d+ g g	 } |	 j	 t
+ |
+   x- t |
+ |  D] \ } } |	 j | |  qW|	 j   |	 j |  t j   } | j d	 |  | j d$ |	  t j d	 d d d g  } | j d.  t j d d
+ d d d g  } | j d/  | j t | j d	 | | g  t j d	 d d d g  } | j d.  | j d	 | | g  t j d d
+ d d d g  } | j d0  t j d
+ d d d g  } | j d1  t j d d d d g  } | j d2  | j d$ | | | g  t j d	 d d d g  } | j d3  t j d d
+ d d d g  } | j d4  | j d | | g  | j t | j d	 t j d	 d d d d d d d g   | j d	 t j d	 d d d d d d g   t j d	 d d d d d d d d g	  } | j d$ |  | j d$ d5  | j d$ |  t j | j   d  } | j d  | j t | j d |  t j | j    } | j d  | j d |  | S(6   s   Level 0 (meshDim=3) - 2 TETRA4 + 3 PENTA6 + 2 POLYH
+        # POLYH #0 becomes 1 TETRA4
+        # POLYH #1 becomes HEXA8
+        # Level -1 (meshDim=2) - 2 TRI3 + 3 QUAD4 + 4 POLYG
+        # POLYG #2 becomes TRI3t   NightmareMeshi&   i   i   g     @@s   X [m]s   Y [m]s   Z [m]i    i   i   i   i   i   i   i	   i
+   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   ii   i   i   i    i!   i"   i%   i$   i#   t   grp0_L0t   grp1_L0t   grp0_LM1t   grp1_LM1t   grp2_LM1t	   grp0_Nodet	   grp1_NodeN(   R   R   t	   rearrangeR   t   setInfoOnComponentsR   t   NORM_TETRA4t   NORM_PENTA6R*   R
+   R   t   zipR   R   R   R   R   R   t   MEDFileUMesht   setMeshAtLevelR   R   t   assertRaisest   InterpKernelExceptiont   setGroupsAtLevelt   setRenumFieldArrt   Nonet   getNumberOfNodes(   R   t   testert   meshNameR   t   mesh0t   type0t   conn0t   typt	   nodalConnt   meshM1t   typeM1t   connM1t   mmR   R   R   R   R   R   R   t   da(    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildMLMeshUnPolyze=  sx        
+!
+        :.*    c         C   s	  t  j   } | j   } t j t t  } | j d  | j |  t	 j   } d d d d d d d d	 d
+ d d d d d d d d d g } | j
+ | | d  | j d d  | j d d  | j d d  | j |  | j   } | j d d d  | j   | S(   Nt   VectorFieldOnCellsg        g      $@g      4@g      ?g      &@g      5@g       @g      (@g      6@g      @g      *@g      7@g      @g      ,@g      8@g      @g      .@g      9@i   i    s   power [MW/m^3]i   s   density [g/cm^3]i   s   temperature [K](   R   R.   t   getNumberOfCellst   MEDCouplingFieldDoubleR   t   ON_CELLSt   ONE_TIMER   t   setMeshR   R   R   t   setArrayt
+   getPointert   setTimet   checkConsistencyLight(   R   R   t	   nbOfCellsR   t   arrayt   arr1t   tmp(    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildVecFieldOnCells_1t  s     <
+c      $   C   s3  t  j   } | j   } t j t t  } | j d  | j |  t	 j   } | j
+ |  d d d d d d d d	 d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% g$ } | j | | d&  | j d' d(  | j d) d*  | j d+ d,  | j d- d+ d&  | j   | S(.   Nt   VectorFieldOnNodesg     Q@g      T@g     V@g     Q@g     @T@g     V@g      R@g     T@g      W@g     @R@g     T@g     @W@g     R@g      U@g     W@g     R@g     @U@g     W@g     @@g     @g     @g     H@g    @g    @g     P@g     @g     @g     X@g    @g    @g     `@g     @g     @g     h@g    @g    @i   i    s   power [MW/m^3]i   s   density [g/cm^3]i   s   temperature [K]g(\ @(   R   R.   R   R   R   t   ON_NODESR   R   R   R   R   R   R   R   R   (   R   R   t	   nbOfNodesR   R   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildVecFieldOnNodes_1  s     6<
+c         C   s  d } d } d } d } d d d d d d g } d | d d d	 | d | d d
+ | d d d	 | d | d d d	 | d | d d | d d d	 | d | d d | d g } d	 | d	 | d	 | d	 | d	 | d	 | g } | } | }	 | }
+ t  j   } t j t t  } | j d d d  | j |  | j t	 | |	 |
+  d d d d d d d d d d d d g } | } |	 d d !}	 |	 } |
+ d d !}
+ |
+ } d d d d d d d d g } | } |	 d d	 !}	 |
+ d d !}
+ | j t
+ | |	 |
+  | j t | | |  t j   } | j d d  | j   } x1 t d  D]# } | j d | t | d   qEW| j |  | j d  | j d d  | j d d  | j   | S(   Ng͚?g۰q?gBė?g2'%?g        g      ?i   i   i   g(\ @gQ	@i   g      i    i   i   i   i   t   MyFirstFieldOnGaussPoints   power [MW/m^3]t   densityi&   (   R   R%   R   R   t   ON_GAUSS_PTR   R   R   t   setGaussLocalizationOnTypeR   R   R   R   R   R   R   t   setIJt   floatR   R   R   R   (   R   t   _at   _bt   _p1t   _p2t   refCoo1t   gsCoo1t   wg1t   _refCoo1t   _gsCoo1t   _wg1t   mt   ft   refCoo2t   _refCoo2t   _gsCoo2t   _wg2t   refCoo3t   _refCoo3R   t   ptrR   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildVecFieldOnGauss_1  sP    7S0*
+c         C   sc  d } d } d } d } d d d d d d g } d | d d d	 | d | d d
+ | d d d	 | d | d d d	 | d | d d | d d d	 | d | d d | d g } d	 | d	 | d	 | d	 | d	 | d	 | g } | } | }	 | }
+ t  j   } t j t t  } | j d d d  | j |  t j   } | j	 d d d g d d  | j
+ | | |	 |
+  |
+ d c d 9<| j
+ d d g | |	 |
+  |
+ d c d 9<| j
+ d	 g | |	 |
+  d d d d d d d d d d d d g } | } |	 d d !}	 |	 } |
+ d d !}
+ |
+ } d d d d d d d d g } | } |	 d d	 !}	 |
+ d d !}
+ | j
+ d d d g | |	 |
+  |
+ d c d 9<| j
+ d g | |	 |
+  | j t | | |  t j   } | j d d  | j   } x1 t d  D]# } | j d | t | d   qW| j |  | j d  | j d d  | j d d  | j   | S(   Ng͚?g۰q?gBė?g2'%?g        g      ?i   i   i   g(\ @gQ	@i   i    i   ig      i   i   i   i	   i5   R   s   power [MW/m^3]R   ij   (   R   R'   R   R   R   R   R   R   R   R   t   setGaussLocalizationOnCellsR   R   R   R   R   R   R   R   R   R   R   R   (   R   R   R   R   R   R   R   R   R   R   R   R   R   t   diR   R   R   R   R   R   R   R   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildVecFieldOnGauss_2  s`    7S0 *
+c         C   sc  d } d } d } d } d d d d d d g } d | d d d	 | d | d d
+ | d d d	 | d | d d d	 | d | d d | d d d	 | d | d d | d g } d	 | d	 | d	 | d	 | d	 | d	 | g } | } | }	 | }
+ t  j   } t j t t  } | j d d d  | j |  t j   } | j	 d d d g d d  | j
+ | | |	 |
+  |
+ d c d 9<| j
+ d d	 g | |	 |
+  |
+ d c d 9<| j
+ d g | |	 |
+  d d d d d d d d d d d d g } | } |	 d d !}	 |	 } |
+ d d !}
+ |
+ } d d d d d d d d g } | } |	 d d	 !}	 |
+ d d !}
+ | j
+ d d d g | |	 |
+  |
+ d c d 9<| j
+ d g | |	 |
+  | j t | | |  t j   } | j d d  | j   } x1 t d  D]# } | j d | t | d   qW| j |  | j d  | j d d  | j d d  | j   | S(   Ng͚?g۰q?gBė?g2'%?g        g      ?i   i   i   g(\ @gQ	@i   i    i   ig      i   i   i   i	   i5   R   s   power [MW/m^3]R   ij   (   R   R'   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   (   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildVecFieldOnGauss_2_Simpler  s`    7S0 *
+c         C   s   t  j   } t j t t  } | j d d d  | j |  t j   } | j	 d d  x1 t
+ d  D]# } | j d | t | d   qg W| j |  | j d d  | j d d	  | j d
+  | j   | S(   NgQ	@i   i   i   i   i    i   s	   power [W]t   temperaturet   MyFieldOnGaussNEi(   (   R   R%   R   R   t   ON_GAUSS_NER   R   R   R   R   R   R   R   R   R   R   R   (   R   R   R   R   R   (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   buildVecFieldOnGaussNE_1%  s    !
+c   %      C   s  t  d d d d d d d d d d d d d d d d d d g d d  } t d d  } | j |  | j   | j t d d d g  | j t d d d g  | j t d d d d g  | j t d	 d
+ d d g  | j t d
+ d d d g  | j   } t   } | j	 d |  | j	 d |  t
+ d d d g  } | j d  t
+ d d d d g  } | j d  t
+ d d g  } | j d  | j d | | | g  t
+ d d g  } | j d  t
+ d d d d d	 d
+ g  }	 |	 j d  t
+ d d g  }
+ |
+ j d  | j d | |	 |
+ g  t   } | j |  t   } d } d# d$ g } t   } x t |  D] \ } \ } } } t t t  } | j | | |  | j |  t  | j   d  } | j   | d | 7} | d 9} | j |  | j   | j |  | j |  qqW| j |  d } d% d& d' g } t   } xGt |  D]9\ } \ } } } t t t  } | j | | |  | j |  t  | j   d  } | j   | d | 7} | j |  | j   | j |  | j |  t t t  } | j | | |  | j |  t  | j   d  } | j   | d( | 7} | j |  | j   | j |  | | | f j |  qYW| j |  d } d) d* d+ d, g } t   } xt |  D]\ } \ } } } t
+ d d d d g  } | j d  | | } t t t  }  |  j | | |  |  j |  t  | j   d  } | j   | d  | d 7} |  j |  |  j   |  j |  | j |  | d |  t
+ d d g  }! |! j d!  | |! }" t t t  }# |# j | | |  |# j |"  t  |" j   d  } | j   | d- | 7} |# j |  |# j   |# j |  | | | f j |# | d |!  qW| j |  t    }$ |$ j! |  |$ j" |  |$ S(.   Ni    i   i   i	   R   i   i   i   i   i   i   it	   gr0_0_2_4t   gr0_1_2_3_4t   gr0_0_4t   grM1_SegOnTri3t   grM1_SegOnQuad4t   grM1_bottomt
+   fNoProfileg{Gz?g{Gz?g?t   fNoProfileMultiLevsg        g?id   t   fProfileMultiLevsg      $@g      4@g      >@t   pfl1i  t
+   pfl2Bottomi  (   i    ig{Gz?(   i   ig{Gz?(   i    ig        (   i   ig?(   i   ig?ie   (   i    ig        (   i   ig      $@(   i   ig      4@(   i   ig      >@i  (#   R   R   R   R
+   R   R   R   t   computeSkinR   R   R   R   R   t   MEDFileMeshest   pushMesht   MEDFileFieldst   MEDFileFieldMultiTSt	   enumerateR   R   R   R   R   R   R   R   R   t   appendFieldNoProfileSBTt	   pushFieldt   setFieldNoProfileSBTt   appendFieldProfilet   setFieldProfilet   MEDFileDatat	   setMeshest	   setFields(%   R   R   R   R   R   t   grp0t   grp1t   grp2t   grp3t   grp4t   grp5t   mst   fst   f1Namet   timeStepsF1R   R   t   itt   ordert   timt   f11Tmpt   arrt   f2Namet   timeStepsF2R   t   f21Tmpt   f22Tmpt   f3Namet   timeStepsF3t   f3R	  t   m0Partt   f31Tmpt   pfl2t   m1Partt   f32Tmpt   data(    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt1   buildACompleteMEDDataStructureWithFieldsOnCells_15  s    H
+	       			" 
+  
+
+	" 
+ 
+ 
+ 
+	" 
+ 
+ 
+ 
+ 
+ 
+ 	  c         C   s1  d d d d d d d d g } d d d d g } d d d d d d d d g } t  j   } | j d  | j d  | j t d |  | j   t  j   } | j d  | j d  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t d | d d	 ! | j   t j   } | j	 | d d  | j
+ |  | j
+ |  t j   } | j d |  | j d
+ |  | j d  t j d g  } | j d  t j d d d d g  }	 |	 j d  | j d
+ | |	 g  t j   }
+ |
+ j d |  t j   } | j |
+  | S(   Ng        g      ?i   i   i   i   i    i   i   it   carreR   R   (   R   R   R	   R
+   R   R   R   R   R   R   R   R   R   R   R   R   R  t   setMeshAtPosR  R  (   t   selfR   t   conn2Dt   conn1Dt   mesh2Dt   mesh1Dt
+   meshCoordsR   R   R   R  t   mfd(    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt,   buildAMEDFileDataWithGroupOnOneFamilyForSauv  sD    
+
+(   t   __name__t
+   __module__R   R   R#   R%   R'   R,   R.   R<   R   R   R   R   R   R   R   R   R5  R?  t   classmethod(    (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyR      sJ   						>			U	7			*	2	1		`	1N(    (   t	   MEDLoadert   mathR   R   R   R   (    (    (    sy   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderDataForTest.pyt   <module>   s   
+
\ Pas de fin de ligne à la fin du fichier
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderFinalize.i MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderFinalize.i
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderFinalize.i	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderFinalize.i	2018-04-19 17:25:17.783798266 +0200
@@ -0,0 +1,78 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+%pythoncode %{
+MEDFileMeshesIterator.__next__ = MEDFileMeshesIterator.next
+MEDFileAnyTypeFieldMultiTSIterator.__next__ = MEDFileAnyTypeFieldMultiTSIterator.next
+MEDFileFieldsIterator.__next__ = MEDFileFieldsIterator.next
+%}
+
+%pythoncode %{
+def MEDCouplingMEDFileUMeshReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileUMesh,((),(self.__getstate__()),))
+MEDFileUMesh.__reduce__=MEDCouplingMEDFileUMeshReduce
+del MEDCouplingMEDFileUMeshReduce
+def MEDCouplingMEDFileCMeshReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileCMesh,((self.serialize(),),(self.__getstate__()),))
+MEDFileCMesh.__reduce__=MEDCouplingMEDFileCMeshReduce
+del MEDCouplingMEDFileCMeshReduce
+def MEDCouplingMEDFileCurveLinearMeshReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileCurveLinearMesh,((self.serialize(),),(self.__getstate__()),))
+MEDFileCurveLinearMesh.__reduce__=MEDCouplingMEDFileCurveLinearMeshReduce
+del MEDCouplingMEDFileCurveLinearMeshReduce
+def MEDCouplingMEDFileDataReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileData,((self.serialize(),),(self.__getstate__()),))
+MEDFileData.__reduce__=MEDCouplingMEDFileDataReduce
+del MEDCouplingMEDFileDataReduce
+def MEDCouplingMEDFileMeshesReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileMeshes,((self.serialize(),),(self.__getstate__()),))
+MEDFileMeshes.__reduce__=MEDCouplingMEDFileMeshesReduce
+del MEDCouplingMEDFileMeshesReduce
+def MEDCouplingMEDFileFieldsReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileFields,((self.serialize(),),(self.__getstate__()),))
+MEDFileFields.__reduce__=MEDCouplingMEDFileFieldsReduce
+del MEDCouplingMEDFileFieldsReduce
+def MEDCouplingMEDFileField1TSReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileField1TS,((self.serialize(),),(self.__getstate__()),))
+MEDFileField1TS.__reduce__=MEDCouplingMEDFileField1TSReduce
+del MEDCouplingMEDFileField1TSReduce
+def MEDCouplingMEDFileFieldMultiTSReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileFieldMultiTS,((self.serialize(),),(self.__getstate__()),))
+MEDFileFieldMultiTS.__reduce__=MEDCouplingMEDFileFieldMultiTSReduce
+del MEDCouplingMEDFileFieldMultiTSReduce
+def MEDCouplingMEDFileIntField1TSReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileIntField1TS,((self.serialize(),),(self.__getstate__()),))
+MEDFileIntField1TS.__reduce__=MEDCouplingMEDFileIntField1TSReduce
+def MEDCouplingMEDFileIntFieldMultiTSReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileIntFieldMultiTS,((self.serialize(),),(self.__getstate__()),))
+MEDFileIntFieldMultiTS.__reduce__=MEDCouplingMEDFileIntFieldMultiTSReduce
+del MEDCouplingMEDFileIntFieldMultiTSReduce
+def MEDCouplingMEDFileFloatField1TSReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileFloatField1TS,((self.serialize(),),(self.__getstate__()),))
+MEDFileFloatField1TS.__reduce__=MEDCouplingMEDFileFloatField1TSReduce
+def MEDCouplingMEDFileFloatFieldMultiTSReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileFloatFieldMultiTS,((self.serialize(),),(self.__getstate__()),))
+MEDFileFloatFieldMultiTS.__reduce__=MEDCouplingMEDFileFloatFieldMultiTSReduce
+del MEDCouplingMEDFileFloatFieldMultiTSReduce
+def MEDCouplingMEDFileParametersReduce(self):
+  return MEDCouplingStdReduceFunct,(MEDFileParameters,((self.serialize(),),(self.__getstate__()),))
+MEDFileParameters.__reduce__=MEDCouplingMEDFileParametersReduce
+del MEDCouplingMEDFileParametersReduce
+%}
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoader.i MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoader.i
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoader.i	2018-04-19 17:04:36.765223281 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoader.i	2018-04-19 17:25:17.760797811 +0200
@@ -18,12 +18,11 @@
 //
 // Author : Anthony Geay (CEA/DEN)
 
+%module MEDLoader
+
 %include "MEDLoaderCommon.i"
 
 %pythoncode %{
-def MEDCouplingDataArrayDoublenew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.DataArrayDouble____new___(cls,args)
 def MEDCouplingDataArrayDoubleIadd(self,*args):
     import _MEDLoader
     return _MEDLoader.DataArrayDouble____iadd___(self, self, *args)
@@ -39,9 +38,6 @@
 def MEDCouplingDataArrayDoubleIpow(self,*args):
     import _MEDLoader
     return _MEDLoader.DataArrayDouble____ipow___(self, self, *args)
-def MEDCouplingFieldDoublenew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingFieldDouble____new___(cls,args)
 def MEDCouplingFieldDoubleIadd(self,*args):
     import _MEDLoader
     return _MEDLoader.MEDCouplingFieldDouble____iadd___(self, self, *args)
@@ -57,18 +53,6 @@
 def MEDCouplingFieldDoubleIpow(self,*args):
     import _MEDLoader
     return _MEDLoader.MEDCouplingFieldDouble____ipow___(self, self, *args)
-def MEDCouplingFieldIntnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingFieldInt____new___(cls,args)
-def MEDCouplingFieldFloatnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingFieldFloat____new___(cls,args)
-def MEDCouplingDataArrayBytenew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.DataArrayByte____new___(cls,args)
-def MEDCouplingDataArrayFloatnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.DataArrayFloat____new___(cls,args)
 def MEDCouplingDataArrayFloatIadd(self,*args):
     import _MEDLoader
     return _MEDLoader.DataArrayFloat____iadd___(self, self, *args)
@@ -81,9 +65,6 @@
 def MEDCouplingDataArrayFloatIdiv(self,*args):
     import _MEDLoader
     return _MEDLoader.DataArrayFloat____idiv___(self, self, *args)
-def MEDCouplingDataArrayIntnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.DataArrayInt____new___(cls,args)
 def MEDCouplingDataArrayIntIadd(self,*args):
     import _MEDLoader
     return _MEDLoader.DataArrayInt____iadd___(self, self, *args)
@@ -129,110 +110,14 @@
 def MEDCouplingDataArrayIntTupleImod(self,*args):
     import _MEDLoader
     return _MEDLoader.DataArrayIntTuple____imod___(self, self, *args)
-def ParaMEDMEMDenseMatrixIadd(self,*args):
+def MEDCouplingDenseMatrixIadd(self,*args):
     import _MEDLoader
     return _MEDLoader.DenseMatrix____iadd___(self, self, *args)
-def ParaMEDMEMDenseMatrixIsub(self,*args):
+def MEDCouplingDenseMatrixIsub(self,*args):
     import _MEDLoader
     return _MEDLoader.DenseMatrix____isub___(self, self, *args)
-def MEDCouplingUMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingUMesh____new___(cls,args)
-def MEDCoupling1DGTUMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCoupling1DGTUMesh____new___(cls,args)
-def MEDCoupling1SGTUMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCoupling1SGTUMesh____new___(cls,args)
-def MEDCouplingCurveLinearMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingCurveLinearMesh____new___(cls,args)
-def MEDCouplingCMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingCMesh____new___(cls,args)
-def MEDCouplingIMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingIMesh____new___(cls,args)
-def MEDCouplingExtrudedMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDCouplingMappedExtrudedMesh____new___(cls,args)
-%}
-
-%pythoncode %{
-def MEDCouplingMEDFileUMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileUMesh____new___(cls,args)
-def MEDCouplingMEDFileCMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileCMesh____new___(cls,args)
-def MEDCouplingMEDFileCurveLinearMeshnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileCurveLinearMesh____new___(cls,args)
-def MEDCouplingMEDFileMeshesnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileMeshes____new___(cls,args)
-def MEDCouplingMEDFileDatanew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileData____new___(cls,args)
-def MEDCouplingMEDFileFieldsnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileFields____new___(cls,args)
-def MEDCouplingMEDFileField1TSnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileField1TS____new___(cls,args)
-def MEDCouplingMEDFileFieldMultiTSnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileFieldMultiTS____new___(cls,args)
-def MEDCouplingMEDFileIntField1TSnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileIntField1TS____new___(cls,args)
-def MEDCouplingMEDFileIntFieldMultiTSnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileIntFieldMultiTS____new___(cls,args)
-def MEDCouplingMEDFileFloatField1TSnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileFloatField1TS____new___(cls,args)
-def MEDCouplingMEDFileFloatFieldMultiTSnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileFloatFieldMultiTS____new___(cls,args)
-def MEDCouplingMEDFileParametersnew(cls,*args):
-    import _MEDLoader
-    return _MEDLoader.MEDFileParameters____new___(cls,args)
 %}
 
 %include "MEDCouplingFinalize.i"
 
-%pythoncode %{
-MEDFileMeshesIterator.__next__ = MEDFileMeshesIterator.next
-MEDFileAnyTypeFieldMultiTSIterator.__next__ = MEDFileAnyTypeFieldMultiTSIterator.next
-MEDFileFieldsIterator.__next__ = MEDFileFieldsIterator.next
-%}
-
-%pythoncode %{
-MEDFileUMesh.__new__=classmethod(MEDCouplingMEDFileUMeshnew)
-del MEDCouplingMEDFileUMeshnew
-MEDFileCMesh.__new__=classmethod(MEDCouplingMEDFileCMeshnew)
-del MEDCouplingMEDFileCMeshnew
-MEDFileCurveLinearMesh.__new__=classmethod(MEDCouplingMEDFileCurveLinearMeshnew)
-del MEDCouplingMEDFileCurveLinearMeshnew
-MEDFileData.__new__=classmethod(MEDCouplingMEDFileDatanew)
-del MEDCouplingMEDFileDatanew
-MEDFileMeshes.__new__=classmethod(MEDCouplingMEDFileMeshesnew)
-del MEDCouplingMEDFileMeshesnew
-MEDFileFields.__new__=classmethod(MEDCouplingMEDFileFieldsnew)
-del MEDCouplingMEDFileFieldsnew
-MEDFileField1TS.__new__=classmethod(MEDCouplingMEDFileField1TSnew)
-del MEDCouplingMEDFileField1TSnew
-MEDFileFieldMultiTS.__new__=classmethod(MEDCouplingMEDFileFieldMultiTSnew)
-del MEDCouplingMEDFileFieldMultiTSnew
-MEDFileIntField1TS.__new__=classmethod(MEDCouplingMEDFileIntField1TSnew)
-del MEDCouplingMEDFileIntField1TSnew
-MEDFileIntFieldMultiTS.__new__=classmethod(MEDCouplingMEDFileIntFieldMultiTSnew)
-del MEDCouplingMEDFileIntFieldMultiTSnew
-MEDFileFloatField1TS.__new__=classmethod(MEDCouplingMEDFileFloatField1TSnew)
-del MEDCouplingMEDFileFloatField1TSnew
-MEDFileFloatFieldMultiTS.__new__=classmethod(MEDCouplingMEDFileFloatFieldMultiTSnew)
-del MEDCouplingMEDFileFloatFieldMultiTSnew
-MEDFileParameters.__new__=classmethod(MEDCouplingMEDFileParametersnew)
-del MEDCouplingMEDFileParametersnew
-%}
+%include "MEDLoaderFinalize.i"
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderSplitter.py MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderSplitter.py
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderSplitter.py	2018-04-19 17:04:36.766223301 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderSplitter.py	2018-04-19 17:25:17.772798048 +0200
@@ -26,7 +26,7 @@
     @classmethod
     def New(cls,mfd,idsLst):
         """ mfd is a MEDFileData instance containing only one mesh. idsLst is a list of DataArrayInt containing each the ids per processor """
-        return MEDLoaderSplitter(fileName)
+        return MEDLoaderSplitter(mfd,idsLst)
         pass
 
     def __init__(self,mfd,idsLst):
@@ -96,18 +96,26 @@
 
     def __splitMesh(self,mfm,idsLst):
         ret0 = [MEDFileMeshes() for i in range(len(idsLst))]
-        m=mfm.getMeshAtLevel(0)
+        m=mfm[0]
+        addlevs=list(mfm.getNonEmptyLevels())[1:]
+        dAddlevs={k:mfm[k] for k in addlevs}
         for ret,ids in zip(ret0,idsLst):
             mlPart=mfm.createNewEmpty()
-            mPart=m[ids] ; trad=mPart.zipCoordsTraducer()
-            trad=trad.invertArrayO2N2N2O(mPart.getNumberOfNodes())
-            mlPart.setMeshAtLevel(0,mPart)
+            mPart=m[ids] ; trado2n=mPart.zipCoordsTraducer()
+            trad=trado2n.invertArrayO2N2N2O(mPart.getNumberOfNodes())
+            mlPart[0]=mPart
             if 0 in mfm.getFamArrNonEmptyLevelsExt():
                 mlPart.setFamilyFieldArr(0,mfm.getFamilyFieldAtLevel(0)[ids])
                 pass
             if 1 in mfm.getFamArrNonEmptyLevelsExt():
                 mlPart.setFamilyFieldArr(1,mfm.getFamilyFieldAtLevel(1)[trad])
                 pass
+            for k,v in dAddlevs.iteritems():
+                part=v.getCellIdsFullyIncludedInNodeIds(trad)
+                mSubPart=v[part] ; mSubPart.renumberNodesInConn(trado2n) ; mSubPart.setCoords(mPart.getCoords())
+                mlPart[k]=mSubPart
+                mlPart.setFamilyFieldArr(k,mfm.getFamilyFieldAtLevel(k)[part])
+                pass
             mlPart.copyFamGrpMapsFrom(mfm)
             ret.pushMesh(mlPart)
             pass
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest1.pyc MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest1.pyc
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest1.pyc	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest1.pyc	2018-04-19 17:25:17.768797969 +0200
@@ -0,0 +1,192 @@
+
+;Zc           @   sz   d  d l  Z  d  d l Z d  d l m Z m Z m Z d  d l m Z d e j f d     YZ e	 d k rv e j
+   n  d S(   iN(   t   pit   et   sqrt(   t   MEDLoaderDataForTestt   MEDLoaderTest1c           B   s   e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
+ d	   Z d
+   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z RS(   c         C   sa   t  j   } | j   t j d | t  t j d | j   d  } |  j | j	 | d   d  S(   Ns   Pyfile1.medi    g-q=(
+   R   t   build1DMesh_1t   checkConsistencyLightt	   MEDLoadert
+   WriteUMesht   Truet   ReadUMeshFromFilet   getNamet
+   assertTruet   isEqual(   t   selft   mesht   mesh_rw(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMesh1DRW   s    
+c         C   sa   t  j   } | j   t j d | t  t j d | j   d  } |  j | j	 | d   d  S(   Ns   Pyfile2.medi    g-q=(
+   R   t   build2DCurveMesh_1R   R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMesh2DCurveRW$   s    
+c         C   sa   t  j   } | j   t j d | t  t j d | j   d  } |  j | j	 | d   d  S(   Ns   Pyfile3.medi    g-q=(
+   R   t   build2DMesh_1R   R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMesh2DRW,   s    
+c         C   sa   t  j   } | j   t j d | t  t j d | j   d  } |  j | j	 | d   d  S(   Ns   Pyfile4.medi    g-q=(
+   R   t   build3DSurfMesh_1R   R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMesh3DSurfRW4   s    
+c         C   sa   t  j   } | j   t j d | t  t j d | j   d  } |  j | j	 | d   d  S(   Ns   Pyfile5.medi    g-q=(
+   R   t   build3DMesh_1R   R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMesh3DRW<   s    
+c      	   C   s  t  j   } t j d | t  t j d | j   j   d | j   d d  } |  j | j	 | d d   t  j
+   } t j d | t  t j d | j   j   d | j   d d  } |  j | j	 | d d   |  j t t j d | j   j   d | j   d d  d  S(   Ns   Pyfile6.medi    i   g-q=s   Pyfile7.medi   i   (   R   t   buildVecFieldOnCells_1R   t
+   WriteFieldR	   t   ReadFieldCellt   getMeshR   R   R   t   buildVecFieldOnNodes_1t   ReadFieldNodet   assertRaisest	   Exception(   R   t   f1t   f2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldRW1D   s    007c   	   	   C   s#  d } d } d } t  j   } t j | | t  | j d d d  | j   j d d |  t j | |  | j d d	 d
+  | j   j d d |  t j | |  t j	 | | j
+   j   d | j   d d  } | j d d d  | j   j d d |  |  j | j | d d   t j	 | | j
+   j   d | j   d d  } t  j   } |  j | j | d d   t j	 | | j
+   j   d | j   d	 d
+  } | j d d	 d
+  | j   j d d |  |  j | j | d d   |  j t t j	 | | j
+   j   d | j   d d
+  t  j   } d } t j | | t  | j d d d  | j   j   } | j   j d d |  t j | |  | j d d d  | j   j d d |  t j | |  t j | | j
+   j   d | j   d d  } | j d d d  | j   j d d |  |  j | j | d d   t j | | j
+   j   d | j   d d  } t  j   } |  j | j | d d   t j | | j
+   j   d | j   d d  } | j d d d  | j   j d d |  |  j | j | d d   d  S(   Ns   Pyfile8.medgOL@g p!6+pg      $@i   i	   i    gHzG$@i   i   g-q=i   i   s   Pyfile9.medg     [@il   im   i   g     @j@i   i   i   (   R   R   R   R   R	   t   setTimet   getArrayt   setIJt!   WriteFieldUsingAlreadyWrittenMeshR   R   R   R   R   R    R!   R   t
+   getPointerR   (	   R   t   fileNamet   VAL1t   VAL2R"   R#   t   f3t	   fileName2t   tmp(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldRW2Q   sZ    0007000c         C   s  d } d } d } d } d } t  j   } | j   j |  | j |  | j d d d  | j   j   } | j   j d	 d	 |  t j	 | | t
+  | j d
+ d d  | j   j d	 d	 |  t j | |  | j   j |  | j d d d  | j   j d	 d	 d |  t j | |  t j | |  } | j d d d  | j   j d	 d	 d |  t j | |  | j d d d  | j   j d	 d	 d |  t j | |  t  j   } | j |  | j   j |  | j d d d  t j | |  | j d d d  | j   j   } | j   j d	 d |  t j | |  | j d d d  | j   j d	 d |  t j | |  t j | | |  }	 |  j d t |	   |  j d |	 d	 d	  |  j d |	 d	 d  |  j d |	 d d	  |  j d |	 d d  |  j d |	 d  d	  |  j d |	 d  d  |  j d |	 d d	  |  j d |	 d d  |  j d |	 d d	  |  j d |	 d d  t j | | |  }
+ |  j d t |
+   |  j d |
+ d	 d	  |  j d |
+ d	 d  |  j d |
+ d d	  |  j d |
+ d d  |  j d |
+ d  d	  |  j d |
+ d  d  t j | | d	 | d d  } |  j | | j   j d	 d	  d!  t j | | d	 | d d  } |  j | | j   j d	 d	  d!  t j | | d	 | d d  } |  j d | | j   j d	 d	  d!  t j | | d	 | d d  } |  j d | | j   j d	 d	  d!  t j | | d	 | d d  } |  j d | | j   j d	 d	  d!  t j | | d	 | d d  } |  j d" | j   j d	 d  d!  t j | | d	 | d d  } |  j | | j   j d	 d  d!  t j | | d	 | d d  } |  j | | j   j d	 d  d!  d  S(#   Ns   Pyfile11.medgOL@g p!6+pt   AFieldt   AMesh1g      $@i   i	   i    gHzG$@i   i   g%@i   i   i   gRQ%@i&   i'   g
+ףp=%@i0   i1   i   g     [@il   im   g     @j@i   i   i   i   i   i   g     Q@(   R   R   R   t   setNameR%   R&   R)   R'   R   R   R	   R(   t   GetMeshNamesOnFieldR   t   GetCellFieldIterationst   assertEqualt   lent   GetNodeFieldIterationsR   t   assertAlmostEqualt   getIJR   (   R   R*   R+   R,   t   name1t   name3R"   R/   t   vect   it1t   it3(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldRW3   s            %%)))%%%c         C   s3  d } t  j   } d d d d d g } | j | t  } | j d  d d d d	 g } | j | t  } | j d
+  t j j   } | j d  | j d  | j	 d  d d d d g } | j
+ t j d | d d ! | j   | j | j    | | | | g }	 d }
+ t j | |
+ |	 t  t j | |
+  } | j |
+  d d d d d d d d d d d d d d d	 d d d g } | j | t  } | j |
+  |  j | j | d   t j | |
+  } |  j d t |   | j d  | j d
+  | j d  | j d  d } t j | |
+ d |  } |  j | j | d   d
+ g } t j | |
+ d |  } |  j | j | d   d g } t j | |
+ d |  } |  j | j | d   d } t j | |
+ d |  } | j d  |  j | j | d   d d g } t j | |
+ d |  } | j d  |  j | j | d   t j | d d  } |  j d t |   d d d d g } |  j | d |  |  j | d |  |  j | d |  |  j | d |  t j | d d  } |  j d t |   |  j | d d  |  j | d d  d  S(   Ns   Pyfile10.medi   i   i   i   i   t   mesh2i   i   t   mesh3t   mesh4i    i   t   3DTotoi   i   i   i   i	   i
+   i   i   i   g-q=t   3DMesh_1s	   Family_-3s	   Family_-5s	   Family_-4s	   Family_-2(   s   mesh2(   R   R   t   buildPartOfMySelfR	   R3   R   t   MEDCouplingUMesht   Newt   setMeshDimensiont   allocateCellst   insertNextCellt   NORM_TETRA4t   finishInsertingCellst	   setCoordst	   getCoordst   WriteUMeshesPartitionR
+   R   R   t   GetMeshGroupsNamesR6   R7   t   indext   ReadUMeshFromGroupst   ReadUMeshFromFamiliest   GetMeshFamiliesNamesOnGroupt   assertInt   GetMeshGroupsNamesOnFamily(   R   R*   t   mesh1t   part1RA   t   part2RB   RC   t   connt   meshest   mnanet   mesh5t   part3t   mesh6t   grpsR=   t   mesh2_2t   mesh3_2t   mesh4_2t   mesh1_2t   rett   reft   ret1(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMultiMeshRW1   sx    
+<		c      
+   C   s  d } t  j   } | j d  \ } } } t j | | t  d d d d d g } | j | t  } | j | j    | j	   } |  j
+ d |  t j j t j t j  }	 |	 j d	  |	 j |  t j j   }
+ |
+ j | d  |	 j |
+  d
+ d d d d d d d d d g
+ } |
+ j | | d  |	 j d d d  |	 j   t j | |	 t  t j | |	 j   j   d |	 j   d d  } t j | |	 j   j   |	 j    } |  j
+ | t j g  | j   |  j |	 j | d d   d  S(   Ns   Pyfile12.medg-q=i   i   i   i   i   i   t   VectorFieldOnCellsg     Q@g     `e@g      $@g     [@g      4@g      ^@g      >@g     @`@g      D@g     a@gQ	@i   i    (   R   R   t
+   mergeNodesR   R   R	   RF   R3   R   t   getNumberOfCellsR6   t   MEDCouplingFieldDoubleRH   t   ON_CELLSt   ONE_TIMEt   setMesht   DataArrayDoublet   alloct   setArrayt	   setValuesR%   R   R   t   FalseR   R   t   GetTypesOfFieldR   R   (   R   R*   RX   t   dat   bt   newNbOfNodesRY   RA   t	   nbOfCellsR"   t   arrayt   arr1R#   t   tt(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldProfilRW1  s4    $
+0'
+c         C   s{   d } t  j   } t j | | t  t j t j | | j   j   d | j   d d  } |  j	 | j
+ | d d   d  S(   Ns   Pyfile13.medi    i   i   g-q=(   R   t   buildVecFieldOnGauss_1R   R   R	   t	   ReadFieldt   ON_GAUSS_PTR   R   R   R   (   R   R*   R"   R#   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldGaussRW13  s    6c         C   s   d } t  j   } t j | | t  |  j t j g t j | d d   t j t j | | j	   j
+   d | j
+   d d  } |  j | j | d d   d  S(   Ns   Pyfile14.medt   2DMesh_2t   MyFieldOnGaussNEi    i   i   g-q=(   R   t   buildVecFieldOnGaussNE_1R   R   R	   R6   t   ON_GAUSS_NERv   R   R   R   R   R   (   R   R*   R"   R#   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldGaussNERW1;  s    %6c         C   s   d } t  j   } d d d d d d g } | j | t  | j   t j | | t  t j | | j	   d  } |  j
+ | j | d   d  S(	   Ns   Pyfile15.medi   i   i   i    i   i   g-q=(   R   R   t   renumberCellsRu   R   R   R   R	   R
+   R   R   R   (   R   R*   R   t	   renumber1R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMesh3DSurfShuffleRWD  s    
+c         C   sY  d } t  j   } |  j d | j    |  j d | j    d d d g } | j |  d d d d	 d
+ d d d d d d d d d d d d d d d g } | j | t  | j   t	 j
+ | | t  | j t  } | j t	 j t  } | j d d d  | j t  } t	 j | |  | j d  | j d d d  | j t  } t	 j | |  | j d  | j d d d  | j t  }	 t	 j | |  d d d  g }
+ t	 j t	 j | | j   j   d | j   |
+  } |  j d t |   |  j | d j | d d   |  j | d j | d d   |  j | d j |	 d d   d  S(!   Ns   Pyfile17.medi   i-   i   i   i   i   i   i   i	   i   i   i   i   i    i   i   i   i   i   i
+   i   i   g        s   2*xg{Gz?s   2*x/3g{Gz?g-q=(   i   i   (   i   i   (   i   i   (   R   t   build3DMesh_2R6   Rl   t   getNumberOfNodest   convertToPolyTypesR   Ru   t   orientCorrectlyPolyhedronsR   R   R	   t   getMeasureFieldt   buildNewTimeReprFromThisRo   R%   t   cloneWithMeshR(   t	   applyFunct   ReadFieldsOnSameMeshRn   R   R   R7   R   R   (   R   R*   t   mt   polyst   renumt   f1TmpR"   t   f_1t   f_2t   f_3t   itst   fs(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMultiFieldShuffleRW1O  s<    B
+3   c      
+   C   s  d } t  j   } d d d g } d d d g } | j | | d  } | j | t  } d d d d	 d
+ g } | j | t  | j d  | | g } t j	 | | t  t j
+ | | j   d  }	 |  j |	 j | d   |	 j | j    |  j |	 j | d   t j
+ | | j   d  }
+ |  j |
+ j | d   t j j t j t j  } | j d  | j |  t j j   } d d d d d d d d d d g
+ } | j | | j   d  | j d d  | j d d  | j |  | j | | j   d  } | j d d d  | j   t j | |  t j | | j   j   d | j   d d  } |  j | j | d d   d  S(   Ns   Pyfile18.medg        g333333ӿg      ?g-q=i   i   i    i   i   t   ExampleOfMultiDimWit   FieldOnFacesShuffleg     Q@g     `e@g      $@g     [@g      4@g      ^@g      >@g     @`@g      D@g     a@s	   plkj [mm]s   pqqqss [mm]gQ	@i   (   R   R   t   findNodesOnPlanet   buildFacePartOfMySelfNodeR	   R   Ru   R3   R   t   WriteUMeshesR
+   R   R   R   Rm   RH   Rn   Ro   Rp   Rq   Rt   Rl   t   setInfoOnComponentRs   R%   R   R(   R   R   (   R   R*   t   m3dt   ptR=   t   nodest   m2dt   renumberR\   t   m3d_bist   m2d_bisR"   R{   R|   R/   R#   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testWriteUMeshesRW1q  sB    $
+0c         C   sn  d } d } t  j   } | j   } t j | | t  t j j t j t j	  } | j
+ d  | j |  t j j   } d d d d d d	 d
+ d d d d d d d d d d d d d d d d d g } | j | | d  | j |  | j d d  | j d d   | j d! d d"  | j   d d# g } | j |  }	 |	 j   j
+ | j   j    t j | |	 t  t j | |	 j   j   d |	 j   d d"  }
+ |
+ j   |  j |
+ j |	 d$ d$   d d% d d& d d# g } |	 j |  t j | | t  t j | |	 t  t j | |	 j   j   d |	 j   d d"  }
+ |
+ j   |  j |
+ j |	 d$ d$   d  S('   Ns   Pyfile19.meds   Pyfile20.medt   VFieldOnNodesg      ?g     @Y@g       @g     Y@g      @g     Y@g      @g      Z@g      @g     @Z@g      @g     Z@g      @g     Z@g       @g      [@g      "@g     @[@g      $@g     [@g      &@g     [@g      (@g      \@i   i    s	   tyty [mm]i   s	   uiop [MW]gQ	@i   i   g-q=i   i   (   R   R   R   R   R   R	   Rm   RH   t   ON_NODESRo   R3   Rp   Rq   Rt   Rs   R   R%   R   t   buildSubPartR   R   R   Ru   R   R   R   t   renumberNodes(   R   R*   R.   R   t	   nbOfNodesR"   R{   R|   t   arr2R#   R-   t   arr3(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldNodeProfilRW1  s>    N
+0
+0
+c   	      C   s  d } t  j   } t j | | t  t j j t j t j  } | j	 d  | j
+ |  d d d d d d d	 d
+ d d d d d d d d d d d d d d d d g } t j j   } | j | d d  | j |  | j d d  | j d d   | j   } | j d! d d"  d# d" d d d$ d% d& d d' d( d) d* g } | j |  | j   t j | | t  t j | | j   j   d | j   d d"  } |  j | j | d+ d+   d  S(,   Ns   Pyfile23.medt   FieldMixg     @g     L@g     @g     X@g     @g     @g     @g     @g     @@g     Б@g     h@g     @g     @g      @g     @g     H@g     @g     p@g     @g     @g     @g     @g     @g     @i   i   i    s	   plkj [mm]i   s   pqqqss [mm]g\(\	@i   i   i   i   i
+   i	   i   i   i   g-q=(   R   R   R   R   R	   Rm   RH   R   Ro   R3   Rp   Rq   Rt   Rs   R   R)   R%   R   R   R   Ru   R   R   R   R   R   (	   R   R*   R   R"   R   R{   R/   t   renumArrR#   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldNodeProfilRW2  s,    $**
+0c         C   s  d } t  j   } t j j t j t j  } | j d  | j |  t j	 j   } | j
+ |  d d d d d d d	 d
+ d d d d g } | j | d d  | j d d  | j d d  | j d d d  | j   t j j t j t j  } | j d  | j |  t j	 j   } | j
+ |  d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. g } | j | d/ d  | j d d  | j d d  | j d d d  | j   t j | | t  t j | | j   j   | j    } |  j d t |   |  j t j | d  t j | | j   j    }	 |  j d t |	   |  j |	 d d k  t j | |  t j | | j   j    }	 |  j d t |	   |  j |	 d d k  t j | | j   j   | j    } |  j d t |   |  j t j | d  |  j t j | d  t j | | j   j   d | j   d d  }
+ |  j |
+ j | d0 d0   t j | | j   j   d | j   d d  }
+ |  j |
+ j | d0 d0   d  S(1   Ns   Pyfile21.medR   g     Q@g     `e@g      $@g     [@g      4@g      ^@g      >@g     @`@g      D@g     a@g      I@g     b@i   i   i    s	   plkj [mm]i   s   pqqqss [mm]gQ	@i   g     @g     L@g     @g     X@g     @g     @g     @g     @g     @@g     Б@g     h@g     @g     @g      @g     @g     H@g     @g     p@g     @g     @g     @g     @g     @g     @i   g-q=(   R   R   R   Rm   RH   Rn   Ro   R3   Rp   Rq   Rs   Rt   R   R%   R   R   R   R	   Rv   R   R   R6   R7   t   GetAllFieldNamesOnMeshR   R(   R   R   R   (   R   R*   R   R"   R{   R|   R#   R   t   tsR   R-   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMixCellAndNodesFieldRW1  sZ    *
+$*
+''00c         C   s  d } t  j   } t j j t j t j  } | j d  | j d d d  | j	 |  | j
+ d d  t j | | t  | j d d	 d
+  | j
+ d d  t j | |  | j d  t j | | t  | j d  | j d  t j | | t  t j j t j t j  } | j d  | j d d	 d  | j	 |  | j
+ d d  t j | | t  t j |  } |  j d t |   |  j | d d k  |  j | d d k  |  j | d d k  |  j | d d k  d  S(   Ns   Pyfile22.medt   Field1gQ@i   i   i   s   x+ygfffffR@i   i   s   x+77.*yt   Field2t   Field3t   2DMesh_2Bist   Field8g{G!@i	   i   s   3*x+yi   i    i   (   R   t   build2DMesh_2R   Rm   RH   R   Ro   R3   R%   Rp   t   fillFromAnalyticR   R	   R(   Ru   Rn   t   GetAllFieldNamesR6   R7   R   (   R   R*   R   R"   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testGetAllFieldNamesRW1  s:    c         C   sa  d } t  j   } | j t  j d d d d g  t  j d d g  t  j d d g   | j   } | j d  t  j t  j  } | j |  d } t  j | d  } | j	   | j
+ |  | j g  t |  D] } d | ^ q  | j |  | j d	  t  j | | t  t  j | | j   d | j   d
+ d
+  } |  j | j | d d   d  S(   Ns   Pyfile57.medi    i   i   i   t   TinyMeshi  s   c%it   FieldBigCompoig-q=(   R   t   MEDCouplingCMeshRN   Rq   t   buildUnstructuredR3   Rm   Rn   Rp   t   iotat	   rearranget   setInfoOnComponentst   rangeRs   R   R	   R   R   R   R   (   R   R*   R   t   ft	   nbOfCompot   arrt   iR#   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testBigNbOfCompoNonReg'  s$     F   
+**c      
+   C   s  d } t  j d t  j  } | j   | j d d d d g  | j t  j d d d d d d d d g d	 d   g  t d	  D] } | j   ^ q } x7 t	 |  D]) \ } } | j
+ t |  d
+ d g  q Wt  j j |  } | j t  } | j   j d g  t  j | | t  t  j | d d | j   d d  } | j t  j | j     |  j | j | d d   | j   } | j   t  j |  } | j t  } | j   j d g  t  j | | t  t  j | d d | j   d d  } | j t  j | j     |  j | j | d d   t  j   } t  j d	  }	 |	 j   | j |	 |	  | j d  | j t  } | j   j d g  t  j | | t  t  j | d d | j   d d  } |  j | j | d d   | j   j   }
+ t  j  d  } | j! d	 d	 g  | j |
+  | j t  } | j   j d g  t  j | | t  t  j | d d | j   d d  } |  j | j | d d   d  S(   Ns   Pyfile73.medR   i    i   i   i   g        g      ?i   g      ?s
+   ABC [defg]t   mergeig-q=("   R   t   MEDCoupling1SGTUMesht
+   NORM_QUAD4RJ   RK   RN   Rq   R   t   deepCopyt	   enumeratet	   translatet   floatt   Merge1SGTUMeshesR   Ru   R&   R   R   R	   R   R   Rp   R   R   R   R   t   convertAllToPolyt   MEDCoupling1DGTUMeshR   R   R3   RO   t   MEDCouplingCurveLinearMesht   setNodeGridStructure(   R   t   fnameR   R   t   mst   eltt   m0R   t   fReadR   t   c(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMultiMeshTypeWrite07  sZ     
+4% $ 
+ $ 
+ $ $c   
+   
+   C   s  d } t  j d t  j  } | j   | j d d d d g  | j t  j d d d d d d d d g d	 d   g  t d	  D] } | j   ^ q } x7 t	 |  D]) \ } } | j
+ t |  d
+ d g  q Wt  j j |  } t  j | | t  t  j | d d  } |  j t | t  j   t  j |  } |  j | j | d   | j   } | j   t  j |  } t  j | | t  t  j | d d  } t  j |  } |  j | j | d   t  j   } t  j d	  } | j   | j | |  | j d  t  j | | t  t  j | d  } |  j t | t  j   |  j | j | d   | j   j   }	 t  j d  } | j d	 d	 g  | j |	  t  j | | t  t  j | d  } |  j t | t  j   |  j | j | d   d  S(   Ns   Pyfile74.medR   i    i   i   i   g        g      ?i   g      ?R   g-q=(   R   R   R   RJ   RK   RN   Rq   R   R   R   R   R   R   t	   WriteMeshR	   t   ReadMeshFromFileR   t
+   isinstanceRG   R   R   R   R   R   R   R3   RO   R   R   (
+   R   R   R   R   R   R   R   t   mReadR   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testMultiMeshTypeWrite1h  sP     
+4% 
+ 
+c         C   sN   t  j   } | j   j d  } | j d d  |  j d | j   k  d S(   s`    This test is a non regression test on MEDFileUMesh.changeGroupName thanks to Alliance.
+        i    t   grp0_LM1t   xonall1N(   R   t,   buildAMEDFileDataWithGroupOnOneFamilyForSauvt	   getMeshest   getMeshAtPost   changeGroupNameR   t   getGroupsNames(   R   t   mfdR   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testChangeGroupName  s
+    c   	      C   s  d } d d d d d d d d g } d d d d g } t  j j d d  } | j d  | j t  j d |  | j   t  j j   } | j | d d  | j	 |  t  j
+ j t  j t  j  } | j |  t  j j   } | j d d  | j d  | j d	 d
+  | j |  | j d  t  j   } t  j d  t  j |  |  j d | j    t  j d	  t  j |  |  j d	 | j    ~ t  j d  |  j t  j t  j | | t  | j   j d	 d  t  j | | t  d S(   sm    This test is a non regression test, to check that in basic API the policies are taken into account.
+        s   Pyfile75.medg        g      ?i   i   i   i   R   i    s   CONCENTRATION of I129t   fieldt   I129N(   R   RG   RH   RJ   RK   R   RM   Rq   Rt   RN   Rm   Rn   Ro   Rp   Rr   R   R   Rs   R3   t   MEDFileUMesht   SetTooLongStrPolicyt   AssignStaticWritePropertiesToR6   t   getTooLongStrPolicyR    t   InterpKernelExceptionR   R	   R&   (	   R   R   t   coordst   conn2DR   t
+   meshCoordsR   t   dt   mm(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testFieldWithTooLongName  s>    
+c         C   s  d } t  j d  } t  j d d d d g  } t  j d d d d d g  } t  j d g  } | j | | |  t  j t  j  } | j d	  | j |  t  j d
+  } | j   | j	 |  | j
+   t  j t  j  } | j d  | j |  t  j d
+  } | j   | d 9} | j	 |  | j
+   | j   }	 |	 j   d 9(|	 j d d d  t  j | | j   t  t  j | |  t  j | |  t  j | |	  t  j | d d d	 d d  }
+ |  j | j |
+ d d   |  j |
+ j   j t  j d d d d d d d d d d d d d d d d  d! d" d# d$ g  d   t  j | d d d d d  } |  j | j | d d   |  j | j   j t  j d d d d d d  d# d% d& d' d( d) d* d+ d, d- d. d/ d0 d1 g  d   t  j | d d d	 d d  } |  j |	 j | d d   |  j | j   j t  j d d d d d! d2 d& d3 d4 d* d5 d6 d. d7 d8 d9 d: d; d< d= g  d   d> S(?   sj    This test focuses on MEDLoader.WriteFieldUsingAlreadyWrittenMesh with mesh different from UMesh.
+        s   Pyfile76.medR   i    i   i   i   i   i   R"   i   R#   i   g?i   ig-q=g        g      ?g       @g      @g      @g      @g      @g      @g       @g      "@g      $@g      &@g      (@g      *@g      ,@g      .@g      0@g      1@g      2@g      3@g      5@g      8@g      ;@g      >@g     @@g      B@g     C@g      E@g     F@g      H@g     I@g      K@g     L@g      4@g      <@g      @@g      D@g      F@g      J@g      L@g      N@g      P@g      Q@g      R@g      S@N(   R   R   Rq   RN   Rm   R   R3   Rp   R   Rs   R   R   R&   R%   R   R   R	   R(   R   R   R   (   R   R   R   t   arrXt   arrYt   arrZR"   R   R#   t   f11t   f1rt   f2rt   f3r(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testUsingAlreadyWrittenMesh2  sL      
+
+  
+ 
+
+  dddc      
+   C   s  d } t  j d  } | j   t  j   } | j | |  | j   } | j d  t  j t  j  } | j d  | j	 d d d  t  j d d d d	 d
+ d d d d g	  } | j
+ |  | j |  t  j | | t  |  j | j t  j |  d d   |  j | j t  j | d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   | j   } | j
+ | j   d  | j d  | j	 d d d	  t  j | |  |  j t t  j |  |  j | j t  j | d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d  d d   |  j | j t  j | d d d	  d d   |  j | j t  j t  j | d d d d d	  d d   | j   } | j	 d d d  | j
+ | j   d  t  j | |  |  j t t  j |  |  j t t  j | d  |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d  d d   |  j | j t  j | d d d	  d d   |  j t t  j | d d	 d	  |  j | j t  j t  j | d d d d d	  d d   |  j t t  j t  j | d d d d	 d	 	 t  j   } | | d <| j | d  t  j t t d    }	 |	 j d  t  j t  j  } | j d  | j	 d d d  t  j d d d d	 d
+ d d d g  } | j
+ |  | j | |	  | j   t  j   }
+ |
+ j | | d |	  |
+ j | d  |  j | j t  j |  d d   |  j | j t  j | d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   | j   } | j
+ | j   d  | j d  | j	 d d d	  t  j   }
+ |
+ j | | d |	  |
+ j | d  |  j t t  j |  |  j | j t  j | d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d  d d   |  j | j t  j | d d d	  d d   |  j | j t  j t  j | d d d d d	  d d   | j   } | j	 d d d  | j
+ | j   d  t  j   }
+ |
+ j | | d |	  |
+ j | d  |  j t t  j |  |  j t t  j | d  |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d d d  d d   |  j | j t  j t  j | d d d d d  d d   |  j | j t  j | d  d d   |  j | j t  j | d d d	  d d   |  j t t  j | d d	 d	  |  j | j t  j t  j | d d d d d	  d d   |  j t t  j t  j | d d d d	 d	 	 d  S(   Ns   Pyfile111.medi   R   R   g      @i   i   i   i   i   i   i   i	   i
+   g-q=i    i   t   field2g      @g      @t   PFL(   R   Rq   R   R   RN   R   R3   Rm   Rn   R%   Rs   Rp   R   R	   R   R   R   R   R&   R(   R    R!   R   t   writet   DataArrayIntt   listR   R   t   MEDFileField1TSt   setFieldProfile(   R   R   R   R   R   Rw   R-   R#   R   t   pflt   f1ts(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   testEasyFieldRead1  s     
+ * %(.:(.:(.:.:.:.:.:(.:+
+' 
+%(.:(.:(.:.:.:.:.:(.:+(   t   __name__t
+   __module__R   R   R   R   R   R$   R0   R@   Ri   R~   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R  R  (    (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyR      s6   							5	J	C	 					"	$	$		4			1	/			+	(	xt   __main__(   R   t   unittestt   mathR    R   R   R   t   TestCaseR   R  t   main(    (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest1.pyt   <module>   s      U
\ Pas de fin de ligne à la fin du fichier
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest2.pyc MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest2.pyc
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest2.pyc	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest2.pyc	2018-04-19 17:25:17.779798187 +0200
@@ -0,0 +1,84 @@
+
+;Zc           @   sx   d  d l  Td  d l Z d  d l m Z m Z m Z d  d l m Z d e j f d     YZ e	 d k rt e j
+   n  d S(   i(   t   *N(   t   pit   et   sqrt(   t   MEDLoaderDataForTestt   MEDLoaderTest2c           B   st   e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
+ d	   Z d
+   Z d   Z RS(   c         C   s[   t  j   } | j   t d | t  t d | j   d  } |  j | j | d   d  S(   Ns   Pyfile1.medi    g-q=(	   R   t   build1DMesh_1t   checkConsistencyLightt   WriteUMeshDept   Falset   ReadUMeshFromFilet   getNamet
+   assertTruet   isEqual(   t   selft   mesht   mesh_rw(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMesh1DRW   s    
+c         C   s[   t  j   } | j   t d | t  t d | j   d  } |  j | j | d   d  S(   Ns   Pyfile2.medi    g-q=(	   R   t   build2DCurveMesh_1R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMesh2DCurveRW$   s    
+c         C   s[   t  j   } | j   t d | t  t d | j   d  } |  j | j | d   d  S(   Ns   Pyfile3.medi    g-q=(	   R   t   build2DMesh_1R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMesh2DRW,   s    
+c         C   s[   t  j   } | j   t d | t  t d | j   d  } |  j | j | d   d  S(   Ns   Pyfile4.medi    g-q=(	   R   t   build3DSurfMesh_1R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMesh3DSurfRW4   s    
+c         C   s[   t  j   } | j   t d | t  t d | j   d  } |  j | j | d   d  S(   Ns   Pyfile5.medi    g-q=(	   R   t   build3DMesh_1R   R   R	   R
+   R   R   R   (   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMesh3DRW<   s    
+c         C   s   t  j   } t d | t  t d | j   j   d | j   d d  } |  j | j | d d   t  j	   } t d | t  t
+ d | j   j   d | j   d d  } |  j | j | d d   d  S(   Ns   Pyfile6.medi    i   g-q=s   Pyfile7.medi   i   (   R   t   buildVecFieldOnCells_1t   WriteFieldDepR	   t   ReadFieldCellt   getMeshR   R   R   t   buildVecFieldOnNodes_1t   ReadFieldNode(   R   t   f1t   f2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testFieldRW1D   s    --c   	      C   s  d } d } d } t  j   } t | | t  | j d d d  | j   j d d |  t | |  | j d d	 d
+  | j   j d d |  t | |  t | | j	   j
+   d | j
+   d d  } | j d d d  | j   j d d |  |  j | j | d d   t | | j	   j
+   d | j
+   d d  } t  j   } |  j | j | d d   t | | j	   j
+   d | j
+   d	 d
+  } | j d d	 d
+  | j   j d d |  |  j | j | d d   t  j   } d } t | | t  | j d d d  | j   j   } | j   j d d |  t | |  | j d d d  | j   j d d |  t | |  t | | j	   j
+   d | j
+   d d  } | j d d d  | j   j d d |  |  j | j | d d   t | | j	   j
+   d | j
+   d d  } t  j   } |  j | j | d d   t | | j	   j
+   d | j
+   d d  } | j d d d  | j   j d d |  |  j | j | d d   d  S(   Ns   Pyfile8.medgOL@g p!6+pg      $@i   i	   i    gHzG$@i   i   g-q=i   s   Pyfile9.medg     [@il   im   i   g     @j@i   i   i   (   R   R   R   R	   t   setTimet   getArrayt   setIJt!   WriteFieldUsingAlreadyWrittenMeshR   R   R   R   R   R   t
+   getPointerR   (	   R   t   fileNamet   VAL1t   VAL2R    R!   t   f3t	   fileName2t   tmp(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testFieldRW2P   sX    ------c   
+      C   sK  d } d } d } d } d } t  j   } | j   j |  | j |  | j d d d  | j   j   } | j   j d	 d	 |  t | | t	  | j d
+ d d  | j   j d	 d	 |  t
+ | |  | j   j |  | j d d d  | j   j d	 d	 d |  t
+ | |  | j d d d  | j   j d	 d	 d |  t
+ | |  | j d d d  | j   j d	 d	 d |  t
+ | |  t  j   } | j |  | j   j |  | j d d d  t
+ | |  | j d d d  | j   j   } | j   j d	 d |  t
+ | |  | j d d d  | j   j d	 d |  t
+ | |  t | | |  } |  j d t |   |  j d | d	 d	  |  j d | d	 d  |  j d | d d	  |  j d | d d  |  j d | d  d	  |  j d | d  d  |  j d | d d	  |  j d | d d  |  j d | d d	  |  j d | d d  t | | |  }	 |  j d t |	   |  j d |	 d	 d	  |  j d |	 d	 d  |  j d |	 d d	  |  j d |	 d d  |  j d |	 d  d	  |  j d |	 d  d  t | | d	 | d d  } |  j | | j   j d	 d	  d!  t | | d	 | d d  } |  j | | j   j d	 d	  d!  t | | d	 | d d  } |  j d | | j   j d	 d	  d!  t | | d	 | d d  } |  j d | | j   j d	 d	  d!  t | | d	 | d d  } |  j d | | j   j d	 d	  d!  t | | d	 | d d  } |  j d" | j   j d	 d  d!  t | | d	 | d d  } |  j | | j   j d	 d  d!  t | | d	 | d d  } |  j | | j   j d	 d  d!  d  S(#   Ns   Pyfile11.medgOL@g p!6+pt   AFieldt   AMesh1g      $@i   i	   i    gHzG$@i   i   g%@i   i   i   gRQ%@i&   i'   g
+ףp=%@i0   i1   i   g     [@il   im   g     @j@i   i   i   i   i   i   g     Q@(   R   R   R   t   setNameR#   R$   R'   R%   R   R	   R&   R   t   GetCellFieldIterationst   assertEqualt   lent   GetNodeFieldIterationsR   t   assertAlmostEqualt   getIJR   (
+   R   R(   R)   R*   t   name1t   name3R    R-   t   it1t   it3(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testFieldRW3   s            %%)))%%%c         C   s;  d } t  j   } d d d d d g } | j | t  } | j d  d d d d	 g } | j | t  } | j d
+  t j   } | j d  | j d  | j d  d d d d g } | j	 t
+ d | d d ! | j   | j | j    | | | | g }	 d }
+ t | |
+ |	 t  t | |
+  } | j |
+  d d d d d d d d d d d d d d d	 d d d g } | j | t  } | j |
+  |  j | j | d   t | |
+  } |  j d t |   | j d  | j d
+  | j d  | j d  d g } t | |
+ d |  } |  j | j | d   d
+ g } t | |
+ d |  } |  j | j | d   d g } t | |
+ d |  } |  j | j | d   d g } t | |
+ d |  } | j d  |  j | j | d   d d g } t | |
+ d |  } | j d  |  j | j | d   d  S(   Ns   Pyfile10.medi   i   i   i   i   t   mesh2i   i   t   mesh3t   mesh4i    i   t   3DTotoi   i   i   i   i	   i
+   i   i   i   g-q=t   3DMesh_1s	   Family_-5s	   Family_-3(   R   R   t   buildPartOfMySelft   TrueR1   t   MEDCouplingUMesht   Newt   setMeshDimensiont   allocateCellst   insertNextCellt   NORM_TETRA4t   finishInsertingCellst	   setCoordst	   getCoordst   WriteUMeshesPartitionDepR	   R
+   R   R   t   GetMeshGroupsNamesR3   R4   t   indext   ReadUMeshFromGroupst   ReadUMeshFromFamilies(   R   R(   t   mesh1t   part1R=   t   part2R>   R?   t   connt   meshest   mnanet   mesh5t   part3t   mesh6t   grpst   vect   mesh2_2t   mesh3_2t   mesh4_2t   mesh1_2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMultiMeshRW1   sb    
+<				c         C   s   d } t  j   } d d d d d d g } | j | t  | j   t | | t  t | | j   d  } |  j | j	 | d   d  S(	   Ns   Pyfile15.medi   i   i   i    i   i   g-q=(
+   R   R   t   renumberCellsR	   R   R   R
+   R   R   R   (   R   R(   R   t	   renumber1R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMesh3DSurfShuffleRW  s    
+c         C   sD  d } t  j   } |  j d | j    |  j d | j    d d d g } | j |  d d d d	 d
+ d d d d d d d d d d d d d d d g } | j | t  | j   t	 | | t  | j
+ t  } | j t t  } | j d d d  | j t  } t | |  | j d  | j d d d  | j t  } t | |  | j d  | j d d d  | j t  }	 t | |  d d d  g }
+ t t | | j   j   d | j   |
+  } |  j d t |   |  j | d j | d d   |  j | d j | d d   |  j | d j |	 d d   d  S(!   Ns   Pyfile17.medi   i-   i   i   i   i   i   i   i	   i   i   i   i   i    i   i   i   i   i   i
+   i   i   g        s   2*xg{Gz?s   2*x/3g{Gz?g-q=(   i   i   (   i   i   (   i   i   (   R   t   build3DMesh_2R3   t   getNumberOfCellst   getNumberOfNodest   convertToPolyTypesRb   R	   t   orientCorrectlyPolyhedronsR   t   getMeasureFieldt   buildNewTimeReprFromThist   ONE_TIMER#   t   cloneWithMeshRC   R&   t	   applyFunct   ReadFieldsOnSameMesht   ON_CELLSR   R   R4   R   R   (   R   R(   t   mt   polyst   renumt   f1TmpR    t   f_1t   f_2t   f_3t   itst   fs(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testMultiFieldShuffleRW1  s<    B
+-   c      
+   C   sh  d } t  j   } d d d g } d d d g } | j | | d  } | j | t  } d d d d	 d
+ g } | j | t  | j d  | | g } t | | t  t	 | | j
+   d  }	 |  j |	 j | d   |	 j | j
+    |  j |	 j | d   t	 | | j
+   d  }
+ |  j |
+ j | d   t j t t  } | j d  | j |  t j   } d d d d d d d d d d g
+ } | j | | j   d  | j d d  | j d d  | j |  | j | | j   d  } | j d d d  | j   t | |  t | | j   j
+   d | j
+   d d  } |  j | j | d d   d  S(   Ns   Pyfile18.medg        g333333ӿg      ?g-q=i   i   i    i   i   t   ExampleOfMultiDimWit   FieldOnFacesShuffleg     Q@g     `e@g      $@g     [@g      4@g      ^@g      >@g     @`@g      D@g     a@s	   plkj [mm]s   pqqqss [mm]gQ	@i   (   R   Re   t   findNodesOnPlanet   buildFacePartOfMySelfNodeRC   Rb   R	   R1   t   WriteUMeshesR
+   R   R   R   t   MEDCouplingFieldDoubleRE   Rp   Rl   t   setMesht   DataArrayDoublet	   setValuesRf   t   setInfoOnComponentt   setArrayR#   R   R&   R   R   (   R   R(   t   m3dt   ptR\   t   nodest   m2dt   renumberRV   t   m3d_bist   m2d_bisR    t   arrayt   arr1R-   R!   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   testWriteUMeshesRW1/  sB    $
+-(   t   __name__t
+   __module__R   R   R   R   R   R"   R.   R<   Ra   Rd   Rz   R   (    (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyR      s   							3	I	6		"	#t   __main__(   t	   MEDLoadert   unittestt   mathR   R   R   R   t   TestCaseR   R   t   main(    (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest2.pyt   <module>   s   
+ :
\ Pas de fin de ligne à la fin du fichier
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest3.py MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest3.py
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest3.py	2018-04-19 17:04:36.767223321 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest3.py	2018-04-19 17:25:17.795798503 +0200
@@ -32,6 +32,36 @@
 else:
     import pickle
 
+class StdOutRedirect(object):
+    def __init__(self,fileName):
+        import os,sys
+        sys.stderr.flush()
+        self.stdoutOld=os.dup(2)
+        self.fdOfSinkFile=os.open(fileName,os.O_CREAT | os.O_RDWR)
+        fd2=os.dup2(self.fdOfSinkFile,2)
+        self.origPyVal=sys.stderr
+        class FlushFile(object):
+            def __init__(self,f):
+                self.f=f
+            def write(self,st):
+                self.f.write(st)
+                self.f.flush()
+            def flush(self):
+                return self.f.flush()
+            def isatty(self):
+                return self.f.isatty()
+            def close(self):
+                os.fsync(self.f)
+                self.f.close();
+        sys.stderr=FlushFile(os.fdopen(self.fdOfSinkFile,"w"))
+    def __del__(self):
+        import os,sys
+        sys.stderr.close()
+        sys.stderr=self.origPyVal
+        os.fsync(2)
+        os.dup2(self.stdoutOld,2)
+        os.close(self.stdoutOld)
+
 class MEDLoaderTest3(unittest.TestCase):
     def testMEDMesh1(self):
         fileName="Pyfile18.med"
@@ -546,6 +576,10 @@
         ff1.setTime(3,4,2.3)
         itt,orr,ti=ff1.getTime()
         self.assertEqual(3,itt); self.assertEqual(4,orr); self.assertAlmostEqual(2.3,ti,14);
+        f1.setTime(5.5,7,8)
+        ff1.copyTimeInfoFrom(f1)
+        itt,orr,ti=ff1.getTime()
+        self.assertEqual(7,itt); self.assertEqual(8,orr); self.assertAlmostEqual(5.5,ti,14);
         da,infos=ff1.getUndergroundDataArrayExt()
         f2.getArray().setName(da.getName())#da has the same name than f2
         self.assertTrue(da.isEqual(f2.getArray(),1e-12))
@@ -878,7 +912,7 @@
         pass
     # Tricky test of the case of in a MED file containing a Field on GAUSS_NE is lying on a profile that is reality represents all the geom entities of a level.
     # By default when using setFieldProfile method such profile is not created because it is not useful ! So here a trick is used to force MEDLoader to do that
-    # for the necessity of the test ! The idea is too create artificially a mesh having one more fictious cell per type and to roll back right after !
+    # for the necessity of the test ! The idea is too create artificially a mesh having one more fictitious cell per type and to roll back right after !
     def testMEDField15(self):
         fname="Pyfile36.med"
         m0=MEDLoaderDataForTest.build2DMesh_1()
@@ -1381,7 +1415,7 @@
         mm.write(fname,2)   
 
     def testBuildInnerBoundaryAlongM1Group4(self):
-        """ Test case where cells touch the M1 group on some nodes only and not on full egdes (triangle mesh for ex)
+        """ Test case where cells touch the M1 group on some nodes only and not on full edges (triangle mesh for ex)
         """
         coo = DataArrayDouble([0.,0., 1.,0., 2.,0., 3.,0.,
                                0.,1., 1.,1., 2.,1., 3.,1.,
@@ -2027,8 +2061,16 @@
         mm.setFamiliesOnGroup("grp0",["MyOtherFam"])
         mm.setFamiliesOnGroup("grpA",["MyOther-1"])
         #
+        self.assertTrue(mm.getNodeFamiliesArr(["MyFam","MyOtherFam"]).isEqual(DataArrayInt([1,3,4,12]))) # find family id 2 and 3 into famCoo
+        #
         daTest=DataArrayInt([1,3,4,6,9,10,12]) ; daTest.setName("grp1")
         mm.addNodeGroup(daTest)
+        self.assertTrue(mm.getNodeGroupArr(daTest.getName()).isEqual(daTest)) # the node group has been pushed right before -> now read it
+        self.assertTrue(mm.getNodeGroupsArr(["grp1","grpA"]).isEqual(DataArrayInt([1,3,4,6,9,10,11,12])))#daTest+[11] because 11 is the rank of -1 (MyOther-1) in famCoo
+        #
+        expect1=DataArrayInt([1,4]) ; expect1.setName("MyFam")
+        self.assertTrue(mm.getNodeFamilyArr(expect1.getName()).isEqual(expect1))
+        #
         self.assertTrue(mm.getGroupArr(1,daTest.getName()).isEqual(daTest))
         self.assertTrue(mm.getFamilyFieldAtLevel(1).isEqual(DataArrayInt([6,2,6,8,2,6,5,6,6,7,7,4,8])))
         for lev,arr in [(0,da0),(-1,da1),(-2,da2)]:
@@ -2596,31 +2638,34 @@
         ff1.setFieldNoProfileSBT(f1)
         a=ff1.getFieldOnMeshAtLevel(0,ON_CELLS,mm1)
         self.assertEqual(a.getArray().getInfoOnComponents(),['power [MW/m^3]','density [g/cm^3]','temperature [K]'])
-        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        self.assertTrue(a.isEqual(f1,1e-12,0))
         ff1.write(fname,0)
+        a,b=ff1.getUndergroundDataArrayExt()
+        self.assertEqual(a.getHiddenCppPointer(),ff1.getUndergroundDataArray().getHiddenCppPointer())
+        self.assertEqual(b,[((3,0),(0,2)),((4,0),(2,4)),((6,0),(4,5)),((5,0),(5,6))])
         ff2=MEDFileAnyTypeField1TS.New(fname)
         self.assertEqual(ff2.getName(),"VectorFieldOnCells")
         self.assertEqual(ff2.getTime(),[0,1,2.0])
         self.assertTrue(isinstance(ff2,MEDFileIntField1TS))
         a=ff1.getFieldOnMeshAtLevel(ON_CELLS,0,mm1)
         self.assertEqual(a.getArray().getInfoOnComponents(),['power [MW/m^3]','density [g/cm^3]','temperature [K]'])
-        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        self.assertTrue(a.isEqual(f1,1e-12,0))
         ff2.setTime(1,2,3.)
         c=ff2.getUndergroundDataArray() ; c*=2
-        ff2.write(fname,0) # 2 time steps in 
+        ff2.write(fname,0) # 2 time steps in
         ffs1=MEDFileAnyTypeFieldMultiTS.New(fname,"VectorFieldOnCells")
         self.assertEqual(ffs1.getTimeSteps(),[(0, 1, 2.0), (1, 2, 3.0)])
         self.assertEqual(len(ffs1),2)
         self.assertTrue(isinstance(ffs1,MEDFileIntFieldMultiTS))
         a=ffs1[2.].getFieldOnMeshAtLevel(ON_CELLS,0,mm1)
-        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        self.assertTrue(a.isEqual(f1,1e-12,0))
         a=ffs1.getFieldOnMeshAtLevel(ON_CELLS,0,1,0,mm1)
-        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        self.assertTrue(a.isEqual(f1,1e-12,0))
         it=ffs1.__iter__() ; it.next() ; ff2bis=it.next()
         a=ff2bis.getFieldOnMeshAtLevel(0,ON_CELLS,mm1)
         self.assertTrue(a.getArray().isEqual(2*f1.getArray()))
         f1.setTime(3.,1,2) ; f1.getArray()[:]*=2
-        self.assertTrue(a.isEqual(f1,1e-12,1e-12)) ; f1.getArray()[:]/=2
+        self.assertTrue(a.isEqual(f1,1e-12,0)) ; f1.getArray()[:]/=2
         bc=DataArrayInt(6,3) ; bc[:]=0 ; bc.setInfoOnComponents(['power [MW/m^3]','density [g/cm^3]','temperature [K]'])
         for it in ffs1:
             a=it.getFieldOnMeshAtLevel(ON_CELLS,0,mm1)
@@ -3708,7 +3753,7 @@
         pass
 
     def testMEDFileUMeshSetName(self):
-        """ This test is a small but important one for MEDReader in sauv mode. When .sauv file is loaded the convertion is performed in memory and a preparation is done then.
+        """ This test is a small but important one for MEDReader in sauv mode. When .sauv file is loaded the conversion is performed in memory and a preparation is done then.
         This preparation makes access to internal MEDCouplingMesh pointers whose name must be updated.
         """
         fname="Pyfile79.med"
@@ -4523,8 +4568,7 @@
             grpExp=grp+delta ; grpExp.setName("%s_node"%grp.getName())
             self.assertTrue(mm.getGroupArr(1,"%s_node"%grp.getName()).isEqual(grpExp))
         pass
-
-    pass
+    
     def testMEDFileJoint1(self):
         fileName="Pyfile92.med"
         coo=DataArrayDouble([(0,0,0),(1,0,0),(2,0,0)])
@@ -4562,8 +4606,8 @@
         self.assertRaises( InterpKernelException, jointsR.getJointAtPos,1)
         self.assertRaises( InterpKernelException, jointsR.destroyJointAtPos,1)
         jointsR.destroyJointAtPos(0)
-        
-    pass
+        pass
+    
     def testMEDFileJoint2(self):
         fileNameWr="Pyfile93.med"
         coo=DataArrayDouble([(0,0,0),(1,0,0),(2,0,0)])
@@ -4656,35 +4700,7 @@
         """ EDF11242 : check status of MED file calls to detect problems immediately. Sorry this test generates awful messages !"""
         fname="Pyfile94.med"
         errfname="Pyfile94.err"
-        class StdOutRedirect(object):
-            def __init__(self,fileName):
-                import os,sys
-                sys.stderr.flush()
-                self.stdoutOld=os.dup(2)
-                self.fdOfSinkFile=os.open(fileName,os.O_CREAT | os.O_RDWR)
-                fd2=os.dup2(self.fdOfSinkFile,2)
-                self.origPyVal=sys.stderr
-                class FlushFile(object):
-                    def __init__(self,f):
-                        self.f=f
-                    def write(self,st):
-                        self.f.write(st)
-                        self.f.flush()
-                    def flush(self):
-                        return self.f.flush()
-                    def isatty(self):
-                        return self.f.isatty()
-                sys.stderr=FlushFile(os.fdopen(self.fdOfSinkFile,"w"))
-            def __del__(self):
-                import os,sys
-                sys.stderr=self.origPyVal
-                if sys.version_info.major >= 3:
-                    self.fdOfSinkFile.close()
-                    pass
-                #os.fsync(self.fdOfSinkFile)
-                os.fsync(2)
-                os.dup2(self.stdoutOld,2)
-                os.close(self.stdoutOld)
+        
         import os
         # first clean file if needed
         if os.path.exists(fname):
@@ -4855,7 +4871,7 @@
       self.assertEqual(mm.getFamiliesIdsOnGroup("RID"),(-4,3))
       mm.write(fileName,2)
       # now read such funny file !
-      mm2=MEDFileMesh.New(fileName) # <- normaly mdump of Pyfile98.med must contain only RID and FAMILLE_ZERO families.
+      mm2=MEDFileMesh.New(fileName) # <- normally mdump of Pyfile98.med must contain only RID and FAMILLE_ZERO families.
       self.assertTrue(mm.isEqual(mm2,1e-16))
       self.assertEqual(mm2.getFamiliesNames(),("FAMILLE_ZERO",'RIDF!/__\\!0000','RIDF!/__\\!0001'))
       self.assertEqual(mm2.getFamiliesNamesWithFilePointOfView(),("FAMILLE_ZERO","RIDF","RIDF"))
@@ -5230,12 +5246,12 @@
         mm=MEDFileMesh.New(fname)
         f1ts=MEDFileIntField1TS(fname,fieldName,6,7)
         ftst0=f1ts.field(mm)
-        self.assertTrue(f0.isEqual(ftst0,1e-12,1e-12))
+        self.assertTrue(f0.isEqual(ftst0,1e-12,0))
         f1ts=MEDFileIntField1TS(fname,fieldName,8,9)
         ftst1=f1ts.field(mm)
-        self.assertTrue(f1.isEqual(ftst1,1e-12,1e-12))
+        self.assertTrue(f1.isEqual(ftst1,1e-12,0))
         fmts=MEDFileIntFieldMultiTS(fname,fieldName)
-        self.assertTrue(f1.isEqual(fmts.field(8,9,mm),1e-12,1e-12))
+        self.assertTrue(f1.isEqual(fmts.field(8,9,mm),1e-12,0))
         ## Basic test on nodes on top level
         f2=MEDCouplingFieldInt(ON_NODES) ; arr2=DataArrayInt([200,201,202]) ; arr2.setInfoOnComponent(0,"tutu") ; f2.setArray(arr2) ; f2.setMesh(m) ; f2.setTime(22.,23,24)
         f2.setName(fieldName)
@@ -5244,9 +5260,9 @@
         #
         mm=MEDFileMesh.New(fname)
         f1ts=MEDFileIntField1TS(fname,fieldName,23,24)
-        self.assertTrue(f2.isEqual(f1ts.field(mm),1e-12,1e-12))
+        self.assertTrue(f2.isEqual(f1ts.field(mm),1e-12,0))
         fmts=MEDFileIntFieldMultiTS(fname,fieldName)
-        self.assertTrue(f2.isEqual(fmts.field(23,24,mm),1e-12,1e-12))
+        self.assertTrue(f2.isEqual(fmts.field(23,24,mm),1e-12,0))
         ## Node on elements
         f3=MEDCouplingFieldInt(ON_GAUSS_NE) ; f3.setMesh(m) ; arr3=DataArrayInt([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]) ; f3.setArray(arr3) ; f3.setTime(0.5,2,3)
         f3.setName(fieldName) ; f3.checkConsistencyLight()
@@ -5254,7 +5270,7 @@
         #
         mm=MEDFileMesh.New(fname)
         f1ts=MEDFileIntField1TS(fname,fieldName,2,3)
-        self.assertTrue(f3.isEqual(f1ts.field(mm),1e-12,1e-12))
+        self.assertTrue(f3.isEqual(f1ts.field(mm),1e-12,0))
         ## Gauss
         f4=MEDCouplingFieldInt(ON_GAUSS_PT) ; f4.setMesh(m) ; f4.setName(fieldName)
         f4.setGaussLocalizationOnType(NORM_TRI3,[0.,0.,1.,0.,1.,1.],[0.1,0.1, 0.2,0.2, 0.3,0.3, 0.4,0.4, 0.5,0.5],[0.2,0.3,0.1,0.05,0.35])
@@ -5265,7 +5281,7 @@
         #
         mm=MEDFileMesh.New(fname)
         f1ts=MEDFileIntField1TS(fname,fieldName,4,5)
-        self.assertTrue(f4.isEqual(f1ts.field(mm),1e-12,1e-12))
+        self.assertTrue(f4.isEqual(f1ts.field(mm),1e-12,0))
         pass
 
     def testMEDFileFieldEasyField3(self):
@@ -5353,7 +5369,7 @@
         f1ts=MEDFileIntField1TS() ; f1ts.setFieldNoProfileSBT(f1) ; f1ts.write(fname,0)
         #
         mm=MEDFileMesh.New(fname) ; f1ts=MEDFileIntField1TS(fname,fieldName,1,2)
-        self.assertTrue(f1.isEqual(f1ts.field(mm),1e-12,1e-12))
+        self.assertTrue(f1.isEqual(f1ts.field(mm),1e-12,0))
         # here f1 lying on level -1 not 0 check if "field" method detect it !
         f1=MEDCouplingFieldInt(ON_CELLS) ; f1.setName(fieldName) ; f1.setArray(DataArrayInt([(0,100),(1,101),(0,100),(1,101),(0,100),(1,101)]))
         f1.setMesh(mm[-1]) # -1 is very important
@@ -5363,7 +5379,7 @@
         f1ts=MEDFileIntField1TS() ; f1ts.setFieldNoProfileSBT(f1) ; f1ts.write(fname,0)
         #
         mm=MEDFileMesh.New(fname) ; f1ts=MEDFileIntField1TS(fname,fieldName,3,4)
-        self.assertTrue(f1.isEqual(f1ts.field(mm),1e-12,1e-12))
+        self.assertTrue(f1.isEqual(f1ts.field(mm),1e-12,0))
         # nodes on elements
         f3=MEDCouplingFieldInt(ON_GAUSS_NE)
         f3.setMesh(mm[-1]) # this line is important
@@ -5372,7 +5388,7 @@
         mm.write(fname,2) ; ff=MEDFileIntField1TS() ; ff.setFieldNoProfileSBT(f3) ; ff.write(fname,0)
         #
         mm=MEDFileMesh.New(fname) ; f1ts=MEDFileIntField1TS(fname,fieldName,2,3)
-        self.assertTrue(f3.isEqual(f1ts.field(mm),1e-12,1e-12))
+        self.assertTrue(f3.isEqual(f1ts.field(mm),1e-12,0))
         # gauss
         f4=MEDCouplingFieldInt(ON_GAUSS_PT)
         f4.setMesh(mm[-1]) # this line is important
@@ -5383,7 +5399,7 @@
         f4.checkConsistencyLight()
         mm.write(fname,2) ; ff=MEDFileIntField1TS() ; ff.setFieldNoProfileSBT(f4) ; ff.write(fname,0)
         mm=MEDFileMesh.New(fname) ; f1ts=MEDFileIntField1TS(fname,fieldName,4,5)
-        self.assertTrue(f4.isEqual(f1ts.field(mm),1e-12,1e-12))
+        self.assertTrue(f4.isEqual(f1ts.field(mm),1e-12,0))
         pass
 
     def testMEDFileFieldEasyField5(self):
@@ -5767,6 +5783,8 @@
         pass
     
     @unittest.skipUnless(LooseVersion(MEDFileVersionStr())>=LooseVersion('3.2.1'),"This test requires at least MEDFile version 3.2.1")
+    @unittest.skipUnless(LooseVersion(MEDFileVersionStr())<LooseVersion('4.0.0'),
+                         "This test is not compatible with MEDFile version 4.0.0 and above")
     def testWriteInto30(self):
         fname="Pyfile108.med"
         fname2="Pyfile109.med"
@@ -5900,12 +5918,12 @@
         fmts5=pickle.loads(st)
         self.assertEqual(len(fs4[0]),len(fmts5))
         self.assertTrue(isinstance(fmts5,MEDFileIntFieldMultiTS))
-        self.assertTrue(fmts5[0].field(ms4[0]).isEqual((fs4[0][0]).field(ms4[0]),1e-12,1e-12))
+        self.assertTrue(fmts5[0].field(ms4[0]).isEqual((fs4[0][0]).field(ms4[0]),1e-12,0))
         # MEDFileIntField1TS
         st=pickle.dumps(fs4[0][0],pickle.HIGHEST_PROTOCOL)
         f1ts6=pickle.loads(st)
         self.assertTrue(isinstance(f1ts6,MEDFileIntField1TS))
-        self.assertTrue(f1ts6.field(ms4[0]).isEqual((fs4[0][0]).field(ms4[0]),1e-12,1e-12))
+        self.assertTrue(f1ts6.field(ms4[0]).isEqual((fs4[0][0]).field(ms4[0]),1e-12,0))
         # MEDFileParameters
         self.testParameters1()# generates Pyfile56.med
         params=MEDFileParameters("Pyfile56.med")
@@ -5989,6 +6007,447 @@
         self.assertTrue(ff1.field(mm).isEqual(f3,1e-12,1e-12))
         pass
     
+    def testFloat32InMEDFileFieldStar1(self):
+        """Like testInt32InMEDFileFieldStar1 but with float32 :)"""
+        fname="Pyfile114.med"
+        f1=MEDLoaderDataForTest.buildVecFieldOnCells_1();
+        f1=f1.convertToFloatField()
+        m1=f1.getMesh()
+        mm1=MEDFileUMesh.New()
+        mm1.setCoords(m1.getCoords())
+        mm1.setMeshAtLevel(0,m1)
+        mm1.setName(m1.getName())
+        mm1.write(fname,2)
+        ff1=MEDFileFloatField1TS()
+        ff1.setFieldNoProfileSBT(f1)
+        a=ff1.getFieldOnMeshAtLevel(0,ON_CELLS,mm1)
+        self.assertEqual(a.getArray().getInfoOnComponents(),['power [MW/m^3]','density [g/cm^3]','temperature [K]'])
+        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        ff1.write(fname,0)
+        a,b=ff1.getUndergroundDataArrayExt()
+        self.assertEqual(a.getHiddenCppPointer(),ff1.getUndergroundDataArray().getHiddenCppPointer())
+        self.assertEqual(b,[((3,0),(0,2)),((4,0),(2,4)),((6,0),(4,5)),((5,0),(5,6))])
+        ff2=MEDFileAnyTypeField1TS.New(fname)
+        self.assertEqual(ff2.getName(),"VectorFieldOnCells")
+        self.assertEqual(ff2.getTime(),[0,1,2.0])
+        self.assertTrue(isinstance(ff2,MEDFileFloatField1TS))
+        a=ff1.getFieldOnMeshAtLevel(ON_CELLS,0,mm1)
+        self.assertEqual(a.getArray().getInfoOnComponents(),['power [MW/m^3]','density [g/cm^3]','temperature [K]'])
+        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        ff2.setTime(1,2,3.)
+        c=ff2.getUndergroundDataArray() ; c*=2
+        ff2.write(fname,0) # 2 time steps in 
+        ffs1=MEDFileAnyTypeFieldMultiTS.New(fname,"VectorFieldOnCells")
+        self.assertEqual(ffs1.getTimeSteps(),[(0, 1, 2.0), (1, 2, 3.0)])
+        self.assertEqual(len(ffs1),2)
+        self.assertTrue(isinstance(ffs1,MEDFileFloatFieldMultiTS))
+        a=ffs1[2.].getFieldOnMeshAtLevel(ON_CELLS,0,mm1)
+        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        a=ffs1.getFieldOnMeshAtLevel(ON_CELLS,0,1,0,mm1)
+        self.assertTrue(a.isEqual(f1,1e-12,1e-12))
+        it=ffs1.__iter__() ; it.next() ; ff2bis=it.next()
+        a=ff2bis.getFieldOnMeshAtLevel(0,ON_CELLS,mm1)
+        self.assertTrue(a.getArray().isEqual(2*f1.getArray(),1e-7))
+        f1.setTime(3.,1,2) ; f1.getArray()[:]*=2
+        self.assertTrue(a.isEqual(f1,1e-12,1e-12)) ; f1.getArray()[:]/=2
+        bc=DataArrayFloat(6,3) ; bc[:]=0 ; bc.setInfoOnComponents(['power [MW/m^3]','density [g/cm^3]','temperature [K]'])
+        for it in ffs1:
+            a=it.getFieldOnMeshAtLevel(ON_CELLS,0,mm1)
+            bc+=a.getArray()
+            pass
+        self.assertTrue(bc.isEqual(3*f1.getArray(),1e-7))
+        nf1=MEDCouplingFieldFloat(ON_NODES)
+        nf1.setTime(9.,10,-1)
+        nf1.setMesh(f1.getMesh())
+        narr=DataArrayFloat(12,2) ; narr.setInfoOnComponents(["aa [u1]","bbbvv [ppp]"]) ; narr[:,0]=list(range(12)) ; narr[:,1]=2*narr[:,0]
+        nf1.setName("VectorFieldOnNodes") ; nf1.setArray(narr)
+        nff1=MEDFileFloatField1TS.New()
+        nff1.setFieldNoProfileSBT(nf1)
+        self.assertEqual(nff1.getInfo(),('aa [u1]','bbbvv [ppp]'))
+        self.assertEqual(nff1.getTime(),[10,-1,9.0])
+        nff1.write(fname,0)
+        #
+        nf2=MEDCouplingFieldFloat(ON_NODES)
+        nf2.setTime(19.,20,-11)
+        nf2.setMesh(f1.getMesh())
+        narr2=DataArrayFloat(8,2) ; narr.setInfoOnComponents(["aapfl [u1]","bbbvvpfl [ppp]"]) ; narr2[:,0]=list(range(8)) ; narr2[:,0]+=10  ; narr2[:,1]=3*narr2[:,0]
+        nf2.setName("VectorFieldOnNodesPfl") ; narr2.setName(nf2.getName()) ; nf2.setArray(narr2)
+        nff2=MEDFileFloatField1TS.New()
+        npfl=DataArrayInt([1,2,4,5,6,7,10,11]) ; npfl.setName("npfl")
+        nff2.setFieldProfile(nf2,mm1,0,npfl)
+        nff2.getFieldWithProfile(ON_NODES,0,mm1)
+        a,b=nff2.getFieldWithProfile(ON_NODES,0,mm1) ; b.setName(npfl.getName())
+        self.assertTrue(b.isEqual(npfl))
+        self.assertTrue(a.isEqual(narr2,1e-7))
+        nff2.write(fname,0)
+        nff2bis=MEDFileFloatField1TS(fname,"VectorFieldOnNodesPfl")
+        a,b=nff2bis.getFieldWithProfile(ON_NODES,0,mm1) ; b.setName(npfl.getName())
+        self.assertTrue(b.isEqual(npfl))
+        self.assertTrue(a.isEqual(narr2,1e-7))
+        #
+        nf3=MEDCouplingFieldDouble(ON_NODES)
+        nf3.setName("VectorFieldOnNodesDouble")
+        nf3.setTime(29.,30,-21)
+        nf3.setMesh(f1.getMesh())
+        nf3.setArray(f1.getMesh().getCoords())
+        nff3=MEDFileField1TS.New()
+        nff3.setFieldNoProfileSBT(nf3)
+        nff3.write(fname,0)
+        fs=MEDFileFields(fname)
+        self.assertEqual(len(fs),4)
+        ffs=[it for it in fs]
+        self.assertTrue(isinstance(ffs[0],MEDFileFloatFieldMultiTS))
+        self.assertTrue(isinstance(ffs[1],MEDFileFloatFieldMultiTS))
+        self.assertTrue(isinstance(ffs[2],MEDFileFieldMultiTS))
+        self.assertTrue(isinstance(ffs[3],MEDFileFloatFieldMultiTS))
+        #
+        self.assertTrue(fs["VectorFieldOnCells"][0].getUndergroundDataArray().isEqualWithoutConsideringStr(f1.getArray(),1e-7))
+        self.assertTrue(fs["VectorFieldOnCells"][1,2].getUndergroundDataArray().isEqualWithoutConsideringStr(2*f1.getArray(),1e-7))
+        self.assertTrue(fs["VectorFieldOnNodesPfl"][0].getUndergroundDataArray().isEqualWithoutConsideringStr(narr2,1e-7))
+        self.assertTrue(fs["VectorFieldOnNodes"][9.].getUndergroundDataArray().isEqualWithoutConsideringStr(narr,1e-7))
+        self.assertTrue(fs["VectorFieldOnNodesDouble"][29.].getUndergroundDataArray().isEqualWithoutConsideringStr(f1.getMesh().getCoords(),1e-12))
+        #
+        nf3_read=MEDFileFieldMultiTS(fname,"VectorFieldOnNodesDouble")
+        self.assertTrue(nf3_read[29.].getUndergroundDataArray().isEqualWithoutConsideringStr(f1.getMesh().getCoords(),1e-12))
+        self.assertRaises(InterpKernelException,MEDFileFloatFieldMultiTS.New,fname,"VectorFieldOnNodesDouble")# exception because trying to read a double field with int instance
+        self.assertRaises(InterpKernelException,MEDFileFieldMultiTS.New,fname,"VectorFieldOnNodes")# exception because trying to read a int field with double instance
+        MEDFileField1TS.New(fname,"VectorFieldOnNodesDouble",30,-21)
+        self.assertRaises(InterpKernelException,MEDFileFloatField1TS.New,fname,"VectorFieldOnNodesDouble",30,-21)# exception because trying to read a double field with int instance
+        MEDFileFloatField1TS.New(fname,"VectorFieldOnNodes",10,-1)
+        self.assertRaises(InterpKernelException,MEDFileField1TS.New,fname,"VectorFieldOnNodes",10,-1)# exception because trying to read a double field with int instance
+        #
+        self.assertEqual(fs.getMeshesNames(),('3DSurfMesh_1','3DSurfMesh_1','3DSurfMesh_1','3DSurfMesh_1'))
+        self.assertTrue(fs.changeMeshNames([('3DSurfMesh_1','3DSurfMesh')]))
+        self.assertEqual(fs.getMeshesNames(),('3DSurfMesh','3DSurfMesh','3DSurfMesh','3DSurfMesh'))
+        self.assertTrue(not fs.changeMeshNames([('3DSurfMesh_1','3DSurfMesh')]))
+        pass
+
+    def testPenta18_1(self):
+        """EDF8478 : Test of read/write of penta18"""
+        fname="Pyfile115.med"
+        arr=DataArrayDouble([
+            (0.,1.,1.),(0.,0.,1.),(1.,0.,1.),
+            (0.,1.,0.),(0.,0.,0.),(1.,0.,0.),
+            (0.,0.5,1.),(0.5,0.,1.),(0.5,0.5,1.),
+            (0.,0.5,0.),(0.5,0.,0.),(0.5,0.5,0.),
+            (0.,1.,0.5),(0.,0.,0.5),(1.,0.,0.5),
+            (0.,0.5,0.5),(0.5,0.,0.5),(0.5,0.5,0.5)])
+        m=MEDCouplingUMesh("mesh",3)
+        m.setCoords(arr)
+        m.allocateCells(1)
+        m.insertNextCell(NORM_PENTA18,list(range(18)))
+        m.checkConsistencyLight()
+        #
+        f=MEDCouplingFieldDouble(ON_NODES)
+        f.setMesh(m)
+        f.setName("FieldOnPenta18")
+        f.setArray(DataArrayDouble(list(range(18))))
+        f.checkConsistencyLight()
+        #
+        m2,d,di,rd,rdi=m.buildDescendingConnectivity()
+        #
+        f2=MEDCouplingFieldDouble(ON_NODES)
+        f2.setMesh(m)
+        f2.setName("FieldOnPenta18Sub")
+        f2.setArray(DataArrayDouble(list(range(18))))
+        f2.checkConsistencyLight()
+        WriteField(fname,f2,True)
+        f3=ReadField(fname)
+        self.assertTrue(f2.isEqual(f3,1e-12,1e-12))
+        self.assertEqual(f3.getMesh().getNumberOfCells(),1)
+        self.assertEqual(f3.getMesh().getTypeOfCell(0),NORM_PENTA18)
+        pass
+
+    @unittest.skipUnless('linux'==platform.system().lower(),"stderr redirection not ported on Windows ?")
+    @unittest.skipUnless(LooseVersion(MEDFileVersionStr())<LooseVersion('4.0.0'),
+                         "This test is not compatible with MEDFile version 4.0.0 and above")
+    def testMedFileCapabilityToCryOnNewFeatureWritingIntoOldFiles(self):
+        fname="Pyfile116.med"
+        errfname="Pyfile116.err"
+        c=DataArrayDouble([0,1,2,3])
+        m=MEDCouplingCMesh()
+        m.setCoords(c,c)
+        m=m.buildUnstructured()
+        m.setName("mesh")
+        mm=MEDFileUMesh()
+        mm[0]=m
+        f=MEDCouplingFieldInt(ON_CELLS)
+        f.setMesh(m) ; arr2=DataArrayInt(m.getNumberOfCells()) ; arr2.iota()
+        f.setArray(arr2)
+        f.setName("field")
+        f1ts=MEDFileIntField1TS()
+        f1ts.setFieldNoProfileSBT(f)
+        mm.write30(fname,2)
+        f1ts.write30(fname,0)
+        #
+        f=MEDCouplingFieldFloat(ON_CELLS)
+        f.setMesh(m) ; arr2=DataArrayFloat(m.getNumberOfCells()) ; arr2.iota()
+        f.setArray(arr2)
+        f.setName("field2")
+        f1ts=MEDFileFloatField1TS()
+        f1ts.setFieldNoProfileSBT(f)
+        #
+        import os,gc
+        tmp=StdOutRedirect(errfname)
+        self.assertRaises(InterpKernelException,f1ts.write30,fname,0)
+        del tmp
+        gc.collect(0)
+        if os.path.exists(errfname):
+            os.remove(errfname)
+        pass
+
+    def testFieldsLinearToQuadratic(self):
+        fname="Pyfile117.med"
+        arr=DataArrayDouble([0,1])
+        m=MEDCouplingCMesh();
+        m.setCoords(arr,arr,arr)
+        m=m.buildUnstructured()
+        m2=m.deepCopy()
+        m2.translate([2,0,0])
+        m3=MEDCouplingUMesh.MergeUMeshes([m,m2])
+        m3.setName("mesh")
+        mm=MEDFileUMesh()
+        mm[0]=m3
+        mmq=mm.linearToQuadratic(0)
+        mms=MEDFileMeshes() ; mms.pushMesh(mm)
+        mmsq=MEDFileMeshes() ; mmsq.pushMesh(mmq)
+        #
+        f=MEDCouplingFieldDouble(ON_NODES)
+        f.setName("field")
+        f.setMesh(m3)
+        f.setTime(3.,1,2)
+        arr=DataArrayDouble(m3.getNumberOfNodes())
+        arr.iota()
+        f.setArray(arr)
+        f1ts=MEDFileField1TS()
+        f1ts.setFieldNoProfileSBT(f)
+        fmts=MEDFileFieldMultiTS()
+        fmts.pushBackTimeStep(f1ts)
+        f1ts_2=f1ts.deepCopy()
+        f1ts_2.setTime(3,4,5.)
+        f1ts_2.getUndergroundDataArray()[:]*=2.
+        fmts.pushBackTimeStep(f1ts_2)
+        fs=MEDFileFields()
+        fs.pushField(fmts)
+        fs2=fs.linearToQuadratic(mms,mmsq)
+        self.myTester1(fs2,mmsq[0])
+        # A small Write/Read and test again
+        mms.write(fname,2) ; fs.write(fname,0)
+        mms=MEDFileMeshes(fname) ; fs=MEDFileFields(fname)
+        mmq=mms[0].linearToQuadratic(0) ; mmqs=MEDFileMeshes() ; mmqs.pushMesh(mmq)
+        fs2=fs.linearToQuadratic(mms,mmqs)
+        self.myTester1(fs2,mmqs[0])
+        pass
+    
+    def myTester1(self,fs2,mmq):
+        dataExp=DataArrayDouble([0.,0.,0.,1.,0.,0.,0.,1.,0.,1.,1.,0.,0.,0.,1.,1.,0.,1.,0.,1.,1.,1.,1.,1.,2.,0.,0.,3.,0.,0.,2.,1.,0.,3.,1.,0.,2.,0.,1.,3.,0.,1.,2.,1.,1.,3.,1.,1.,0.5, 0.,0.,0.,0.5, 0.,0.5, 1.,0.,1.,0.5, 0.,0.5, 0.,1.,0.,0.5, 1.,0.5, 1.,1.,1.,0.5, 1.,1.,0.,0.5, 0.,0.,0.5, 0.,1.,0.5, 1.,1.,0.5, 2.5, 0.,0.,2.,0.5, 0.,2.5, 1.,0.,3.,0.5, 0.,2.5, 0.,1.,2.,0.5, 1.,2.5, 1.,1.,3.,0.5, 1.,3.,0.,0.5, 2.,0.,0.5, 2.,1.,0.5, 3.,1.,0.5],40,3)
+        dataExp1=DataArrayInt([1,0,2,3,5,4,6,7,16,17,18,19,20,21,22,23,24,25,26,27,9,8,10,11,13,12,14,15,28,29,30,31,32,33,34,35,36,37,38,39])
+        dataExp2=DataArrayDouble([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0.5,1,2.5,2,4.5,5,6.5,6,3,2,4,5,8.5,9,10.5,10,12.5,13,14.5,14,11,10,12,13])
+        fToTest=fs2[0][0].field(mmq)
+        self.assertEqual(fToTest.getTime(),[3.,1,2])
+        mTest=MEDCoupling1SGTUMesh(fToTest.getMesh())
+        self.assertTrue(mTest.getNodalConnectivity().isEqual(dataExp1))
+        self.assertTrue(mTest.getCoords().isEqual(dataExp,1e-12))
+        self.assertTrue(fToTest.getArray().isEqual(dataExp2,1e-12))
+        # testing 2nd timestep
+        fToTest=fs2[0][1].field(mmq)
+        self.assertEqual(fToTest.getTime(),[5.,3,4])
+        mTest=MEDCoupling1SGTUMesh(fToTest.getMesh())
+        self.assertTrue(mTest.getNodalConnectivity().isEqual(dataExp1))
+        self.assertTrue(mTest.getCoords().isEqual(dataExp,1e-12))
+        self.assertTrue(fToTest.getArray().isEqual(2*dataExp2,1e-12))
+        pass
+
+    def testFieldsLinearToQuadratic2(self):
+        """Same than testFieldsLinearToQuadratic but with profile on NODES"""
+        fname="Pyfile118.med"
+        arr=DataArrayDouble([0,1])
+        m=MEDCouplingCMesh();
+        m.setCoords(arr,arr,arr)
+        m=m.buildUnstructured()
+        m2=m.deepCopy()
+        m2.translate([2,0,0])
+        m3=MEDCouplingUMesh.MergeUMeshes([m,m2])
+        m3.setName("mesh")
+        # add a point for fun
+        m3.setCoords(DataArrayDouble.Aggregate(m3.getCoords(),DataArrayDouble([1.5,1.5,1.5],1,3)))
+        #
+        mm=MEDFileUMesh()
+        mm[0]=m3
+        mmq=mm.linearToQuadratic(0)
+        mms=MEDFileMeshes() ; mms.pushMesh(mm)
+        mmsq=MEDFileMeshes() ; mmsq.pushMesh(mmq)
+        #
+        f=MEDCouplingFieldDouble(ON_NODES)
+        f.setName("field")
+        f.setMesh(m3)
+        f.setTime(3.,1,2)
+        arr=DataArrayDouble(8) ; arr.iota()
+        arr.iota()
+        f.setArray(arr)
+        f1ts=MEDFileField1TS()
+        pfl=DataArrayInt([8,9,10,11,12,13,14,15]) ; pfl.setName("pfl")
+        f1ts.setFieldProfile(f,mm,0,pfl) # f lying on 8 nodes of cell #1
+        f1ts_2=f1ts.deepCopy()
+        f1ts_2.setTime(3,4,5.)
+        f1ts_2.getUndergroundDataArray()[:]*=4.
+        fmts=MEDFileFieldMultiTS()
+        fmts.pushBackTimeStep(f1ts)
+        fmts.pushBackTimeStep(f1ts_2)
+        fs=MEDFileFields()
+        fs.pushField(fmts)
+        fs2=fs.linearToQuadratic(mms,mmsq)
+        mms.write(fname,2) ; fs.write(fname,0)
+        #
+        self.myTester2(fs2,mmq)
+        # Read/write
+        mms=MEDFileMeshes(fname) ; fs=MEDFileFields(fname)
+        mmq=mms[0].linearToQuadratic(0) ; mmqs=MEDFileMeshes() ; mmqs.pushMesh(mmq)
+        fs2=fs.linearToQuadratic(mms,mmqs)
+        self.myTester2(fs2,mmq)
+        ## More vicious add single node 16
+        mm=MEDFileUMesh()
+        mm[0]=m3
+        mmq=mm.linearToQuadratic(0)
+        mms=MEDFileMeshes() ; mms.pushMesh(mm)
+        mmsq=MEDFileMeshes() ; mmsq.pushMesh(mmq)
+        #
+        f=MEDCouplingFieldDouble(ON_NODES)
+        f.setName("field")
+        f.setMesh(m3)
+        f.setTime(3.,1,2)
+        arr=DataArrayDouble(9) ; arr.iota()
+        arr.iota()
+        f.setArray(arr)
+        f1ts=MEDFileField1TS()
+        pfl=DataArrayInt([8,9,10,11,12,13,14,15,16]) ; pfl.setName("pfl")
+        f1ts.setFieldProfile(f,mm,0,pfl) # f lying on 9 nodes of cell #1 + orphan node
+        fmts=MEDFileFieldMultiTS()
+        fmts.pushBackTimeStep(f1ts)
+        fs=MEDFileFields()
+        fs.pushField(fmts)
+        fs2=fs.linearToQuadratic(mms,mmsq)
+        #
+        pflExpected=DataArrayInt([8,9,10,11,12,13,14,15,16,29,30,31,32,33,34,35,36,37,38,39,40]) ; pflExpected.setName("pfl_NODE")
+        f1tsToTest=fs2[0][0]
+        exp1=DataArrayDouble([0,1,2,3,4,5,6,7,8,0.5,1,2.5,2,4.5,5,6.5,6,3,2,4,5])
+        assert(f1tsToTest.getProfile("pfl_NODE").isEqual(pflExpected))
+        assert(f1tsToTest.getUndergroundDataArray().isEqual(exp1,1e-12))
+        assert(f1tsToTest.getFieldSplitedByType()==[(40,[(1,(0,21),'pfl_NODE','')])])
+        pass
+
+    def myTester2(self,fs2,mmq):
+        pflExpected=DataArrayInt([8,9,10,11,12,13,14,15,29,30,31,32,33,34,35,36,37,38,39,40]) ; pflExpected.setName("pfl_NODE")
+        f1tsToTest=fs2[0][0]
+        exp1=DataArrayDouble([0,1,2,3,4,5,6,7,0.5,1,2.5,2,4.5,5,6.5,6,3,2,4,5])
+        self.assertTrue(f1tsToTest.getProfile("pfl_NODE").isEqual(pflExpected))
+        self.assertTrue(f1tsToTest.getUndergroundDataArray().isEqual(exp1,1e-12))
+        self.assertEqual(f1tsToTest.getFieldSplitedByType(),[(NORM_ERROR,[(1,(0,20),'pfl_NODE','')])])
+        fToTest=fs2[0][0].field(mmq)
+        self.assertEqual(fToTest.getTime(),[3.,1,2])
+        mTest=MEDCoupling1SGTUMesh(fToTest.getMesh())
+        self.assertTrue(mTest.getNodalConnectivity().isEqual(DataArrayInt([1,0,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19])))
+        self.assertTrue(mTest.getCoords().isEqual(DataArrayDouble([(2,0,0),(3,0,0),(2,1,0),(3,1,0),(2,0,1),(3,0,1),(2,1,1),(3,1,1),(2.5,0,0),(2,0.5,0),(2.5,1,0),(3,0.5,0),(2.5,0,1),(2,0.5,1),(2.5,1,1),(3,0.5,1),(3,0,0.5),(2,0,0.5),(2,1,0.5),(3,1,0.5)],20,3),1e-12))
+        self.assertTrue(fToTest.getArray().isEqual(exp1,1e-12))
+        # 2nd Time step
+        f1tsToTest=fs2[0][1]
+        self.assertTrue(f1tsToTest.getProfile("pfl_NODE").isEqual(pflExpected))
+        self.assertTrue(f1tsToTest.getUndergroundDataArray().isEqual(4*exp1,1e-12))
+        self.assertEqual(f1tsToTest.getFieldSplitedByType(),[(NORM_ERROR,[(1,(0,20),'pfl_NODE','')])])
+        fToTest=fs2[0][1].field(mmq)
+        self.assertEqual(fToTest.getTime(),[5.,3,4])
+        mTest=MEDCoupling1SGTUMesh(fToTest.getMesh())
+        self.assertTrue(mTest.getNodalConnectivity().isEqual(DataArrayInt([1,0,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19])))
+        self.assertTrue(mTest.getCoords().isEqual(DataArrayDouble([(2,0,0),(3,0,0),(2,1,0),(3,1,0),(2,0,1),(3,0,1),(2,1,1),(3,1,1),(2.5,0,0),(2,0.5,0),(2.5,1,0),(3,0.5,0),(2.5,0,1),(2,0.5,1),(2.5,1,1),(3,0.5,1),(3,0,0.5),(2,0,0.5),(2,1,0.5),(3,1,0.5)],20,3),1e-12))
+        self.assertTrue(fToTest.getArray().isEqual(4*exp1,1e-12))
+        
+        pass
+
+    def testSetFieldProfileFlatly1(self):
+        """ Sometimes for downstream code fan of profiles, profile are requested unconditionally. setFieldProfile try to reduce at most profile usage. So setFieldProfileFlatly has been added to always create
+        a profile."""
+        arr=DataArrayDouble(10) ; arr.iota()
+        m=MEDCouplingCMesh() ; m.setCoords(arr,arr)
+        m=m.buildUnstructured()
+        m2=m.deepCopy()
+        m2.simplexize(0)
+        m=MEDCouplingUMesh.MergeUMeshes(m2,m)
+        m.setName("mesh")
+        mm=MEDFileUMesh()
+        mm[0]=m
+        f=MEDCouplingFieldDouble(ON_CELLS)
+        f.setMesh(m)
+        arr=DataArrayDouble(m.getNumberOfCells())
+        arr.iota()
+        f.setArray(arr)
+        f.setName("field")
+        pfl=DataArrayInt(m.getNumberOfCells()) ; pfl.iota() ; pfl.setName("pfl")
+        #
+        refSp=[(3,[(0,(0,162),'','')]),(4,[(0,(162,243),'','')])]
+        refSp1=[(3,[(0,(0,162),'pfl_NORM_TRI3','')]),(4,[(0,(162,243),'pfl_NORM_QUAD4','')])]
+        #
+        f1ts=MEDFileField1TS()
+        f1ts.setFieldProfile(f,mm,0,pfl)
+        self.assertEqual(f1ts.getPfls(),()) # here setFieldProfile has detected useless pfl -> no pfl
+        self.assertEqual(f1ts.getFieldSplitedByType(),refSp)
+        self.assertTrue(f1ts.field(mm).isEqual(f,1e-12,1e-12)) # the essential
+        #
+        f1ts=MEDFileField1TS()
+        f1ts.setFieldProfileFlatly(f,mm,0,pfl) # no optimization attempt. Create pfl unconditionally
+        self.assertEqual(f1ts.getPfls(),("%s_NORM_TRI3"%pfl.getName(),"%s_NORM_QUAD4"%pfl.getName()))
+        self.assertEqual(f1ts.getFieldSplitedByType(),refSp1)
+        self.assertTrue(f1ts.field(mm).isEqual(f,1e-12,1e-12)) # the essential
+        self.assertTrue(f1ts.getProfile("pfl_NORM_TRI3").isIota(162))
+        self.assertTrue(f1ts.getProfile("pfl_NORM_QUAD4").isIota(81))
+        pass
+
+    def testRmGroupAtSpeLevelAndMultiLevGrpCreation(self):
+        """ Here multi level groups are created"""
+        arr=DataArrayDouble(11) ; arr.iota()
+        m=MEDCouplingCMesh() ; m.setCoords(arr,arr)
+        m=m.buildUnstructured()
+        m.setName("mesh")
+        m1=m.buildDescendingConnectivity()[0]
+        mm=MEDFileUMesh()
+        mm[0]=m ; mm[-1]=m1
+        ################
+        grpName="grp0"
+        grp0_0=DataArrayInt([0,1,2,6]) ; grp0_0.setName(grpName)
+        grp0_1=DataArrayInt([0,1,2,7]) ; grp0_1.setName(grpName)
+        grp1=DataArrayInt([1,2,3,5,6]) ; grp1.setName("grp1")
+        grp2=DataArrayInt([2,3,5,8]) ; grp2.setName("grp2")
+        ################ ajouter un groupe sur plusieurs niveau
+        mm.addGroup(0,grp1)
+        mm.addGroup(-1,grp2)
+        mm.addGroup(0,grp0_0)
+        mm.addGroup(-1,grp0_1)
+        self.assertEqual(mm.getGrpNonEmptyLevels(grpName),(0,-1))
+        self.assertTrue(mm.getGroupArr(0,grpName).isEqual(grp0_0))
+        self.assertTrue(mm.getGroupArr(-1,grpName).isEqual(grp0_1))
+        self.assertTrue(mm.getGroupArr(0,"grp1").isEqual(grp1))
+        self.assertTrue(mm.getGroupArr(-1,"grp2").isEqual(grp2))
+        self.assertRaises(InterpKernelException,mm.addGroup,-1,grp0_1) # raise
+        self.assertTrue(mm.getGroupArr(0,grpName).isEqual(grp0_0))
+        self.assertTrue(mm.getGroupArr(-1,grpName).isEqual(grp0_1))
+        self.assertTrue(mm.getGroupArr(0,"grp1").isEqual(grp1))
+        self.assertTrue(mm.getGroupArr(-1,"grp2").isEqual(grp2))
+        mm.removeGroupAtLevel(0,grpName)
+        self.assertEqual(mm.getGrpNonEmptyLevels(grpName),(-1,))
+        self.assertTrue(mm.getGroupArr(-1,grpName).isEqual(grp0_1))
+        self.assertTrue(mm.getGroupArr(0,"grp1").isEqual(grp1))
+        self.assertTrue(mm.getGroupArr(-1,"grp2").isEqual(grp2))
+        mm.removeGroupAtLevel(-1,grpName)
+        self.assertEqual(mm.getGrpNonEmptyLevels(grpName),())
+        self.assertRaises(InterpKernelException,mm.removeGroupAtLevel,-2,grpName)
+        mm.addGroup(-1,grp0_1)
+        mm.addGroup(0,grp0_0)
+        self.assertEqual(mm.getGrpNonEmptyLevels(grpName),(0,-1))
+        self.assertTrue(mm.getGroupArr(0,grpName).isEqual(grp0_0))
+        self.assertTrue(mm.getGroupArr(-1,grpName).isEqual(grp0_1))
+        self.assertTrue(mm.getGroupArr(0,"grp1").isEqual(grp1))
+        self.assertTrue(mm.getGroupArr(-1,"grp2").isEqual(grp2))
+        pass
+    
     pass
 
 if __name__ == "__main__":
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest3.pyc MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest3.pyc
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest3.pyc	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest3.pyc	2018-04-19 17:25:17.777798147 +0200
@@ -0,0 +1,2042 @@
+
+;Zc           @   s   d  d l  Td  d l Z d  d l Z d  d l m Z m Z m Z d  d l m Z d  d l m	 Z	 d  d l
+ Z
+ e
+ j j d k  r d  d l Z n d  d l Z d e f d     YZ d	 e j f d
+     YZ e d k r e j   n  d S(   i(   t   *N(   t   pit   et   sqrt(   t   MEDLoaderDataForTest(   t   LooseVersioni   t   StdOutRedirectc           B   s   e  Z d    Z d   Z RS(   c            s   d d  l    d d  l } | j j     j d  |  _   j |   j   j B |  _	   j
+ |  j	 d  } | j |  _ d t f   f d     Y} |   j |  j	 d   | _ d  S(   Nii   t	   FlushFilec              s;   e  Z d    Z d   Z d   Z d   Z   f d   Z RS(   c         S   s   | |  _  d  S(   N(   t   f(   t   selfR   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   __init__,   s    c         S   s!   |  j  j |  |  j  j   d  S(   N(   R   t   writet   flush(   R	   t   st(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR   .   s    c         S   s   |  j  j   S(   N(   R   R   (   R	   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR   1   s    c         S   s   |  j  j   S(   N(   R   t   isatty(   R	   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR   3   s    c            s!     j  |  j  |  j j   d  S(   N(   t   fsyncR   t   close(   R	   (   t   os(    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR   5   s    (   t   __name__t
+   __module__R
+   R   R   R   R   (    (   R   (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR   +   s
+   				t   w(   R   t   syst   stderrR   t   dupt	   stdoutOldt   opent   O_CREATt   O_RDWRt   fdOfSinkFilet   dup2t	   origPyValt   objectt   fdopen(   R	   t   fileNameR   t   fd2R   (    (   R   ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR
+   $   s    c         C   se   d d  l  } d d  l } | j j   |  j | _ | j d  | j |  j d  | j |  j  d  S(   Nii   (   R   R   R   R   R   R   R   R   (   R	   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   __del__9   s    (   R   R   R
+   R#   (    (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR   #   s   	t   MEDLoaderTest3c           B   sc  e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
+ d	   Z d
+   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z  d   Z! d    Z" d!   Z# d"   Z$ d#   Z% d$   Z& d%   Z' d&   Z( d'   Z) d(   Z* d)   Z+ d*   Z, d+   Z- d,   Z. d-   Z/ d.   Z0 d/   Z1 d0   Z2 d1   Z3 d2   Z4 d3   Z5 d4   Z6 d5   Z7 d6   Z8 d7   Z9 d8   Z: d9   Z; d:   Z< d;   Z= d<   Z> d=   Z? d>   Z@ d?   ZA d@   ZB dA   ZC dB   ZD dC   ZE dD   ZF dE   ZG dF   ZH dG   ZI dH   ZJ dI   ZK dJ   ZL dK   ZM dL   ZN dM   ZO eP jQ eR   dN  dO    ZS dP   ZT dQ   ZU dR   ZV dS   ZW dT   ZX dU   ZY dV   ZZ dW   Z[ dX   ZZ eP jQ dY e\ j]   j^   k dZ  d[    Z_ d\   Z` d]   Za eP jQ eR   dN  d^    Zb d_   Zc d`   Zd da   Ze db   Zf dc   Zg dd   Zh de   Zi df   Zj dg   Zk dh   Zl di   Zm dj   Zn dk   Zo dl   Zp dm   Zq dn   Zr eP jQ es et    es do  k dp  eP jQ es et    es dq  k  dr  ds     Zu eP jQ eR   dN  dt    Zv eP jQ eR   dN  du    Zw dv   Zx dw   Zy dx   Zz dy   Z{ eP jQ dY e\ j]   j^   k dZ  eP jQ es et    es dq  k  dr  dz     Z| d{   Z} d|   Z~ d}   Z d~   Z d   Z d   Z RS(   c         C   s   d } d } t  j | |  } |  j t t  j | d  |  j d | j    | j t  } t | | d  } |  j	 | j
+ | d   | j t  } t | | d  } |  j	 | j
+ | d   d  S(   Ns   Pyfile18.medt   ExampleOfMultiDimWt    i    ig-q=(   i    i(   t   MEDFileMesht   Newt   assertRaisest   InterpKernelExceptiont   assertEqualt   getNonEmptyLevelst   getLevel0Mesht   Truet   ReadUMeshFromFilet
+   assertTruet   isEqualt   getLevelM1Mesh(   R	   R!   t   mnamet   medmesht   m1_0t   m1_1t   m2_0t   m2_1(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh1B   s    c   
+   	   C   s0  d } d } d } t  j | |  } |  j d | j    | j t  } t | | d  } |  j | j | d   | j	 d d t  } t
+ | | d d g  } |  j | j | d   | j	 d d t  } t
+ | | d d g  } |  j | j | d   | j d d d g  } t
+ | | d d d g  } | j | j    |  j | j | d   | j d d t  } t | | d d g  } |  j | j | d   | j d d d	 g t  } t | | d d d	 g  } | j | j    |  j | j | d   |  j | j | d   | j | d
+  |  j d d
+ d d d g | j d d t  j    |  j d d
+ d g | j d d t  j    |  j d d
+ d d d g | j d d	 d g t  j    |  j d d d
+ d d d d d g | j d d d d g t  j    | j d  }	 |  j t | j |	 t  |  j d
+ d d d d g | j d d  j    |  j d
+ d d g | j d d  j    |  j d
+ d d d d g | j d d	 d g  j    |  j d d
+ d d d d d d g | j d d d d g t  j    |  j t | j |	 t  d  S(   Ns   Pyfile10.medt   3DTotos   MEDFileMesh1.medi    g-q=t   mesh2t   mesh3s	   Family_-3s	   Family_-5i   i   i   i   i   i   i   i   t   mesh4i   i   (   i    (   t   MEDFileUMeshR(   R+   R,   R-   R.   R/   R0   R1   t   getGroupt   ReadUMeshFromGroupst	   getGroupst   setNamet   getNamet	   getFamilyt   ReadUMeshFromFamiliest   getFamiliesR   t   getGroupArrt	   getValuest   getFamilyArrt   getFamiliesArrt   getGroupsArrt   getFamilyNameGivenIdR)   R*   t   getNodeFamilyArrt   False(
+   R	   R!   R3   t   outFileNameR4   R5   R6   t   g1_0t   g1_1t   famn(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh2P   sN    4.:F1+7Fc         C   s}  d } t  j   } d d d d d d d d d d d d d d d d d d g } d d d d d d d	 d d
+ d	 d d d d d d d
+ d g } | j | d d	  t j   } | j d	  | j d
+  | j t d | d d ! | j t d | d d ! | j t d | d d ! | j t	 d | d d ! | j t	 d | d d ! | j
+   | j |  | j   t j   } | j d  | j d  | j t d	 d d g  | j t d	 d d g  | j t d d	 d d
+ g  | j
+   | j |  | j   t j   } | j d  | j d  | j t d d g  | j t d d g  | j t d d	 g  | j t d d g  | j
+   | j |  | j   t j   } |  j | j    | j d  | j d  | j |  | j d |  | j d |  | j d |  t j   }	 |	 j d d g d	 d  |	 j d  t j   }
+ |
+ j d d	 d g d d  |
+ j d  | j d |	 |
+ g t  t j   } | j d d d	 g d d  | j d  t j   } | j d d	 g d	 d  | j d  | j d | | g t  t j   } | j t t d   d d  | j d  t j   } | j t t d   d d  | j d  | j d | | g t  | j d d  | j d d t  } |  j |	 j |   | j d d t  } |  j |
+ j |   | j d d t  } |  j | j |   | j d d t  } |  j | j |   | j d d t  } |  j | j |   | j d d t  } |  j | j |   |  j | j d   | j d d  } |  j | j   t t d
+   k  | j    } |  j | j | d  d  ~ | j! | d	  t" j |  } |  j# t t t	 g | j$ d   |  j# t t g | j$ d   |  j# t g | j$ d   | j% t	  } |  j t& | t'   |  j | j(   j t d d d d d d d
+ d g    |  j | j)   j t d d d g    | j* d  } |  j# d t+ |   |  j t& | d t,   |  j t& | d t,   |  j t& | d	 t'   |  j | j    |  j t& | j-   t.   |  j t+ | j-    d k  | j/ d  } | j | j0    | j | j1    |  j | j | d   |  j# d d d g d d g d g g d	 d	 d f t2 | d   d  S(    Ns   MEDFileMesh3.medg333333ӿg?gffffff?i    i   i   i   i   i   i   i   i   i	   i
+   i   i   t   MyFirstMEDCouplingMEDmesht   IHopeToConvinceLastMEDMEMUsersiit   G1t   G2t   GrpOnAllCellg-q=(   i   i   (   i   i   (   i   i   (   i   i   (   i   i   (   i    i   (3   t   DataArrayDoubleR(   t	   setValuest   MEDCouplingUMesht   setMeshDimensiont   allocateCellst   insertNextCellt	   NORM_TRI3t
+   NORM_QUAD4t   NORM_POLYGONt   finishInsertingCellst	   setCoordst   checkConsistencyLightt	   NORM_SEG2t	   NORM_SEG3t   NORM_POINT1R>   R0   t   getUnivNameWrStatusRB   t   setDescriptiont   setMeshAtLevelt   DataArrayIntt   setGroupsAtLevelRN   t   listt   ranget   createGroupOnAllRG   R1   t   existsGroupRH   t   deepCopyR   R'   R+   t   getGeoTypesAtLevelt%   getDirectUndergroundSingleGeoTypeMesht
+   isinstancet   MEDCoupling1DGTUMesht   getNodalConnectivityt   getNodalConnectivityIndext'   getDirectUndergroundSingleGeoTypeMeshest   lent   MEDCoupling1SGTUMesht   getUnivNamet   strt   getMeshAtLevelRC   t   getDescriptiont   GetUMeshGlobalInfo(   R	   RO   t   ct   coordst
+   targetConnt   mt   m1t   m2t   mmt   g1_2t   g2_2RQ   t   g2_1t   g1_Nt   g2_Nt   tt   mmCpyt   mm0t   lmmt   mbis(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh3{   s    <<
+
+
+
+
+
+% ":+ @c         C   s  d } t  j   } d d d d d d d d d d d d d d d d d d g } d d d d d d d	 d d
+ d	 d d d d d d d
+ d g } | j | d d	  | j d d  | j d d  t j   } | j d	  | j d
+  | j t d | d d ! | j t	 d | d d ! | j t	 d | d d ! | j t d | d d ! | j t d | d d ! | j
+   | j |  | j   t j   } | j d  | j d  | j t d	 d d g  | j t d d	 d d
+ g  | j t d	 d d g  | j
+   | j |  | j   t j   } | j d  | j d  | j t d d g  | j t d d g  | j t d d	 g  | j t d d g  | j
+   | j |  | j   t j   } | j d  | j d  | j |  t j   }	 |	 j d d d d d d d d d g	 d d  | j d |	  | j d | t  | j d | t  | j d | t  | j d  | j d | t  t j   }
+ |
+ j d	 d g d	 d  |
+ j d  t j   } | j d	 d d g d d  | j d  | j d |
+ | g t  t j   } | j d d	 d g d d  | j d  t j   } | j d d	 g d	 d  | j d  | j d | | g t  t j   } | j d d d d d d d d g d d  | j d  t j   } | j d d d d d d d d d g	 d d  | j d  | j d | | g t  | j d d t  } |  j |
+ j |   | j d d t  } |  j | j |   | j d d t  } |  j | j |   | j d d t  } |  j | j |   |  j | j d    | j | d	  t j |  } | j | d!  } |  j | d  t | j  d   } | j!   |  j" d" d# d$ d% d& g |  | j# d g d g  xK | j$ d  D]: } |  j" | j | d  j%   | j | d  j%    qWt | j  d   } | j!   |  j" d" d# d$ d% d& g |  |  j" d' d' d( g | j& d  j%    | j& d  j' d d d)  |  j" d' d) d( g | j& d  j%    |  j | j( d*   | j) d d+  |  j | j( d*   |  j" t t* d   | j d d+  j%    d  S(,   Ns   MEDFileMesh4.medg333333ӿg?gffffff?i    i   i   i   i   i   i   i   i   i	   s   abcdef [km]s	   ghij [MW]i
+   i   i   t   My2ndMEDCouplingMEDmesht   ThisIsImpossibleToDoWithMEDMEMi   i   i   i   i   i   iiRV   RW   RX   g-q=s	   Family_-3s	   Family_-4s	   Family_-7t	   Family_10t	   Family_11iiis	   Family_-8t   GrpOnAllFace(+   RY   R(   RZ   t   setInfoOnComponentR[   R\   R]   R^   R`   R_   Rb   Rc   Rd   Re   Rf   Rg   R>   RB   Ri   Rk   t   setRenumFieldArrRj   R.   t   removeMeshAtLevelRl   RG   R0   R1   Rp   R   R'   Rm   t   getFamiliesOnGroupt   sortR+   t   keepFamIdsOnlyOnLevst   getGrpNonEmptyLevelsExtRH   t   getFamilyFieldAtLevelt   setIJt   existsFamilyRo   Rn   (   R	   RO   R   R   R   R   R   R   R   t	   renumNodeR   R   RQ   R   R   R   R   t   mm2t   rest   lt   lev(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh4   s    <<
+
+
+
+
+
+.+. 
+4 
+((.c         C   so   d } d } t  j | |  } | j t  } | j d  } ~ |  j d | j    |  j d | j    d  S(   Ns   Pyfile18.medR%   i    i   (   R>   R(   R-   R.   R   R+   t   getNumberOfCellst   getNumberOfTuples(   R	   R!   R3   R4   R5   t   da1(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh5Y  s    c   	      C   s  d } t  j   } | j d d d  t j   } t j   } | j d d d g d d  | j d	 d
+  | j d	 |  t j   } | j d d g d d  | j d	 d  | j d |  t j   } | j d d g d d  | j d	 d  | j d |  | j |  |  j	 | d	 j
+ | d   |  j	 t | d	 t   | j d  | j d  | j d  | j d  t j   } | j d	 d	 d d	 d d d d d	 d d d g d d  | j d |  | j d d  | j d d  } d d d g } |  j | | j    |  j	 | j    | j | d  t j |  } |  j t g | j d	   |  j	 t | t    |  j	 t | j   t   |  j	 t | j    d	 k  |  j	 | j
+ | d  d	  |  j | | j d d  j    | j   } | j   } | j | d | d	 | d  | j | j     | j | j!    | j | j"    |  j	 | j
+ | d   d  S(   Ns   MEDFileMesh5.medigffffff@g        g      ?g       @i   i   i    s   XX [mm]g333333?i   s   YY [km]g?s   ZZ [um]g-q=t   myFirstCartMesht   mmmmppppppppt   msi   i   t   family1i	   (#   t   MEDFileCMeshR(   t   setTimet   MEDCouplingCMeshRY   RZ   R   t   setCoordsAtt   setMeshR0   R1   Rt   RB   Ri   t   setTimeValuet   setTimeUnitRk   t   setFamilyFieldArrt   setFamilyIdRI   R+   RH   Rh   R   R'   t
+   NORM_HEXA8Rr   R{   R|   Ry   t   getMesht   getTimeRC   t   getTimeUnitR~   (	   R	   RO   R   R   t   dat	   expected1R   R   t   tt(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh6d  s^    7"c         C   s  d } t  j   \ } } } } } } } }	 }
+ } } } } } t j   } | j | j    | j d |  | j d |  | j d |  | j d |  | j d |  | j d |  | j d |  | j d |	  | j d |
+  | j d |  t	 |  } x, t
+ |  D] } | j | | | |  qWt	 |  } x, t
+ |  D] } | j | | | |  qOW| j | j    | j | j    |  j d | j d   |  j d | j d   |  j d  | j d   |  j d! | j d d g   |  j d" | j d	   |  j d# | j d
+   |  j d$ | j d
+ d	 g   |  j d% | j d   |  j d& | j d   | j | d  |  j t t |  d  S('   Ns   Pyfile24.medi    iii   t   A2A4t   A1t   AP2t    A4A3____________________________t    MESH____DALT3___DALLE___________t   A1A2t   A3A1t   A3C5t   A4A3t   B1C1t   B2B4t   B3B1t   B4C3t   C1C4t   C2B2t   C3C2t   C4B3t   C5A4t   DALLEt   DALQ1t   DALQ2t   DALT3t   MESHi   (   i(    (   i(   ii(   i(   i    (   i    i(   s   A1A2s   A2A4s   A3A1s   A3C5s   A4A3s   B1C1s   B2B4s   B3B1s   B4C3s   C1C4s   C2B2s   C3C2s   C4B3s   C5A4(   s   DALLEs   DALQ1s   DALQ2s   DALT3s   MESH(   R   t   buildMultiLevelMesh_1R>   R(   Rc   t	   getCoordsRj   R   R   Ry   Rn   t	   addFamilyt   setFamiliesIdsOnGroupRB   RC   Ri   R~   R+   t   getGrpNonEmptyLevelst   getGrpsNonEmptyLevelst   getFamNonEmptyLevelst   getFamsNonEmptyLevelst   getGroupsOnSpecifiedLevR   R)   R*   t   MEDFileField1TS(   R	   R!   R   R   t   m0t   f2t   f1t   f0t   pt   n2t   n1t   n0t   fnst   fidst   grpnst   famIdsPerGrpR   t   nbOfFamst   it   nbOfGrps(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh7  sH    6c         C   s   | d d g =d  S(   Ng{Gz?i   i   (   i   i   (    (   R	   t   ff(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   funcToTestDelItem  s    c         C   s  t  j d  } | j d d  t d  } d d g d d g d d g g } |  j d t |   xN t |  D]@ \ } } |  j | | | j   d   |  j t |  t	  qo W|  j d	 | j
+    |  j d d g | d j   d
+   |  j d d g | d j   d
+   |  j d d g | d j   d
+   | j d d  | j   } g  | D] } | d
+  ^ qX} |  j d d d g |  |  j |  | j   } g  | D] } | d
+  ^ q} |  j d g |  d  S(   Ns   Pyfile17.meds   Pyfile17_bis.medi   i   i   i   i   i   t   MeasureOfMesh_Extrudedig{Gz?i    (   i   i   (   i   i   (   i   i   (   i   i   (   i   i   (   R'   R(   R   t   MEDFileFieldMultiTSR+   Ry   t	   enumerateR   t   typeR   RC   t   getTimeStepsR   (   R	   R   R   t
+   tsExpectedt   post   f1tst   tst   elt(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField1  s,    !$$$  c         C   sa   t  j d  } | j d d  t j d  } | j d d  |  j d
+ d g t d d	   d  S(   Ns   Pyfile19.meds   Pyfile19_bis.medi   i    t   tytyR   t   uiopt   MWt   VFieldOnNodes(   R   s   mm(   R   R   (   R'   R(   R   R   R+   t   GetComponentsNamesOfField(   R	   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField2  s    c   	      C   s#  t  j d  } | j d d  t j d d  } | j d d  t j d d d d  } | j t d  } t d d d d d d  } |  j | j	 | d	 d	   t j d d  } | j t d  } |  j | j	 | d	 d	   t j d  } | j t d  } |  j | j	 | d	 d	   d  S(
+   Ns   Pyfile13.meds   Pyfile13_bis.medi   t   MyFirstFieldOnGaussPointi    i   i   t   2DMesh_2g-q=(
+   R'   R(   R   R   R   t   getFieldAtLevelt   ON_GAUSS_PTt   ReadFieldGaussR0   R1   (	   R	   R   R   R   R   t   ff3t   f3t   ff4t   f4(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField3  s    c         C   s   t  j d  } | j d d  t j d d  } | j d d  t j d d d d  } | j t d  } t d d d d d d  } |  j | j	 | d	 d	   d  S(
+   Ns   Pyfile14.meds   Pyfile14_bis.medi   t   MyFieldOnGaussNEi    i   i   R  g-q=(
+   R'   R(   R   R   R   R  t   ON_GAUSS_NEt   ReadFieldGaussNER0   R1   (   R	   R   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField4  s    c         C   s  t  j d d d d  } | j t d  } t d d d d d d  } |  j | j   j   j | j   j   d   | j   j	 | j   d  | j
+ | j   d d  |  j | j | d d   | j t d d  } t d d d d d d  } |  j | j | d d   | j t d d	  } |  j | j | d d   | j t d d  } |  j | j | d d   | j
+ | j   d
+ d  |  j | j | d d   d  S(   Ns   Pyfile17.medR   i   i   i    t   Extrudedg-q=i   i   i   (   R   R(   R  t   ON_CELLSt   ReadFieldCellR0   R   R   R1   t   tryToShareSameCoordst   changeUnderlyingMesh(   R	   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField5  s"    1c         C   s  t  j d d  } | j   } |  j t | j t | d d | d d d  | j t | d d | d d d  } t d d d d | d d | d d  } |  j	 | j
+ | d d   t  j d d  } | j   } | j t | d d | d d d  } t d d	 d d | d d | d d  } |  j	 | j
+ | d d   |  j t | j t | d d | d d d  |  j t | j t | d d | d d d d  d  S(
+   Ns   Pyfile7.medt   VectorFieldOnNodesi    i   t   3DSurfMesh_1g-q=s   Pyfile19.medR  t   2DMesh_1(   R   R(   t   getIterationsR)   R*   R  R  t   ON_NODESt   ReadFieldNodeR0   R1   (   R	   R   t   itsR   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField6  s    /(+(+/2c         C   s   t  j d d  } | j   } | j t | d d | d d d  } t d d d d | d d | d d  } |  j | j | d d   d  S(   Ns   Pyfile12.medt   VectorFieldOnCellsi    i   t   3DMesh_1g-q=(   R   R(   R  R  R  R  R0   R1   (   R	   R   R  R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField7'  s    (+c         C   s  d } t  j   } | j   } t j   } | j | j    | j d |  | j | j	    | j
+ | d  t j   } | j |  | j
+ | d  t | | j   j	   d | j	   | j   d | j   d  } | j   \ } } }	 |  j d |  |  j d |  |  j d |	 d  |  j | j | d d   | j d d	 d
+  | j   \ } } }	 |  j d |  |  j d	 |  |  j d
+ |	 d  | j d d d  | j |  | j   \ } } }	 |  j d |  |  j d |  |  j d |	 d  | j   \ }
+ } | j   j |
+ j	    |  j |
+ j | j   d   |  j d d f d d  f d! d" f d# d$ f g |  d } t  j   } | j   } t j   } | j | j    | j d |  | j | j	    | j
+ | d  t j   } | j |  d } | j   j d d |  }
+ | j
+ | d  t | | j   j	   d | j	   | j   d | j   d  } |  j | j | d d   | j   j d d |  |  j | j | d d   d } t  j   } | j   } t j   } | j | j    | j d |  | j | j	    | j
+ | d  t j   } | j |  | j
+ | d  t | | j   j	   d | j	   | j   d | j   d  } |  j | j | d d   | j   \ }
+ } | j   j |
+ j	    |  j |
+ j | j   d   |  j d% d& f d' d( f d) d* f g |  d } t  j   } | j   } | j t     | j   } | j t     | j   } t j   } | j | j    | j d |  | j | j	    | j
+ | d  t j   } |  j! t" | j |  | j#   j$ | j#   j%    |  j! t" | j |  | j |  | j
+ | d  t j | | j	   | j   d | j   d  } | j& t' d  } |  j | j | d d   | j(   } | j) d  } |  j d | j	    |  j d+ | j*    |  j d | j+    |  j d | j,    |  j d | j-    | j   \ }
+ } | j   j |
+ j	    |  j |
+ j | j   d   |  j d |
+ j.    |  j d, d- f d. d/ f d0 d1 f d2 d3 f d4 d5 f d6 d7 f g |  d  S(8   Ns   Pyfile25.medi    i   i   g       @i   g-q=i   i   gffffff@g      @i   i   i   i   s   Pyfile26.medg     @s   Pyfile27.medi   s   Pyfile28.medt(   Loc_MyFirstFieldOnGaussPoint_NORM_TRI6_5ii5   i   i   i$   i*   i,   (   i   i    (   i    i   (   i   i    (   i   i   (   i   i    (   i   i   (   i   i    (   i   i   (   i   i    (   i    i   (   i   i    (   i   i   (   i   i    (   i   i   (   ii   iii   iii    i    ii    i    (   i   i    (   i    i   (   i   i   (   i   i   (   i   i   (   i   i$   (   i   i    (   i$   i*   (   i   i   (   i*   i,   (   i   i    (   i,   i5   (/   R   t   buildVecFieldOnCells_1R   R>   R(   Rc   R   Rj   RB   RC   R   R   t   setFieldNoProfileSBTR  R   R+   t   assertAlmostEqualR0   R1   R   t   copyTimeInfoFromt   getUndergroundDataArrayExtt   getArrayt   buildVecFieldOnNodes_1t   getUndergroundDataArrayR   R  t   buildVecFieldOnGaussNE_1R  t   buildVecFieldOnGauss_2_SimplerRq   t   setDiscretizationt#   MEDCouplingFieldDiscretizationGaussR)   R*   t   getDiscretizationt   setArrayOfDiscIdst   getArrayOfDiscIdsR  R  t   getFieldSplitedByType2t   getLocalizationt   getRefCoordst   getNumberOfPointsInCellst   getNumberOfGaussPointst   getDimensionR   (   R	   t   fnameR   R   t   mm1t   ff1R   t   ittt   orrt   tiR   t   infost   nvt   f1InvalidCpyt   f1InvalidCpy2t   ff2t   sbtt   loc1(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField80  s    A      4AA+2Fc         C   s  d } t  j   } t j   } t j   } | j | j    | j d |  | j | j	    t
+ j   } | j |  t j   } t j   } | j | j    | j d |  | j | j	    t
+ j   } | j |  t j   }	 |	 j d |  |	 j d |  | j |	  xO t d d g |	  D]8 \ }
+ } |  j |
+ | j	    |  j t |  t  q/W|  j d | j   j    t j   } t j   } t j   } | j t  } | j d  | j t t  } | j   j d d  | j |  | j t  } | j d  | j t t  } | j   j d d	  | j |  | j   } | j d
+  | j t t  } | j d d  | j   j d d  | j   j d d  | j |  t  j   } | j! |  | j! |  | j! |  x< t d d d
+ g |  D]" \ }
+ } |  j |
+ | j	    qW| j" |  d } | j# | d  t  j |  } |  j d | j$    |  j d | j%    |  j& t' | j   j( d  t   |  j& t' | j   d t   |  j& t' | j   d t   | j   j( d  j) d  } |  j& | j* | d   |  j d | j+   j,    |  j d g | j+   j- d  j.    |  j d g | j+   d j.    |  j d g | j+   j/ d  j.    |  j d g | j+   d j.    d  S(   Ns   Pyfile29.medi    i   t   1DMesh_1t   2DCurveMesh_1R   s
+   power [kW]t   f21s   sta [mm]t   f22i   s   3*x*IVec+2*x*JVecs   distance [km]s   displacement [cm]s   Pyfile29_2.medi   g-q=ig        (   s   1DMesh_1s   2DCurveMesh_1(   s   f1s   f21s   f22(   iig        (   iig        (   iig        (   iig        (0   t   MEDFileDataR(   R   t   build1DMesh_1R>   Rc   R   Rj   RB   RC   t   MEDFileMeshMultiTSt   setOneTimeStept   build2DCurveMesh_1t   MEDFileMeshest   setMeshAtPost	   setMeshest   zipR+   R   t	   getMeshest   getMeshesNamesR   t   getMeasureFieldR.   t   buildNewTimeReprFromThist   ONE_TIMERN   R)  R   t   appendFieldNoProfileSBTRq   t	   applyFunct   MEDFileFieldst	   pushFieldt	   setFieldsR   t   getNumberOfMeshest   getNumberOfFieldsR0   Rt   t   getMeshAtPosR}   R1   t	   getFieldst   getFieldsNamest   getFieldAtPosR   t   getFieldWithName(   R	   R9  t   dR   R:  t   mmm1R   R   t   mmm2R   t   namet   mmmR;  t   ff21t   ff22R   RI  RJ  t   fst   fmtst   fname2t   d2t   m1bis(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileData1  s             "         %%  (#(#c         C   s  d } t  j   } t j   } | j | j    | j d |  | j | d  t j   } t	 j t
+ t  } | j d  t j   } | j d# d  | j d  | j d  | j d d  | j d d	  | j |  t j   } | j d d  | j d  | j d
+  | j | | d |  | j d g d f g  | j   } | j | d  | j t
+ d |  \ } }	 | j d  |  j |	 j |   |  j | j | d   t j | | j   d d  }
+ t j | | j   d d  } |
+ j |  |
+ j   } |  j d | d d  |  j d | d d d d  |  j d | d d d d  |  j d d d d d d d d d d d d g | d d d d j    |  j d | d d  |  j d | d d d d  |  j d | d d d d  |  j d d d d  d! d" g | d d d d j    |  j d g |
+ j     |
+ j t
+ d |  \ } }	 | j d  |  j |	 j |   |  j | j | d   d  S($   Ns   Pyfile30.medi    i   t   F1i	   i   g      @s
+   sigX [MPa]s
+   sigY [GPa]t   sup1t   sup1_NORM_QUAD4t   ForV650R&   g+=ii   i   i   i
+   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   (!   R   t   build2DMesh_3R>   R(   Rc   R   Rj   R   R   t   MEDCouplingFieldDoubleR  RX  RB   RY   t   alloct   iotat	   rearrangeR   t   setArrayRk   t   setFieldProfilet   changePflsNamesRq   t   getFieldWithProfileR0   t   isEqualWithoutConsideringStrR1   RC   t   deepCpyGlobsR3  R+   RH   t   getTypesOfFieldAvailable(   R	   R9  R   R:  R;  R   Re  R   t   valst   pflRC  R	  RD  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField9  s\                  J  8 c         C   s|  d } t  j   } | j d d d d d d g t  t j   } | j | j    | j d |  | j	 | j
+    | j | d  t j   } t j t t  } | j	 d  t j   } | j d d  | j d	  | j d  | j d d
+  | j d d  | j |  t j   } | j d d d d g d d  | j	 d  | j | | d |  | j d d d  | j d  } | j |  | j |  | j | | d |  | j   } | j | d  | j t d d d |  \ }	 }
+ |	 j	 d  |  j |
+ j |   |  j |	 j  | d   | j t d d d |  \ }	 }
+ |	 j	 d  |  j |
+ j |   |  j |	 j  | d   t j | | j
+    } |  j! d d g | j"    | j t d d d |  \ }	 }
+ |	 j	 d  |  j |
+ j |   |  j |	 j  | d   | j t d d d |  \ }	 }
+ |	 j	 d  |  j |
+ j |   |  j |	 j  | d   d  S(   Ns   Pyfile31.medi    i   i   i   i   i   t   F2g      @s
+   sigX [MPa]s
+   sigY [GPa]t   sup2g333333?s   2*xR&   g+=ig        i   (   iig        (   i   i   g333333?(#   R   t   build2DMesh_1t   renumberCellsRN   R>   R(   Rc   R   Rj   RB   RC   R   R   Rw  R  RX  RY   Rx  Ry  Rz  R   R{  Rk   RZ   t   appendFieldProfileR   RZ  t   copyStringInfoFromRq   R~  R0   R  R1   R+   R   (   R	   R9  R   R:  R;  R   Re  R   R   R  R  RC  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField10  s`    "              ! ! ! ! c         C   sQ  d } t  j   } | j d d d d d d g t  t j   } | j | j    | j d |  | j	 | d  t
+ j   } t j t t  } | j d  t j   } | j d d  | j d
+  | j d  | j d d  | j d d  | j |  t j   } | j d d d d d d g d	 d  | j d  | j | | d |  |  j | j   d g  f  | j	 | d  | j t d |  \ } }	 | j d  |  j |	 j |   |  j | j | d   t
+ j | | j   d d  }
+ |
+ j t d |  \ } }	 | j d  |  j |	 j |   |  j | j | d   d  S(   Ns   Pyfile32.medi    i   i   i   i   i   t   F1Nodei   g      @s
+   sigX [MPa]s
+   sigY [GPa]i   i   t   sup1NodeiR&   g+=i   (   R   R  R  RN   R>   R(   Rc   R   Rj   R   R   Rw  R  RX  RB   RY   Rx  Ry  Rz  R   R{  Rk   RZ   R|  R+   R,   R~  R0   R  R1   RC   (   R	   R9  R   R:  R;  R   Re  R   R  R  RC  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField11  sB    "         %   c         C   sG  d } t  j   } | j d d d d d d g t  t j   } | j | j    | j d |  | j	 | d  t
+ j   } t j t t  } | j d  t j   } | j d d  | j d
+  | j d  | j d d  | j d d  | j |  t j   } | j d d d d d d g d	 d  | j d  | j | | d |  | j d d d  | j d  } | j |  | j |  | j | | d |  | j	 | d  | j t d d d |  \ }	 }
+ |	 j d  |  j |
+ j |   |  j |	 j | d   | j t d d d |  \ }	 }
+ |	 j d  |  j |
+ j |   |  j |	 j | d   t
+ j | | j    } | j t d d d |  \ }	 }
+ |	 j d  |  j |
+ j |   |  j |	 j | d   | j t d d d |  \ }	 }
+ |	 j d  |  j |
+ j |   |  j |	 j | d   d  S(   Ns   Pyfile33.medi    i   i   i   i   i   R  i   g      @s
+   sigX [MPa]s
+   sigY [GPa]i   i   R  g333333?s   2*xR&   g+=ii   (    R   R  R  RN   R>   R(   Rc   R   Rj   R   R   Rw  R  RX  RB   RY   Rx  Ry  Rz  R   R{  Rk   RZ   R  R   RZ  R  R~  R0   R  R1   RC   (   R	   R9  R   R:  R;  R   Re  R   R   R  R  RC  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField122  sZ    "         %    ! ! ! ! c         C   sc  d } t  j   } | j d d d d d d g t  | j   } | j t t d   t  } | j	 |  t
+ j   } | j | j    | j d |  | j | d  t j   } t j t t  } | j	 d  t j   } | j d d  | j d
+  | j d  | j d d  | j d d  | j |  t j   } | j d d d g d d  | j	 d  | j | | d |  | j | d  | j t d |  \ }	 }
+ |	 j	 d  |  j |
+ j |   |  j |	 j  | d   t j | | j   d d  } | j t d |  \ }	 }
+ |	 j	 d  |  j |
+ j |   |  j |	 j  | d   d  S(   Ns   Pyfile34.medi    i   i   i   i   i   t   F3Nodei   g      @s
+   sigX [MPa]s
+   sigY [GPa]t   sup1NodeEltR&   g+=ii   (!   R   R  R  RN   RC   t   buildPartOfMySelfRm   Rn   R.   RB   R>   R(   Rc   R   Rj   R   R   Rw  R  RX  RY   Rx  Ry  Rz  R   R{  Rk   RZ   R|  R~  R0   R  R1   (   R	   R9  R   t   tmpR:  R;  R   Re  R   R  R  RC  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField13S  sF    "             c         C   s  d } t  j   } | j d d d d d d g t  | j   } | j t t d   t  } | j	 |  t
+ j   } | j | j    | j d |  | j | d  t j   } t j t t  } | j	 d  t j   } | j d d  | j d
+  | j d  | j d d  | j d d  | j |  t j   } | j d d d g d d  | j	 d  | j | | d |  | j d d d  | j d  }	 |	 j |  | j |	  | j | | d |  | j | d  | j  t d d d |  \ }
+ } |
+ j	 d  |  j! | j" |   |  j! |
+ j# | d   | j  t d d d |  \ }
+ } |
+ j	 d  |  j! | j" |   |  j! |
+ j# |	 d   |  j$ d g d g g | j%    t j | | j    } | j  t d d d |  \ }
+ } |
+ j	 d  |  j! | j" |   |  j! |
+ j# | d   | j  t d d d |  \ }
+ } |
+ j	 d  |  j! | j" |   |  j! |
+ j# |	 d   d  S(   Ns   Pyfile35.medi    i   i   i   i   i   t   F4Nodei   g      @s
+   sigX [MPa]s
+   sigY [GPa]R  g333333?s   2*xiR&   g+=i   (&   R   R  R  RN   RC   R  Rm   Rn   R.   RB   R>   R(   Rc   R   Rj   R   R   Rw  R  RX  RY   Rx  Ry  Rz  R   R{  Rk   RZ   R  R   RZ  R  R~  R0   R  R1   R+   R  (   R	   R9  R   R  R:  R;  R   Re  R   R   R  R  RC  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField14n  sb    "              ! ! "! ! c      	   C   sV  d } t  j   } | j d d d d d d g t  | j   } | j d d d d d d d d g t  } | j |  t j	   } | j
+ | j    | j d |  t j	   } t j	 t t  } | j d  t j	   } | j d d  | j d
+  | j d  | j d d  | j d d  | j |  t j	   }	 |	 j d d d d d g d d  |	 j d  | j | | d |	  | j t t d   t  } | j |  | j d |  | j | d  | j | d  | j t | d  } | j t d |  \ }
+ } |
+ j d  |  j | j  d   |  j | j!   j" |
+ d   d  S(   Ns   Pyfile36.medi    i   i   i   i   i   R  i   g      @s
+   sigX [MPa]s
+   sigY [GPa]i   R  R&   g-q=i(   (#   R   R  R  RN   RC   R  R.   RB   R>   R(   Rc   R   Rj   R   Rw  R  RX  RY   Rx  Ry  Rz  R   R{  Rk   RZ   R|  Rm   Rn   R   t   getFieldOnMeshAtLevelR~  R0   t   isIotaR)  R1   (   R	   R9  R   R  R   R:  R;  R   Re  R   R   t   p1(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField15  sD    "*          "    c         C   s  d } t  j   } | j   } t j   } | j | j    | j d |  | j | j	    t
+ j   } | j |  | j   d } | j   | j | j	    | j d |  | j | d  | j t  } t j   } | j | j   j   d  | j   | d  d   d f <d | j   | d  d   d f <d | j   | d  d   d f <| j t t  } | j |  | j |  | j |  | j |  | j | d  t
+ j | | j	   d d  }	 |	 j t d  }
+ |  j | j |
+ d d   |	 j t d  }
+ |  j | j |
+ d d   |	 j t  }
+ |  j | j |
+ d d   d } | j | d  t
+ j   } | j |  | j | d  t
+ j | | j	   d d  }	 |	 j t  }
+ |  j | j |
+ d d   d  S(	   Ns   Pyfile37.medi    ii   i   i   g-q=s   Pyfile38.med(    R   R$  R   R>   R(   Rc   R   Rj   RB   RC   R   R%  t   buildDescendingConnectivityt   sortCellsInMEDFileFrmtR   RV  R.   RY   Rx  R)  R   RW  RX  RN   R{  t   copyTinyStringsFromt   copyTinyAttrFromR  R  R0   R1   t   getFieldAtTopLevel(   R	   R9  R   R   R:  R;  R   R   t   ddRC  t   f1bis(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField16  sT    
+  c         C   sU  d } t  j   } | j d d d d d d g t  t j   } | j | j    | j d |  | j	 | j
+    | j | d  t j   } t j   } t j t t  } | j	 d  t j   } | j d d  | j d	  | j d  | j d d
+  | j d d  | j |  t j   } | j d d d d g d d  | j	 d  | j | | d |  | j d d d  | j d  }	 |	 j |  | j |	  | j | | d |  | j d  | j d |  | j   } | j | d  t j |  }
+ |
+ j  d  } | j! t d d  } |  j" | j#   j$ | j#   d   d  S(   Ns   Pyfile39.medi    i   i   i   i   i   R  g      @s
+   sigX [MPa]s
+   sigY [GPa]R  g333333?s   2*xg-q=i   (%   R   R  R  RN   R>   R(   Rc   R   Rj   RB   RC   R   R[  R   Rw  R  RX  RY   Rx  Ry  Rz  R   R{  Rk   RZ   R  R   RZ  R  t   resizet   setFieldAtPosRq   Rc  R  R0   R)  R1   (   R	   R9  R   R:  t   ffsR;  R   Re  R   R   t   ffsrR	  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField17  sJ    "              %c         C   s9  d } t  j   } | j d d d d d d g t  t j   } | j | j    | j d |  | j	 | j
+    | j | d  t j   } t j   } t j t t  } | j	 d  t j   } | j d d  | j d	  | j d  | j d d
+  | j d d  | j |  t j   } | j d d d d g d d  | j	 d  | j | | d |  | j d d d  | j d  }	 |	 j |  | j |	  | j | | d |  | j |  | j | d  t j |  }
+ |
+ j d  } | j t d d  } |  j  | j!   j" | j!   d   d  S(   Ns   Pyfile40.medi    i   i   i   i   i   R  g      @s
+   sigX [MPa]s
+   sigY [GPa]R  g333333?s   2*xg-q=i   (#   R   R  R  RN   R>   R(   Rc   R   Rj   RB   RC   R   R[  R   Rw  R  RX  RY   Rx  Ry  Rz  R   R{  Rk   RZ   R  R   RZ  R  R\  Rc  R  R0   R)  R1   (   R	   R9  R   R:  R  R;  R   Re  R   R   R  R	  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDField18  sF    "              %c         C   s>   d } t  j |  } |  j d | j   j d  j    d  S(   Ns   Pyfile13.medt)   Loc_MyFirstFieldOnGaussPoint_NORM_QUAD4_1t(   Loc_MyFirstFieldOnGaussPoint_NORM_TRI3_0t(   Loc_MyFirstFieldOnGaussPoint_NORM_TRI6_2i    (   R  R  R  (   RK  R(   R+   Ra  Rc  t   getLocs(   R	   R9  Re  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFieldBug1  s    %c         C   sf  t  j   } | j   t j   } | j d |  t j   } | j d d g d d  | j d  t j   } | j d d g d d  | j d  t j   } | j d d d g d d  | j d  | j	 d | | g t
+  |  j d | j    |  j d | j    |  j d | j d   |  j d | j d   | j   |  j d | j    |  j d | j    |  j d | j d   |  j d | j d   t j   } | j d |  | j	 d | | | g t
+  |  j d | j    |  j d | j    |  j d | j d   |  j d | j d   |  j d | j d   | j   |  j d | j    |  j d | j    |  j d | j d   |  j d | j d   |  j d | j d   | j d d  | j d d  } |  j | j |   | j d d  } |  j | j |   | j d d  } |  j | j |   d  S(    Ni    i   i   t   g1i   t   g2t   g3s	   Family_-2s	   Family_-3s	   Family_-4s	   Family_-5i   i   (   s   g1s   g2(   s	   Family_-2s	   Family_-3(   s	   Family_-2(   s	   Family_-3(   s   g1s   g2(   s   g1s   g2(   s   g1(   s   g2(   s   g1s   g2s   g3(   s	   Family_-2s	   Family_-4s	   Family_-5(   s	   Family_-2s	   Family_-4(   s	   Family_-5(   s	   Family_-4s	   Family_-5(   s   g1s   g2s   g3(   s	   Family_-2s	   Family_-4s	   Family_-5(   s	   Family_-2s	   Family_-4(   s	   Family_-5(   s	   Family_-4s	   Family_-5(   R   RL  t   convertQuadraticCellsToLinearR>   R(   Rj   Rk   RZ   RB   Rl   RN   R+   t   getGroupsNamest   getFamiliesNamesR   t   assignFamilyNameWithGroupNamet   changeFamilyIdRG   R0   R1   (   R	   R   R   R  R  R  t   g(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDMesh8  sZ    
+      
+
+c         C   s  d } t  j   } | j   } t j   } | j | j    | j d |  | j | d  t	 j   } | j
+ |  | j | d  | j   } | j   } | j d d d g  | j d  | j   d 9(| j d	  t j   } | j | j    | j d |  | j | d  t	 j   }	 |	 j
+ |  |	 j | d  t | d
+ d d d d  }
+ |  j |
+ j | d d   t | d d d	 d d  } |  j | j | d d   d  S(   Ns   Pyfile41.medi    i   g      ?g333333?gffffff?t   3DSurfMesh_2g       @t   VectorFieldOnCells2R  R   i   g-q=(   R   R$  R   R>   R(   Rc   R   Rj   R   R   R%  Rq   t	   translateRB   R)  R  R0   R1   (   R	   R9  R   R   R:  R;  R   R   R   RC  R
+  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt4   testMEDLoaderMEDLoaderNSReadFieldDoubleDataInMedFile@  s8    c         C   s  d } t  j   \ } } } } } } } }	 }
+ } } } } } t j   } | j | j    | j d |  | j d |  | j d |  | j | d  d } d d d	 g } t j   } t	 j   } | j
+ | j   t |  d
+  | j d  | j t |   | j |  t j t t  } | j |  | j |  | j |  | j   | j |  |  j | j   d d g f  t	 j   } | j
+ | j   t |  d
+  | j d  | j t |   | j |  t j t t  } | j |  | j |  | j |  | j   | j |  |  j | j   d d d g f  t	 j   } | j
+ | j   t |  d
+  | j d  | j t |   | j |  t j t t  } | j |  | j |  | j |  | j   | j |  |  j | j   d d d d g f  | j | d  d } d d g } t j   } t	 j   } | j
+ | j   d d
+  | j d  | j d  | j |  t j t t  } | j |  | j |  | j |  | j   | j |  |  j | j   d d g f  t	 j   } | j
+ | j   t |  d
+  | j d  | j t |   | j |  t j t t  } | j |  | j |  | j |  | j   | j |  |  j | j   d
+ d d g f  | j | d  t j | | d d  } |  j | j   d d d d g f  |  j | j   d d d d d f g f d
+ d d d d f g f d d d d d f g f d d d d d f g f g  t j | | d d  } |  j | j   d
+ d d g f  |  j | j   d d d d d f g f d
+ d d d d f g f g  d  S(   Ns   Pyfile42.medi    iii   t   Field1t   comp1t   comp2t   comp3i   g      @g     g@g     V@t   Field2t   comp11t   comp22g     gg     Vi   R&   iT   i   i   i   (   i    i   (   i   iT   (   iT   i   (   i   i   (   i    i   (   i   iT   (   R   R   R>   R(   Rc   R   Rj   R   R   RY   Rx  R   Ry   Ry  Rz  t   setInfoOnComponentsRw  R  RX  RB   R{  R   Rd   R%  R+   R,   t   getFieldSplitedByType(   R	   R9  R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   t
+   FieldName1t
+   compNames1R;  t   da2t   da0R   t
+   FieldName2t
+   compNames2RC  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt!   testMEDLoaderMultiLevelCellField1`  s    6     
+     
+"     
+%    
+     
+"%v"Fc         C   s  d } t  j   \ } } } } } } } }	 }
+ } } } } } t j   } | j d |  | j d |  | j d |  t j   } t j t t  } | j	 d  t
+ j   } | j d d d d	 d
+ d g d d  | j |  t j   } | j d d g d d  | j	 d  | j | | d |  | j t d |  } |  j t | j    |  j d | j   j    |  j d | j   j    |  j d | j   j    |  j d d d g | j   j   j    |  j d d g | j   j   j    |  j d | j   j    |  j d | j   j    d d d d	 d
+ d g } d d d g } d d d g } xh t d  D]Z } |  j | | | j   j d  | d  |  j | | | j   j d  | d  qvWx= t d  D]/ } |  j | | | j   j d |  d  qW~ | j t d |  } |  j t  | j    |  j d | j   j    |  j d | j   j    |  j d | j   j    |  j d d d d g | j   j   j    |  j d d d g | j   j   j    |  j d | j   j    |  j d | j   j    x= t d  D]/ } |  j | | | j   j d |  d  q4W| j! | d  | j! | d  t j   } | j d d g d d  | j	 d  t j   } | j | | d |  | j t d |  } |  j t | j    |  j d | j   j    |  j d | j   j    |  j d | j   j    |  j d d d g | j   j   j    |  j d d g | j   j   j    |  j d | j   j    |  j d | j   j    d	 d
+ d d d d g } xh t d  D]Z } |  j | | | j   j d  | d  |  j | | | j   j d  | d  q
+Wx= t d  D]/ } |  j | | | j   j d |  d  quW| j t d |  } |  j t  | j    |  j d | j   j    |  j d | j   j    |  j d | j   j    |  j d d d d g | j   j   j    |  j d d d g | j   j   j    |  j d | j   j    |  j d | j   j    x= t d  D]/ } |  j | | | j   j d |  d  qWd  S(   Ns   Pyfile43.medi    iit   NodeFieldPflg      ?g      $@g      Y@g       @g      4@g      i@i   i   i   t   PflNodeg      @g        g      @i   i   i   i   ("   R   R   R>   R(   Rj   R   Rw  R  RX  RB   RY   RZ   R{  Rk   R|  R  R+   t   getTypeOfFieldR   t   getMeshDimensionR   t   getNumberOfNodesRv   RH   Rw   R)  R   t   getNumberOfComponentsRn   R&  t   getCoordinatesOfNodet   getIJR  R   (   R	   R9  R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   t   arrR  t   tes0R   t   nodeCoordsWithValue1t   nodeCoordsWithValue2R   t   tes1t   tes2t	   expected2t   tes3(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt#   testFieldOnPflRetrieveOnMdimRelMax1  s    6 %  +(**).+)  +(**).+)c         C   s-  d } t  j   } | j d t j d d d d d d g   | j d	 t j d d d d d g   | j   } | j d
+  | j   j d d g  | j   d d d d d d d d d d d d d d d d d d g } | j | j	    t
+ j d d d g  } | j d   t
+ j d! d" g  } | j d#  t j   } | j d |  | j d$ |  | j d$ | | g  t
+ j d d d g  } | j d%  | j d	 | g  d d& d d d d d" d& d d d d' d" d d g } d d! d d d& d d( d! d& d" d d d( d" d' g }	 d d! d d d) d d( d! d) d d d d( d d g }
+ |  j d) | j    |  j | | j d  d* d+ d g j   j    |  j |	 | j d  d, d d! g j   j    | j d   \ } } } |  j d& d" d' g | j    |  j d, d d! g | j    |  j d* d+ d g | j    |  j d | j    |  j d d d g | j d$ d   j    |  j d! d" g | j d$ d#  j    |  j d d d g | j d	 d%  j    |  j d' d- d. g | j d$ d/  j    |  j | | j d  d* d+ d g j   j    |  j |
+ | j d  d, d d! g j   j    |  j t | j d$ d/  j | j d$ d   d0 d1  | j d$ d/  j | j d$ d   d* d1  t j d2 d3 d4 d5 d6 d3 d7 d8 d9 d: d4 d8 d; d< d= d5 d9 d< d> d? g  } | j d  j t  j   } | | } | j   |  j | j   d d1 k   | j   t |  c d d@ g 7)|  j t | j d$ d/  j | j d$ d   d* d1  | } dA dB dC g | d, d( +| j d  j t  j   } | | } | j   |  j | j   d d1 k   | j  | d0  d  S(D   Ns   Pyfile44.medi    g        g?gffffff@g@g      @g      @i   t   AnthonyDuplicates   X [km]s   Z [mm]i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i   i   t   Grpi	   i   t   Grp2it   GrpNodei   i   i
+   i   i   i   i   i   i   t   Grp_dupi   g-q=g\(\?gQ?gzG?gp=
+ף?gffffff?g
+ףp=
+?g(\?gzG?g?g
+ףp=
+?gQ?g333333?g\(\?g @g333333ӿgףp=
+?g)\(?g?(!   R   R(   R   RY   t   buildUnstructuredRB   R   R  R  RC   Rk   R>   Rj   Rl   R+   R  R}   Rv   RH   t   buildInnerBoundaryAlongM1GroupRG   R)   R*   R?   t   checkGeoEquivalWithRV  R.   R)  t   absR0   t   getMaxValueRy   R   (   R	   R9  R   R   t   grpt   grp2R   t   grpNodet   ref0t   ref1t   ref2t   nodest   cellst   cells2t	   refValuest
+   valsToTestt   deltat
+   refValues2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt#   testBuildInnerBoundaryAlongM1Group1  sl    +( G   33322+(++224+K 
+ 
+#4  
+ 
+c         C   s  d } t  j   } | j d t j d d d d d d g   | j d	 t j d d d d d g   | j   } | j d
+  | j   j d d g  | j   d d d d d d d d d d d d d d d d d d g } | j | j	    t
+ j d d g  } | j d   t
+ j d! d" g  } | j d#  t j   } | j d |  | j d$ |  | j d$ | | g  t
+ j d d d g  } | j d%  | j d	 | g  d d& d d d d d" d& d d d d' d" d d g } d d! d d d& d d( d! d& d" g
+ }	 d d! d d d) d d( d! d) d" g
+ }
+ |  j d) | j    |  j | | j d  d* d+ d g j   j    |  j |	 | j d  d, d g j   j    | j d   \ } } } |  j d& g | j    |  j d, d g | j    |  j d* d+ g | j    |  j d | j    |  j d d g | j d$ d   j    |  j d! d" g | j d$ d#  j    |  j d d d g | j d	 d%  j    |  j d' d- g | j d$ d.  j    |  j | | j d  d* d+ d g j   j    |  j |
+ | j d  d, d g j   j    |  j t | j d$ d.  j | j d$ d   d/ d0  | j d$ d.  j | j d$ d   d* d0  t j d1 d2 d3 d4 d5 d2 d6 d7 d8 d9 d3 d7 d: d; d< d4 d8 d; d= d> g  } | j d  j t  j   } | | } | j   |  j | j   d d0 k   | j   t |  c d d? g 7)|  j t | j d$ d.  j | j d$ d   d* d0  | } d@ dA g | d, d! +| j d  j t  j   } | | } | j   |  j | j   d d0 k   | j  | d/  d  S(B   Ns   Pyfile45.medi    g        g?gffffff@g@g      @g      @i   R  s   X [km]s   Z [mm]i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i   i   R  i	   i   R  iR  i   i   i
+   i   i   i   i   i   R  i   g-q=g\(\?gQ?gzG?gp=
+ף?gffffff?g
+ףp=
+?g(\?gzG?g?g
+ףp=
+?gQ?g333333?g\(\?g @g333333ӿgףp=
+?gQ?(!   R   R(   R   RY   R  RB   R   R  R  RC   Rk   R>   Rj   Rl   R+   R  R}   Rv   RH   R  RG   R)   R*   R?   R  RV  R.   R)  R  R0   R  Ry   R   (   R	   R9  R   R   R  R  R   R  R  R  R  R  R  R  R  R  R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt#   testBuildInnerBoundaryAlongM1Group2-  sl    +( G   3$$2/((+(2/4+K 
+ 
+#4  
+ 
+c      
+   C   s  d } t  j   } | j d t d d d d d g   | j d t d d	 d
+ g   | j   } | j d  | j   d } | j | j    t d d g  } | j d  t	 j   } | j
+ d |  | j
+ d |  | j d | g  | j d  \ } } } |  j d d g | j    |  j d d g | j    |  j d d g | j    |  j d | j    |  j d d g | j d d  j    |  j d d g | j d d  j    d d d d d d d d d d g
+ }	 d d d d d d d d d d g
+ }
+ |  j |	 | j d  d d g j   j    |  j |
+ | j d  d d g j   j    |  j t | j d d  j | j d d  d d   | j d d  j | j d d  d d   t d d! d" d# d d! d" d# g  } | j d  j t  j   } | | } | j   |  j | j   d d$ k   | j   t |  c d d% g 7)|  j t | j d d  j | j d d  d d   | } d& | d <d' | d <| j d  j t  j   } | | } | j   |  j | j   d d  k   | j | d  d( S()   s@    Test buildInnerBoundaryAlongM1Group() with *non-connex* cracks s   Pyfile73.medi    g        g?gffffff@g@g      @i   g      ?g       @t   simplei   i   R  ii   i   i   i   i   i   R  i   i   i   i   i   i   i   i	   i   g-q=g333333?g?gffffff?g|=g333333ӿg=
+ףp=?gGz?N(    R   R(   R   RY   R  RB   R  RC   Rk   R>   Rj   Rl   R  R+   RH   R  RG   R}   Rv   R)   R*   R?   R  RV  R.   R)  R  R0   R  R   Ry   R   (   R	   R9  R   R   t   grpSegR   R  t   cellsModt   cellsNotModR  R  R  R  R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt#   testBuildInnerBoundaryAlongM1Group3_  sT    %  (($$//4+$ 
+ 
+#4 
+ 
+ 
+ 
+c      0   C   s  t  d d d d d d d d d d d d d d d d d d d d d d d d g d d  } d d d	 d
+ d d
+ d	 d d d d d d d d d d d d d d d d d d d	 d d d d	 d d d d
+ d d d d
+ d d d d d d d d d d g0 } t   } | j d d
+  | j   | d	 9} t d d  } | j |  | j t |  |  | j   | j   \ } } } } } t d d g  } | j	 d  t d d
+ g  } | j	 d  t
+   }	 |	 j d |  |	 j d |  |	 j d | | g  | j   }
+ |	 j d  \ } } } |	 j d  } | j   |	 j d  } | j   |  j |
+ d |	 j    |  j |
+ d | j    |  j |
+ d | j    |  j d d g | j    |  j d d d d g | j   |
+ j    |  j t d d d g  t | j     |  j t d d d	 d g  t | j     |  j d d g |	 j d d  j    |  j d d g |	 j d d  j    |  j d d
+ g |	 j d d  j    d d d d d d d d d d d d g } d d d d d d d d d d
+ d d d d
+ d d g } |  j | |	 j d  d d d g j   j    |  j | |	 j d  d	 d d d g j   j    |  j t |	 j d d  j |	 j d d  d d  |	 j d d  j |	 j d d  d d  |	 j d  } | j   \ } } } } } | j |	 j d  d d  d S(   sr    Test case where cells touch the M1 group on some nodes only and not on full edges (triangle mesh for ex)
+        g        g      ?g       @g      @i   i   i   i    i   i   i   i	   i
+   i   i   i   i   i   t   2Dt   groupt   group2ii   i   t	   group_dupg-q=g#@N(   RY   Rk   Rx  Ry  R[   Rc   t   setConnectivityt   checkConsistencyR  RB   R>   Rj   Rl   R  R  R}   R+   RH   R   t   setRG   Rv   R)   R*   R?   R  t   checkDeepEquivalOnSameNodesWith(   R	   t   coot   connt   connIR   R   t   _t   grpIdst   grpIds2t   mfut   nNodt   nodesDupt   cells1R  t   m2_bist   m1_bisR  R  t   m_bis0t   m_desc(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt#   testBuildInnerBoundaryAlongM1Group4  sf    '	 
+ 
+
+  	
+
+,+.(((*6254+c        C   s
+  t  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d	 d d d d
+ d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d! d" d# g d$ d%  } d& d' d( d) d* d& d+ d, d- d. d& d/ d0 d1 d. d& d2 d3 d4 d5 d& d, d0 d. d1 d& d) d- d6 d. d& d, d3 d1 d7 d& d+ d, d. d1 d& d8 d9 d/ d1 d& d) d' d: d; d& d/ d+ d. d1 d& d& d< d6 d. d& d3 d, d1 d5 d& d9 d= d> d? d& d, d0 d1 d5 d& d. d& d< d0 d& d. d@ d/ d: d& d) d: d@ d. d& d, d. d& d6 d& d/ d+ d1 d? d& d) dA d' d* d& d9 d? d/ d1 d& d@ d: d) d% d& d9 d= d? d1 d& d/ d0 d. dB d& d) d: d. d; d& d/ d+ d? d@ d& d+ d, d1 d7 d& d3 d4 d5 d1 d& dC d: dD d' d& d, d0 d5 d& d& d4 d0 d5 d1 d& d- d. d) d+ d& d8 d0 d4 d1 d& d/ d0 dB d8 d& d. d- d6 d, d& d9 d8 d4 d1 d& d: d< dB d. d& d7 d= d1 d+ d& d; d' d: d< d& d+ d, d7 d- d& dB d< d: dE d& d/ d0 d8 d1 d& d6 d) d. d; d& d8 dF d9 d4 d& d? d= d+ d1 d& d) d( d' d6 d& d. d; d< d6 d& d6 d' d< dG d& d. d; d: d< d& d6 d- d) dH d& d, d0 d& d. d& d/ d+ d@ d. d& d' d( d* dI d& d3 d= d7 dJ d& d0 d. dB d< d& d3 d7 d= d1 d& d6 d< d& dK d& d' d6 dL dG d& dM d' dC dD d& dB d. d/ d: d& d. d@ d) d+ d& dC d' dN d< d& d' dM dA dD d& dC d< d: d' d& d( d) dH d6 d& dA dM dI dO d& dN d' dL dG d& dI d' dL dN d& d' d( dI dL d& dA d: d' dD d& d' d( dL d6 d& dA d: d) d' d& dP dC dM dN d& dA dM d' dI d& dA d' d* dI d& dI dQ dL d( d& d) d: dA d% d& dM d' dI dN d& dN dL dR dG d& d< d' d6 d; d& dN d' dG d< d& d) d6 d' d; d& d6 d< dK dG d& dM d' dN dC d& d: d< dC dE g} dH d2 dO d< d- d3 dC dM d; d' dS dT dU dV dW dX dY dZ d[ d\ d] d^ d_ d` da db dc dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz d{ d| d} d~ d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gW } t d d%  } | j |  | j t |  t |   | j   | j   \ } } } } } t d0 d g  } | j d  t   } | j	 dH |  | j	 d |  t dH dK g  }	 |	 j d  | j
+ dH |	 g  | j
+ d | g  | j   }
+ | j d  \ } } } | j dH  } | j   | j d  } | j   |  j |
+ dK | j    |  j |
+ dK | j    |  j |
+ dK | j    |  j d% g | j    |  j | j   d% j   | j   |
+ j    |  j t d? g  t | j     |  j t d g  t | j     |  j d0 d g | j d d  j    |  j dH dK g | j dH d  j    |  j d g | j d d  j    | j d  } | j   \ } } } } } | j | j d  dE d  d S(   s    Full 3D test with tetras only. In this case a tri from the group is not duplicated because it is made only
+        of non duplicated nodes. The tri in question is hence not part of the final new "dup" group. g      i@g        g      y@g     Y@guO@gQA@w`@g	\Y@gcj Y@g r@gR˗X@gx	Gr@g#<GX@gDbY@g]=X@gX@g^=X@g+Im   Y@g5^=X@gl*S Y@g5^=X@gMn*S Y@g
+X@g" Y@gړX@gϙD Y@g[or@g
+   Y@glor@g Y@g\a@g)}X@gjS Y@gD}nr@glL[eJX@g8$KX@i.   i   i   i-   i   i   i*   i%   i&   i   i,   i'   i$   i)   i   i   i   i   i   i   i   i   i   i(   i   i   i   i   i   i!   i   i   i+   i   i   i   i    i    i   i   i"   i#   i   i
+   i   i   i	   i2   i7   i<   iA   iF   iK   iP   iU   iZ   i_   id   ii   in   is   ix   i}   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i  i	  i  i  i  i  i"  i'  i,  i1  i6  i;  i@  iE  iJ  iO  iT  iY  i^  ic  ih  im  ir  iw  i|  i  i  i  i  i  i  i  i  i  i  t   3DiJ   R  it   group_3diM   i   R  g#@N(   RY   R[   Rc   R  Rk   R   R  RB   R>   Rj   Rl   R  R  R}   R+   RH   R   R  RG   R  (   R	   R  t   c0t   cI0t   m3R   R  R  R	  t   grpIds3DR
+  R  R  R  t   m3_bisR  R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testBuildInnerBoundary5  st    H<-3*0$~~~rf3
+ 	 
+
+0%%((%c         C   s  d } t  j |  } t  j | d d d  } t  j |  } t | d d d  } t |  } t   } |  j   t d  } t d d d d  } t   } t   } t |  } t | d  } t   } t |  } t   } t | d d d  } t   } t | d  } t	   } t	 |  } t
+   } t
+ |  } t   } t d	 d  } t d
+ d	 d d d d g d d  } t   } t d	 d  } t d
+ d	 d d d d g d d  } t d d  } t   } t   } t t t  } t t  } t g   } t g   } d  S(   Ns   Pyfile18.medR%   is   MEDFileMesh5.medR   t   FieldOnFacesShufflei   i   i   i   i   i   i   t   jjj(   R'   R(   R>   R   R   RM  RP  R   R   R[  RK  Rk   RY   R[   R   Rw  R  RX  t   MEDCouplingFieldTemplateR  t   MEDCouplingMultiFieldst   MEDCouplingFieldOverTime(   R	   R9  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testBasicConstructors  sL    	
+								  $	  $ 		c         C   s  d } t  j   } | d  } | j d  | j t  } | j t t  } | j d d d  | j d  | d  } | j   j | j	    | d } | j   j | j	    t
+ j   } | j d	 |  t j   } | j | | d	 t j d	 d d
+   | j | d  | j | d	  t j | | j	   | j   d
+ | j   d  } | j t d	 |  }	 | j t d	  }
+ |	 j   |
+ j   |  j |	 j | d d   |  j |
+ j | d d   d  S(   Ns   Pyfile46.medi
+   t   meshg      @i   i   t   SemiPartialFieldi   i    i   i   g-q=(   R   Rv  RB   RV  RN   RW  RX  R   R   RC   R>   R(   Rj   R   R|  Rk   t   RangeR   R   R  R  R  Rd   R0   R1   (   R	   R9  R   R   R   R   R   R   RC  t   freadt   fread2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testBugSemiPartialField  s4    
+ 
+ 
+ %2
+
+c      &   C   s  d } t  j |   } d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g& } |  j | | j d  j    |  j | j   d  t d d d	 g d
+ d d g d d
+ d g d d d g d d d g d d d g g d d d	 g d
+ d d g d d d g d d d g d d d g d d d g g f  | j | d  |  j | j d	 d  j   d	 d d d g  |  j | j d	 d  j   d d d
+ d d g  |  j | j d d  j   d d d d
+ d g  |  j | j d d  j   d d
+ d d g  |  j | j d d  j   d d d d g  |  j | j d d  j   d	 d d d g  |  j | j d d  j   d d d d d g  |  j | j d  j   |  | j	 d	 d   | j d d   d  S(   Ns   Pyfile47.medi   i   i   i   i   i   i   i    i   i   i	   i   i   i   i   i   t   grp0_L0t   grp1_L0it   grp0_LM1t   grp1_LM1t   grp2_LM1i   i   t	   grp0_Nodet	   grp1_Node(   R   t   buildMLMeshUnPolyzeR+   R   RH   t   unPolyzeR.   R   RG   R   t   NoneR   (   R	   R9  R   t   ref(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testUnPolyze1<  s"    x.11...1c      -   C   s  d } t  j   } t j |   } t j   } | j |  | j |  t j   } | j |  t	 j   } | j
+ |  t j t t  } | j d  | j d d d  t j dT  } | j d  | j d  | j d	 d
+ g  | j |  | j | j d   | j |  | j d  }	 t j t t  }
+ |
+ j d  |
+ j d d d  t j d d d d g  } | j d  |
+ j | j d  |  t j d d d d d d d d g d d  } | j d	 d
+ g  |
+ j |  |	 j |
+ | d |  t j t t  } | j d  | j d d d  t j d d d d d d d d g  } | j d  t j d d d d d d d  d! d" d# d$ d% d& d' d( d) g d d  } | j d	 d
+ g  | j | j d*  |  | j |  |	 j | | d* |  | j   j |	  | j   | j   d } |  j | j    d  |  j | j!   dU g  | j" d d  \ } } |  j | dV dW f dX dY f dZ d[ f d\ d] f d^ d_ f d` da f db dc f g  |  j# | d d+ !j$ t d d d d g d d  d4   |  j# | d+ d, !j$ t d d d  d! d" d# g d d  d4   |  j# | d, d- !j$ t d$ d% d& d' d( d) g d d  d4   |  j# | d- d/ !j$ t d d d d g d d  d4   |  j# | d/ d1 !j$ t d d g d d  d4   |  j# | d1 d3 !j$ t d d g d d  d4   |  j dd | j%    |  j d d de d5 d8 f g f d d df d8 d8 f g f d d dg d8 d8 f g f d. d dh d6 d8 f g f d0 d di d7 d8 f g f d2 d dj d8 d8 f g f d+ d dk d8 d8 f g f g | j& d d   |  j | j' d5  j(   d d g  |  j | j' d6  j(   d d g  |  j | j' d7  j(   d g  | j) t d d d | j*   d  } |  j# | j+   j$ t d d d d d d d d g d d  d4   |  j | j,   j-   j(   d. d d d d9 d. d: d; d< d= d0 d> d? d@ dA dB dC d2 dD dE dF dG dH dI dJ dK g  |  j | j,   j.   j(   d d dL dM d: g  | j) t d d d* | j*   d  } |  j# | j+   j$ t d d d d d d d  d! d" d# d$ d% d& d' d( d) g  d4   |  j | j,   j-   j(   d d d d d d d d d d d9 d dN d dL dO dP dQ d d. dR d0 dM d d2 dS d> d? d@ d dA dB dC d: d; d dE dF dG dH dI dJ dK g+  |  j | j,   j.   j(   d d d dQ d2 dA d= dI d, g	  | j/ | d  d  S(l   Ns   Pyfile48.medR   g      #@i   i   i&   i   g      @s
+   Power [MW]s   Density [kg/m^3]i    i   i   i   t   pfltestg     @g    @g     @g     @g     8@g    +@g     :@g    +@i   t	   pfltestM1g     r@g    |@g     r@g    |@g      y@g     @g     y@g    @g      y@g     @g      @g     2@g     @g    2@g     @g    02@ii(   i+   i.   i   i0   i   i1   i   i2   g:0yE>t   NewPfl_0t   NewPfl_1t   NewPfl_2R&   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i
+   i   i	   i   i   i   i   i   iL   (   i   i   g      #@(   i   i    (   i&   i(   (   i   i    (   i(   i+   (   i   i    (   i+   i.   (   i   i    (   i.   i0   (   i   i    (   i0   i1   (   i   i    (   i1   i2   (   i(   i    (   i    i&   (   R4  R5  R6  (   i&   i(   (   i(   i+   (   i+   i.   (   i.   i0   (   i0   i1   (   i1   i2   (   i    i&   (0   RK  R(   R   R-  RP  t   pushMeshRR  R[  R]  R   R\  Rw  R  RX  RB   R   RY   Ry  Rz  R  R{  R   R}   RY  t   getTimeStepAtPosR  Rk   R|  Ra  t   shallowCpyGlobst   unPolyzeMeshesR+   t   getNumberOfTSR   R(  R0   R  t   getPflsReallyUsedR  t
+   getProfileRH   R  RT  R)  R   Rv   Rw   R   (   R	   R9  t   mfdR   t   meshest   fieldsR   t   f0_0R   t   ff0t   f0_1R  t   f0_2t   pfl2Rm  R  t   entryt   ftest0t   ftest1(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testUnPolyze2P  s          -  ' E 
+O8>>822%%"%Cp1%U=c         C   s  d } d } t  d d d d d d d d d d d d d d d d g d d  } t d d  } | j |  | j d	  | j t t t d    | j   t d d  } | j |  | j d	  | j t	 t t d
+    | j   t d d  } | j |  | j d	  | j t
+ t t d    | j   d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g d d g g } d | g d | g d | g } d   | D | (x3 t | |  D]" \ }	 }
+ |	 j   } | |
+ 7} q9Wt j |  }	 |	 j d  |	 d  } | j |	 j    t j t t  } | j |  | j d d	 d  t  d  } | j d  | j |  | j d  | j   } | j d d	 d d d
+ d  d! d d g	 d d d d d d g d" d" d# d# g d$ d% g  | j d& d' g d d d d d d g d" d" d# d# d$ d$ g d$ d( d) g  | j d d* g d d d d d d d d g d" d" d# d# d$ d$ d$ d$ d$ d$ g
+ d$ d( d+ d, d- g  | j   | j   } | j   j | j   j    t   } | j d |	  | j  | d  t! j   } t" t t d    } | j d.  |  j# t$ | j% | | d |  |  j# t$ | j% | | d |  | j% | | d |  | j  | d  |  j& | j'   dH  |  j& | j(   dI  t" d d	 d d d
+ d  d! d d g	  } | j d/  |  j) | j* d/  j+ |   t" d& d' g  } | j d0  |  j) | j* d0  j+ |   |  j& | j,   dJ  |  j& | j-   dK  t. j |  } | j/   d } | j0   d d } | j1 t d |  | j1 t d |  } |  j) | j+ | d4 d4   t2 | |	 j   d | j   | j3   d	 | j3   d  } | j   |  j) | j+ | d4 d4   t4 | | t5  t2 | |	 j   d | j   | j3   d	 | j3   d  } |  j) | j+ | d4 d4   t j t t  } t" d	 d d  d! d d& d5 d6 d7 d8 g
+  } | j d9  |	 | } | j |	 j    | j |  | j d d	 d  t  d:  } | j d  | j |  | j d;  | j d d	 d g d d d d d d g d" d" d# d# g d$ d% g  | j d d
+ d  g d d d d d d g d" d" d# d# d$ d$ g d$ d( d) g  | j d! d d d& g d d d d d d d d d d d d d d d d g d" d" d# d# d$ d$ d$ d$ d$ d$ g
+ d$ d( d+ d, d- g  | j   t   } | j d |	  | j  | d  t! j   } | j% | | d |  |  j& | j'   dL  |  j& | j* d<  j6   d	 d d! g  |  j& | j* d=  j6   d  d d& g  |  j& | j* d>  j6   d d d
+ d  g  | j  | d  t. j |  } | j/   d } | j0   d d } | j1 t d |  | j1 t d |  } | j7 d d	 d d d
+ d  d! d d d& g
+  |  j) | j+ | d4 d4   t2 | |	 j   d | j   | j3   d	 | j3   d  } | j7 d d	 d d d
+ d  d! d d d& g
+  |  j) | j+ | d4 d4   t4 | | t5  t2 | |	 j   d | j   | j3   d	 | j3   d  } | j7 d d	 d d d
+ d  d! d d d& g
+  |  j) | j+ | d4 d4   t j t t  } | j |	  | j d d	 d  t  d?  } | j d  | j |  | j d@  | j d d	 d d d
+ d  d! d d g	 d d d d d d g d" d" d# d# g d$ d% g  | j d& d' g d d d d d d g d" d" d# d# d$ d$ g d$ d( d) g  | j d d* g d d d d d d d d g d" d" d# d# d$ d$ d$ d$ d$ d$ g
+ d$ d( d+ d, d- g  | j d dA d5 d7 d8 g d d d d d d d d d d d d d d d d g d" d" d# d# d$ d$ d$ d$ g d$ d+ dB d( g  | j d6 dC g d d d d d d d d d d d d d d d d g d" d" d# d# d$ d$ g d$ d+ d+ g  | j   t   } | j d |	  t! j   } | j8 |  |  j& | j'   dM  |  j& | j* dD  j6   d d	 d d d
+ d  d! d d g	  |  j& | j* dE  j6   d& d' g  |  j& | j* dF  j6   d d	 d d
+ d  g  |  j& | j* dG  j6   d d! g  | j  | d  | j  | d  t. j |  } | j/   d } | j0   d d } | j1 t d |  } | j7 d d	 d d d
+ d  d! d d d& d' d d* d dA d5 d7 d8 d6 dC g  |  j) | j+ | d4 d4   t2 | |	 j   d | j   | j3   d	 | j3   d  } | j7 d d	 d d d
+ d  d! d d d& d' d d* d dA d5 d7 d8 d6 dC g  |  j) | j+ | d4 d4   t4 | | t5  t2 | |	 j   d | j   | j3   d	 | j3   d  } | j7 d d	 d d d
+ d  d! d d d& d' d d* d dA d5 d7 d8 d6 dC g  |  j) | j+ | d4 d4   d  S(N   Ns   Pyfile49.meds   Pyfile50.medg        g      ?g      ?i   i   R&   i   i   i   g      @g       @g      @g       @g      $@g      (@g      ,@g      0@g      2@g      4@i   i   c         s   s   |  ] } | j    Vq d  S(   N(   Rq   (   t   .0R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pys	   <genexpr>  s    R   i   g      @i"   g      @t   fieldCellOnPflWithoutPfli    i   i   g333333?gffffff?g?g?i	   i
+   gQ?gp=
+ף?i   g?g{Gz?g{Gz?R  t   pfl_NORM_TRI3_loc_0t   pfl_NORM_TRI3_loc_1t(   Loc_fieldCellOnPflWithoutPfl_NORM_TRI3_0t(   Loc_fieldCellOnPflWithoutPfl_NORM_TRI3_1t)   Loc_fieldCellOnPflWithoutPfl_NORM_QUAD4_2g-q=i   i   i   i   RE  i#   t   fieldCellOnPflWithoutPfl2t   pfl2_NORM_TRI3_loc_0t   pfl2_NORM_TRI3_loc_1t   pfl2_NORM_QUAD8_loc_2i<   t   fieldCellWithoutPfli   gQ?i   t#   Pfl_fieldCellWithoutPfl_NORM_TRI3_0t#   Pfl_fieldCellWithoutPfl_NORM_TRI3_1t$   Pfl_fieldCellWithoutPfl_NORM_QUAD8_3t$   Pfl_fieldCellWithoutPfl_NORM_QUAD8_4(   RL  RM  (   RL  RM  (   RN  RO  RP  (   RN  RO  RP  (   RR  RS  RT  (   RV  RW  RX  RY  (9   RY   R[   Rc   R]   R^   t
+   NORM_QUAD8Rm   Rn   Rb   R`   R_   RS  R   t   MergeUMeshesRB   RC   Rw  R(   R  RX  R   R   Ry  R{  Rq   t   setGaussLocalizationOnCellsRd   R0  R1  R2  R>   Rj   R   R   Rk   R)   R*   R|  R+   t   getPflsR<  R0   R=  R1   R  t   getLocsReallyUsedRK  RT  Ra  R  R  R   t
+   WriteFieldR.   RH   R  R%  (   R	   R9  Rn  R   t   mQ8t   mQ4t   mT3t   trR   R   R   Re  R   R   R   t   fInvalidt	   fInvalid2R   R   R  R   t   dataReadt   mReadt   f1tsReadR   t   f2_bist   f2_terR
+  t   f3_bist   f3_ter(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testGaussWriteOnPfl1  s0   B 
+ 
+ 
+# 
+
+  UIa
+	 '  ;
+;* 
+  CL
+	((++;+;+ UIayg
+	:%.%I;I;Ic         C   s@  d } t  d d d d d d d d d d d d d d d d d d g d d  } t d d  } | j d  | j t d	 d
+ d g  | j t d
+ d d g  | j t d d d
+ d	 g  | j t d d d d
+ g  | j t d
+ d d d g  | j   | j |  t | j   d	  } | j d  d d	 d d d d
+ d
+ d	 d d
+ d d
+ d	 d d d d d g } x7 t	 d  D]) } | j t
+ | d | d | d ! qrW| j   | j |  t   } | j d |  | j d |  d } d }	 d }
+ t t t  } | j d  | j |
+ | |	  t d d	 d d d
+ g  } | j d  t  d d d d d g  } | j |  t   } | j | | d |  | j | d  | j | d  t t t  } | j d  | j |
+ | |	  t d d	 d d d
+ d d g  } | j d  t  d d d d d d  d! g  } | j |  t   } | j | | d |  | j | d  ~ ~ ~ ~ ~ t j |  } | j d  } | j   } | d d g } | j | j    | j   | j |  t j | | j   | |	  } | j t |  } | j   |  j | j  | d" d"   | j! t d  } | j   |  j | j  | d" d"   | j t d |  } | j   |  j | j  | d" d"   t" | | j   d | j   | |	  } | j   |  j | j  | d" d"   t j | | j   | |	  } | j d  } | j   } | d d	 d d d
+ d d d g } | j | j    | j   | j |  | j t |  } | j   |  j | j  | d" d"   | j! t d  } | j   |  j | j  | d" d"   | j t d |  } | j   |  j | j  | d" d"   t" | | j   d | j   | |	  } | j   |  j | j#   j  | d"   |  j$ t% | j t |  |  j$ t% | j! t d  |  j$ t% | j t d |  | j& t d |  \ } } | j | j'   j    |  j | j  | j'   d"   | j | j    |  j | j  |   d  S(#   Ns   Pyfile51.medg        g      ?g      ?i	   i   t   Meshi   i   i   i    i   i   i   i   ig      @t
+   fieldNode0t   PflIdentity0i
+   i   i   i   i   t
+   fieldNode1t   PflIdentity1i   i   i   i   i   i   i   g-q=((   RY   R[   R]   R^   R_   R`   Rb   Rc   RC   Rn   Re   R>   Rj   Rw  R  RX  RB   R   Rk   R{  R   R|  R   R'   R(   R}   Rq   t	   zipCoordsR   R  Rd   R0   R1   R  R  R   R)   R*   R~  R)  (   R	   R9  R  R   R   t   conn1R   R   t   dtt   itt   timRo  t   pfl0R  R   Rq  t   pfl1t   arr1R   t   m00t   ff0_1t   ff0_2t   ff0_3t   ff0_4t   m10t   ff1_1t   ff1_2t   ff1_3t   ff1_4t   arr_rt   pfl1_r(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFieldPflOnNode1-  s    H
+<#
+	   	 ! !	   
+
+
+
+'
+ "  
+
+
+
+'
+c         C   s  d } t  d d d d d d d d d d d d d d d d d d g d d  } t d d  } | j d  | j t d	 d
+ d g  | j t d
+ d d g  | j t d d d
+ d	 g  | j t d d d d
+ g  | j t d
+ d d d g  | j   | j |  t | j   d	  } | j d  d d	 d d d d
+ d
+ d	 d d
+ d d
+ d	 d d d d d g } x7 t	 d  D]) } | j t
+ | d | d | d ! qrW| j   | j |  t   } | j d |  | j d |  d } d }	 d }
+ t t t  } | j d  | j |
+ | |	  t d d	 d g  } | j d  t  d d d g  } | j |  t   } | j | | d |  | j | d  | j | d  t t t  } | j d  | j |
+ | |	  t d d	 d d d
+ d d g  } | j d  t  d d d d d d d g  } | j |  t   } | j | | d |  | j | d  ~ ~ ~ ~ ~ t j |  } | j d  } | j   } | | } | j | j    | j |  t j | | j   | |	  } | j t |  } | j   |  j | j | d  d    | j  t d  } | j   |  j | j | d  d    | j t d |  } | j   |  j | j | d  d    t! | | j   d | j   | |	  } | j   |  j | j | d  d    t j | | j   | |	  } | j d  } | j   } | | } | j | j    | j |  | j t |  } | j   |  j | j | d  d    | j  t d  } | j   |  j | j | d  d    | j t d |  } | j   |  j | j | d  d    t! | | j   d | j   | |	  } | j   |  j | j"   j | d    |  j# t$ | j t |  |  j# t$ | j  t d  |  j# t$ | j t d |  | j% t d |  \ } } | j | j&   j    |  j | j | j&   d    | j | j    |  j | j |   d  S(!   Ns   Pyfile52.medg        g      ?g      ?i	   i   Rn  i   i   i   i    i   i   i   i   ig      @t
+   fieldCell0Rp  i
+   i   i   t
+   fieldCell1Rr  i   i   i   i   i   i   i   g-q=('   RY   R[   R]   R^   R_   R`   Rb   Rc   RC   Rn   Re   R>   Rj   Rw  R  RX  RB   R   Rk   R{  R   R|  R   R'   R(   R}   Rq   R   R  Rd   R0   R1   R  R  R   R)   R*   R~  R)  (   R	   R9  R  R   R   Rt  R   R   Ru  Rv  Rw  R  Rx  R  R   R  Ry  Rz  R   R{  R|  R}  R~  R  R  R  R  R  R  R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFieldPflOnCell1  s    H
+<#
+	   	 ! !	 
+ 
+
+
+'
+ 
+ 
+
+
+'
+c   
+      C   s  t    } t d  } | j d  | j d  | j d d d g  t d d  } | j d	  | j t d
+ d d g  | j t	 d d d d g  | j t
+ d
+ d d d d g  t d d
+  } | j d	  | j t d
+ d g  | j t d d g  t d d	  } | j d	  | j t d g  | j t d g  | j t d g  | j |  | j d	 |  | j |  | j d |  | j |  | j d |  t d  } | j d  | j d
+ |  t d  } | j d  | j d
+ |  t d d d g  } | j d	 |  t d d d g  } | j d	 |  t d d g  } | j d |  t d d g  } | j d |  t d d d g  } | j d |  t d d d  g  } | j d |  | j   }	 |  j |	 j t d d	 d
+ d d d d d! d d g
+    |  j | j d
+  j t d d! d d d" d d# g    |  j | j d
+  j t d! d d d d d# d$ g    |  j | j d	  j   j t d d	 d
+ d d d
+ d d d d! d	 d d d d
+ g    |  j | j d	  j   j t d	 d d" d% g    |  j | j d  j   j t d
+ d	 d d
+ d! d g    |  j | j d  j   j t d	 d d g    |  j | j d  j   j t d	 d
+ d	 d d	 d g    |  j | j d  j   j t d	 d d d g    d  S(&   Ni   g      ?i   s   aaa [b]s   cc [dd]s   e [fff]t   totoi   i    i   i   i   i   i   iii
+   i   i(   i   i,  i  i2   i<   i  iX  iF   iP   iZ   i  i   i  i   i	   i   i   i   (   R>   RY   Ry  Rz  R  R[   R]   R^   R_   R`   Ra   Re   Rg   Rc   Rj   Rk   R   R   Rs  R0   R1   t   getNumberFieldAtLevelR   R}   Rv   Rw   (
+   R	   R   R  R   R   R   t   numCoot   famCooR   t   o2n(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileUMeshZipCoords1  sl    	                              :::X7=4=7c         C   s  d } t    } t d  } | j d  | j d  | j d d d g  t d d	  } | j d
+  | j t d d	 d g  | j t	 d	 d d d g  | j t
+ d d d d d	 g  t d d  } | j d
+  | j t d d g  | j t d d g  t d d
+  } | j d
+  | j t d	 g  | j t d g  | j t d g  | j |  | j d
+ |  | j |  | j d |  | j |  | j d |  | j   } t d
+ d	 d
+ d d	 d
+ d d
+ d
+ d
+ d
+ d d g  } | j d |  t d
+ d
+ d
+ g  }	 | j d
+ |	  t d
+ d g  }
+ | j d |
+  t d
+ d
+ d
+ g  } | j d |  | j d d	  | j d d  | j d d  | j d d g  | j d d g  |  j | j d d g  j t d d d d g    t d d d d d d d g  } | j d  | j |  |  j | j | j    j |   |  j | j d d g  j t d d d d d d d d g    t d d g  } | j d  |  j | j | j    j |   |  j | j d | j    j |   |  j | j d  j t d d	 d d d	 d d d d d d d d g    xN d
+ |	 f d |
+ f d | f g D]+ \ } } |  j | j |  j |   qtW|  j | j    d"  |  j | j!   d#  |  j | j" d  d  |  j | j" d	  d  x9 d$ d% d& d' g D]% \ } } |  j | j" |  |  qW|  j | j# d  d(  t d d g  } | j d  |  j | j d d  j |   | j$ d g  |  j | j d d  j |   | j% | d	  t& j' |  } |  j | j d | j    j |   |  j | j d  j t d d	 d d d	 d d d d d d d d g    xN d
+ |	 f d |
+ f d | f g D]+ \ } } |  j | j |  j |   q~W|  j | j    d)  |  j | j!   d*  |  j | j" d  d  |  j | j" d	  d  x9 d+ d, d- d. g D]% \ } } |  j | j" |  |  qW|  j | j# d  d/  t d d g  } | j d  |  j | j d d  j |   | j$ d g  |  j | j d d  j |   d  S(0   Ns   Pyfile53.medi'   g      ?i   s   aaa [b]s   cc [dd]s   e [fff]R  i   i    i   i   i   i   i   iit   MyFamt
+   MyOtherFams	   MyOther-1t   grp0t   grpAi   i	   i
+   t   grp1i   i   t   Family_4t   Family_5t   Family_7t   Family_8t   FAMILLE_ZERO(   R  R  R  R  R  s	   MyOther-1R  (   s   grp0s   grp1R  (   R  i   (   R  i   (   R  i   (   R  i   (   R  R  (   s   FAMILLE_ZEROR  R  R  R  R  s	   MyOther-1R  (   s   grp0s   grp1R  (   R  i   (   R  i   (   R  i   (   R  i   (   R  R  ((   R>   RY   Ry  Rz  R  R[   R]   R^   R_   R`   Ra   Re   Rg   Rc   Rj   Rq   Rk   R   R   t   setFamiliesOnGroupR0   t   getNodeFamiliesArrR1   RB   t   addNodeGroupt   getNodeGroupArrRC   t   getNodeGroupsArrRM   RG   R   R+   R  R  RL   R   RZ   R   R'   R(   (   R	   R9  R   R  R   R   R   R   R  R  R   R  t   daTestt   expect1R   R  t   famNamet   famIdR   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDUMeshAddNodeGroup1  s    	                 3    7! %C %(L. ""(L. ""c         C   s?  d } t    } t d  } | j d  | j d  | j d d d g  t d d	  } | j d
+  x- t d  D] } | j t	 d d	 d g  qt Wx0 t d  D]" } | j t
+ d d d	 d
+ g  q Wx6 t d	  D]( } | j t d
+ d
+ d d d	 d	 g  q Wt d d  } | j d
+  | j t d d g  | j t d d g  t d d
+  } | j d
+  | j t d	 g  | j t d g  | j t d g  | j |  | j d
+ |  | j |  | j d |  | j |  | j d |  | j   } t d
+ d	 d
+ d d	 d
+ d d
+ d
+ d
+ d
+ d d g  }	 | j d
+ |	  t d
+ d
+ d
+ g  }
+ | j d |
+  t d
+ d g  } | j d |  t d
+ d
+ d
+ g  } | j d |  | j d d	  | j d d  | j d d  | j d d g  | j d d g  t d d d d d d d g  } | j d  | j d
+ |  |  j | j d
+ | j    j |   |  j | j d
+  j t d d	 d d d	 d d d d d d d d g    xN d |
+ f d | f d | f g D]+ \ } } |  j | j |  j |   qW|  j | j   d$  |  j | j   d%  |  j | j d  d  |  j | j d	  d  x9 d& d' d( d) g D]% \ } } |  j | j |  |  q|W|  j | j  d  d*  t d d g  } | j d  |  j | j d
+ d  j |   | j! d g  |  j | j d d  j |   | j" | d	  t# j$ |  } |  j | j d
+ | j    j |   |  j | j d
+  j t d d	 d d d	 d d d d d d d d g    xN d |
+ f d | f d | f g D]+ \ } } |  j | j |  j |   qW|  j | j   d+  |  j | j   d,  |  j | j d  d  |  j | j d	  d  x9 d- d. d/ d0 g D]% \ } } |  j | j |  |  qW|  j | j  d  d1  t d d g  } | j d  |  j | j d
+ d  j |   | j! d g  |  j | j d d  j |   d  S(2   Ns   Pyfile54.medi	   g      ?i   s   aaa [b]s   cc [dd]s   e [fff]R  i   i    i   i   i   i   i   iiR  R  s	   MyOther-1R  R  i
+   i   R  iiiiis	   Family_-4s	   Family_-5s	   Family_-7s	   Family_-8R  (   s	   Family_-4s	   Family_-5s	   Family_-7s	   Family_-8s   MyFams	   MyOther-1s
+   MyOtherFam(   s   grp0s   grp1s   grpA(   s	   Family_-4i(   s	   Family_-5i(   s	   Family_-7i(   s	   Family_-8i(   s
+   MyOtherFams	   Family_-8(   s   FAMILLE_ZEROs	   Family_-4s	   Family_-5s	   Family_-7s	   Family_-8s   MyFams	   MyOther-1s
+   MyOtherFam(   s   grp0s   grp1s   grpA(   s	   Family_-4i(   s	   Family_-5i(   s	   Family_-7i(   s	   Family_-8i(   s	   Family_-8s
+   MyOtherFam(%   R>   RY   Ry  Rz  R  R[   R]   Rn   R^   R_   R`   Ra   Re   Rg   Rc   Rj   Rq   Rk   R   R   R  RB   t   addGroupR0   RG   RC   R1   R   R+   R  R  RL   R   RZ   R   R'   R(   (   R	   R9  R   R  R   R   R   R   R   R  R  R   R  R  R   R  R  R  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDUMeshAddGroup1@  s    	    "          3    ! (L. ""(L. ""c         C   s)  t    } | j   } | j d d  | j   | } ~ ~ t   } t d d  } | j d  | j | |  | j   } | j d  | j	 t
+  } |  j | j   t t d$ d% d |    |  j | j   t t d& d' d	 |    t   } | j d |  |  j | j   t t d( d) d |    t   } | j |  |  j | j   t t d* d+ d, |    t   }	 |	 j |  |  j |	 j   t t d- d. d/ |    | j d d d  |	 j |  |  j |	 j   t t d0 d1 d2 |    |  j |	 d3 j   t t d4 d5 d6 |    | d  }
+ |
+ j d d d  t  j d d d  } | j d  |	 j |
+ | d |  |  j |	 j   t t d7 d8 d9 |    |  j |	 j d  j   t t d: d; d |    |  j |	 d< j   t t d= d> d |    d  S(?   Ni    i   i
+   R   i  id   i   iw  i   i1  i  i  i(   ig  i   i/  i2   i  i   i   i   g      ?ii:  iZ   i  i   g       @R  i,	  i   i0
+  i   i  iF  i|  iD  i  i  i  i  i  i|  i   i  i  i   i  i4  i   (   i    ii  i{  i   i  i
+  i   i   i   (   i   ii  id  (   Rk   t   getHeapMemorySizeRx  R   RY   Ry  Rc   R  RB   RV  RN   t   assertInRm   Rn   R>   Rj   R   R%  R   RY  R   R"  R  R=  (   R	   t   at   aat	   strMulFacR   R  R   R   R   t   fffR   R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testHeapMem1  sJ    	   	 --	-	-	--1
+ -61c         C   si  d } t    } | j d d d  | j d  | j d  | j d  t d d
+  } | j d  | j d  | j |  | j	 d d g  | j
+   t   } | j |  t d	  } | j d  | j d
+ |  t d	  } | j d  | j d
+ |  t d  } | j d  | j d |  t d  } | j d  |  j t | j d
+ |  | j   | j d
+ |  | j | d  t |  }	 |	 j   }
+ |  j |
+ j | d   |  j |
+ j   d  |  j |
+ j   d  t j |  }	 |  j t |	 t   |  j t |	 j   t   |  j t |	 j    d k  |  j |	 j   j | d   d  S(   Ns   Pyfile55.medgffffff@i   i   t   uss   Example of Cuve linear mesht   buildCLMeshi   i   i   g      @i  i   i(   i    i   i  i   g-q=i<   (    t   MEDCouplingCurveLinearMeshR   R   RB   Ri   RY   Ry  Rz  Rc   t   setNodeGridStructureRd   t   MEDFileCurveLinearMeshR   Rk   R   R   R)   R*   t   popBackSilentR   R   R0   R1   R+   t   getSpaceDimensiont   getSpaceDimensionOnNodeStructR'   R(   Rt   R{   R|   Ry   (   R	   R9  R   t   a1R   Re  t   d3Ro  t   d4R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testCurveLinearMesh1  sP    	 
+	    
+c         C   s  d } t    } t d d d g  } | j | |  | j d  t   } | j |  t   } | j |  t   } t	   } | j
+ |  | j |  t   } | j d  | j d  | j d  | j d	 d
+ d d  | j d
+ d d d  | j   }	 |	 j d  |	 j d  | j |  | j |	  | j | d
+  t	 |  }
+ |  j | j |
+ d  d  |  j | d	 d j   d d  | j   } |	 j   } |	 j   } |  j | j |	 d  d  |	 j d g  |  j | j |	 d  d  | d g =|  j | j |	 d  d  |  j t | d	 j d  |  j t | d j d  |  j | d d j   d d  |  j | d d j   d d  | } |  j | j |
+ d  d  |  j |
+ d j | d  d  |  j |
+ d j |	 d  d  |  j |
+ d d j   d d  |  j | j   d  t | d  } |  j | j | d  d  t |  } |  j | j | d  d  t |  } |  j | j   d  |  j | j   d d  t | d  } |  j | j   d  |  j | j   d d  t | d d
+ d  } |  j | j   d  |  j | j   d d  t |  } |  j d
+ | j    |  j | j    d d j   d d  d  S(   Ns   Pyfile56.medg        g333333?g      @R   t   As   An example of parameterR   i   i   g333333@gQ@i   gffffff@gDl8@t   Bs   A second exampleg+=i    i   (   i   i   (   i   i   (   i   i   (   i   i   (   i   i   (   i   i   (   R  R  (   i   i   (!   R   RY   Rc   RB   R   R   RP  R7  RK  t   MEDFileParameterst	   setParamsRR  t   MEDFileParameterMultiTSRi   R   t   appendValueRq   t	   pushParamR   R0   R1   R&  t   getValuet   eraseTimeStepIdsR)   R*   t   __getitem__R+   t   getParamsNamest   MEDFileParameterDouble1TSRC   t   getNumberOfParamst	   getParams(   R	   R9  R   R  R   R   t   dataR   t   ptst   pts2t   p2t   p3t   pts4t   pts3t   ptsrt   p1tsrt   data2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testParameters1  s~    	   	 	 		 	     !
+!!!"!'c         C   s  d } d } t  j   } | j   d } | j   t   } | j d |  | j d |  t d d  } g  t d  D] } d | ^ qw | (| j d |  t j	 | | | j
+ d  g  } g  t d  D] } d	 | ^ q | (| j d |  | j
+ d
+ d  }	 g  t d  D] } d | ^ q|	 (| j d |	  | j | d  t j |  }
+ |  j | j d  j t g  t d  D] } d | ^ q}   |  j | j d  j t g  t d  D] } d	 | ^ q   |  j | j d  j t g  t d  D] } d | ^ q   |  j | j |
+ d  d  |
+ j d  j d d d  |  j | j |
+ d  d  |
+ j d  j d d d  |  j | j |
+ d  d  | j   } |  j | j | d  d  | j d d   |  j | j | d  d  | j d d   |  j | j | d  d  | j d d   | j | d  t j |  }
+ |  j |
+ j d  d   |  j |
+ j d  j t g  t d  D] } d | ^ q   |  j |
+ j d  d   t   } t d d d g  } | j | |  | j d  t   } | j |  | j d t g  t d
+  D] } d | ^ q?  | j d t g  t d  D] } d | ^ qr  | j | d  t j |  } |  j | j d  j t g  t d
+  D] } d | ^ q   |  j | j d  j t g  t d  D] } d | ^ q   |  j | j | d  d  | j d  j d d d  |  j | j | d  d  | j d  j d d d  |  j | j | d  d  | j   } |  j | j | d  d  d  S(   Ns   Pyfile58.meds   Pyfile59.medi    ii   i   s   CellL0#%.3d      i   s   CellLM1#%.3d     i   i   s   Node#%.3d        i   g-q=t   Mt   Ng        g?gffffff@t   cmeshs   Cell#%.3d        i	   (   R   t   build3DSurfMesh_1R  R  R>   Rj   t   DataArrayAsciiCharRn   t   setNameFieldAtLevelt	   Aggregatet   subArrayR   R'   R(   R0   t   getNameFieldAtLevelR1   R   Rq   R/  R+   R   RY   Rc   RB   R   R   (   R	   R9  Rn  R   R   R   t   namesCellL0R   t   namesCellL1t
+   namesNodest   mmrR   R   R  t   cct   ccrt   ccCpy(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt    testNamesOnCellAndNodesInMeshes1
+	  sv    
+	$!$$BBBB		33BBc         C   s  t    } t d d d d d g  } | j | |  | j   } | j d  t d d d	 d
+ d d d d d d d d g  } | j d  t d d d d g  } | j d  | j   } t   } | j d |  | j d |  | j	 d | | g  | j
+ d d	  | j d  } | j d  } | j d d  } | j d d  } | | g }	 t | j    }
+ |
+ j d  x$ t |	  D] \ } } | |
+ | <qW| j   \ } } } } } | j | d	  \ } } |  j |  t j | | |  \ } } |  j | j   j d   | j |
+  t |	  d  g } x3 t |	  D]% \ } } | j |  } | | | <qBW| d j t d d d	 d d d d d d d g
+   | d j t d
+ d d d d d g   d  S(   Ng        g      ?g       @g      @g      @R   i    i   i   i   i   i   i   i	   i
+   i   i   i   R  i   i   i   i   R  is   example.med(   R   RY   Rc   R  RB   Rk   t   computeSkinR>   Rj   Rl   R   R}   RG   R   t   fillWithValueR   R  t   areCellsIncludedInR0   R[   t   ExtractFromIndexedArrayst   deltaShiftIndext	   isUniformt   transformWithIndArrRy   R/  t   findIdsEqualR1   (   R	   R   R  R  R  R   R   R   R   t   grpst   whichGrpt   grpIdR  R  t   bt   bIR   t   cIR   R   t   c2t   c2It	   splitOfM1R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testToExportInExamples1K	  sN    	 0  	
+
+5)c         C   sD   t    } | j d  |  j | d d   |  j d t |   d  S(   Ni   i    (   R[  R  R+   R/  Ry   (   R	   Rl  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testBugCorrection1r	  s
+    	c         C   s{  d } d } t  j   } | j | d  t  j   } | j | d  t |  } t |  } x | j   j   D] } | j   | } | j   | } xb | j   D]T } | j |  }	 x< |	 D]4 }
+ |  j | j	 | |
+  j
+ | j	 | |
+    q Wq Wqo Wxv| j   j   D]b} | j   | } | j   | } x9| j   D]+\ } } } | | | f } | | | f } t | j    d k rx | j   d D]k } | j t | |  \ } } | j t | |  \ } } |  j | j
+ |   |  j | j
+ | d   qWqDx^ | j   d D]L } | j t | |  } | j t | |  } |  j | j
+ | d d   qWqDWqWd  S(   Ns   Pyfile60.meds   Pyfile61.medi   i    i   g|=(   R   t1   buildACompleteMEDDataStructureWithFieldsOnCells_1R   RK  RT  RU  R,   R   R0   RG   R1   Ra  Rb  R   Ry   R<  R~  R  R  (   R	   t   f1Namet   f2Namet   d1Ro  t   mnR   R   R   t	   grpsNamest   grpNamet   fieldnR   R   Rv  t   orderRw  t   f1tt   f2tRz  Ry  t   arr2RE  t   f1mct   f2mc(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt.   testCompareMEDFilesContainingOnlyFieldsOnCell1y	  sP     .c         C   s	  t    } t d d d d d g  } | j | | |  | j   } | j   d } | j d  t d d d	 d
+ g  } | j d  t d	 d
+ d d g  } | j d  t d d d d g  } | j d  t d d d d g  } | j d  t d d d d g  } | j d  t d d d d g  }	 |	 j d  t   }
+ |
+ j d |  |
+ j	 d | | g  t
+ |
+ j d   } t
+ |
+ j d   } |  j |
+ j d  d   |  j |
+ j d  d!  |
+ j   |  j |
+ j d  d"  |  j |
+ j d  d#  |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    xD |
+ j d  D]3 } x* |
+ j |  D] } |  j | d k   qWqWt   }
+ |
+ j d |  |
+ j d |  |
+ j	 d | | g  |
+ j	 d | | g  t
+ |
+ j d   } t
+ |
+ j d   } t
+ |
+ j d   } t
+ |
+ j d   } |  j |
+ j d  d$  |  j |
+ j d  d%  |  j |
+ j d  d&  |  j |
+ j d  d'  |
+ j   |  j |
+ j d  d(  |  j |
+ j d  d)  |  j |
+ j d  d*  |  j |
+ j d  d+  |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    x[ d d g D]M } xD |
+ j |  D]3 } x* |
+ j |  D] } |  j | d k   qWqpWqZWt   }
+ |
+ j d |  |
+ j d |  |
+ j	 d | | g  |
+ j	 d | | g  |
+ j	 d | |	 g  t
+ |
+ j d   } t
+ |
+ j d   } t
+ |
+ j d   } t
+ |
+ j d   } t
+ |
+ j d   } t
+ |
+ j d   } |  j |
+ j d  d,  |  j |
+ j d  d-  |  j |
+ j d  d.  |  j |
+ j d  d/  |  j |
+ j d  d0  |  j |
+ j d  d1  |
+ j   |  j |
+ j d  d2  |  j |
+ j d  d3  |  j |
+ j d  d4  |  j |
+ j d  d5  |  j |
+ j d  d6  |  j |
+ j d  d7  |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j |
+ j d d  j |   |  j |
+ j d d  j |	   |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    |  j | t
+ |
+ j d    x[ d d g D]M } xD |
+ j |  D]3 } x* |
+ j |  D] } |  j | d k   q	Wqs	Wq]	WxD |
+ j d  D]3 } x* |
+ j |  D] } |  j | d k  q	Wq	Wd  S(8   Ng        g      ?g       @g      @g      @i    R   i   i   i   R  i   i   R  i   i   i   i   t   g1Facei   i   t   g2Facei
+   i   i   i   t   g1Nodei   i   t   g2Nodei(   i    (   i    (   i    (   i    (   i    (   i    (   i(   i(   i    (   i    (   i(   i(   i    (   i    (   i(   i(   i   (   i   (   i    (   i    (   i(   i(   i   (   i   (   R   RY   Rc   R  R  RB   Rk   R>   Rj   Rl   R  R   R+   R   t   normalizeFamIdsMEDFileR0   RG   R1   R   t   getFamiliesIdsOnGroup(   R	   R   R  R   R  R  R  R  R  R	  R   t   s1t   s2R  R   t   s3t   s4R   t   s5t   s6(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt$   testNonRegBugNormalizeFamIdsMEDFile1	  s    	      	 
+""	  
+""""	   
+""""""c         C   si  d } t  j   \ } } } } } } } }	 }
+ } } } } } t j   } | j | j    | j d |  | j d |  | j d |  | j d |  | j d |  | j d |  | j d |  t |  } x, t	 |  D] } | j
+ | | | |  q Wt |  } x, t	 |  D] } | j | | | |  qW| j | j    | j | j    | j | d  t j |  } t j |  } t | d  } x" | D] } | j | | d  qW| j | d  ~ t j |  } xw | D]o } xf | j |  D]U } | j | |  } | j | | d  } | j | d  |  j | j |   qWqWd  S(	   Ns   Pyfile62.medi    iii   i   t   maR  (   R   R   R>   R(   Rc   R   Rj   R   Ry   Rn   R   R   RB   RC   Ri   R~   R   R'   t   GetMeshGroupsNamest   changeGroupNameR   RG   R0   R1   (   R	   R!   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R:  t   groupNamesIniRh  R   R   t   arr0R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt)   testNonRegressionMantis22212ChangeGrpName
+  sP    6c      	   C   s
+  d } t  j   } | j   } | j   } t j   } | j | j    | j d |  | j	 | j
+    | j | d  t   } | j |  | j d t |  } |  j | j   j   d d d g  |  j | j | d d   | j | d  | j   \ } } |  j | j   | j   j    |  j | d' d( f d) d* f d+ d, f d- d. f g  t j |  } |  j | j
+   d  |  j | j   d d d g  |  j t | t   | j t d |  } |  j | j   j   d d d g  |  j | j | d d   | j d d d  | j   }	 |	 d 9}	 | j | d  t j | d  }
+ |  j |
+ j   d/ d0 g  |  j t |
+  d  |  j t |
+ t   |
+ d j t d |  } |  j | j | d d   |
+ j t d d d |  } |  j | j | d d   |
+ j    } | j!   | j!   } | j d t |  } |  j | j   j d | j     | j d d d  | j   d 9(|  j | j | d d   | j   d :(t" d
+ d  } d | (| j# d d d g  x3 |
+ D]+ } | j t d |  } | | j   7} qW|  j | j d | j     t$ t%  } | j d d d  | j& | j    t" d d  } | j# d d g  t' t( d   | d  d   d f <d | d  d   d f | d  d   d f <| j	 d  | j) |  t j   } | j |  |  j | j*   d1  |  j | j   d d d g  | j | d  t$ t%  } | j d d d  | j& | j    t" d d  } | j# d d g  t' t( d   | d  d   d f <| d  d   d f c d 7<d | d  d   d f | d  d   d f <| j	 d  | j	 | j
+    | j) |  t j   } t" d d d	 d d
+ d d d g  } | j	 d   | j+ | | d |  | j, t% d |  | j, t% d |  \ } } | j	 | j
+    |  j | j |   |  j | j |   | j | d  t | d  } | j, t% d |  \ } } | j	 | j
+    |  j | j |   |  j | j |   t- t%  } | j	 d!  | j d" d# d$  | j& | j    | j) | j   j    t. j   } | j |  | j | d  t/ |  } |  j t |  d	  g  | D] } | ^ q#} |  j t | d t   |  j t | d t   |  j t | d t0   |  j t | d t   |  j | d d j   j1 | j     |  j | d d2 j   j1 d | j     |  j | d d j   j1 |   |  j | d d j   j1 |   |  j | d! d" j   j1 | j   j   d   t0 | d!  } |  j | d" j   j1 | j   j   d   |  j2 t3 t j | d!  |  j2 t3 t0 j | d  t. j | d! d# d$  |  j2 t3 t j | d! d# d$  t j | d d d  |  j2 t3 t. j | d d d  |  j | j4   d3  |  j | j5 d4 g   |  j | j4   d5  |  j | j5 d6 g   d  S(7   Ns   Pyfile63.medi    i   s   power [MW/m^3]s   density [g/cm^3]s   temperature [K]g-q=i   i   i   i   R   i   g       @g      @g      "@i
+   ii   s   aa [u1]s   bbbvv [ppp]R  g      3@i   ii   s
+   aapfl [u1]s   bbbvvpfl [ppp]t   VectorFieldOnNodesPfli   i   t   npflt   VectorFieldOnNodesDoubleg      =@i   iR  t
+   3DSurfMesh(   i   i    (   i    i   (   i   i    (   i   i   (   i   i    (   i   i   (   i   i    (   i   i   (   i    i   g       @(   i   i   g      @(   s   aa [u1]s   bbbvv [ppp](   i   i   (   s   3DSurfMesh_1s   3DSurfMesh_1s   3DSurfMesh_1s   3DSurfMesh_1(   s   3DSurfMesh_1R  (   R  R  R  R  (   s   3DSurfMesh_1R  (6   R   R$  t   convertToIntFieldR   R>   R(   Rc   R   Rj   RB   RC   R   t   MEDFileIntField1TSR%  R  R  R+   R)  t   getInfoOnComponentsR0   R1   R(  t   getHiddenCppPointerR+  t   MEDFileAnyTypeField1TSR   Rt   R   t   MEDFileAnyTypeFieldMultiTSR   Ry   t   MEDFileIntFieldMultiTSt   __iter__t   nextRk   R  t   MEDCouplingFieldIntR  R   Rm   Rn   R{  t   getInfoR|  R~  Rw  R   R[  R   R  R)   R*   RU  t   changeMeshNames(   R	   R9  R   R   R:  R;  R  R  RC  R   t   ffs1Rv  t   ff2bist   bct   nf1t   narrt   nff1t   nf2t   narr2t   nff2R  t   nff2bist   nf3t   nff3Rl  R  t   nf3_read(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testInt32InMEDFileFieldStar1C
+  s    	%"4% 
+ 
+ &       " *   "  *  $   *.$$3/c   	      C   s  d } t  t  } | j d d d  | j d  t d  } | j   t   } | j d |  | j d  t	   } | j
+ |  | j | d  | j
+ |  t d d  } | j d	 d
+ g  t t d   | d  d   d f <d | d  d   d f | d  d   d f <| j |  | j d  t j   } | j |  |  j | j   d  | j | d  | j d d d  t j   } | j |  | j | d  | j d d d  t j   } | j |  | j | d  |  j t |  j   d d d g t f  t | d  } | j d  | j | d  |  j t |  j   d d d g t f  | j d d d  t j   } | j |  | j | d  |  j t |  j   d d d g t f  |  j t |  j d g  j   d g t f  |  j t |  j d g  j   d d g t f  | j d  | j d d d  t j   } | j |  | j | d  |  j t |  j   d  d! d" d# g t f  |  j t |  d j   d  d  S($   Ns   Pyfile64.medgMbP?i    iR  i   R   i   s   aa [u1]s   bbbvv [ppp]i   R  gjt?g5^I @R  g5^I@i   (   i    i(   i   i(   i   i(   i    i(   i   i(   i   i(   i    i(   i   i(   i   i(   i   i(   i   i(   i   i(   i    i(   i   i(   i    i(   i   i(   i   i(   i   i(   Rw  R  R   R   RY   Ry  R   R   RB   R   R   R   R  Rm   Rn   R{  R   R(   R%  R+   t	   getDtUnitR[  t   getCommonIterationsRN   R   R.   t#   partOfThisLyingOnSpecifiedTimeStepst&   partOfThisNotLyingOnSpecifiedTimeSteps(	   R	   R9  R   R   R   R   R  R;  t   ff1s(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFields1
+  sf      
+ 	  	    " *      ++   +14    . c      
+   C   sN  d } t    j   t   j   t d d  } | j   | j t d d d g  | j t d( d) d* g   g  t	 d  D] } | j
+   ^ q{ } x- t |  D] \ } } | j | d g  q Wt j |  } t d	 d  } | j   | j t d d d d
+ g  | j t d+ d, d- d. g   g  t	 d  D] } | j
+   ^ q3} x1 t |  D]# \ } } | j d | d g  qXWt j |  } t j | |  } | j d  | j   j d d g  t   }	 t   }
+ xt	 d  D]} d d g } d } t d  } | j | d  | j d  | j |  t t  } | j |  | j |  | j |  | j t | d  d | d | d  |	 j |  t    } | j |  |
+ j |  |  j |
+ j   |  |  j |	 j   d/  |  j |
+ j   d0  | d k r| j d d g  |  j  t! |	 j |  |  j  t! | j" d g  | j" d d g  |  j  t! |
+ j |  qqW|	 j
+   } |	 j
+   } |	 j
+   } |	 j#   } |  j$ t% |	  d k o t% |
+  d k o t% |  d k o t% |  d k o t% |  d k o t% |  d k  | d  d  d  =|  j$ t% |  d k oj| j&   d1 d2 d3 d4 d5 g k  | d d6 d g =|  j$ t% |  d k o| j&   d7 d8 d9 d: d; d< d= g k  | d d> d g } |  j$ t' | t   |  j$ t% |  d
+ k o| j&   d? d@ dA g k  | d  d  d   } |  j$ t' | t   |  j$ t% |  d k ow| j&   dB dC dD dE g k  t(   } | j) |	  | j d%  | j) |  | j d&  | j) |  | j d'  | j) |  |  j$ t% |  d k o| j*   dF k  | j+ | d  t( |  } |  j | j,   dG dH dI g t- f  | j. | j,   d  } |  j$ | j*   dJ k o| j,   dK dL dM g t/ f k  | d% d
+ g =|  j$ | j*   dN k o| j,   dO dP dQ g t/ f k  | d d' g } |  j$ t' | t(   |  j | j*   dR  t0   } | j1 d |  | j+ | d  d  S(S   Ns   Pyfile65.medt   trii   i    i   g        g      ?i   t   quadi   i   R   s   XX [m]s   YYY [km]i
+   s   aa [bb]s	   ccc [ddd]t   1stFieldi   g?s   eee [dd]iii   ii   iig?i	   i   iiiiit   2ndFieldt   3rdFieldt   4thField(   g        g        (   g        g      ?(   g      ?g        (   g        g        (   g        g      ?(   g      ?g      ?(   g      ?g        (   s   aa [bb]s	   ccc [ddd](   s   aa [bb]s	   ccc [ddd](   i   i(   i   i(   i   i(   i   i(   i
+   i(   i   i(   i   i(   i   i(   i   i(   i   i(   i   i(   i   i(   i	   i(   i   i(   i   i(   i   i(   i	   i(   i
+   i(   i   i(   i   i(   i   i(   R?  R@  RA  RB  (   i   i(   i   i(   i   i(   R?  R@  RA  RB  (   i   i(   i   i(   i   i(   R?  RA  (   i   i(   i   i(   i   i(   R?  RB  (2   R   t   __str__R   R[   R]   R^   R_   Rc   RY   Rn   Rq   R   R  R[  R`   RB   R   R  Ry  Rz  Rw  R  R{  R   R   t   floatRY  R%  t   pushBackTimeStepR+   RC   R'  R)   R*   t   setInfot
+   shallowCpyR0   Ry   R  Rt   R[  R\  Rb  R   R8  R.   R9  RN   R>   Rj   (   R	   R9  R=  R   t   trisR   R>  t   quadsR   t   fmts0_0t   fmts0_1t   infos1t   name1Re  R   R   t   fmts0_2t   fmts0_3t   fmts0_4t   fmts0_5t   fmts0_6t   fmts0_7t   fs0t   fs1t   fs2R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFields2
+  s    
+ % 
+ %  		       *	  s:@47	   +%::	  c      	   C   s  d } t  d d  } | j   | j t d d d g  | j t d! d" d# g   g  t d  D] } | j   ^ qa } x- t |  D] \ } } | j	 | d g  q Wt  j
+ |  } t  d	 d  } | j   | j t d d d d
+ g  | j t d$ d% d& d' g   g  t d  D] } | j   ^ q} x1 t |  D]# \ } } | j	 d | d g  q>Wt  j
+ |  } t  j
+ | |  } | j d  | j   j d d g  t   }	 |	 j d |  |	 j | d  t d d d d
+ d d d g  }
+ |
+ j d  t d d d d
+ d d d d g  } | j d  t   } t   } x(t d  D]} d d g } d } t d  } | j | d  | j d  | j |  t t  } | j |  | j |  | j |  | j t | d  d | d | d  | j | |	 d |
+  t   } | j | |	 d |
+  | j |  |  j  | j!   d(  |  j  | j!   d)  qSW|  j  | j"   d d*  |  j  | j"   d+  | j#   |  j  | j"   d,  |  j$ | j% d  j& | j% d    | j   } | j   } | j   } t'   } | j( |  | j d  | j( |  | j d  | j( |  | j d  | j( |  |  j  | j"   d-  t   } x t d  D] } d d g } d } t d  } | j | d  | j d  | j |  t t  } | j |  | j |  | j |  | j t | d  d | d | d  t   } | j | |	 d |  | j |  qW| j d  | j( |  |  j  | j"   d.  | j)   | j | d  d  S(/   Ns   Pyfile66.medR=  i   i    i   g        g      ?i   R>  i   i   R   s   XX [m]s   YYY [km]i   R  i   RE  i
+   s   aa [bb]s	   ccc [ddd]R?  i   g?t   pfl_NORM_QUAD4R@  RA  RB  i   i   t   5thFieldt   pfl2_NORM_QUAD4(   g        g        (   g        g      ?(   g      ?g        (   g        g        (   g        g      ?(   g      ?g      ?(   g      ?g        (   s   aa [bb]s	   ccc [ddd](   s   aa [bb]s	   ccc [ddd](   RX  (   RX  (   RX  (   RX  (   RX  RZ  (*   R[   R]   R^   R_   Rc   RY   Rn   Rq   R   R  R[  R`   RB   R   R  R>   Rj   R   Rk   R   Ry  Rz  Rw  R  R{  R   R   RD  R  R   R|  RE  R+   R'  R]  t   zipPflsNamesR0   R=  R1   R[  R\  t   checkGlobsCoherency(   R	   R9  R=  R   RH  R   R>  RI  R   R   R  RE  RJ  RK  RL  RM  Re  R   R   RN  RO  RP  RT  RQ  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFields3&  s    
+ % 
+ %  	  ! $ 		       *	  
+(	   	       *	   
+c      	   C   sI  d } t  d d  } | j   | j t d d d g  | j t d  d! d" g   g  t d  D] } | j   ^ qa } x- t |  D] \ } } | j	 | d g  q Wt  j
+ |  } t  d	 d  } | j   | j t d d d d
+ g  | j t d# d$ d% d& g   g  t d  D] } | j   ^ q} x1 t |  D]# \ } } | j	 d | d g  q>Wt  j
+ |  } t  j
+ | |  } | j d  | j   j d d g  t   }	 |	 j d |  |	 j | d  t d d d d
+ d d d g  }
+ |
+ j d  t d d d d
+ d d d d g  } | j d  t   } t   } d d d g } x t d  D] } d } t d  } | j | d  | j d
+  | j |  t t  } | j |  | j |  | j |  | j t | d  d | d | d  t   } | j | |	 d |
+  | j |  |  j  | j!   t" |   qbW| j# |  |  j  d t$ |   | j%   } |  j  d
+ t$ |   x$ | D] } |  j  d t$ |   qWx$ | D] } |  j& t' | t   qWx> | D]6 } | j d | j(   t) j* | j!   d  f  qW| j+ |  |  j  d t$ |   x$ | D] } |  j  d t$ |   qLW|  j  | j,   d'  |  j  | j-   d(  | j | d  ~ t |  } |  j  | j,   d)  |  j  | j-   d*  |  j  d t$ |   xIt d  D];} x t d d d g  D] \ } } | | | } | j. t d |	  } t d  } | j | d  | j d
+  | d  d   | f } | j/ d | |  |  j& | j0 | j1   d   q"W| d | } | j. t d |	  } t d  } | j | d  | j d
+  | j |  |  j& | j0 | j1   d   qWd  S(+   Ns   Pyfile67.medR=  i   i    i   g        g      ?i   R>  i   i   R   s   XX [m]s   YYY [km]i   R  i   RE  s   aa [bb]s	   ccc [ddd]s   ZZZZ [MW*s]i
+   R?  i   g?s   %s_%sRX  t   1stField_aat   1stField_ccct   1stField_ZZZZgvIh%<=(   g        g        (   g        g      ?(   g      ?g        (   g        g        (   g        g      ?(   g      ?g      ?(   g      ?g        (   s   pfl_NORM_QUAD4(   s   pfl_NORM_QUAD4(   s   pfl_NORM_QUAD4(   s   pfl_NORM_QUAD4(2   R[   R]   R^   R_   Rc   RY   Rn   Rq   R   R  R[  R`   RB   R   R  R>   Rj   R   Rk   R[  R   Ry  Rz  Rw  R  R{  R   R   RD  R   R|  RE  R+   R'  t   tupleR\  Ry   t   splitComponentsR0   Rt   RC   t	   DataArrayt   GetVarNameFromInfot
+   pushFieldsR]  R<  R  R   R1   R)  (   R	   R9  R=  R   RH  R   R>  RI  R   R   R  RE  Rl  RK  RL  RM  Re  R   R   R   RU  t   jt	   fieldName(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testSplitComponents1g  s    
+ % 
+ %  	  ! $ 		      *	    0  "       c         C   s	  d } t  d d  } | j   | j t d d d g  | j t d% d& d' g   g  t d  D] } | j   ^ qa } x- t |  D] \ } } | j	 | d g  q Wt  j
+ |  } t  d	 d  } | j   | j t d d d d
+ g  | j t d( d) d* d+ g   g  t d  D] } | j   ^ q} x1 t |  D]# \ } } | j	 d | d g  q>Wt  j
+ |  } t  j
+ | |  } | j d  | j   j d d g  t   }	 |	 j d |  t   }
+ t t t  } | j |  t | j   d  } | j   | j d  | j d d g  | j |  | j d  | j   |
+ j |  d
+ d d, d d f g f d d d- d d f g f g } |  j |
+ j   |  |
+ j   } |  j | j   |  |  j | j    j! | j"     | j#   } |  j | j"   j! |
+ j"   d   |  j | j   |  ~ ~ ~
+ ~ ~ ~ t   }
+ t t t  } | j | d   t d.  } | j   | j d  | j d d g  | j |  | j d  | j   t$ j% d d d  } | j d  |
+ j& | |	 d |  d
+ d d/ d d f g f d d d0 d d f g f g } |  j |
+ j   |  |
+ j   } |  j t' | t(   |  j | j   |  |  j | j    j! | j"     | j#   } |  j t' | t   |  j | j"   j! |
+ j"   d   |  j | j   |  t)   }
+ t t t  } | j | d   t d1  } | j   | j d  | j d d g  | j |  | j d  | j* d d d  | j   |
+ j+ | |	 d |  t t t  } | j | d   t d2  } | j d  | j d  | j d d g  | j |  | j d  | j* d d d   | j   |
+ j+ | |	 d |  t t t  } | j | d   t d3  } | j d!  | j d  | j d d g  | j |  | j d  | j* d" d d#  | j   |
+ j+ | |	 d |  |
+ j   } |  j t' | t,   |  j | j-   d4 d5 d6 g  x t. d d d! g | j-    D]c \ } \ } } } |  j | j | |  |  | j" | |  } | j/ t$ j% | | d d   qZW|  j | j0   d7  |	 j1 | d  | j1 | d  | j#   } |  j t' | t)   |  j | j-   d8 d9 d: g  x t. d d d! g | j-    D]l \ } \ } } } |  j | j | |  |  | j" | |  } | j/ t$ j% | | d d  j2   d$  qWW|  j | j0   d;  t3 j4 | d  } |  j t' | t,   |  j | j-   d< d= d> g  x t. d d d! g | j-    D]c \ } \ } } } |  j | j | |  |  | j" | |  } | j/ t$ j% | | d d   qC	W|  j | j0   d?  d  S(@   Ns   Pyfile68.medR=  i   i    i   g        g      ?i   R>  i   i   R   s   XX [m]s   YYY [km]s   X [km]s   YY [mm]t	   FieldCellR&   i	   gvIh%<=i   s   XX [pm]s   YYY [hm]t   FieldCellPflR  RX  t   FieldCellMTimeg?i
+   id   g?i   i   g @i   g+=(   g        g        (   g        g      ?(   g      ?g        (   g        g        (   g        g      ?(   g      ?g      ?(   g      ?g        (   i    i   (   i   i	   i   (   i    i   (   i   i   i   i   i   (   i    i
+   g?(   i   i   g?(   i   i   g @(   s   pfl_NORM_QUAD4s   pfl_NORM_QUAD4s   pfl_NORM_QUAD4(   i    i
+   g?(   i   i   g?(   i   i   g @(   s   pfl_NORM_QUAD4s   pfl_NORM_QUAD4s   pfl_NORM_QUAD4(   i    i
+   g?(   i   i   g?(   i   i   g @(   s   pfl_NORM_QUAD4(5   R[   R]   R^   R_   Rc   RY   Rn   Rq   R   R  R[  R`   RB   R   R  R>   Rj   R   Rw  R  RX  R   R   Ry  Rz  R{  Rd   R%  R+   R  t   convertToIntR0   t   convertToIntArrR1   R+  t   convertToDoubleRk   R"  R|  Rt   R  R   R   R  R#  R   RS  R  R]  R   t   convertToDblArrR"  R(   (   R	   R9  R=  R   RH  R   R>  RI  R   R   RB  R   R  t   fspExpt   ff0iR;  R  t   deltRu  Rv  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldConvertTo1  s   
+ % 
+ %  	 	   
+    
+6"%	   
+    
+ 6"%	   
+     
+        
+        
+4 4)4 c      	   C   s	  d } t    } | j   } | j d d  | j   | } ~ ~ t d d  } | j   | j t d d d g  | j t d5 d6 d7 g   g  t	 d  D] } | j
+   ^ q } x- t |  D] \ } } | j | d g  q Wt j |  } t d	 d  }	 |	 j   |	 j t d d d d
+ g  |	 j t d8 d9 d: d; g   g  t	 d  D] } |	 j
+   ^ qT}
+ x1 t |
+  D]# \ } } | j d | d g  qyWt j |
+  }
+ t j | |
+  } | j d  | j   j d d g  t   } | j d |  | j | d  t   } t t t  } | j |  t | j   d  } | j   | j d  | j d d g  | j |  | j d  | j   | j |  | j | d  d
+ d d< d d f g f d d d= d d f g f g } |  j  | j!   |  t   } t t t  } | j | d   t d>  } | j   | j d  | j d d g  | j |  | j d  | j   t  j" d d d  } | j d  | j# | | d |  d
+ d d? d d f g f d d d@ d d f g f g } |  j  | j!   |  | j | d  t | t$  } |  j  | j%   d  |  j& | j'   j(    |  j  | j'   j)   d d g  | j   } |  j* | t+ t	 d d d |    | j,   t d  } | j   | j d  |  j& | j'   j- | d   |  j  | j   | dB  t | d t$  } |  j  | j'   j)   d d g  | j   } |  j* | t+ t	 d  d! d" |    | j,   t d#  } | j   | j d  |  j& | j'   j- | d   |  j  | j   | dD  | j,   |  j& | j'   j- | d   |  j  | j   | dF  | j'   j. d d d$  |  j& | j'   j- | d   | j,   |  j& | j'   j- | d   | j'   j. d d d$  |  j& | j'   j- | d   | j/   |  j  | j'   j0 d d  d$  |  j& | j'   j- | d   | j   } |  j* | t+ t	 d% d& d |    | j1   | j   | } |  j  | d'  | j,   |  j  | j   | d  t | d d( d( t$  } | j   } |  j* | t+ t	 d) d* d" |    | j,   |  j& | j'   j- | d   |  j  | j   | dH  d+ } t2   } x t	 d,  D] } t t t  } | j |  t | j   d  } | j t3 | d-   | j d  | j d d g  | j |  | j |  | j4 t3 |  d. | d# |  | j   | j5 |  q5W| j | d  t6 j7 | | t$  } | j   } |  j* | t+ t	 d/ d0 dJ |    | j,   |  j  | j   | dM  ~ t8 | t$  } | j   } |  j* | t+ t	 d3 d4 dN t9 |  |    | j,   |  j  | j   | dQ dS dU  d  S(V   Ns   Pyfile69.medi    i   R=  i   g        g      ?i   R>  i   i(   R   s   XX [m]s   YYY [km]s   X [km]s   YY [mm]Ri  R&   i   iF   i2   s   XX [pm]s   YYY [hm]Rj  R  RX  i   i  i   g+=i   i^  iX  i   id   g      @iL  ix  iii+  il  t   FieldCellMultiTSi   i  g?i  i#  iP   i   i  i/'  (   g        g        (   g        g      ?(   g      ?g        (   g        g        (   g        g      ?(   g      ?g      ?(   g      ?g        (   i    i   (   i   iF   id   (   i    i   (   i   i2   i0  i`  i  i   i  i   i  i   ij   ik   ix  i+  iW  i   ix  i+  iW  i0  i`  i  i   (:   Rk   R  Rx  R[   R]   R^   R_   Rc   RY   Rn   Rq   R   R  R[  R`   RB   R   R  R>   Rj   R   R   Rw  R  RX  R   R   Ry  Rz  R{  Rd   R%  R+   R  R"  R|  RN   RC   R0   R+  t   isAllocatedR  R  Rm   t
+   loadArraysR  R   t   loadArraysIfNecessaryR  t   unloadArraysR   RD  R   RY  R"  R(   R[  Ry   (   R	   R9  R  R  R  R=  R   RH  R   R>  RI  R   R   RB  R   R  Rp  R  t   heap_memory_reft   hmdRg  R   R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldPartialLoading  s   	   
+ % 
+ %  	  	   
+    
+6	   
+    
+ 6"'
+ 
+ "'
+ 
+ 
+ 
+ 
+" '
+
+'
+	       !
+'
+1
+"c         C   s  t    } |  j | j   oT | j   oT | j   oT | j   oT | j   oT | j    | j   | j	   t  d  } |  j | j   o | j   o | j   o | j   o | j   o | j    t  d  } |  j | j   o)| j   o)| j   o)| j   o)| j   o)| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   oH| j   oH| j   oH| j   oH| j   oH| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   od| j   od| j   od| j   od| j   od| j    t  d	  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d
+  } |  j | j   o#| j   o#| j   o#| j   o#| j   o#| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o?| j   o?| j   o?| j   o?| j   o?| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   oX| j   oX| j   oX| j   oX| j   oX| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   ov| j   ov| j   ov| j   ov| j   ov| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o3| j   o3| j   o3| j   o3| j   o3| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   oL	| j   oL	| j   oL	| j   oL	| j   oL	| j    t  d  } |  j | j   o	| j   o	| j   o	| j   o	| j   o	| j    t  d  } |  j | j   o	
+| j   o	
+| j   o	
+| j   o	
+| j   o	
+| j    t  d  } |  j | j   og
+| j   og
+| j   og
+| j   og
+| j   og
+| j    t  d  } |  j | j   o
+| j   o
+| j   o
+| j   o
+| j   o
+| j    t  d  } |  j | j   o"| j   o"| j   o"| j   o"| j   o"| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d   } |  j | j   o8| j   o8| j   o8| j   o8| j   o8| j    t  d!  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d"  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d#  } |  j | j   oV| j   oV| j   oV| j   oV| j   oV| j    t  d$  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d%  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d&  } |  j | j   oq| j   oq| j   oq| j   oq| j   oq| j    t  d'  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d(  } |  j | j   o,| j   o,| j   o,| j   o,| j   o,| j    t  d)  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d*  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d+  } |  j | j   oG| j   oG| j   oG| j   oG| j   oG| j    t  d,  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d-  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d.  } |  j | j   o_| j   o_| j   o_| j   o_| j   o_| j    t  d/  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d0  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d1  } |  j | j   ow| j   ow| j   ow| j   ow| j   ow| j    t  d2  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d3  } |  j | j   o3| j   o3| j   o3| j   o3| j   o3| j    t  d4  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d5  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d6  } |  j | j   oK| j   oK| j   oK| j   oK| j   oK| j    t  d7  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d8  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d9  } |  j | j   ob| j   ob| j   ob| j   ob| j   ob| j    t  d:  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d;  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d<  } |  j | j   ox| j   ox| j   ox| j   ox| j   ox| j    t  d=  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d>  } |  j | j   o1| j   o1| j   o1| j   o1| j   o1| j    t  d?  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d@  } |  j | j   o| j   o| j   o| j   o| j   o| j    t  d@  } | j
+ t  |  j | j   d?  | j
+ t  |  j | j   d@  | j t  |  j | j   d>  | j t  |  j | j   d@  | j t  |  j | j   d<  | j t  |  j | j   d@  | j t  |  j | j   d8  | j t  |  j | j   d@  | j t  |  j | j   d0  | j t  |  j | j   d@  | j t  |  j | j   d   | j t  |  j | j   d@  d  S(A   Ni    i   i   i   i   i   i   i   i   i	   i
+   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   i)   i*   i+   i,   i-   i.   i/   i0   i1   i2   i3   i4   i5   i6   i7   i8   i9   i:   i;   i<   i=   i>   i?   (   t   MEDFileMeshReadSelectorR0   t   isCellFamilyFieldReadingt   isNodeFamilyFieldReadingt   isCellNameFieldReadingt   isNodeNameFieldReadingt   isCellNumFieldReadingt   isNodeNumFieldReadingRC  t   __repr__t   setCellFamilyFieldReadingRN   R+   t   getCodeR.   t   setNodeFamilyFieldReadingt   setCellNameFieldReadingt   setNodeNameFieldReadingt   setCellNumFieldReadingt   setNodeNumFieldReading(   R	   t   mrs(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileMeshReadSelector1}  s<   	O
+ 
+UTTSTSSRTSSRSRRQTSSRSRRQSRRQRQQPTSSRSRRQSRRQRQQPSRRQRQQPRQQPQPPOc         C   s
+  d } t  d d  } | j   | j t d d d g  | j t d! d" d# g   g  t d  D] } | j   ^ qa } x- t |  D] \ } } | j	 | d g  q Wt  j
+ |  } t  d	 d  } | j   | j t d d d d
+ g  | j t d$ d% d& d' g   g  t d  D] } | j   ^ q} x1 t |  D]# \ } } | j	 d | d g  q>Wt  j
+ |  } t  j
+ | |  } | j d  | j   j d d g  | j   d }	 t   }
+ |
+ j | |	 g  t d d d
+ d d g  } | j d  t d d d
+ d d d g  } | j d  |
+ j d | | g  t j d d d  } | j d  t j d d d  } | j d  |
+ j d | | g  t j d d d  } | j d  t j d d d  } | j d  |
+ j d | | g  |
+ j d t j d d d   |
+ j d t j d
+ d d   |
+ j d t j d d d   |
+ j | d  t j | d d d t    }
+ |
+ j   } |
+ j d  |
+ j d  |
+ j   } |  j | | d+ k  t j | t d   }
+ |  j t |
+ j    d  |  j |
+ j d  j  | d   |  j |
+ j d  j  |	 d   |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  | |
+ j   } |  j | d d, d
+ d. k  t j | t d   }
+ |  j t |
+ j    d  |  j |
+ j d  j  | d   |  j |
+ j d  j  |	 d   |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  | |
+ j   } |  j | | k   |  j | d d/ d d1 k  t | t d
+   }
+ |  j t |
+ j    d  |  j |
+ j d  j  | d   |  j |
+ j d  j  |	 d   |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  | |
+ j   } |  j | | k   |  j | d d2 d d4 k  t | d d d t d   }
+ |  j t |
+ j    d  |  j |
+ j d  j  | d   |  j |
+ j d  j  |	 d   |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  | |
+ j   } |  j | | k   |  j | d6 k  t j | d d d t d    }
+ |  j t |
+ j    d  |  j |
+ j d  j  | d   |  j |
+ j d  j  |	 d   |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j! d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  |  j |
+ j# d  d  k  | |
+ j   } |  j | | k   |  j | d  d  S(7   Ns   Pyfile70.medR=  i   i    i   g        g      ?i   R>  i   i   R   s   XX [m]s   YYY [km]i   R  i   i   R  i    R  t   grp3it   grp4t   grp5i   i#   i$   i	   gvIh%<=i   i3   (   g        g        (   g        g      ?(   g      ?g        (   g        g        (   g        g      ?(   g      ?g      ?(   g      ?g        i)   i   iH  i(  i)   i   i  i)   i   i  i)   i   i   i   i   ($   R[   R]   R^   R_   Rc   RY   Rn   Rq   R   R  R[  R`   RB   R   R  R  R>   RR  Rk   Rl   R"  R   R   R'   R(   R|  R  R}   R0   R+   Ry   R  R1   R   R/  R  (   R	   R9  R=  R   RH  R   R>  RI  R   R   R   R  R  R  R  R  R  t   b4_ref_heap_memt   ref_heap_memt   delta1t   delta2t   delta3t   delta4t   delta5(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testPartialReadOfMeshes  s    
+ % 
+ %  	       """"""""!""c         C   sE  t  d d  } | j   | j t d d d g  | j t d# d$ d% g   g  t d  D] } | j   ^ q[ } x- t |  D] \ } } | j	 | d g  q Wt  j
+ |  } t  d d  } | j   | j t d d d d	 g  | j t d& d' d( d) g   g  t d
+  D] } | j   ^ q} x1 t |  D]# \ } } | j	 d
+ | d g  q8Wt  j
+ |  } t  j
+ | |  } | j d  | j   j d d g  | j   d } t   }	 |	 j | | g  t   }
+ t t  } t d  } | j d  | j |  | j d  t d d d d	 d d
+ d g  } | j d  |
+ j | |	 d |  t   }
+ t t  } t d  } | j d  | j |  | j d  t d d d d	 d d
+ d g  } | j d  |  j t |
+ j | |	 d |  t   }
+ t t  } t d  } | j d  | j |  | j d  t d d d	 d
+ d d d g  } | j d  |
+ j | |	 d |  |  j |
+ j   j | d   t   }
+ t t  } t d  } | j d  | j |  | j d  t d d d	 d
+ d d d g  } | j d  | j  | |  | j! d d g d d d d d d g d d d d d d g d d d g  | j! d g d d d d d d g d d g d g  | j! d	 d d
+ d g d d d d d d d d g d d d d d d d d d d g
+ d d d d d g  | j  d   |
+ j | |	 d |  |  j |
+ j   j | d   t d  } | j d   | j |  |  j t |
+ j | |	 d |  t d  } | j d  |  j |
+ j   j | d   t   }
+ t t#  } t d!  } | j d  | j |  | j d  t d d d	 d
+ d d d g  } | j d  |
+ j | |	 d |  |  j |
+ j   j | d   t d  } | j d"  | j |  |  j t |
+ j | |	 d |  |  j |
+ j   j | d   t   }
+ |  j t |
+ j | |	 d |  |  j t |
+ j | |	 d |  | j |  |
+ j | |	 d |  d  S(*   NR=  i   i    i   g        g      ?i   R>  i   i   R   s   XX [m]s   YYY [km]i   i  t	   anonymousi   R  i   g|=i   g333333?gffffff?g?g333333?g?g?g      ?gQ?gQ?i   i  i   i  (   g        g        (   g        g      ?(   g      ?g        (   g        g        (   g        g      ?(   g      ?g      ?(   g      ?g        ($   R[   R]   R^   R_   Rc   RY   Rn   Rq   R   R  R[  R`   RB   R   R  R  R>   RR  R   Rw  R  Ry  R{  Rk   R|  R)   R*   R  R0   R+  R1   R  R   R\  R/  R  (   R	   R=  R   RH  R   R>  RI  R   R   R   R   R   R  R  t   vals2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testCheckCompatibilityPfl1  s    
+ % 
+ %  	 	 ! 	 ! 	 ! 	 ! I4g   	 !  	c         C   s  d } t  d  } | j   t   } | j | |  | j   } t d d  } | j | j    | j d  t   } | j	 d |  | j
+ d t t t d d     | j d t d d d d d d	 d	 d	 d	 d	 d	 d d d
+ d
+ d
+ g   | j | d  ~ ~ ~ ~ ~ t j |  } |  j d | j    |  j | j   j t  d d d d d d d d d d d d d d d d g  d   |  j | j d  j t t t d d      |  j | j d  j t d d d d d d	 d	 d	 d	 d	 d	 d d d
+ d
+ d
+ g    d  S(   Ns   Pyfile71.medi   R   i   i    i
+   i   iiii   i   g-q=(    (   i    i    (   i   i    (   i   i    (   i   i    (   i    i   (   i   i   (   i   i   (   i   i   (   i    i   (   i   i   (   i   i   (   i   i   (   i    i   (   i   i   (   i   i   (   i   i   (   RY   Ry  R   Rc   R  R[   R   R]   R>   Rj   R   Rk   Rm   Rn   R   R   R'   R(   R+   R,   R0   R1   R  R   (   R	   R9  R  R   R   R{  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testWRMeshWithNoCells  s*     
+	    	%FU4Uc      
+   C   s  d } t  d t  } | j   | j d d d d g  | j t d d d d d d d d g d	 d   g  t d	  D] } | j   ^ qv } x7 t |  D]) \ } } | j	 t
+ |  d
+ d g  q Wt  j |  j   } | j   g  t d  D] } | j   ^ q } x7 t |  D]) \ } } | j	 t
+ |  d
+ d
+ g  qWt  j |  j   } | j   | j   t j | |  } t   } | j d |  t d d d g  }	 |	 j d  t d	 d d g  }
+ |
+ j d  t d d d d	 d d g  } | j d  | j d |	 |
+ | g  | j | d  ~ t |  } |  j | j d d  j |	   |  j | j d d  j |
+   |  j | j d d  j |   |  j | j d  j | d   t t  } | j d  | j |  t d  } | j   t d  } | j d  t j | |  } | j  d d g  | j! |  | j"   | j# d d d  t$   } | j% |  | j | d  t$ |  } | j& t d |  } |  j | j | d d   d  S(   Ns   Pyfile72.medR   i    i   i   i   g        g      ?i   g      ?i   R  i   i   R  R  g-q=t   MyFirstFieldi	   id   s   mm [kg]s   sds [m]gffffff@('   Rz   R`   R]   R^   Rc   RY   Rn   Rq   R   R  RD  t   Merge1SGTUMeshesR  t   convertAllToPolyt   convertLinearCellsToQuadraticR[   R[  R>   Rj   Rk   RB   Rl   R   R0   RG   R1   R}   Rw  R  R   Ry  t   MeldR  R{  Rd   R   R   R%  R  (   R	   R9  R   R   R   R   R   R   R   R  R  R  t   mm_readR   R  Rz  R  R   t   ff_readt   f_read(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testWRQPolyg1  sl     
+1%
+%
+
+	   """"  
+   
+	c      	   C   s  d } t  d d d d d d g  } t d d  } | j |  | j   | j t d d d d g  | j t d d d d g  | j   t   } | j d |  t	   } | j
+ |  t   } d d g } t   } | j |  t t  }	 |	 j |  |	 j d	  |	 j d
+ d d  |	 j d  t  d d d d d d d d g  | d <| d j d d  |	 j | d  | j |	  |	 j d d d  t  d d d d d d d d g  | d <| d j d d  |	 j | d  | j |	  |	 j d d d  t  d d d d d d d d g  | d <| d j d d  |	 j | d  | j |	  |	 j d d d  t  d d d d d d d d g  | d <| d j d d  |	 j | d  | j |	  xz t |  D]l \ }
+ } |  j | d |
+ j   j | d   | d |
+ j   |  j | d |
+ j   j | d   qW| j   xA t |  D]3 \ }
+ } |  j | d |
+ j   j | d   qbW| d j   xA t |  D]3 \ }
+ } |  j | d |
+ j   j | d   qWd S(   s   
+        This test checks that a call to loadArraysIfNecessary works (does nothing) on field data structure whatever its level 1TS, MTS, Fields.
+        s   Pyfile77.medi    i   i   R   i   i   i   R   g?t   myELNOFieldi   t   Comp0g@gffffff
+@g@g-q=N(   i    i    i    (   i   i   i    (   i   i    i    (   i   i   i    (   i   i    i    (   i    i   i    (   RY   R[   Rc   R]   R^   R`   Rb   R>   Rj   RP  R7  R[  R/  R   R\  Rw  R  R   R   R   RB   R   R{  RY  R   R0   R+  R1   Rw  (   R	   R9  R   R   R   R   Rl  t   arrsRB  R   R   R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt'   testLoadIfNecessaryOnFromScratchFields0.  sl     
+
+	 	 		   ( ( ( ( ''
+''c         C   sQ  d } t  d d d d d d d d d d d d d d d d d d d d d d d d d d d g d d  } d d d	 d
+ d
+ d	 d d	 d d d d d	 d d d d d	 g } t d d  } | j |  | j   xx d d
+ d d g d
+ d d d	 g d d d	 d g d d	 d d g d	 d d d g d d d d g g D] } | j t |  q,Wxx d d
+ d d d	 g d
+ d d d	 d g d d d	 d d g d d	 d d d g d	 d d d d g g D] } | j t |  qWxr d d
+ d d d	 d g d
+ d d d	 d d g d d d	 d d d g d d	 d d d d g g D] } | j t |  qW| j   t   } | j	 d  | j
+ d  | j d  | j t d | d	 d ! | j t d | d d ! | j t d	 | d d	 ! | j t d	 | d d ! | j t d	 | d d ! | j |  t d d  } | j |  | j   | j t d g  | j t d g  | j t d	 g  | j t d g  t   } | j d |  | j d |  | j d |  | j | d  t j |  } t   }	 t   }
+ t   } x | j   D] } x | j |  D]q } | j |  } t t  } | j |  t  | j    } | j   | j |  | j	 d  | j |  qWqW|  j  | j   d  x$ d d d g D] } | j! |  qW|
+ j" |  |	 j# |
+  |	 j | d  ~	 ~
+ ~ t |  }	 |  j  t$ |	  d
+  |  j  t$ |	 d  d
+  |	 d d } |  j  | j%   d d d d d f g f d d d  d d f g f d	 d d! d d f g f d d d" d d f g f d d d# d d f g f d d d$ d d f g f g  |  j& | j'   j( t  d d
+ d d d d
+ d d
+ d d d
+ d d d	 d d d
+ d d d	 d d
+ d d g  d   d S(%   s    This test is very important, because the same mechanism is used by the MEDReader to generate a field on all the mesh without any processing and memory.
+        s   Pyfile78.medg333333ӿg        g?gffffff?i	   i   i    i   i   i   i   i   i   i   R   i
+   i   i   iiR   R&   i   i   i   i   g-q=N(   i    ii(   i    i   (   i   i   (   i   i	   (   i	   i   (   i   i   (   i   i   ()   RY   R[   Rc   R]   R^   t   NORM_TETRA4t
+   NORM_PYRA5t   NORM_PENTA6R   RB   R\   R_   R`   Rg   R>   Rj   R   R'   R(   R[  R   R   R,   Rr   Rs   Rw  R  R   t   getNumberOfTuplesExpectedRy  R{  R%  R+   Rx   RE  R\  Ry   R  R0   R+  R1   (   R	   R9  R   R   R   R   R   R  R   Rl  Rm  R   R   t   gtt   p0R   R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt+   testField1TSSetFieldNoProfileSBTPerGeoTypese  s    c< 
+gga
+	  
+				  
+ 	mc         C   s  d } d d d d d d d d d d d d	 d d d	 d
+ d d g } t    } t   } | j d  t d d d d d d d d d d d d d d d d d d d d d d d d d d d g d d  } | j d  | j t d | d d	 ! | j t d | d	 d ! | j t d | d d ! | j t d | d d ! | j t d | d d ! | j |  | j	 d |  t   } | j d  | j |  | j   | j t
+ d g  | j t
+ d g  | j t
+ d g  | j t
+ d g  | j	 d |  |  j | j   d  |  j | j d  j   d  | j   |  j | j t  j   d  | j d  |  j | j   d  |  j | j t  j   d  |  j | j t  j   d  |  j | j t
+  j   d  |  j | j d  j   d  d S(   s   This test is a small but important one for MEDReader in sauv mode. When .sauv file is loaded the conversion is performed in memory and a preparation is done then.
+        This preparation makes access to internal MEDCouplingMesh pointers whose name must be updated.
+        s   Pyfile79.medi    i   i   i   i   i   i   i   i   g333333ӿg        g?gffffff?i	   i
+   i   i   iR&   t   abcN(   R>   R[   R\   RY   R]   R^   R_   R`   Rc   Rj   Rg   R+   RC   R}   t   forceComputationOfPartsRs   RB   (   R	   R9  R   R   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileUMeshSetName  sD    <		 c	  
+
+c         C   s  d } t    } | j d  t d  } | j   | j | |  | j   } |  j d |  t t  } | j d  | j	 |  t |  } | j   t
+   } | j	 |  t   } x t |  D] } t |  d | d | d f }	 | j |	   t |  }
+ t |  } | j |  | | ;} | |
+ | <| j |
+  t   } | j |  | j |  q W| j   |  j | d	 j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   t   } | j |  |  j | d	 d	 j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   | j   |  j | d	 d	 j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   | d	 d	 } |  j | j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   | j   |  j | j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   | j | d  | j | d	  ~ ~ ~ ~ ~ t j |  } t |  } |  j | d	 j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   | j   |  j | d	 j   j    | j   |  j | d	 j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   ~ ~ t |  } |  j | d	 d	 j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   | j   |  j | d	 d	 j   j    | j   |  j | d	 d	 j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   ~ t |  } |  j | j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   | j   |  j | j   j    | j   |  j | j   j t d
+ d d d d d d d d d d d d d d d d d d d d d d  d! d" g  d#   d  S($   Ns   Pyfile80.medR  i   i   t   FieldOnCellg?i   i   i    g        g      ?g       @g      @g      @g      @g      @g      @g       @g      "@g      $@g      &@g      (@g      *@g      ,@g      .@g      0@g      1@g      2@g      3@g      4@g      5@g      6@g      7@g      8@g-q=(   R   RB   RY   Ry  Rc   R   R+   Rw  R  R   R   R   Rn   RD  R   Rk   R{  R   R%  RE  t   unloadArraysWithoutDataLossR0   R+  R1   R[  R\  R   R'   R(   Ru  Rw  (   R	   R!   R   R  t   nbCellsR   R   Rm  R   R   R  t   permR   Rl  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt-   testMEDFileFieldsUnloadArraysWithoutDataLoss1  s    	  
+  
+		"  
+
+	
+t	 x
+xp
+pt
+
+tx
+"
+xp
+
+pc      ;   C   sp  d } t  d  } | j   t   } | j | |  | j   } | j d  | j d d  d d d g } | j   j |  | j	   t
+   } | j d	 |  t   } | j |  | j d  | j   } | j | j    | j d
+ |  t d d d d d d	 d d d d d d d d d d d d d d d d d d d  g  } t d! d" d# d$ d% d	 d& d
+ d' d( d) d* d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 g  } t d8 d  }	 g  t d8  D] }
+ d9 |
+ ^ q|	 (t d d d	 d d g  } t d! d* d	 d& d
+ g  } | j d	 |  | j d	 |  | j d	 |	  | j d
+ |  | j d
+ |  t d d d d d d d d d d d  d d d d d: d; d< d= d> d? d@ dA dB d8 dC dD dE dF dG dH dI dJ dK dL dM g$  } t d, d6 d5 d2 d1 d$ d+ d% d3 d4 d7 d- d0 d/ d. dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ d] d^ d_ d` da db g$  } t dL d  } g  t dL  D] }
+ dc |
+ ^ qh| (| j d |  | j d |  | j d |  | j dd de  | j df dg  | j dd dh di g  | j df di dj g  | j | d  t
+ j | d t g d	 d d g  } |  j | j   t g  |  j | j t  j   j t d d	 d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d  d d d d d g(    t  d	 d	 d	 f d d	 d	 f d d	 d	 f d d	 d	 f d d	 d	 f d d	 d	 f d	 d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d	 d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f g  } | j |  |  j | j   j | dk   |  j | j d	  j | d    |  j | j d	  j | d    |  j | j d	  j |	 d    |  j | j d  j | d    |  j | j d  j | d    |  j | j d  j | d    t
+ j | d t g d d8 d g  } |  j | j   t g  |  j | j t  j   j t d d	 d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d  d d d d d d d d d d d d d d  d d d d d  d d g8    t  d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d	 d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d	 d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d	 d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f g  } | j |  |  j | j   j | dk   |  j | j d	  j | d   |  j | j d	  j | d   |  j | j d	  j |	 d   |  j | j d  j | d   |  j | j d  j | d   |  j | j d  j | d   t
+ j | d t  t g d	 d d d d d g  } |  j | j   t t  g  |  j | j d	  j | d d !  |  j | j d	  j | d d !  |  j | j d	  j |	 d d !  |  j | j d
+  j |   |  j | j d
+  j |   |  j | j d
+  t! k  |  j | j t  j   j t d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d  d d d d d g$    |  j | j t   j   j t d	 d d d d d d d d d g
+    t  d	 d	 d	 f d d	 d	 f d d	 d	 f d d	 d	 f d d	 d	 f d d	 d	 f d	 d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d	 d d	 f d d d	 f d d d	 f d d d	 f d d d	 f d d d	 f g  } | j |  |  j | j   j | dk   |  j | j d  j | d    |  j | j d  j | d    |  j | j d  j | d    dl S(m   s   This method tests MEDFileUMesh.LoadPart that loads only a part of a specified mesh in a MED file. The part is specfied using a slice of cell ids. Only nodes on which cells lies are loaded to reduce at most the amount of
+        memory of the returned instance.
+        s   Pyfile81.medi   Rn  i   g        s   aa [b]s   cc [de]s   gg [klm]i    ii   i
+   i   i   i   i	   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   iiiiiiiiiiiiiiiiiiiiiiii   s   Cell#%.3d        i"   i!   i    i   i   i   i   i   i   i-   i,   i+   i*   i)   i(   i'   i&   i%   i$   i#   iiiiiiiiiiiiiiiiiiiiis   Node#%.3d        t   Fam7iM   t   Fam8iX   t   Grp0t   Grp1R  g-q=N("   RY   Ry  R   Rc   R  RB   t   changeSpaceDimensionR   R  R   R>   Rj   Rk   R  Rn   R   R   R  R   t   setGroupsOnFamilyR   t
+   LoadPartOfR`   R+   t   getAllGeoTypesR0   Rs   Rv   R1   R   R  R  Re   R/  (   R	   R!   R  R   R?  R   R   t   renum0t	   famField0R  R   t   renumM1t
+   famFieldM1t   renum1t	   famField1R  R   R  R:  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileUMeshLoadPart1  s     
+	 
+		   WW$xx$$ ######$ ! ######0&&&I ###c         C   s  d } d } d d g } t  d  } | j   t   } | j | |  | j   } | j |  | j d d  d d	 d
+ g } | j   j |  | j	   t
+ t t  } | j |  | j d  t  d d  } | j |  t t d   | d d  d f <t t d d   | d d  d f <| j |  t | | t  t
+ t t  } | j |  | j d  t  d d  } | j |  t t d d   | d d  d f <t t d d   | d d  d f <| j |  | j   t | |  t   } t j | | t g d d d g  }	 | j |	  t j | t |  }
+ |  j |
+ d d j   d d d& d d f g f g  t   } t j | | t g d d d g  }	 | j |	  t j | t |  }
+ |
+ j   }
+ |
+ d d j    t  d d  } t t d d   | d d  d f <t t d d   | d d  d f <| j |  |  j! |
+ d d j"   j# | d    |
+ d d j    t  d! d  } t t d" d#   | d d  d f <t t d$ d%   | d d  d f <| j |  |  j! |
+ d d j"   j# | d    d S('   s   This method tests partial loading on fields on CELL. It is the same principle than those in testMEDFileUMeshLoadPart1.
+        s   Pyfile82.medRn  s   aa [kg]s	   bbb [m/s]i   i   g        s   aa [b]s   cc [de]s   gg [klm]t   Fieldi   i   Ni    id   i}   i   t	   FieldNodei$   i   i   i,  iP  i(   i   R&   i   i   ig   is   g-q=i   i   i   i/  iD  (   i    i   ($   RY   Ry  R   Rc   R  RB   R  R   R  R   Rw  R  RX  R   Rm   Rn   R{  R_  R.   R  Rd   t!   WriteFieldUsingAlreadyWrittenMeshRP  R>   R  R`   R7  R[  RN   R+   R  Rq   Rv  R0   R+  R1   (   R	   R!   t   meshNamet   composR  R   R?  R   R   R   Rl  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldsLoadPart1a  sn     
+	 
+  "%  %%
+	$6	$ % %' % %'c         C   s   d } t  d
+ d d g  } | j d d d g  t   } | j |  | j d  | j | d  t j |  } |  j | j	   d  |  j
+ | j   j | d	   d  S(   Ns   Pyfile83.medi    i   i   s   aa [m]s   bbb [s]s
+   cccc [m/s]R   g-q=(   i    i    i    (   i   i    i    (   i   i    i    (   RY   R  R>   Rc   RB   R   R'   R(   R+   RC   R0   R   R1   (   R	   R!   R  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileWithoutCells1  s    	c         C   s[  d } d } d d g } t  d  } | j   t   } | j | |  | j   } | j |  | j d d  d d	 d
+ g } | j   j |  | j	   t
+ t t  } | j |  | j d  t  d d  } | j |  t t d   | d d  d f <t t d d   | d d  d f <| j |  t | | t  t
+ t t  } | j |  | j d  t  d d  } | j |  t t d d   | d d  d f <t t d d   | d d  d f <| j |  | j   t | |  t   } t j | | t g d d d g  }	 | j |	  |	 j d t  }
+ |  j |
+ j   t d d d   |	 j d  }
+ |  j |
+ j   t d d d   |  j |
+ j    d k o|
+ j    |	 j!   k  |	 j"   |	 j d t  }
+ |  j |
+ j   t d d d   |	 j d  }
+ |  j |
+ j    d k oB|
+ j    |	 j!   k  |  j |
+ j#   j$ t% d d d d d d d  d! g    t& j | t' |  } | d d j(   t  d5 d6 g  } | j |  |  j | d d j)   j$ | d$   | d d j(   t  d7 d8 d9 d: d; d< d= d> g  } | j |  |  j | d d j)   j$ | d$   d S(?   s    Test close to Pyfile82.med except that here zipCoords on MEDFileUMesh is invoked here to see if the PartDef is correctly updated.
+        s   Pyfile84.medRn  s   aa [kg]s	   bbb [m/s]i   i   g        s   aa [b]s   cc [de]s   gg [klm]R  i   i   Ni    id   i}   i   R  i$   i   i   i,  iP  i   i   i
+   i   i   i   i   i   i   ih   ii   g-q=i   i0  i   i1  i   i2  i   i3  i   i6  i   i7  i   i8  i   i9  (   i   ih   (   i   ii   (   i   i0  (   i   i1  (   i   i2  (   i   i3  (   i   i6  (   i   i7  (   i   i8  (   i   i9  (*   RY   Ry  R   Rc   R  RB   R  R   R  R   Rw  R  RX  R   Rm   Rn   R{  R_  R.   R  Rd   R  RP  R>   R  R`   R7  t   getPartDefAtLevelR+   t   getSlicet   sliceR0   t   getNumberOfElemsR  Rs  t   toDAIR1   Rk   R[  RN   Rv  R+  (   R	   R!   R  R  R  R   R?  R   R   R   t   spdRl  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testZipCoordsWithLoadPart1  sp     
+	 
+  "%  %%
+	$""1
+"1:'$'c         C   s   t    } | j t d d d d d g  t d d d d d g   | j d  t   } | j |  t d d d d d g  } | j d	  | j d | g  |  j | j	 d  j
+ t d
+ d d
+ d d d d
+ d d
+ d
+ d
+ d
+ d
+ d
+ d
+ d
+ g    d S(   s\    Non regression test to check that setGroupsAtLevel is available with MEDFileCMesh.
+        i    i   i   i   i   Rn  i   i   t
+   MyAssemblyiiN(   R   Rc   RY   RB   R   R   Rk   Rl   R0   R   R1   (   R	   R   R   R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt    testMEDFileCMeshSetGroupsAtLevel  s    	 :	  Uc        C   s$  d } d } d } d } t  d d d d g  } t  d d	 d
+ d d d d d d d d d g  } t d  } | j   t   } | j | |  | j   } | j | j    }	 | |	 } | j   | | }
+ | | j | j    } |
+ j	 d  t
+ j |
+ | g  } | j |  | j   \ } } } } } | j   j d	  } t   } | j d |  | j d |  t  d d	 d
+ d d d d d d g	  } | j d  | j d | g  | } | j d  | j d | g  | j | d
+  t d  } | j   t   } | j |  | j   } | j |  | j d  | j | j   d d  d	 d
+ d g f  t   } | j d |  | j | d  t j | |  } t j | |  } | j d  } | j | d  } |  j | j   | j    |  j | j d  d  |  j | j d  d  |  j | j   d d d d d d  f  |  j | j d  d f  |  j | j d  d f  |  j | j d  d f  |  j | j d  d! f  |  j | j d   d! f  |  j | j d  d f  t d" d# d# f d$ d# d# f d% d# d# f d& d# d# f d# d" d# f d" d" d# f d$ d" d# f d% d" d# f d& d" d# f d' d" d# f d# d$ d# f d" d$ d# f d$ d$ d# f d% d$ d# f d& d$ d# f d' d$ d# f d# d% d# f d" d% d# f d$ d% d# f d% d% d# f d& d% d# f d' d% d# f d# d& d# f d" d& d# f d$ d& d# f d% d& d# f d& d& d# f d' d& d# f d" d' d# f d$ d' d# f d% d' d# f d& d' d# f d" d# d" f d$ d# d" f d% d# d" f d& d# d" f d# d" d" f d" d" d" f d$ d" d" f d% d" d" f d& d" d" f d' d" d" f d# d$ d" f d" d$ d" f d$ d$ d" f d% d$ d" f d& d$ d" f d' d$ d" f d# d% d" f d" d% d" f d$ d% d" f d% d% d" f d& d% d" f d' d% d" f d# d& d" f d" d& d" f d$ d& d" f d% d& d" f d& d& d" f d' d& d" f d" d' d" f d$ d' d" f d% d' d" f d& d' d" f d" d# d$ f d$ d# d$ f d% d# d$ f d& d# d$ f d# d" d$ f d" d" d$ f d$ d" d$ f d% d" d$ f d& d" d$ f d' d" d$ f d# d$ d$ f d" d$ d$ f d$ d$ d$ f d% d$ d$ f d& d$ d$ f d' d$ d$ f d# d% d$ f d" d% d$ f d$ d% d$ f d% d% d$ f d& d% d$ f d' d% d$ f d# d& d$ f d" d& d$ f d$ d& d$ f d% d& d$ f d& d& d$ f d' d& d$ f d" d' d$ f d$ d' d$ f d% d' d$ f d& d' d$ f g`  } |  j | j   j  | d(   t  d) d	 d d d* d+ d, d) d	 d d d* d, d- d) d
+ d	 d d. d* d- d) d
+ d d d. d- d/ d) d d
+ d d0 d. d/ d) d d d d0 d/ d1 d) d d d2 d, d3 d4 d) d d2 d5 d, d4 d6 d) d7 d d8 d9 d1 d: d) d7 d8 d; d9 d: d< d) d5 d2 d) d6 d4 d= d) d5 d) d d6 d= d> d) d; d8 d d< d: d? d) d; d d@ d< d? dA d) d d) dB d> d= dC d) d dB dD d> dC dE d) d@ d d dA d? dF d) d@ d dG dA dF dH d) d dD dI dJ dE dK d) d dI dL dJ dK dM d) d d dL dN dJ dM d) d dL dO dN dM dP d) d d dO dF dN dP d) d dO dQ dF dP dR d) d* d+ d, dS dT dU d) d* d, d- dS dU dV d) d. d* d- d dS dV d) d. d- d/ d dV dW d) d0 d. d/ dX d dW d) d0 d/ d1 dX dW dY d) d, d3 d4 dU dZ d[ d) d, d4 d6 dU d[ d\ d) d9 d1 d: d] dY d^ d) d9 d: d< d] d^ d_ d) d6 d4 d= d\ d[ d` d) d6 d= d> d\ d` da d) d< d: d? d_ d^ db d) d< d? dA d_ db dc d) d> d= dC da d` dd d) d> dC dE da dd de d) dA d? dF dc db df d) dA dF dH dc df dg d) dJ dE dK dh de di d) dJ dK dM dh di dj d) dN dJ dM dk dh dj d) dN dM dP dk dj dl d) dF dN dP df dk dl d) dF dP dR df dl dm d d d d5 d d- d, d6 dn d d d d d d/ d- dn do d d d d d8 d1 d/ do d: d d d5 d d dn d6 d> dp d d d d d do dn dp dq d d8 d d d d: do dq d? d d d dD d dp d> dE dJ d d d d d dq dp dJ dN d d d d d d? dq dN dF d d- d, d6 dn dV dU d\ dr d d/ d- dn do dW dV dr ds d d1 d/ do d: dY dW ds d^ d dn d6 d> dp dr d\ da dt d do dn dp dq ds dr dt du d d: do dq d? d^ ds du db d dp d> dE dJ dt da de dh d dq dp dJ dN du dt dh dk d d? dq dN dF db du dk df g } |  j | d j!   j  |   t  d d d8 d@ dI d0 d4 d> dJ dR dV ds db dg dv dw dx dy dz d{ d| d} d~ d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gC  } |  j | d j"   j  |   t  d d	 d d d d	 d d d d
+ d	 d d d
+ d d d d d
+ d d d d d d d d d2 d d d2 d5 d d7 d d8 d d7 d8 d; d d5 d2 d) d d5 d) d d d; d8 d d d; d d@ d d d) dB d d dB dD d d@ d d d d@ d dG d d dD dI d d dI dL d d d dL d d dL dO d d d dO d d dO dQ d dS dT dU d dS dU dV d d dS dV d d dV dW d dX d dW d dX dW dY d dU dZ d[ d dU d[ d\ d d] dY d^ d d] d^ d_ d d\ d[ d` d d\ d` da d d_ d^ db d d_ db dc d da d` dd d da dd de d dc db df d dc df dg d dh de di d dh di dj d dk dh dj d dk dj dl d df dk dl d df dl dm d d	 d d+ d* d d d d, d+ d d d	 d* d, d d d d- d, d d d	 d* d- d d
+ d	 d* d. d d d
+ d. d- d d d d/ d- d d d
+ d. d/ d d d
+ d. d0 d d d d0 d/ d d d d1 d/ d d d d0 d1 d d d d3 d, d d d2 d4 d3 d d2 d d, d4 d d2 d5 d6 d4 d d5 d d, d6 d d7 d d1 d9 d d d8 d: d1 d d8 d7 d9 d: d d8 d; d< d: d d; d7 d9 d< d d2 d) d= d4 d d) d5 d6 d= d d) d d> d= d d d5 d6 d> d d8 d d? d: d d d; d< d? d d d@ dA d? d d@ d; d< dA d d) dB dC d= d dB d d> dC d dB dD dE dC d dD d d> dE d d d dF d? d d d@ dA dF d d dG dH dF d dG d@ dA dH d d dD dE dJ d dD dI dK dE d dI d dJ dK d dI dL dM dK d dL d dJ dM d d d dJ dN d dL d dN dM d dL dO dP dM d dO d dN dP d d d dN dF d dO d dF dP d dO dQ dR dP d dQ d dF dR d d5 d dn d6 d d d d- dn d d d do dn d d d d/ do d d d8 d: do d d d dp d> d d d dn dp d d d dq dp d d d do dq d d d d? dq d d d dp dJ d d d dq dN d d* d+ dT dS d d+ d, dU dT d d, d* dS dU d d, d- dV dU d d- d* dS dV d d. d* dS d d d- d. d dV d d- d/ dW dV d d/ d. d dW d d0 d. d dX d d/ d0 dX dW d d/ d1 dY dW d d1 d0 dX dY d d, d3 dZ dU d d3 d4 d[ dZ d d4 d, dU d[ d d4 d6 d\ d[ d d6 d, dU d\ d d9 d1 dY d] d d1 d: d^ dY d d: d9 d] d^ d d: d< d_ d^ d d< d9 d] d_ d d4 d= d` d[ d d= d6 d\ d` d d= d> da d` d d> d6 d\ da d d: d? db d^ d d? d< d_ db d d? dA dc db d dA d< d_ dc d d= dC dd d` d dC d> da dd d dC dE de dd d dE d> da de d d? dF df db d dF dA dc df d dF dH dg df d dH dA dc dg d dJ dE de dh d dE dK di de d dK dJ dh di d dK dM dj di d dM dJ dh dj d dN dJ dh dk d dM dN dk dj d dM dP dl dj d dP dN dk dl d dF dN dk df d dP dF df dl d dP dR dm dl d dR dF df dm d d6 dn dr d\ d dn d- dV dr d dn do ds dr d do d/ dW ds d do d: d^ ds d d> dp dt da d dp dn dr dt d dp dq du dt d dq do ds du d dq d? db du d dJ dp dt dh d dN dq du dk d d d d5 d d d d d d d d d d d8 d d d5 d d d d d d d d d8 d d d d d d dD d d d d d d d d d d d d dV dU d\ dr d dW dV dr ds d dY dW ds d^ d dr d\ da dt d ds dr dt du d d^ ds du db d dt da de dh d du dt dh dk d db du dk df g } |  j | d j!   j  |   t  d d d d d) d d dI d+ d3 d1 dn d= d? dJ dK dT dZ dY dr d` db dh di d d d d dx d d d d d d d| d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d ddddddddd	d
+dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKg  } |  j | d j"   j  |   t  d	 d	 d d	 d d d	 d d	 d	 d d d	 d d	 d	 d
+ d	 d	 d d
+ d	 d d d	 d d
+ d	 d d
+ d	 d d d	 d d d	 d d d	 d d d	 d d2 d	 d2 d d	 d2 d5 d	 d5 d d	 d7 d d	 d d8 d	 d8 d7 d	 d8 d; d	 d; d7 d	 d2 d) d	 d) d5 d	 d) d d	 d d5 d	 d8 d d	 d d; d	 d d@ d	 d@ d; d	 d) dB d	 dB d d	 dB dD d	 dD d d	 d d d	 d d@ d	 d dG d	 dG d@ d	 d dD d	 dD dI d	 dI d d	 dI dL d	 dL d d	 d d d	 dL d d	 dL dO d	 dO d d	 d d d	 dO d d	 dO dQ d	 dQ d d	 d5 d d	 d d d	 d d d	 d d d	 d d8 d	 d d d	 d d d	 d d d	 d d d	 d d d	 d d d	 d d d	 dS dT d	 dT dU d	 dU dS d	 dU dV d	 dV dS d	 d dS d	 dV d d	 dV dW d	 dW d d	 dX d d	 dW dX d	 dW dY d	 dY dX d	 dU dZ d	 dZ d[ d	 d[ dU d	 d[ d\ d	 d\ dU d	 d] dY d	 dY d^ d	 d^ d] d	 d^ d_ d	 d_ d] d	 d[ d` d	 d` d\ d	 d` da d	 da d\ d	 d^ db d	 db d_ d	 db dc d	 dc d_ d	 d` dd d	 dd da d	 dd de d	 de da d	 db df d	 df dc d	 df dg d	 dg dc d	 dh de d	 de di d	 di dh d	 di dj d	 dj dh d	 dk dh d	 dj dk d	 dj dl d	 dl dk d	 df dk d	 dl df d	 dl dm d	 dm df d	 d\ dr d	 dr dV d	 dr ds d	 ds dW d	 ds d^ d	 da dt d	 dt dr d	 dt du d	 du ds d	 du db d	 dh dt d	 dk du g } |  j | d! j!   j  |   t  dL } | j   | d 9} |  j | d! j"   j  |   |  j | j# d d  j   d  |  j | j# d! d  j   d  |  j | j# d d  j$ t  d d	 d
+ d d d d dMdNg	    |  j | j# d d  j$ t  d d d dG dI dL dOdPdQg	    |  j | j# d! d  j$ t  d d	 d d7 d d d8 d dB dD dO dQ d* d, d- d1 d4 d: dp dq g    |  j | j# d! d   j$ t  dT dS dU d] dr ds d^ dt dd de dl dm dRdSdTd dUdVdWdXg    |  j | j# d d  j$ t  d d	 d
+ d d d d d d dG dI dL d= d> dp dN dF dH g    |  j | j# d d  j$ t  d= d> dA dN dK dM dP d dV dW d^ d_ da dc dd dh df dl dv dYdx dZd[d\d d]dz d^d_d`dadbdcddded d~ dfdgdhg(    | j di | j | d  d S(j  s5    New functionality of MEDFileUMesh.buildExtrudedMesh.s   Pyfile85.medRn  t   Mesh1Dt   Mesh3Di    i   i   i   i   i   i   i   i   i   i   i   i   i   i   ii   i   i   R  R  NiB   i   t   grp0_extrudedt   grp0_topt   grp1_extrudedt   grp1_topig      ?g        g       @g      @g      @g      @g-q=i   i!   i    i%   i&   i"   i'   i#   i(   i
+   i$   i*   i   i+   i	   i   i)   i.   i   i/   i0   i1   i4   i   i5   i   i6   i   i7   i:   i   i;   i   i8   i<   i   i=   i9   i   i>   i   i?   iA   i@   iE   iF   iG   iC   iH   iD   iJ   iK   iI   iN   iO   iP   iQ   iT   iU   iV   iW   iZ   i[   iX   i\   i]   iY   i^   i_   i,   i-   i2   i3   iL   iM   iR   iS   ib   ii   ip   iw   i~   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i  i
+  i  i  i  i&  i-  i4  i;  iB  iI  iP  iY  ib  ik  it  i}  i  i  i  i  i  i  i  i  i  i  i  i  i  i`   id   ih   il   it   ix   i|   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i  i  i  i  i  i  i$  i)  i.  i3  i8  i=  iG  iL  iQ  iV  i[  i`  ie  ij  io  iy  i~  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i  i
+  i  i  i  i  i#  i(  i-  i2  i7  i<  iA  iF  iK  iP  iU  iZ  i_  id  ii  in  is  ix  i}  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i	  i  i  i  i  i"  i'  i,  i1  i6  i;  i@  iE  iJ  iO  iT  iY  i^  ic  ih  im  ir  iw  i|  i  i  i  i  i  i  i   i   i   i   i   i   ia   ie   if   ij   in   ir   is   ic   iq   iu   iy   i}   i   i   i   i   i   i   i   i   i   i   i   t   MeshExtruded(%   Rk   RY   Ry  R   Rc   R  t   buildComplementR   Rs  t
+   simplexizeR[   t   MergeUMeshesOnSameCoordsRB   R  R  R  R>   Rj   Rl   R   R  R   R'   R(   R}   t   buildExtrudedMeshR+   RC   t   getNumberOfCellsAtLevelR  R   R0   R1   Rv   Rw   RG   R  (   R	   R!   t
+   meshName2Dt
+   meshName1Dt   meshName3DOutR  Ro  R  R   t   d1cR   R   t   mMinus1R  R   Re  R   R   R  R  R  t   mm1Dt   mm2Dt   m1Dt   mm3D(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt"   testMEDFileUMeshBuildExtrudedMesh1  s    0 
+	 
+ 
+
+ 	 '   
+	  ,	(                        W       
+ 
+ ""CCdd^s   requires numpyc         C   s  d } t  d d d d d d d d d d d d d d d d d d g d d  } | j d d g  d	 d
+ d d d d d d d d d d d d
+ d d d d g } t   } | j d  | j d  | j t d
+ | d d ! | j t d
+ | d d ! | j t d | d	 d ! | j t d | d d ! | j t d | d d ! | j	   | j
+ |  | j   t j   } | j d  | j d
+  | j t d d d g  | j t d d
+ d g  | j t d
+ d d d g  | j	   | j
+ |  | j   t j   } | j d	  | j d  | j t d d g  | j t d d
+ g  | j t d d g  | j t d d g  | j	   | j
+ |  | j   t j   } |  j | j    | j d  | j d  | j
+ |  | | d <| | d	 <| j d	 t d d d d d g   | | d <| j d t d d d d g   t j   } | j d d
+ g d d  | j d   t j   }	 |	 j d d d
+ g d
+ d  |	 j d!  | j d	 | |	 g t  t j   }
+ |
+ j d	 d d g d
+ d  |
+ j d   t j   } | j d	 d g d d  | j d!  | j d |
+ | g t  t j   } | j t t d   d d  | j d   t j   } | j t t d   d d  | j d!  | j d | | g t  | j d	 d"  | j d	 d  t  } |  j | j |   | j d	 d! t  } |  j |	 j |   | j d d  t  } |  j |
+ j |   | j d d! t  } |  j | j |   | j d d  t  } |  j | j |   | j d d! t  } |  j | j |   |  j | j d"   | j d	 d"  } t  j! | t  j"  } t  j# |  } |  j | j | d#  d	  |  j$ | j%   t&  | j' t(  t  j! | t  j"  } t  j# |  } |  j | j | d#  d	  |  j$ | j%   t(  d  S($   Ns   Pyfile86.medg333333ӿg?gffffff?i	   i   R  t   bbbi    i   i   i   i   i   i   i   i
+   i   i   RT   RU   ii    i)   i2   i8   iif   i4   i-   i?   RV   RW   RX   g-q=()   RY   R  R[   R\   R]   R^   R_   R`   Ra   Rb   Rc   Rd   R(   Re   Rf   Rg   R>   R0   Rh   RB   Ri   R   Rk   RZ   Rl   RN   Rm   Rn   Ro   RG   R1   Rp   t   picklet   dumpst   HIGHEST_PROTOCOLt   loadsR+   t   getAxisTypet   AX_CARTt   setAxisTypet   AX_CYL(   R	   RO   R   R   R   R   R   R   R   R   RQ   R   R   R   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileUMeshPickeling15  s    H<	
+
+
+
+
+
+
+
+%
+"c         C   s  d } d } d } d } d } t    } t |  } | j   | j |  | j   } | j |  t   } x t |  D] }	 t t	  }
+ |
+ j
+ |  t |  } | j   | |	 9} |
+ j |  |
+ j |  |
+ j t |	  |	 d  | j |
+  qy Wt   } | | d <| j | d  | j | d  t | t  } t j | t	 t f g t  } | j   | j   xI t |  D]; }	 |  j | | |	 j   j | | |	 j   d   q}Wt    } | j t d d	 d d
+ g  t d d	 g   | j   } | j d  t    } | j t d
+ d d g  t d d	 g   | j   } t j | |  } | j |  t   } x t |  D] }	 t t  }
+ |
+ j
+ |  t d  } | j   | |	 9} |
+ j |  |
+ j |  |
+ j t |	  |	 d  | j |
+  qWt   } | | d <| d =|  j | j   d  | | d <|  j | j   d  | j | d  t | t  } t j | t t f g t  } t j | | t t  f g t  } t j | t t f t t  f g t  } | j   | j   | j   | j   x t |  D] }	 |  j | | |	 j   d  j | | |	 j   d   |  j | | |	 j   d d !j | |	 j   d   |  j | | |	 j   j | | |	 j   d   qWd  S(   Ni   t   myFields   Pyfile87.medi
+   Rn  i    i   g-q=i   i   i   i   i   i   (    (   i    (!   R   RY   Ry  Rc   R  RB   R   Rn   Rw  R  R   R{  R   RD  RY  R>   R   R[  RN   t   LoadSpecificEntitiest
+   NORM_ERRORRw  R0   R+  R1   R  R[   R[  R  R+   R,   R_   R`   (   R	   t   nbNodesRg  R!   t   nbPdtR  R   R  Rm  R   R   R   Rl  RV  R   R   R  t   fs3t   fs4(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt&   testMEDFileFieldsLoadSpecificEntities1  s    	 
+	 
+ 
+	 
+
+
+5	 .  	 +  	 
+ 
+	 
+
+!'
+
+
+
+985c         C   s  d } d } d } d } d } d } t    } t |  } | j   | j |  | j   } | j |  | | }	 t   }
+ x t |	  D] } t   } t	 j
+ t d | d  | |	  } x t | j | j | j  D] } t t  } | j |  t |  } | j   | | 9} | j |  | j d	 | | f  | j t |  | d  | j |  q W|
+ j |  q Wt   } | | d <|
+ j | d
+  | j | d  d   } d d  l } t |  } i  } | j d  } x | D]} } | d  d  d  } | j |  } | rP| | | j d
+  d  d  d  | j d  d  d  d   q| | | d  qWt   } x | D] } | | d g k rt | | d d   | | <n  g  } x; | | D]/ } | j t j  | | | t t! f g   qW| j"   | j#   } t$ |  } x' t |  D] } | j% | j#    q W| j |  | j |  qtW|  j& | d j'   g  t |  D] } | d t |  f ^ q{ d  S(   Ni   R  s   Pyfile88.medi,  Rn  id   i    i   s   %s_%di   c         S   s1   | |  k r  |  | j  |  n | g |  | <d  S(   N(   t   append(   Re  t   keyt   val(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   appendInDict  s    is   ([\d]+)([\s\S]+)$R&   R   c         S   s
+   t  |   S(   N(   t   int(   t   x(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   <lambda>  s    ((   R   RY   Ry  Rc   R  RB   R[  Rn   R   Rc  t   GetSliceR  t   startt   stopt   stepRw  R  R   R{  R   RD  RY  R\  R>   R   t   ret   GetAllFieldNamest   compilet   matchR  t   sortedR  R  R  t   reverset   popRy   t   pushBackTimeStepsR+   R   (   R	   R  Rg  R!   R  R  t   maxPdtR   R  t	   nbOfFieldRl  Rf  Rm  t   sR   R   R   R  R
+  t	   allFieldst   allFieldsDictt   patR   t   stRevRV  t   kt   fmts2Rv  t   zeResut   nbItert   ii(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileLotsOfTSRW1  s    	 
+
+		!" 
+ 
+	 
+	<	)
+Bc        C   sX  d } d } t    } t d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d	 d
+ d f d d d f g  } t d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d! d d d d! d d" d d d d d d d# d d d d d d" d d! d d d! d$ d% d d d d d" d d d d d d d# d d d d d d d d d d$ d d d% d d d d# d d d d d! d# d d d d d$ d d d" d& d! d d% d' d$ d d d d% d( d# d d d d d d d# d d! d d d d" d  d) d d d d" d d d d d d# d d! d d# d% d d d d d d d d d d d d d d d d d d d$ d! d d d d d d d d d" d d d d d" d) d d d" d! d& d d d* d d  d d d d d d d" d d d  d d d d d d d d# d( d d d d d" d d d! d$ d& d d d d d  d d d d d d d d d d d g } t d d( d  d$ d d d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA dB dC dD dE dF dG dH dI dJ dK dL dM dN dO dP dQ dR dS dT dU dV dW dX dY dZ d[ d\ g8  } t | d)  } | j |  | j | |  | | d <t d) d d d d) d d d d) d d* d  d) d d d  d) d d d d) d d d d) d d  d) d) d d d) d) d$ d! d% d) d( d% d# d) d! d# d% d) d$ d% d' d) d d d# d) d d# d! d) d& d d! d) d& d! d$ d) d( d d% d) d' d% d d) d d d d) d d d d) d( d d d) d% d d d) d d d d) d d d d) d  d* d d) d& d" d d) d d d d) d) d  d" d) d d d d) d" d d d) d  d d d) d  d d" d) d) d" d d) d& d d" d) d$ d' d d) d d d d) d& d$ d d) d" d d d) d d$ d d) d d d d) d d d* d) d d d d) d d( d# d) d d d d) d d# d d) d d d d) d d# d d) d d d g  } t d d' d d% d d d d] d^ d_ d- d` da db dc d1 dd de df dg d5 dh di dj dk d9 dl dm dn do d= dp dq dr ds dA dt du dv dw dE dx dy dz d{ dI d| d} d~ g1  }	 t | d*  }
+ |
+ j |  |
+ j | |	  |
+ | d <t d d d d d d d d* d) d  d  d* d d d d) d' d% d% d( d( d# d# d d& d d d d' d$ d$ d& d d d d' d d d d( d) d" d" d& d* d d d g0  } t | t  } | j |  | j |  | j	   | d <t d0  } d | (| j
+ d |  | j
+ d t d d d* d d d d d d d d d d d d d d d d d d d d d d d d d g   t d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d g0  } | j
+ d |  t d d d d d d d d d d d d d d d d d d d d d d d d g  } | j
+ d |  xH d d f d d f d d f d d* f f D] \ } } | j | |  q^WxH d d f f d d f f d d f f g D] \ } } | j | |  qW| j | d*  t j |  } | j d d  } | j   } | j d  | j d |  | j   |  j | j | j d d    |  j | j d  j |   |  j | j d  j |   |  j | j d  j |   |  j | j d  j t d d d* d d d d d d d d d d d d d d d d d d d d d d d d d g    d d f f d d f f d d f f d d f f g } d d f d d f d d f d d* f d d f g } |  j t | j    g  | D] } | d ^ q x- | D]% \ } } |  j | j |  |  qW|  j t | j    g  | D] } | d ^ q x- | D]% \ } } |  j | j |  |  q+Wd S(   sZ    Test for bug EDF10720. The aim of this test is the call of MEDFileMesh.rearrangeFamilies.s   Pyfile89.medt
+   Maillage_2g        g      i@g      Y@g-Q'8]@gGҮ	T@g-Q'8]@gJ(LO@gFۯL@gFhU]@gEYG@a@gdك]@gyU	]@i   i   i   i	   i   i   i   i   i   i   i    i   i   i   i   i   i   i
+   i   i   i   i   i   i   i   i   i   i   i   i#   i(   i-   i2   i7   i<   iA   iF   iK   iP   iU   iZ   i_   id   ii   in   is   ix   i}   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i  i	  i  i  i   i    i$   i,   i0   i4   i8   i@   iD   iH   iL   iT   iX   i\   i`   ih   il   ip   it   i|   i   i   i   i   i   i   i   i   i   i   i   i   i   i   iiiiR  s   FAM_-6_Groupe_1s   FAM_-7_Groupe_2t   FAM_2_Groupe_3t   Groupe_1t   Groupe_2t   Groupe_3t   TOTOt   Family_9N(   R>   RY   Rk   R[   Rc   R  Rz   Re   t   setNodalConnectivityR  R   R   R  R   R'   R(   R?   t   computeFetchedNodeIdsRB   R  t   rearrangeFamiliesR0   R1   RG   R   R+   Rm   R  R   R  t   getFamilyId(   R	   R!   R  R   R   R  t   c0iR   t   c1t   c1iR   R  R   R  R  R  R   t   fidR  t   famst   dait   allGrpst   allFamsR   t   eltId(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileMeshRearrangeFamIds1(  sx    	 ]   H 
+  N 
+  jT77
+"y6333c   	      C   sz  t    } d } t   } t   } t d  } | j   | j |  | j |  | j |  t t	  } | j |  | j
+ t d d d d g   | j d  | j   t d d	 d
+ d g  } | j d  | j | | d |  |  j | j   d  | j t	 d |  } |  j | j | d d   ~ ~ ~ ~ ~ t    } d } t   } t   } t d  } | j   | j |  | j |  | j   } | | d <t t	  } | j |  | j
+ t d d d d g   | j d  | j   t d d	 d
+ d g  } | j d  | j | | d |  |  j | j   d  | j t	 d |  } |  j | j | d d   d S(   so    Non regression test. For structured mesh, push a false partial field in MEDFileField1TS using setFieldProfile.R   i   g333333?gffffff@g333333@g      @R  i    i   i   i   t   TUTUg-q=N(    (    (   R   R   R   RY   Ry  Rc   RB   R   Rw  R  R{  Rd   Rk   R|  R+   R]  R  R0   R1   R>   R  (	   R	   R   R  R   R   R  t   fieldR  t   field2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testNonRegrCMeshSetFieldPfl1c  sV    			  
+
+ 			  
+
+
+ c         C   s  d } d } d } t  d  } | j   t   } | j | |  | j   } t d d d d g  } | | } | j d	  | | j | j    } t	 j
+ | |  } | j d d
+  t  d  } | j   t   }	 |	 j |  |	 j   }	 |	 j d d
+  |	 j |	 j   d  d   d d d	 g f  | j   |	 j   d }
+ | j |	 d	  } | j   | j |  | } | j | j    | j |
+  | j |  | j   | j   }	 |	 j |  t	 j | j    } | j |  | d d d g } t   } | | d	 <| | d <|	 | d <| | d <t d d d d g  } | j d  t d	 d g  } | j d  t d	 d d d d g  } | j d  t d d d d d g  } | j d  t d	 d d d d g  } | j d  t d d d  d! g  } | j d"  t d d d d d d! g  } | j d#  | j d	 | | g  | j d | | | g  | j d | | g  | j d	 d
+  } | j | d  | j d
+  } |  j | j | d$  d	  d  S(%   NR   s   Pyfile90.meds   Pyfile91.medi   i   i   i   i   i    g        i   i   i   i
+   iiit   Eastt   Corner1i   i	   t	   SouthFacei   i   i   i   t	   NorthFacei   t   DiagFacei   i   i   i   t   vol1t   vol2g-q=(   RY   Ry  R   Rc   R  Rk   R  R  R   R[   R  R  R   R  R  R  RB   t   shiftNodeNumbersInConnR   R  t   Build0DMeshFromCoordsR>   Rl   t   linearToQuadraticR   t   quadraticToLinearR0   R1   (   R	   R  R!   t	   fileName2R  R   Re  R   R   R  R  t   m3Dt   m2Dt   m0DR   t   grpEdge0t   grpEdge1t   grpFaceSoutht   grpFaceNortht   diagFaceR=  R>  t   mmOut1t   mmOut2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt(   testMEDFileUMeshLinearToQuadraticAndRev1  s|     
+	 
+ 
+	   ,
+    
+   	
+ 
+ 
+ 
+       c      
+   C   s  t    } t d  } | j   t d  } | j   | j | |  | j d  t   } | j |  t d d d d d g  } | j d	  | j d
+ |  t d d d d d d d g  } | j d  | j d
+ |  t d
+ d d d d g  } | j d  | j d
+ |  t d g  } | j d  | j d
+ |  xB | | | | g D]. }	 |  j	 | j
+ d
+ |	 j    j |	   qUW|  j | j   d  d }
+ xW | | | | g D]C }	 |	 j   } | |
+ 7} | j d |	 j    | j d |  qW|  j | j   d  xB | | | | g D]. }	 |  j	 | j
+ d
+ |	 j    j |	   q&Wxg | | | | g D]S }	 |	 |
+ } | j d |	 j    |  j	 | j
+ d d |	 j    j |   qkW| j   xB | | | | g D]. }	 |  j	 | j
+ d
+ |	 j    j |	   qWxg | | | | g D]S }	 |	 |
+ } | j d |	 j    |  j	 | j
+ d d |	 j    j |   q$Wd  S(   Ni	   i   R   i   i   i   i   i   R  i    i   i   i   R  i   i   i
+   i   R  i   R  i   s   %s_nodet	   grp0_nodet	   grp1_nodet	   grp2_nodet	   grp3_node(   s   grp0s   grp1s   grp2s   grp3(   s   grp0RO  s   grp1RP  s   grp2RQ  s   grp3RR  (   R   RY   Ry  Rc   RB   R   R   Rk   R  R0   RG   RC   R1   R+   R  Rq   R
+  (   R	   R   t   arrXt   arrYR   R  R  R  R  R  R  R  t   grpExp(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileMeshAddGroup1  sZ    	 
+ 
+	 !   , 
+ ,
+ 0
+,
+ 0c      
+   C   sZ  d } t  d d d g  } | j d d d g  t   } | j |  | j d  | j d	  | j | d  t t d d d
+ d d d d d g   } t t d d d d g  t	 t	  } t
+   } | j |  | j |  t   } | j |  | j d  | j d  | j d  | j d  | j d  |  j | j   d  |  j | j   d  |  j | j   d  |  j | j   d  |  j | j   d  t   } | j |  | j | d  t | | j    }	 |  j |	 j   d  |	 j d  }
+ |  j |
+ j |   |  j t  |	 j d  |  j t  |	 j! d  |	 j! d  d  S(   Ns   Pyfile92.medi    i   i   s   x [cm]s   y [cm]s   z [cm]t   maa1s   un maillagei   i   i   i   i   i   i	   i
+   i   i   t   joint_descriptiont   joint_1(   i    i    i    (   i   i    i    (   i   i    i    ("   RY   R  R>   Rc   RB   Ri   R   t   MEDFileJointCorrespondenceRk   R_   t   MEDFileJointOneStept   pushCorrespondencet   MEDFileJointt   pushStept   setLocalMeshNamet   setRemoteMeshNamet   setJointNamet   setDomainNumberR+   t   getLocalMeshNamet   getRemoteMeshNameR~   t   getJointNamet   getDomainNumbert   MEDFileJointst	   pushJointRC   t   getNumberOfJointst   getJointAtPosR0   R1   R)   R*   t   destroyJointAtPos(   R	   R!   R  R   t   node_correspondt   cell_correspondt   one_step_jointt	   one_jointt   jointst   jointsRt   jR(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileJoint1  sH    	*$			c         C   s  d } t  d d d g  } | j d d d g  t   } | j |  | j d  | j d	  t t d
+ d d d g   } t t d d g  t t	  } t
+   } t
+   } t   } t   }	 | j |  | j |  | j |  | j |  |	 j |  | j d  | j d  | j d  | j d  | j d  |	 j d  |	 j d  |	 j d  |	 j d  |	 j d  t   }
+ |
+ j |  |
+ j |	  | j |
+  | j | d  t j |  } |  j | j   d  | j   } |  j | j   | j    |  j t |  d  | d } | d } |  j | d  k  |  j | d  k  |  j  | j! |   |  j  | j! |	   d  S(   Ns   Pyfile93.medi    i   i   s   x [cm]s   y [cm]s   z [cm]RW  s   un maillagei   i   i   i   i   i   t   joint_description_1RY  t   joint_description_2t   joint_2(   i    i    i    (   i   i    i    (   i   i    i    ("   RY   R  R>   Rc   RB   Ri   RZ  Rk   R  R  R[  R]  R\  R^  R_  R`  Ra  Rb  Rg  Rh  t	   setJointsR   R'   R(   R+   Ri  t	   getJointst   getMeshNameRC   Ry   t   assertFalseR/  R0   R1   (   R	   t
+   fileNameWrR  R   Rl  Rm  Rn  t   two_step_jointRo  t	   two_jointRp  Rq  t   jointR1t   jointR2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileJoint2  sZ    						
+
+c      
+   C   su  t  t d d d d d d d d g   } t  t d	 d
+ d d g  t t  } t  t d	 d
+ d g  t t  } t  t d	 d
+ d d g  t t  } t   } | j |  | j |  t   } | j |  | j |  t   } | j |  | j |  t   } | j |  t   }	 |	 j |  t   }
+ |
+ j |  |  j | j |   |  j | j |   |  j | j |   |  j | j |	   |  j | j |
+   t	   } | j
+ |  | j d  | j d  | j d  | j d  | j d  |  j d | j    |  j d | j    |  j d | j    |  j d | j    |  j d | j    d  S(   Ni   i   i   i   i   i   i   i   i	   i
+   i   i   RW  t   maa2RX  RY  (   RZ  Rk   R_   R`   R[  R\  R0   R1   Rz  R]  R^  R_  R`  Ri   Ra  Rb  R+   Rc  Rd  R~   Rf  Re  (   R	   Rl  Rm  t   cell_correspon2t   cell_correspon3t
+   joint1st_1t
+   joint1st_2t
+   joint1st_3t
+   joint1st_4t
+   joint1st_5t
+   joint1st_6Ro  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyRs  3  sJ    *$!$							t   linuxs*   stderr redirection not ported on Windows ?c   
+      C   s`  d } d } d d l  } | j j |  r: | j |  n  t   } t d  } | j   | j | |  t   } | j	 |  | j
+ d  | j | d  | j | d  t t  } | j
+ d	  | j	 |  | j t d
+   d | j   (| j   t   } | j |  t |  }	 |  j t | j | d  ~	 | j j |  r\| j |  n  d S(   su    EDF11242 : check status of MED file calls to detect problems immediately. Sorry this test generates awful messages !s   Pyfile94.meds   Pyfile94.erriNi   R   i   i$  R5  id   g      Y@i    (   R   t   patht   existst   removeR   RY   Ry  Rc   R   R   RB   R   t   chmodRw  R  R{  R)  Rd   R   R%  R   R)   R*   (
+   R	   R9  t   errfnameR   R   R  R   R   R   R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileSafeCall0Z  s:    	 
+	
+	c         C   s   d } t  d  } | j   t   } | j | |  | j d  t   } | j |  | j t  | j	 | d  t |  } |  j
+ | j   d  | j t  | j	 | d  t |  } |  j | j   d k  d S(   sE    Non regression test to check the effectiveness of univ write status.s   Pyfile95.medi
+   R   i   R&   N(   RY   Ry  R   Rc   RB   R   R   t   setUnivNameWrStatusRN   R   R+   R{   R.   R0   (   R	   R9  R  R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testUnivStatus1  s"     
+	  	 c         C   s   d } t  d d  } | j t g  d d   | j t g   t d g   t   } | j d |  | j | d  t |  } |  j d | j	    | j
+   } |  j d |  d S(   si    MEDLoader should be able to consistently write and read an empty mesh (coords array
+      with 0 tuples s   Pyfile96.medR  i   i    N(    (   R[   Rc   RY   R  Rk   R>   Rj   R   R+   RC   R,   (   R	   R9  R   R	  t   mfu2t   lvl(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testEmptyMesh  s    	c         C   s  d } d } d } d } d } t  |  } | j   | | d :} | | 9} t   } | j | | |  | j   } | j |  t   } | | d <| j   }	 |	 | d <|	 j   d	 d	  d
+ f }
+ |
+ j	 | d | d  } | j |  |
+ j	 d d  } | j |  | j
+ d | | g  t j | d
+  } t j |  } t j | d
+  } t j |  } |  j | j | d  d  d	 S(   s[    Check that pickalization can be performed on a unpickalized instance. Non regression test.t   Mesh_1t   HAUTt   BASEg      ?i   i   i    iNi   g-q=g        g-qg-q=(   RY   Ry  R   Rc   R  RB   R>   R  t   computeCellCenterOfMasst   findIdsInRangeRl   R  R  R  R0   R1   (   R	   Rh  t   grpName1t   grpName2t   hauteurt   nbOfNodesPerAxisR  R   R   R   t   bary1R  R  R   R   t   st2R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileUMeshPickeling2  s:     
+  
+	   	 
+ 
+  c         C   s)	  d } d } t    } t d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d	 d f d d	 d f d d	 d f d d	 d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d	 d f d d	 d f d d	 d f d d	 d f d d d
+ f d d d f d d d f d d d
+ f d d d f d d d
+ f d d d f d d d
+ f d d d f d d d f d d d f d d d f d d d
+ f d d d
+ f d d d f d d d
+ f d d d
+ f d d d f d d d
+ f g3  } | j d d d g  t d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d! d d d d d d! d d  d d g<  } t | t  } | j |  | j |  | | d" <t d# d$ d d d d d d d d d d% d d d
+ d& d	 d# d d' d( d d d) d' d d d* d) d d d+ d* d d% d, d+ d d& d- d. d	 d' d/ d0 d( d) d d/ d' d* d1 d d) d+ d2 d1 d* d, d3 d2 d+ d- d4 d d d5 d  d d d6 d d d d7 d5 d d d8 d6 d5 d7 d d d6 d8 d d d  d5 d d d d6 d d d d d8 d6 d d d9 d: d d d6 d d d d: d! d d6 d d d! d: d d d6 d8 d d d: d9 d d g  } t | t  } | j |  | j |  | | d <d; | j	 d"  (d | j	 d  (| j
+ d< d"  | j
+ d= d;  | j
+ d> d?  | j d@ d" d; d? g  dA }	 dB }
+ | j   | j   } | j |	  } | j |
+  t d d
+ f d d f d d f d d f d d& f d d( f d d) f d d+ f d d- f d d0 f d d f d d2 f g  } | j d" |  |  j | j   j   d  |  j | j   j t  j |   | j   j   |  j | j   j   d  | j   j t |  |  j | j   j   d  |  j | j   j t  j |   | j   | j   | j   } | j |	  } | j |
+  | j   } | j t |  |  j | j   j   d  |  j | j   j t  j |   | j   } |  j | j | dC  d  |  j | j   j   d  |  j | j   j d  j   j t  j |   d | j   j d  j   j t  d d f <|  j | j | dC  d  d | j   j d  j   j t  d d f <|  j | j | dC  d  | j | d  t j |  } |  j | j | dC  d  dD S(E   s9    First check of equivalence implementation in MEDFileMeshs   Pyfile97.medt   M_01i    i   i   i$   i   i   i   i   i   g      )@s   X [Sans_unite]s   Y [Sans_unite]s   Z [Sans_unite]i   i   i   i   i   i   i    i,   i!   i(   i%   i#   i/   i*   i'   i0   i+   i&   ii   i   i   i   i   i   i	   i   i
+   i   i   i   i   i   i   i   i   i   i1   i2   i)   i-   i"   i.   is   HOMARD________-1s   HOMARD________-2s   HOMARD________-3it   HOMARDt   MAILLES_A_RECOLLER_APRES_HOMARDs   Cette equivalence decrit les mailles a recoller. Dans chaque correspondance, le premier numero est celui de la maille coupee ; le second numero est celui d'une des petites mailles en regard.g-q=N(    R>   RY   R  Rk   Rz   R`   Rc   R&  R   R   R   R   t   initializeEquivalencest   getEquivalencest   appendEmptyEquivalenceWithNameRi   R{  R+   t   getCellt   sizeR0   R)  R1   t   cleart   setArrayForTypet   killEquivalencest   initCellRq   t   getEquivalenceR   R'   R(   (   R	   R!   R  R   R  t   connQ4R   t   connH8R   t   eqNamet   descEqt   eqst   eq0t   corrR   R   t   mm3(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileEquivalence1  sx    	  r   
+    
+
+x%%
+
+%4..c   	      C   s  d } d } d t  j   } t d  } | j   t   } | j | |  | j   } t   } | | d <| j |  | j	 d d  d | j
+ d  d )| j	 d	 | d d  | j d	 | d d
+ g  t d  } d | (d | d d d d g <| j d |  | j	 d	 | d d  | j d	 | d d
+ g  |  j | j   d  |  j | j   d  |  j | j d
+  d  | j | d  t  j |  } |  j | j | d   |  j | j   d  |  j | j   d  |  j | j d
+  d  d S(   s}   Non regression bug EDF11911. For serial killers using same family name to store both cells and nodes ! Only sky is the limit.s   Pyfile98.medR   s   %s%%04ii   i    R  iis   RIDF%st   RIDi   i   i   i   i   s   RIDF!/__\!0000s   RIDF!/__\!0001t   RIDFgؗҜ<N(   s   FAMILLE_ZEROs   RIDF!/__\!0000s   RIDF!/__\!0001(   s   FAMILLE_ZEROR  R  (   ii   (   s   FAMILLE_ZEROs   RIDF!/__\!0000s   RIDF!/__\!0001(   s   FAMILLE_ZEROR  R  (   ii   (   R'   t   GetMagicFamilyStrRY   Ry  R   Rc   R  R>   RB   R   R   R  Rk   R   R+   R  t#   getFamiliesNamesWithFilePointOfViewR  R   R(   R0   R1   (	   R	   R!   R  t   magicStR  R   R   Re  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileForFamiliesPlayer1  s>     
+	 	
+  c         C   s)  t  d  } | j   t   } | j | |  | j   } t   } | | d <| j   t d  } d | (t d  } d | (| j d |  | j d |  | j	 d  | j
+ d  | j d d d	  | j d
+ d  | j d d
+ g  | j d  | j   j   } | d j   j   } |  j | | d j   j    | d j   j   } | j t  j   j   }	 |  j | | j t  j   j    | j t  | j   }
+ |  j |
+ j   t  | j t  |  j t |
+ t   |  j | j   |
+ j   k  |  j | | j   j   k  |  j | |
+ j   j   k  |  j |
+ j   j   |
+ d j   j    |  j |
+ j   j   |
+ j t  j   j    |  j |
+ d j   j   |  |  j |
+ d j   j   |  |  j |
+ j t  j   j   |	  |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j    | j     |  j |
+ j!   | j!    |  j |
+ j"   | j"    |  j g  |
+ j"   D] } |
+ j# |  ^ qg  | j"   D] } | j# |  ^ q |  j | j$ d  j   | j    |  j |
+ j$ d  j   | j    |  j | j$ d  j   | j    |  j |
+ j$ d  j   | j    | j t  | j   }
+ |  j |
+ j   t  |  j t |
+ t   |  j | j   |
+ j   k  t  d  } | j   t   } | j | |  | j%   } t&   } | j' |  | j t  | j d |  | j d |  | j	 d  | j
+ d  | j d d d	  | j d
+ d  | j d d
+ g  | j d  | j(   j   j   } | j   }
+ |  j |
+ j   t  |  j t |
+ t&   |  j | j   |
+ j   k  |  j | | j(   j   j   k  |  j | |
+ j(   j   j   k  |  j |
+ j(   j)   | j(   j)    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j    | j     |  j |
+ j!   | j!    |  j |
+ j"   | j"    |  j g  |
+ j"   D] } |
+ j# |  ^ qg  | j"   D] } | j# |  ^ q |  j | j$ d  j   | j    |  j |
+ j$ d  j   | j    |  j | j$ d  j   | j    |  j |
+ j$ d  j   | j    | j t  | j   }
+ |  j |
+ j   t  |  j t |
+ t&   |  j | j   |
+ j   k  t  d  } | j   t   } | j | |  t*   } | j' |  | j t  | j d |  | j d |  | j	 d  | j
+ d  | j d d d	  | j d
+ d  | j d d
+ g  | j d  | j   }
+ |  j |
+ j   t  |  j t |
+ t&   |  j |
+ j(   j)   | j(   j)    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j   | j    |  j |
+ j    | j     |  j |
+ j!   | j!    |  j |
+ j"   | j"    |  j g  |
+ j"   D] } |
+ j# |  ^ q
+g  | j"   D] } | j# |  ^ q |  j | j$ d  j   | j    |  j |
+ j$ d  j   | j    |  j | j$ d  j   | j    |  j |
+ j$ d  j   | j    | j t  | j   }
+ |  j |
+ j   t  |  j t |
+ t*   |  j | j   |
+ j   k  d S(   sl    This test is advanced to be sure that no unnecessary copies had been made during cartesianization process. i   i    i   i	   i   R  R  i   g      @R   iRe  R   N(+   RY   Ry  R   Rc   R  R>   R  Rk   R   RB   Ri   R   R   R  R   R   R   Rv   R+   Rw   Rs   R`   R  R  t   cartesianizeR  R  R0   Rt   RC   R~   R   R   R  R  R)  R   t   buildCurveLinearR  R   R   t   getNodeGridStructureR   (   R	   R  R   R   t   d0R  R  R  R  t   ref3R   R   t   elt2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testCartesianizer1  s    
+ 	  	 
+ 
+         %,1  %T%%%% 
+ 	  	        %%(T%%%% 
+ 	 	        (T%%%%c      
+   C   s{  t  d d  } | j t d g d d d   | j t t d d d t d d d g  t d d d	 g   | j   \ } } } } } t   } | j d |  | j d
+ |  | j	   | j
+   } t d g d  } | j d |  | j d  |  j t | j	  | } | j
+   } t d g d  } | j d |  | j d  |  j t | j	  | } | j
+   } | j d t d g d   |  j t | j	  | } | j
+   } t d g d  } | j d |  | j d  |  j t | j	  | } | j
+   } t d g d  } | j d |  | j d  |  j t | j	  | } | j
+   } t d g d  } | j d |  | j d  |  j t | j	  | } | j
+   } | j d t d g d   |  j t | j	  | } | j
+   } t d g d  } | j d |  | j d  |  j t | j	  | } | j
+   } t d g d  } | j d
+ |  | j d  |  j t | j	  | } | j
+   } t d g d  } | j d
+ |  | j d  |  j t | j	  | } | j
+   } | j d
+ t d g d   |  j t | j	  | } | j
+   } t d g d  } | j d
+ |  | j d  |  j t | j	  d  S(   Nt   2di   g        g      ?i   i    i   i   i   ii#   s   tutu           xi   (   g        g      ?(   R[   Rc   RY   R  Rk   R_   R  R>   Rj   R   Rq   R   t   reAllocR)   R*   R   R  R  (   R	   R   R   R  t   mumt   mum2R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testCheckCoherency{  s     =	
+                    c      
+   C   s]  t  d d  } | j t d g d d d   | j t t d d d t d d d g  t d d d	 g   | j   \ } } } } } t   } | j d |  | j d
+ |  | j	   | j
+   t | j   d  } | j d  t | j   d  } | j d  | j d |  | j d
+ |  |  j t | j
+  | j d
+ | d  | j
+   d  S(   NR  i   g        g      ?i   i    i   i   i   iid   (   g        g      ?(   R[   Rc   RY   R  Rk   R_   R  R>   Rj   R   t   checkSMESHConsistencyR   Ry  R   R)   R*   (   R	   R   R   R  R  R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testCheckSMESHConsistency  s&     =	
+
+  
+c      
+   C   s6  t  d d  } | j t d g d d d   | j t t d d d t d d d g  t d d d	 g   | j   \ } } } } } t   } | j d |  | j d
+ |  | j	   t | j
+   d  } | j d  t | j
+   d  } | j d  | j d |  | j d
+ |  | j   | j   d  S(   NR  i   g        g      ?i   i    i   i   i   i(   g        g      ?(   R[   Rc   RY   R  Rk   R_   R  R>   Rj   R   R   Ry  R   t   clearNodeAndCellNumbersR  (   R	   R   R   R  R  R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testClearNodeAndCellNumbers  s"     =	
+  
+
+c         C   s1  d } d } t  d d d d g  } t  d d d g  } t   } | j | |  | j |  t   } | j |  t d d d d d d g  } t d d d d d	 d d d
+ d d d d g  } | j d |  | j d |  | j | d  t	 j
+ |  } |  j | j d  d  k	  |  j | j d  d  k	  | j d d   | j d d   |  j | j d  d  k  |  j | j d  d  k  | j   }	 |  j |	 j d  d  k  |  j |	 j d  d  k  | j | d  t	 j
+ |  }
+ |  j |
+ j d  d  k  |  j |
+ j d  d  k  d  S(   NR   s   Pyfile99.medi    i   i   i   iii   i   (   RY   R   Rc   RB   R   R   Rk   R   R   R'   R(   R0   R   R/  Rq   (   R	   R  R9  RS  RT  R   R   t
+   famCellIdst
+   famNodeIdsR  R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testCMeshSetFamilyFieldArrNull  s:    	  	 0c         C   sq  d } t  d d d d g  } t  d d d g  } t   } | j | |  | j d  t   } | j |  t   } d } t d d d g  } | j |  t t	  }	 |	 j |  d	 }
+ |	 j
+ d
+ d d  |	 j |
+  t d d d g  } |	 j |  | j |	 | d |  | j | d  | j | d  t j |  } t j |  } |  j t | t   |  j | j   |
+  |  j t |  d  | d } | j t	 d |  \ } } |  j | j   |  |  j | j   |
+  |  j | j |   | j t	 d |  } |  j | j   j |   |  j | j   |	 j    |  j | j   j   t |   d  S(   Ns   Pyfile100.medi    i   i   i   Rn  t   PFLi   R  g333333?ie   if   ig   (   RY   R   Rc   RB   R   R   R#  Rk   R&  R  R   R{  R  R   R'   R(   R"  R0   Rt   R+   RC   Ry   R~  R  R  R)  R   R   R   (   R	   R9  RS  RT  R   R   Rm  t   pflNameR  R   Rg  R  R   t   ftestR2  t   ftest2(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt    testAppendFieldProfileOnIntField  sJ    	  		    
+"c         C   s  d } d } t    } t dE dF dG g  } t d d  } | j |  | j   | j t d d d g  | j t d d d	 g  | j t d d d g  | j t d
+ d d g  | j t d d d d g  | j t d d d d g  | | d <| j | d  t d d d d d d g  } t	 t
+  } | j |  | j |  | j |  | j d d d  | j   } t   }	 |	 j |  |	 j | d  | d }
+ | j |
+  | j d d d
+  t   }	 |	 j |  |	 j | d  | j   } t j |  } t | | d d  } | j |  } |  j | j | d d   t | | d d
+  } | j |  } |  j | j | d d   t | |  } |  j | j | j d d
+ |  d d   t	 t  } t d d d  g  }
+ |
+ j d d!  | j |
+  | j |  | j d" d# d$  | j |  | j | d  t   }	 |	 j |  |	 j | d  t j |  } t | | d# d$  } |  j | j | j |  d d   t | |  } |  j | j | j d# d$ |  d d   t	 t  } | j |  t d d d d d d	 d d d d
+ d d d d d% d& d' d( d) d* g  } | j |  | j d+ d d  | j |  | j   | j | d  t   }	 |	 j |  |	 j | d  t j |  } t | | d d  } |  j | j | j |  d d   t	 t  } | j |  | j |  | j t d, d, d- d, d- d- g d. d. d/ d/ d0 d0 d1 d1 d+ d+ g
+ d/ d0 d. d2 d3 g  | j t d, d, d- d, d- d- d, d- g d0 d1 d4 d5 g d5 d0 g  | j d6 d d	  t d d d d d d d d d d% d7 d8 d9 d# d$ d: d; d< d= d> d? d@ dA dB g  } | j d dC  | j |  | j   | j | d  t   }	 |	 j |  |	 j | d  t j |  } t | | d d	  } |  j | j | j |  d d   dD S(H   s   Check for all spatial discretization of field (cells,nodes,elno,gauss) for double field that all is OK. Here no profile and only top level is considered.s   Pyfile101.medt   field1i   i   i   i   i   i   i   i	   i
+   R   i    i   i   id   ie   if   ig   ih   ii   ij   ik   i   i   g       @i  g      @g-q=i   i   i   t   tutug      6@i   i   i   i   i   i   i   i   g      ?g        g      ?g?g?g333333?g?g?gffffff?g333333?gffffff?g      ?i   i   i   i   i   i    i!   i"   i-   i.   i7   i8   R  N(   i   i   i   (   i   i   i   (   i   i	   i
+   (   R>   RY   R[   Rc   R]   R^   R_   R`   R   Rw  R  R{  R   RB   R   Rq   R   RY  R   R%  R'   R(   R5  R0   R1   R  R   R  Rd   R  t   setGaussLocalizationOnType(   R	   R9  Rg  R   R  R   R  R   R   R   R  R   R   t   ftst0t   ftst1Rm  R   R
+  t   arr3R  t   arr4(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldEasyField1  s    	 
+
+   	 
+  	 +     	  %+  H   
+ 	  %  U@ T  
+ 	  %c         C   s  d } d } t    } t dE dF dG g  } t d d  } | j |  | j   | j t d d d g  | j t d d d	 g  | j t d d d g  | j t d
+ d d g  | j t d d d d g  | j t d d d d g  | | d <| j | d  t	 d d d d d d g  } t
+ t  } | j |  | j |  | j |  | j d d d  | j   } t   }	 |	 j |  |	 j | d  | d }
+ | j |
+  | j d d d
+  t   }	 |	 j |  |	 j | d  | j   } t j |  } t | | d d  } | j |  } |  j | j | d d   t | | d d
+  } | j |  } |  j | j | d d   t | |  } |  j | j | j d d
+ |  d d   t
+ t  } t	 d d d  g  }
+ |
+ j d d!  | j |
+  | j |  | j d" d# d$  | j |  | j | d  t   }	 |	 j |  |	 j | d  t j |  } t | | d# d$  } |  j | j | j |  d d   t | |  } |  j | j | j d# d$ |  d d   t
+ t  } | j |  t	 d d d d d d	 d d d d
+ d d d d d% d& d' d( d) d* g  } | j |  | j d+ d d  | j |  | j   | j | d  t   }	 |	 j |  |	 j | d  t j |  } t | | d d  } |  j | j | j |  d d   t
+ t  } | j |  | j |  | j t d, d, d- d, d- d- g d. d. d/ d/ d0 d0 d1 d1 d+ d+ g
+ d/ d0 d. d2 d3 g  | j t d, d, d- d, d- d- d, d- g d0 d1 d4 d5 g d5 d0 g  | j d6 d d	  t	 d d d d d d d d d d% d7 d8 d9 d# d$ d: d; d< d= d> d? d@ dA dB g  } | j d dC  | j |  | j   | j | d  t   }	 |	 j |  |	 j | d  t j |  } t | | d d	  } |  j | j | j |  d d   dD S(H   s   Same thantestMEDFileFieldEasyField1 except that here intfields are considered.
+        Check for all spatial discretization of field (cells,nodes,elno,gauss) for int field that all is OK. Here no profile and only top level is considered.s   Pyfile102.medR  i   i   i   i   i   i   i   i	   i
+   R   i    i   i   id   ie   if   ig   ih   ii   ij   ik   i   i   g       @i  g      @g-q=i   i   i   R  g      6@i   i   i   i   i   i   i   i   g      ?g        g      ?g?g?g333333?g?g?gffffff?g333333?gffffff?g      ?i   i   i   i   i   i    i!   i"   i-   i.   i7   i8   R  N(   i   i   i   (   i   i   i   (   i   i	   i
+   (    R>   RY   R[   Rc   R]   R^   R_   R`   R   Rk   R&  R  R{  R   RB   R   Rq   R#  RY  R  R%  R'   R(   R5  R0   R1   R  R   R  Rd   R  R  (   R	   R9  Rg  R   R  R   R  R   R   R   R  R   R   R  R  Rm  R   R
+  R  R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldEasyField2a  s    	 
+
+   	 
+  	 +     	  %+  H   
+ 	  %  U@ T  
+ 	  %c         C   s	  d } d } t    } t d@ dA dB g  } t d d  } | j |  | j   | j t d d d g  | j t d d d	 g  | j t d d d g  | j t d
+ d d g  | j t d d d d g  | j t d d d d g  | | d <t d d  } | j |  | j   | j t d d d	 d g  | j t d d d d g  | | d <| j	 | d  t
+ t  } | j |  | j t dC dD g   | j | d  | j d d d  t   } | j |  | j	 | d  t j |  } t | | d d  } |  j | j | j |  d d   t
+ t  } | j |  | j t dE dF dG dH dI dJ g   | j | d  | j d d d  | j   | j	 | d  t   } | j |  | j	 | d  t j |  } t | | d d  } |  j | j | j |  d d   t
+ t  }	 |	 j | d  t d d d d d d	 d d d d
+ d d d d d d d  d! d" d# g  }
+ |	 j |
+  |	 j d$ d d  |	 j |  |	 j   | j	 | d  t   } | j |	  | j	 | d  t j |  } t | | d d  } |  j |	 j | j |  d d   t
+ t  } | j | d  | j |  | j t d% d% d& d% d& d& g d' d' d( d( d) d) d* d* d$ d$ g
+ d( d) d' d+ d, g  | j t d% d% d& d% d& d& d% d& g d) d* d- d. g d. d) g  | j d/ d d	  t d d d d d d d d d d d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= g  } | j d d>  | j |  | j   | j	 | d  t   } | j |  | j	 | d  t j |  } t | | d d	  } |  j | j | j |  d d   d? S(K   s   Here a multi level mesh. And field on cells lying on different level of this mesh. Show how "field" method deal with that. Here on field double are considered.s   Pyfile103.medR  i   i   i   i   i   i   i   i	   i
+   R   i    i   i   id   ie   if   ig   ih   ii   ij   ik   ig      @g-q=g      0@i   i   i   i   i   i   i   i   g      ?g        g      ?g?g?g333333?g?g?gffffff?g333333?gffffff?g      ?i   i   i   i   i   i   i   i    i!   i"   i-   i.   i7   i8   R  N(   i   i   i   (   i   i   i   (   i   i	   i
+   (   i    id   (   i   ie   (   i    id   (   i   ie   (   i    id   (   i   ie   (   i    id   (   i   ie   (   R>   RY   R[   Rc   R]   R^   R_   R`   R  R   Rw  R  RB   R{  R   R   R   R%  R'   R(   R0   R1   R5  Rd   R  R  R  R   (   R	   R9  Rg  R   R  R   R   R   R   R
+  R  R   R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldEasyField3  s    	 
+
+ 
+
+    	   %  %
+	   %H   
+ 	   %U@ T  
+ 	   %c         C   s	  d } d } t    } t d@ dA dB g  } t d d  } | j |  | j   | j t d d d g  | j t d d d	 g  | j t d d d g  | j t d
+ d d g  | j t d d d d g  | j t d d d d g  | | d <t d d  } | j |  | j   | j t d d d	 d g  | j t d d d d g  | | d <| j	 | d  t
+ t  } | j |  | j t dC dD g   | j | d  | j d d d  t   } | j |  | j	 | d  t j |  } t | | d d  } |  j | j | j |  d d   t
+ t  } | j |  | j t dE dF dG dH dI dJ g   | j | d  | j d d d  | j   | j	 | d  t   } | j |  | j	 | d  t j |  } t | | d d  } |  j | j | j |  d d   t
+ t  }	 |	 j | d  t d d d d d d	 d d d d
+ d d d d d d d  d! d" d# g  }
+ |	 j |
+  |	 j d$ d d  |	 j |  |	 j   | j	 | d  t   } | j |	  | j	 | d  t j |  } t | | d d  } |  j |	 j | j |  d d   t
+ t  } | j | d  | j |  | j t d% d% d& d% d& d& g d' d' d( d( d) d) d* d* d$ d$ g
+ d( d) d' d+ d, g  | j t d% d% d& d% d& d& d% d& g d) d* d- d. g d. d) g  | j d/ d d	  t d d d d d d d d d d d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: d; d< d= g  } | j d d>  | j |  | j   | j	 | d  t   } | j |  | j	 | d  t j |  } t | | d d	  } |  j | j | j |  d d   d? S(K   s7    Same than testMEDFileFieldEasyField3 but with integerss   Pyfile104.medR  i   i   i   i   i   i   i   i	   i
+   R   i    i   i   id   ie   if   ig   ih   ii   ij   ik   ig      @g-q=g      0@i   i   i   i   i   i   i   i   g      ?g        g      ?g?g?g333333?g?g?gffffff?g333333?gffffff?g      ?i   i   i   i   i   i   i   i    i!   i"   i-   i.   i7   i8   R  N(   i   i   i   (   i   i   i   (   i   i	   i
+   (   i    id   (   i   ie   (   i    id   (   i   ie   (   i    id   (   i   ie   (   i    id   (   i   ie   (   R>   RY   R[   Rc   R]   R^   R_   R`   R  R   R&  R  RB   R{  Rk   R   R   R  R%  R'   R(   R0   R1   R5  Rd   R  R  R  R   (   R	   R9  Rg  R   R  R   R   R   R   R
+  R  R   R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldEasyField4  s    	 
+
+ 
+
+    	   %  %
+	   %H   
+ 	   %U@ T  
+ 	   %c         C   s  d } d } t    } t d d  d! g  } t d d  } | j |  | j   | j t d d d g  | j t d d d	 g  | j t d d d g  | j t d
+ d d g  | j t d d d d g  | j t d d d d g  | | d <| j | d  t	 d d d d	 g  } | j
+ d  | j   | } | j
+ | j    t d d d d g  } t t  }	 |	 j |  |	 j |  |	 j
+ |  |	 j d d d  |	 j   t   }
+ |
+ j |	 | d |  |
+ j | d  t j |  } t | | d d  } |  j |	 j | j |  d d   t d d  } | j |  | j   | j t d d d	 d g  | j t d d d d g  t    } | | d <| | d <t   }
+ |
+ j |	 | d |  t j |  } t | | d d  } |  j |	 j | j |  d d   d S("   sO   More and more difficult now look at how profiles are managed by "field" method.s   Pyfile105.medR  i   i   i   i   i   i   i   i	   i
+   R   i    i   i   id   ie   if   ig   ih   ii   ij   ik   R  i   i   g       @g-q=iN(   i   i   i   (   i   i   i   (   i   i	   i
+   (   R>   RY   R[   Rc   R]   R^   R_   R`   R   Rk   RB   Rq   RC   Rw  R  R{  R   R   Rd   R   R  R'   R(   R   R0   R1   R5  R  R|  (   R	   R9  Rg  R   R  R   R  R   R  R   R   R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testMEDFileFieldEasyField5  s\    	 
+
+      
+	  % 
+	
+ 
+	  %c   $      C   sC  t  d? d@ dA dB dC dD dE dF dG dH dI dJ dK dL dM g  } d } t | d  } | j |  | j   | j t d d d g  | j t d d d g  | j t d	 d
+ d g  | j t d	 d d
+ g  | j t d d d g  | j t d d d g  | j t d d d	 d g  | j t d d	 d d g  | j t d d
+ d d g  | j t d d d d	 g  | j t d d d d g  t | d  } | j |  | j   | j t d d g  | j t d d g  | j t d d g  | j t d d g  | j t d d g  | j t d d g  | j t d d g  | j t d d g  | j t d d
+ g  | j t d
+ d g  | j t d d g  | j t d d g  t   } | | d <| | d <t	 d d d d d d d	 d d d
+ g
+  } i  } t	 d d d d d d	 g  | d <t	 d d d d d g  | d <t
+   } |  j | j |  j |   | | d <d }	 t   }
+ | j |
+  dN } d g } t  d d d d d d d d d d d g  } | j |  t t  } | j |   | j |  | j |  | j |	  t t  } | j |   | j t  d  d! d" d# d$ d% d& d' d( d) d* d+ g   | j |  | j |	  | j   j |  t t  } | j |   | j t  d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d: g   | j |  | j |	  | j   j |  t   } | j |  | j |  | j |  |
+ j |  | j |  } | j | |  } |  j t |  d  | d } |  j t |  d  | d } |  j t  | j! |  |  j | d j"   j | | d j"   d;   |  j | d j"   j | | d j"   d;   | j#   | d } | j$ | d j% | j&    t | d   | j | j'    |  j | d j | d;   | j#   | d } | j$ | d j% | j&    t | d   | j | j'    |  j | d j | d;   |  j | d j | d;   | j( t d |  } | j)   |  j | j*   t  |  j | j+   j | d;   t  d d d d d d g  } | j |  |  j | j   j | d;   |  j | j,   t- |   | j( t d |  } | j)   |  j | j*   t  |  j | j+   j | d;   t  d" d# d$ d% d) g  } | j |  |  j | j   j | d;   |  j | j,   t- |   | j( t d |  } | j)   t  d, d- d. d/ d0 d2 d3 d4 d8 d9 g
+  } | j |  |  j | j   j | d;   |  j | j,   t- |   t
+   } t   }
+ | j |
+  dO dP dQ g } x t. |  D] \ } } t t  } | j |   | | d> }  | j |   | j |  | j |	  | j   j |  t   } | j |  |
+ j |  qo	W| j | |  }! |  j t |!  d  |! d } |  j t |  t |   x t. t/ | |   D] \ } \ }" } |" j! |  }# |# j)   |  j |# j*   t  t  d d d d d d g  } | j |  | | d> 7} |  j |# j+   j | d;   |  j |# j   j | d;   |  j |# j,   t- |   qg
+Wd  S(R   Ni    i   i   i   i   R   i   i	   i   i   i   i   i   i   i   i
+   it   Field0g     0@s   toto [m]id   ie   if   ig   ih   ii   ij   ik   il   im   in   i   i   i   i   i   i   i   i   i   i   i   i   i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  g-q=g     1@g     2@g     @@(   i    i    (   i   i    (   i   i    (   i   i    (   i   i    (   i    i   (   i   i   (   i   i   (   i   i   (   i   i   (   i    i   (   i   i   (   i   i   (   i   i   (   i   i   (   g     0@i   i   (   g     0@i   i   (   g     1@i   i   (   g     2@i   i   (0   RY   R[   Rc   R]   R^   R_   R`   Re   R>   Rk   R[  R0   t    deduceNodeSubPartFromCellSubPartR1   R   R\  R  Rw  R  R   R{  R   RB   R)  R  R   R%  RE  t   extractPartR+   Ry   R)   R*   R5  R  Rq   t   renumberNodest   invertArrayN2O2O2NR  RC   R  Rd   R  R   R   Rm   R   RS  ($   R	   R  R  R   R   R   R  t   tabRl  t   fname0Rm  t   t0t   ict   arr0_0R   R   R   R   t   mmOutt   fsPart0t   fmtsPt   m0Partt   m1Partt   f0Partt   arr0Expt   f1Partt   arr1Expt   f2Partt   arr2Expt   tssR   R   t   myarrt   fsPart1t   f1tsPt   fPart(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testExtractPart1F  s   9  
+  
+	
+ 
+*"	
+	 	-      7    @  	   
+
+11 -  -  
+   
+   
+*  	 	    	  
+( 
+  c   !         s  d } d } d } d } t    } t d d d d d	 d
+ d d d d d d g d	 d  } | j d d d g  | j |  t | d  } | j   | j |  | j t d d d d g  | j t d	 d d d g  | j t d d d d
+ d d g  | j t d d d d d d g  | j t d d d d d  d! g  | | d <| j	 d t
+ d d d d	 d g   | j d t
+ d
+ d d d d g   t | d  } | j   | j |  | j t d d d g  | j t d d	 d g  | j t d d d d g  | j t d d
+ d d g  | j t d d d d g  | j t d d d d g  | | d" <| j	 d" t
+ d d d d d d
+ g   | j d" t
+ d d d d d d g   x+ t d d  D] }	 | j d# |	 |	  qW| j d$ d  | j d% d&  | j d' d( d) g  | j d* d( d) g  | j	 d t
+ d d d d g   | j d t
+ d d d  d! g   t    }
+ t d d d+ d
+ d d, d d d- d d d. d d d/ g d d  } | j d d d g  |
+ j |  t | d  } | j   | j |  | j t d& d0 d1 d2 g  | j t d3 d4 d5 d6 g  | j t d7 d8 d9 d: g  | j t d; d< d= d> d? d@ g  | |
+ d <|
+ j	 d t
+ dA dB dC dD g   |
+ j d t
+ dE dF dG dH g   t | d  } | j   | j |  | j t d& d0 d1 g  | j t d2 d3 d4 g  | j t d5 d6 d7 g  | j t d8 d9 d: d; g  | j t d< d= d> d? g  | j t d@ dI dJ dK g  | j t dL dM dN dO g  | j t dP dQ dR dS g  | |
+ d" <|
+ j	 d" t
+ dT dU dV dW dX dY dZ d[ g   |
+ j d" t
+ d\ d] d^ d_ d` da db dc g   x/ t d d  D] }	 |
+ j dd |	 |	 d+  q:W|
+ j d% d&  |
+ j d$ d  |
+ j d' de df g  |
+ j dg dh di g  |
+ j	 d t
+ d; d< d= d> d? g   |
+ j d t
+ dM dN dO dP dQ g   t  j | |
+ g  } dj        |  dk } d } d  dn do g } t   } t   } t t    j | d   j |  t d d d d d g  } | j |   j |   j |    j dp   j   | j   t t    j | d"   j |  t d d d d d d g  } | j |   j |   j |    j dp   j   | j   t t    j | d   j |  t d d d d g  } | j |   j |   j |    j dp   j   | j   | j |  | j   } | j  d  d  d  | j    dq 7(| j |  t   } t   } t t    j |
+ d   j |  t d d d d g  } | j |   j |   j |    j dp   j   | j   t t    j |
+ d"   j |  t d d d d d d d d g  } | j |   j |   j |    j dp   j   | j   t t    j |
+ d   j |  t d d d d d g  } | j |   j |   j |    j dp   j   | j   | j |  | j   } | j  d  d  d  | j    dq 7(| j |  t!   } | j" t#    | j$   j% |  | j& t'    | j(   j) |  t!   } | j" t#    | j$   j% |
+  | j& t'    | j(   j) |  t! j | | g  }           f	 d   }  |   |  | j* | d  | j* | d  t! j t! |  t! |  g  } |   |  d S(   sj    Testing of MEDFileData::Aggregate and MEDFileUMesh::Aggregate and MEDFileUMesh::getAllDistributionOfType s   Pyfile106_1.meds   Pyfile106_2.meds   Pyfile106_3.medR   i   i   i
+   i   i   i   i   i   i   i   i   i   s   aa [m]s   bbb [kg]s	   cccc [MW]i    i	   i   i   i   i   i   i   i   i   i   i   i   i   is   F%dR  t   H1id   t   myGRPR  t   F6t   myGRP1i   i   i    i!   i"   ie   if   ig   ih   ii   ij   ik   il   im   in   io   ip   iq   ir   is   it   iu   i(   i)   i*   i+   i2   i3   i4   i5   iv   iw   ix   iy   iz   i{   i|   i}   i~   i   i   i   i   i   i   i   i   i   i   i,  i-  i.  i/  i0  i1  i2  i3  s   G%dRW   t   G6t   myGRP2t   G4t   G7c      D   S   s  t  d~ d d d d d d d d g	  } | j d d d g  |  j | j   j | d   |  j | d j   j t d d d d d d d d d d
+ d d d d d  d d! d" d# d$ d d% d& d' d( d d d d d d	 d d d d d d d d) d d* d+ d, d- d. d/ d d0 d1 d2 d3 d4 d5 g5    |  j | d j   j t d d d d d* d/ d d6 d7 d8 g
+    |  j | d9 j   j t d d d d d d d d d d d d d d  d! d" d d# d$ d% d d d
+ d d d d d d	 d d d d d d d d d) d* d+ d d& d' d( d0 d d1 d2 d3 d4 d d5 d: d; d< d d= d> d? d@ d dA dB dC dD gA    |  j | d9 j   j t d d d d	 d d* d/ d dE dF dG dH dI dJ dK g    |  j | j d  j t d d dF dL dM d d d dN g	    |  j | j	 d  j t d d	 dH dO dP d d d d8 g	    |  j | j d9  j t d d
+ dQ dR dS d d d d dT dU dV dW dX g    |  j | j	 d9  j t d d dY dZ d[ d d) d* d+ d\ d] d^ d_ d` g    d d d d d d d d d d d d d d d d d d d d d d g } |  j
+ t | j    t g  | D] } | d ^ q&  |  j
+ t g  | j   D] } | j |  ^ qV t g  | D] } | d ^ q{  |  j
+ | j   d  |  j
+ | j   t d f t d f t d f t d f t d f g  d  S(   Ni   i   i
+   i   i   i   i   i   i   i   i   i   i	   i   i   i   i    i   i   i!   i   i   i"   s   aa [m]s   bbb [kg]s	   cccc [MW]g-q=i    ih   ii   ij   ik   il   im   in   io   ip   iq   ir   is   i   i   i   i   i   i   i   it   iu   iv   iw   ix   iy   i'   i.   i5   iiz   i{   i|   i}   i~   i   i   i   i   i   i   i#   i(   i-   i2   i7   i<   iA   i)   i*   i+   i3   i4   i   i   i   i   i   i   i   i   i,  i-  i.  i/  i0  i1  i2  i3  R  Rr  R  t   F3t   F4t   F5R  t   F7t   F8t   F9RV   t   G10t   G11RW   t   G3R  t   G5R  i$   R  i%   t   G8i&   t   G9R  id   R  R   R  (   i   i   i
+   (   i   i   i   (   i   i   i   (   i   i   i   (   i	   i
+   i   (   i   i   i   (   i   i   i    (   i   i   i!   (   i   i   i"   (   s   FAMILLE_ZEROi    (   s   F1i   (   s   F2i   (   R  i   (   R  i   (   R  i   (   R  i   (   R  i   (   R	  i   (   R
+  i	   (   s   G1i   (   R  i(   (   R  i)   (   s   G2i    (   R  i!   (   R  i"   (   R  i#   (   R  i$   (   R  i%   (   R  i&   (   R  i'   (   R  id   (   R  R   R  (   RY   R  R0   R   R1   Rv   Rk   Rw   R   R  R+   R  R  R)  R  t   getAllDistributionOfTypesR_   R`   R  R  R  (   t   testerR   t   cooExpt	   refFamIdsR   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt	   CheckMesh   s"    ' DS@@OOH9UCt   zeFieldgffffff@gffffff@s   dd [W]s   eee [kA]R   i  i   i   i   i   i6   i   i7   i   i8   i   i9   i   i   i;   i   i<   i   i=   i   i>   i   i?   i   i@   i   iA   i   iB   i   c            s  |  j  t | j    d  |  j  t | j    d     | j   d  |  j  t | j   d  d  | j   d d } | j t d | j   d  } t j   g  } | j   j	   j
+   } | j |  |  j | j | d d   | j t d | j   d  } t j   g  } | j   j	   j
+   } | j |  |  j | j | d d   | j t d | j   d  } t j   g  } | j   j	   j
+   } | j |  |  j | j | d d   | j   d d } | j t d | j   d  }	 t j   g  } | j   j	   j
+   } | j |  | j    | j   d 7(|  j | j |	 d d   | j t d | j   d  }
+ t j   g  } | j   j	   j
+   } | j |  | j    | j   d 7(|  j | j |
+ d d   | j t d | j   d  } t j   g  } | j   j	   j
+   } | j |  | j    | j   d 7(|  j | j | d d   d  S(   Ni   i    i   g-q=ii  (   R+   Ry   RT  Ra  R  R  Rw  t   MergeFieldsR   Rq   R  R  R0   R1   R  R   R)  (   R  R>  t   zeF1t   zeF1_1R0  R  t   zeF1_2t   zeF1_3t   zeF2t   zeF2_1t   zeF2_2t   zeF2_3(	   R  t   f1_1t   f1_2t   f1_3t   f2_1t   f2_2t   f2_3R	   t   t2(    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   CheckMFD\  sT        N(   gffffff@i   i   (   gffffff@i   i   (   i
+   in   (   i   io   (   i   ip   (   i   iq   (   i   ir   (   i   is   (   i   it   (   i   iu   (   i   iv   (   i   iw   (   i   ix   (   i   iy   (   i   iz   (   i   i{   (   i   i|   (   i2   i   (   i3   i   (   i4   i   (   i5   i   (   i6   i   (   i7   i   (   i8   i   (   i9   i   (   i   i   (   i;   i   (   i<   i   (   i=   i   (   i>   i   (   i?   i   (   i@   i   (   iA   i   (   iB   i   (+   R>   RY   R  Rc   R[   R]   R^   R  R  R   Rk   R   R_   R`   Rn   R   R  R  R   R   Rw  R  R   RB   R{  R   R   Rd   R%  R  RE  Rq   R+  RK  RR  RP  RT  R7  R]  R[  Ra  R\  R   (!   R	   t   fname1Rn  t   fname3R  R:  R   t   mm1_0t   mm1_1R   R   t   mm2_0t   mm2_1R   Rg  t   t1t   infoct   fmts1t   f1ts1Rz  R  R  t   f1ts2R  t   f1ts3R  t   arr5t   arr6t   f1ts4t   mfd1t   mfd2R>  R'  (    (	   R  R   R!  R"  R#  R$  R%  R	   R&  ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testSymmetryPlusAggregationMFD1  s\   	6  
+"""
+%% 
+
+((""	?  
+"
+"" 
+
+..%%			    
+    
+    
+		    
+  $  
+    
+		') !c         C   s  d } t  d d d d g  } t  d d d d d g  } t  d d d d d d g  } t   } | j | | |  | j d  t |  } t |  } | j | d  | j   } t j	 |  }	 |	 j   }
+ |  j
+ | j | d	   |  j
+ | j |
+ d	   d  S(
+   Ns   Pyfile107.medi    i   i   i   i   i   R   g-q=(   RY   R   Rc   RB   t   MEDCouplingMappedExtrudedMeshR>   R   t   convertToExtrudedMeshR'   R(   R0   R1   (   R	   R9  RS  RT  t   arrZt   mesh3Dt   exR   t   ex2R   t   ex3(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testExtrudedMesh1  s       	  s   3.2.1s1   This test requires at least MEDFile version 3.2.1s   4.0.0s@   This test is not compatible with MEDFile version 4.0.0 and abovec         C   s)  d } d } t  d d  } | j t d d d d g d d   | j   | j t d d g  t   } | | d <| j d d  | j | d  t	 t
+ |   j d  d d g k s t  t |  } |  j | j | d	   | j | d  t	 t
+ |   j d  t t   d   k s%t  d  S(
+   Ns   Pyfile108.meds   Pyfile109.medR   i   i    i   R  i   g-q=(   R[   Rc   RY   R]   R^   Re   R>   R   t   write30R   t   MEDFileVersionOfFileStrt   versiont   AssertionErrorR0   R1   R   Rm   t   MEDFileVersion(   R	   R9  Rn  R   R   R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testWriteInto30  s      % 
+ 	 
++2c   #      C   s1  d } t  d d d d d d d d d d d d d d d d d d g d d  } t d d  } | j d  | j t d	 d
+ d g  | j t d
+ d d g  | j t d d d
+ d	 g  | j t d d d d
+ g  | j t d
+ d d d g  | j   | j |  t | j   d	  } | j d  d d	 d d d d
+ d
+ d	 d d
+ d d
+ d	 d d d d d g } x7 t	 d  D]) } | j t
+ | d | d | d ! qrW| j   | j |  t   } | j d |  | j d |  d } d }	 d }
+ t t t  } | j d  | j |
+ | |	  t d d	 d d d
+ g  } | j d  t  d d d d d g  } | j |  t   } | j | | d |  t t t  } | j d  | j |
+ | |	  t d d	 d d d
+ d d g  } | j d  t  d d d d d d  d! g  } | j |  t   } | j | | d |  t   } | j t    | j t    | j   j |  t   } | j |  | j   j  |  | j!   } t |  } |  j" t# | j    d	  |  j" t# | j    d	  |  j" t# | j   d  d	  |  j$ | j   d j% | j   d d"   | j   d d j& | j   d  } | j   d d j& | j   d  } |  j$ | j% | d" d"   t' j( | t' j)  } t' j* |  } |  j" t# | j    d	  |  j" t# | j    d	  |  j" t# | j   d  d	  |  j$ | j   d j% | j   d d"   | j   d d j& | j   d  } |  j$ | j% | d" d"   t' j( | j   t' j)  } t' j* |  } | d d j& | j   d  } |  j$ | j% | d" d"   t' j( | j   d t' j)  } t' j* |  } | d j& | j   d  } |  j$ | j% | d" d"   t' j( | j   d d t' j)  } t' j* |  }  |  j& | j   d  }! |  j$ |! j% | d" d"   t' j( | j   t' j)  } t' j* |  }" |  j" t# |"  d	  |  j$ |" d j% | j   d d"   d  S(#   Ns   Pyfile110.medg        g      ?g      ?i	   i   Rn  i   i   i   i    i   i   i   i   ig      @Ro  Rp  i
+   i   i   i   i   Rq  Rr  i   i   i   i   i   i   i   g-q=(+   RY   R[   R]   R^   R_   R`   Rb   Rc   RC   Rn   Re   R>   Rj   Rw  R  RX  RB   R   Rk   R{  R   R|  RK  RR  RP  R]  R[  RT  R7  R   RE  Ra  R\  t	   serializeR+   Ry   R0   R1   R5  R  R  R  R  (#   R	   R9  R  R   R   Rt  R   R   Ru  Rv  Rw  Ro  Rx  R  R   Rq  Ry  Rz  R   R>  Rm  Re  R8  RC  R   R   t   mfd3R	  R  R  t   fmts5t   ff5t   f1ts6t   ff6t   ms7(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt"   testPickelizationOfMEDFileObjects1  s    H
+<#
+	   	! !		 	  -'' -'!#'c         C   s  |  j    t j d  } |  j t | t   t j | t j  } t j	 |  } |  j t | t   |  j | j
+   j | j
+   d   |  j   t j d  } |  j t | t   t j | t j  } t j	 |  } |  j t | t   |  j | j
+   j | j
+   d   |  j   t d  } t d  } |  j t | d t   t j | d t j  } t j	 |  } |  j t | d  t |   |  j t | t   |  j | d j | d  j | d d j | d  d d   t j | d d t j  } t j	 |  } |  j t | t   |  j | j | d  j | d d j | d  d d   |  j   t d  }	 t j |	 t j  } t j	 |  }
+ |  j t |	  t |
+   x? t t |	   D]+ } |  j |	 | j |
+ | d  d  qWd  S(   Ns   MEDFileMesh5.medg-q=s   Pyfile55.meds   Pyfile63.medi    s   Pyfile56.med(   R   R'   R(   R0   Rt   R   R  R  R  R  R   R1   R  R  R6  R[  RP  R#  R+   Ry   R5  R  R  R  Rn   (   R	   R   R   R   R  R  t   ms4RJ  RL  t   paramst   params7R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt"   testPickelizationOfMEDFileObjects2  sH    
+%
+%
+ B>
+%c         C   s  d } t  d  } | j   t j |  } | j d  t   } | | d <|  j | j d   t d d d d	 d g  } | j	   } | j
+ d |  | j   |  j t | j
+ d | d
+ d
+ d	   | j   |  j | j   | j d  j    |  j | j d  j |   | j | d	  t j |  } |  j | j | d  d  |  j | j d  j |   | j d  j d d d  |  j | j | d  d  | j d  j d d d  |  j | j | d  d  d
+ S(   s8   Test global number on nodes here. Used by partitionners.s   Pyfile112.medi   R   i    i   i   i   i	   i   Ng-q=i
+   (   RY   Ry  R[   t   Build1DMeshFromCoordsRB   R>   R0   t   getGlobalNumFieldAtLevelRk   Rq   t   setGlobalNumFieldAtLevelR   R)   R*   R+   R   R1   R   R'   R(   R   (   R	   R9  R  R   R   Re  t   dRefR   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testGlobalNumOnNodes12  s2     
+	
+
+&
+%c         C   s  d } t  d  } | j   t j |  } | j d  t   } | | d <d } d } t t  } | j |  | j |  | j	 t  d	 d
+ d d d g   | j
+ |   t t  } | j |  | j |  | j	 t  d d d d g   | j
+ |   t   }	 |	 j |  |	 j |  |  j t |	 j    t t t g   |	 j   }
+ |
+ j   d 7(|
+ j
+ d d d  t   } | j |	  | j |
+  | j | d  | j | d  t j t t f g  } t j |  } t | t |  } | j   |  j t |  d  | d } |  j t |  d  | d } | d } |  j | j   t g  |  j | j  |  j! | d d   | j   } | d 7} | j
+ d d d  |  j | j  |  j! | d d   d S(   ss   Test for advanced API on read to speed up read phase for users with "huge" number of time steps (more than 10 000).s   Pyfile113.medi   R   i    R  g      @i   i   g        g?g?g333333?g?g      ?g?g333333?g?i   i   g      @g-q=g       @N(   g      @i   i   ("   RY   Ry  R[   RT  RB   R>   Rw  R  R   R{  R   R  R   R%  R+   R  R  Rq   R+  R   RE  R   t   MEDFileEntitiest	   BuildFromR  R'   R(   R[  RN   Rv  Ry   R0   R5  R1   (   R	   R9  R  R   R   Rg  t   ts1R   R   R   t   f1ts_2Rm  t   entRl  RB  R;  R
+  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testPartialReadOfEntities1M  s^     
+	
+  "  	(	
+
+
+ 
+% 
+ %c      	   C   s
+  d } t  j   } | j   } | j   } t j   } | j | j    | j d |  | j	 | j
+    | j | d  t   } | j |  | j d t |  } |  j | j   j   d d d g  |  j | j | d d   | j | d  | j   \ } } |  j | j   | j   j    |  j | d) d* f d+ d, f d- d. f d/ d0 f g  t j |  } |  j | j
+   d  |  j | j   d d d g  |  j t | t   | j t d |  } |  j | j   j   d d d g  |  j | j | d d   | j d d d  | j   }	 |	 d 9}	 | j | d  t j | d  }
+ |  j |
+ j   d1 d2 g  |  j t |
+  d  |  j t |
+ t   |
+ d j t d |  } |  j | j | d d   |
+ j t d d d |  } |  j | j | d d   |
+ j    } | j!   | j!   } | j d t |  } |  j | j   j d | j   d   | j d d d  | j   d 9(|  j | j | d d   | j   d :(t" d
+ d  } d | (| j# d d d g  x3 |
+ D]+ } | j t d |  } | | j   7} qW|  j | j d | j   d   t$ t%  } | j d d d  | j& | j    t" d d  } | j# d d g  t' t( d   | d d  d f <d | d d  d f | d d  d f <| j	 d  | j) |  t j   } | j |  |  j | j*   d3  |  j | j   d d d g  | j | d  t$ t%  } | j d d d  | j& | j    t" d d  } | j# d d g  t' t( d   | d d  d f <| d d  d f c d 7<d | d d  d f | d d  d f <| j	 d  | j	 | j
+    | j) |  t j   } t+ d d d	 d d
+ d  d d! g  } | j	 d"  | j, | | d |  | j- t% d |  | j- t% d |  \ } } | j	 | j
+    |  j | j |   |  j | j | d   | j | d  t | d  } | j- t% d |  \ } } | j	 | j
+    |  j | j |   |  j | j | d   t. t%  } | j	 d#  | j d$ d% d&  | j& | j    | j) | j   j    t/ j   } | j |  | j | d  t0 |  } |  j t |  d	  g  | D] } | ^ q/} |  j t | d t   |  j t | d t   |  j t | d t1   |  j t | d t   |  j | d d j   j2 | j   d   |  j | d d4 j   j2 d | j   d   |  j | d d j   j2 | d   |  j | d d j   j2 | d   |  j | d# d$ j   j2 | j   j   d   t1 | d#  } |  j | d$ j   j2 | j   j   d   |  j3 t4 t j | d#  |  j3 t4 t1 j | d  t/ j | d# d% d&  |  j3 t4 t j | d# d% d&  t j | d d d  |  j3 t4 t/ j | d d d  |  j | j5   d5  |  j | j6 d6 g   |  j | j5   d7  |  j | j6 d8 g   d S(9   s5   Like testInt32InMEDFileFieldStar1 but with float32 :)s   Pyfile114.medi    i   s   power [MW/m^3]s   density [g/cm^3]s   temperature [K]g-q=i   i   i   i   R   i   g       @g      @gHz>g      "@i
+   ii   s   aa [u1]s   bbbvv [ppp]NR  g      3@i   ii   s
+   aapfl [u1]s   bbbvvpfl [ppp]R  i   i   R  R  g      =@i   iR  R  (   i   i    (   i    i   (   i   i    (   i   i   (   i   i    (   i   i   (   i   i    (   i   i   (   i    i   g       @(   i   i   g      @(   s   aa [u1]s   bbbvv [ppp](   i   i   (   s   3DSurfMesh_1s   3DSurfMesh_1s   3DSurfMesh_1s   3DSurfMesh_1(   s   3DSurfMesh_1s
+   3DSurfMesh(   s
+   3DSurfMeshs
+   3DSurfMeshs
+   3DSurfMeshs
+   3DSurfMesh(   s   3DSurfMesh_1s
+   3DSurfMesh(7   R   R$  t   convertToFloatFieldR   R>   R(   Rc   R   Rj   RB   RC   R   t   MEDFileFloatField1TSR%  R  R  R+   R)  R  R0   R1   R(  R   R+  R!  R   Rt   R   R"  R   Ry   t   MEDFileFloatFieldMultiTSR$  R%  t   DataArrayFloatR  t   MEDCouplingFieldFloatR  R   Rm   Rn   R{  R'  Rk   R|  R~  Rw  R   R[  R   R  R)   R*   RU  R(  (   R	   R9  R   R   R:  R;  R  R  RC  R   R)  Rv  R*  R+  R,  R-  R.  R/  R0  R1  R  R2  R3  R4  Rl  R  R5  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testFloat32InMEDFileFieldStar1z  s    	%"4% 
+ 
+ )    #  " *   "  *  $   -1''3/c         C   s  d } t  d d d d d d d d d d d d d d d d d d g  } t d d  } | j |  | j d  | j t t t d    | j   t	 t
+  } | j |  | j d	  | j t  t t d     | j   | j   \ } } } } }	 t	 t
+  }
+ |
+ j |  |
+ j d
+  |
+ j t  t t d     |
+ j   t | |
+ t  t |  } |  j |
+ j | d d   |  j | j   j   d  |  j | j   j d  t  d S(    s'   EDF8478 : Test of read/write of penta18s   Pyfile115.medg        g      ?g      ?R   i   i   i   t   FieldOnPenta18t   FieldOnPenta18Subg-q=i    N(   g        g      ?g      ?(   g        g        g      ?(   g      ?g        g      ?(   g        g      ?g        (   g        g        g        (   g      ?g        g        (   g        g      ?g      ?(   g      ?g        g      ?(   g      ?g      ?g      ?(   g        g      ?g        (   g      ?g        g        (   g      ?g      ?g        (   g        g      ?g      ?(   g        g        g      ?(   g      ?g        g      ?(   g        g      ?g      ?(   g      ?g        g      ?(   g      ?g      ?g      ?(   RY   R[   Rc   R]   R^   t   NORM_PENTA18Rm   Rn   Rd   Rw  R  R   RB   R{  R  R_  R.   t	   ReadFieldR0   R1   R+   R   R   t   getTypeOfCell(   R	   R9  R  R   R   R   Re  t   dit   rdt   rdiR   R
+  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testPenta18_1  s<    					
+
+
+c         C   s  d } d } t  d d d d g  } t   } | j | |  | j   } | j d  t   } | | d <t t  } | j |  t	 | j
+    } | j   | j |  | j d  t   } | j |  | j | d  | j | d  t t  } | j |  t | j
+    } | j   | j |  | j d	  t   } | j |  d
+ d  l }	 d
+ d  l }
+ t |  } |  j t | j | d  ~ |
+ j d  |	 j j |  r|	 j |  n  d  S(   Ns   Pyfile116.meds   Pyfile116.erri    i   i   i   R   R5  R6  i(   RY   R   Rc   R  RB   R>   R&  R  R   Rk   R   Ry  R{  R  R%  RB  Rc  Rb  R`  R   t   gcR   R)   R*   t   collectR  R  R  (   R	   R9  R  R   R   R   R   R  R   R   Rn  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt9   testMedFileCapabilityToCryOnNewFeatureWritingIntoOldFiles  sF    		
+  
+	  
+	c         C   sd  d } t  d d g  } t   } | j | | |  | j   } | j   } | j d d d g  t j | | g  } | j d  t	   } | | d <| j
+ d  } t   } | j |  t   }	 |	 j |  t t  }
+ |
+ j d  |
+ j |  |
+ j d d d  t  | j    } | j   |
+ j |  t   } | j |
+  t   } | j |  | j   } | j d d	 d
+  | j   d 9(| j |  t   } | j |  | j
+ | |	  } |  j | |	 d  | j | d  | j | d  t |  } t |  } | d j
+ d  } t   } | j |  | j
+ | |  } |  j | | d  d  S(   Ns   Pyfile117.medi    i   i   R   R5  g      @i   i   g      @g       @(   RY   R   Rc   R  Rq   R  R[   R[  RB   R>   RA  RP  R7  Rw  R  R   R   R  Ry  R{  R   R%  R   RE  R+  R[  R\  t	   myTester1R   (   R	   R9  R  R   R   R  R   t   mmqt   mmst   mmsqR   R   Rm  R\  Rl  RV  t   mmqs(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testFieldsLinearToQuadratic7  sZ    		
+	 	 
+			   	 c      y   C   s  t  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d gx d d  } t d	 d
+ d d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ g(  } t  d
+ d	 d d d d d d d d d d d! d  d" d# d d	 d d d0 d d1 d d d d d d2 d d3 d d4 d  d5 d" d d d! d  g(  } | d
+ d
+ j |  } |  j | j   d d	 d g  t | j    } |  j | j   j	 |   |  j | j
+   j	 | d6   |  j | j   j	 | d6   | d
+ d	 j |  } |  j | j   d7 d d g  t | j    } |  j | j   j	 |   |  j | j
+   j	 | d6   |  j | j   j	 d | d6   d  S(8   Ng        g      ?g       @g      @g      ?g      @i(   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i	   i   i
+   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   g      @g      @g      !@g      %@g      )@g      -@g-q=g      @(   RY   Rk   R5  R+   R   Rz   R   R0   Rv   R1   R   R)  (   R	   RV  Rr  t   dataExpt   dataExp1t   dataExp2t   fToTestt   mTest(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyRq  b  s"     {#c         C   s0  d } t  d d g  } t   } | j | | |  | j   } | j   } | j d d d g  t j | | g  } | j d  | j t  j	 | j
+   t  d d d g d d    t   } | | d <| j d  } t   } | j |  t   }	 |	 j |  t t  }
+ |
+ j d  |
+ j |  |
+ j d	 d d  t  d
+  } | j   | j   |
+ j |  t   } t d
+ d d d d d d d g  } | j d  | j |
+ | d |  | j   } | j d d d  | j   d 9(t   } | j |  | j |  t   } | j |  | j | |	  } | j | d  | j | d  |  j | |  t |  } t |  } | d j d  } t   } | j |  | j | |  } |  j | |  t   } | | d <| j d  } t   } | j |  t   }	 |	 j |  t t  }
+ |
+ j d  |
+ j |  |
+ j d	 d d  t  d  } | j   | j   |
+ j |  t   } t d
+ d d d d d d d d g	  } | j d  | j |
+ | d |  t   } | j |  t   } | j |  | j | |	  } t d
+ d d d d d d d d d d d d d d d d d d  d! d" g  } | j d#  | d d } t  d d d d d d$ d% d& d
+ d' d d( d d) d$ d* d% d d d d$ g  } | j d#  j  |  st!  | j   j  | d+  st!  | j"   d" d d/ d# d- f g f g k s,t!  d. S(0   s?   Same than testFieldsLinearToQuadratic but with profile on NODESs   Pyfile118.medi    i   i   R   g      ?i   R5  g      @i   i	   i
+   i   i   i   i   i   R  i   g      @g      @i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   t   pfl_NODEi   i   i   g      ?g      @g      @g      @g-q=i   R&   N(   i    i   (#   RY   R   Rc   R  Rq   R  R[   R[  RB   R  R   R>   RA  RP  R7  Rw  R  R   R   Ry  R{  R   Rk   R|  R+  R   RE  R[  R\  R   t	   myTester2R=  R1   RE  R  (   R	   R9  R  R   R   R  R   Rr  Rs  Rt  R   R   R  R\  Rm  Rl  RV  Ru  t   pflExpectedt
+   f1tsToTestt   exp1(    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testFieldsLinearToQuadratic2u  s    	4	
+	 	  
+
+	$ 		   	 	
+	 	  
+
+	' 		K K0c         C   si  t  d d d d d d d d d	 d
+ d d d d d d d d d d g  } | j d  | d d } t d d d d d d d d d d d d d  d d! d d d d d g  } |  j | j d  j |   |  j | j   j | d"   |  j | j   t	 d d d# f d d$ f g f g  | d d j
+ |  } |  j | j   d% d d g  t | j    } |  j | j   j t  d d d d d d d d d d d d d d d d d& d' d( d) g    |  j | j   j t d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f g d# d  d"   |  j | j   j | d"   | d d } |  j | j d  j |   |  j | j   j d | d"   |  j | j   t	 d d d# f d d$ f g f g  | d d j
+ |  } |  j | j   d* d d g  t | j    } |  j | j   j t  d d d d d d d d d d d d d d d d d& d' d( d) g    |  j | j   j t d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f d d d f g d# d  d"   |  j | j   j d | d"   d  S(+   Ni   i	   i
+   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   R|  i    i   i   i   i   i   i   i   g      ?g      @g      @g      @g-q=i   R&   g      @i   i   i   i   g      @(   Rk   RB   RY   R0   R=  R1   R+  R+   R  R  R5  R   Rz   R   Rv   R   R)  (   R	   RV  Rr  R~  R  R  Rz  R{  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR}    s4    H H4^ #4^ #c   
+      C   s  t  d  } | j   t   } | j | |  | j   } | j   } | j d  t j | |  } | j	 d  t
+   } | | d <t t  } | j |  t  | j    } | j   | j |  | j	 d  t | j    } | j   | j	 d  d d d d d f g f d	 d d d d f g f g } d d d d d f g f d	 d d d d f g f g } t   }	 |	 j | | d |  |  j |	 j   d  |  j |	 j   |  |  j |	 j |  j | d d   t   }	 |	 j | | d |  |  j |	 j   d | j   d | j   f  |  j |	 j   |  |  j |	 j |  j | d d   |  j |	 j d  j d   |  j |	 j d  j d   d S(   s    Sometimes for downstream code fan of profiles, profile are requested unconditionally. setFieldProfile try to reduce at most profile usage. So setFieldProfileFlatly has been added to always create
+        a profile.i
+   i    R   R5  R  i   i   R&   i   i   t   pfl_NORM_TRI3RX  g-q=s   %s_NORM_TRI3s   %s_NORM_QUAD4iQ   N(   i    i   (   i   i   (   i    i   (   i   i   (    (   RY   Ry  R   Rc   R  Rq   R  R[   R[  RB   R>   Rw  R  R   R   R{  Rk   R   R|  R+   R]  R  R0   R5  R1   t   setFieldProfileFlatlyRC   R=  R  (
+   R	   R  R   R   R   R   R  t   refSpt   refSp1R   (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   testSetFieldProfileFlatly1  sF     
+	 	
+
+ 
+ 66	%	0%c   
+      C   s*  t  d  } | j   t   } | j | |  | j   } | j d  | j   d } t   } | | d <| | d <d } t d d d d g  } | j |  t d d d d	 g  } | j |  t d d d
+ d d g  } | j d  t d d
+ d d g  }	 |	 j d  | j	 d |  | j	 d |	  | j	 d |  | j	 d |  |  j
+ | j |  d  |  j | j d |  j |   |  j | j d |  j |   |  j | j d d  j |   |  j | j d d  j |	   |  j t | j	 d |  |  j | j d |  j |   |  j | j d |  j |   |  j | j d d  j |   |  j | j d d  j |	   | j d |  |  j
+ | j |  d  |  j | j d |  j |   |  j | j d d  j |   |  j | j d d  j |	   | j d |  |  j
+ | j |  d  |  j t | j d |  | j	 d |  | j	 d |  |  j
+ | j |  d  |  j | j d |  j |   |  j | j d |  j |   |  j | j d d  j |   |  j | j d d  j |	   d S(   s$    Here multi level groups are createdi   R   i    iR  i   i   i   i   i   i   R  i   R  iN(   i    i(   i(    (   i    i(   RY   Ry  R   Rc   R  RB   R  R>   Rk   R  R+   R   R0   RG   R1   R)   R*   t   removeGroupAtLevel(
+   R	   R  R   R   R   R  t   grp0_0t   grp0_1R  R  (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt+   testRmGroupAtSpeLevelAndMultiLevGrpCreation  sb     
+	 	
+ 
+    """""""""""""""(   R   R   R9   RS   R   R   R   R   R   R   R   R  R  R  R  R  R"  RF  Rq  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R%  R1  RI  Rm  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R6  R<  RW  R]  Rh  Rs  R{  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  t   unittestt
+   skipUnlesst   MEDCouplingHasNumPyBindingsR  R  R  R3  R7  RN  RV  Rs  R  t   platformt   systemt   lowerR  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R9  RA  R   t   MEDFileVersionStrRG  RO  RS  RX  R^  Rd  Rm  Rp  Rv  Rq  R  R}  R  R  (    (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyR$   A   s   		+	s	k		1	(											d	9	'	$		!		&		/				+	 	F	U	2	2	*	5	<	%			A		Z	Y		F	G	%	(	6	A	'		.	p	,	r	 	Q	A	E	b	o		t	R		7	7	F	$	?	S	3		7		Qb	E	L	;	)	+	%	'	0	'-(			8		j	=				$	E	F	;	;	)	m		$Z,		-	s	$!$	+		N		&	/t   __main__(   t	   MEDLoaderR  R  t   mathR   R   R   R   t   distutils.versionR   R   t   version_infot   majort   cPickleR  R   R   t   TestCaseR$   R   t   main(    (    (    ss   /volatile/home/salome/Test_Archives/SALOME-S-8.5.0-CO7-SRC/SOURCES/MEDCOUPLING/src/MEDLoader/Swig/MEDLoaderTest3.pyt   <module>   sL   
+                         
\ Pas de fin de ligne à la fin du fichier
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest4.py MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest4.py
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTest4.py	2018-04-19 17:04:36.768223341 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTest4.py	2018-04-19 17:25:17.766797930 +0200
@@ -17,7 +17,7 @@
 #
 # See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 #
-# Author : Anthony Geay (CEA/DEN)
+# Author : Anthony Geay (EDF R&D)
 
 from MEDLoader import *
 import unittest
@@ -4119,7 +4119,7 @@
         pass
 
     def test28(self):
-        """ This test defines 2 fields f0,f1,f2,f3 lying on an unstructured mesh whith cells including NORM_POINT1.
+        """ This test defines 2 fields f0,f1,f2,f3 lying on an unstructured mesh with cells including NORM_POINT1.
         Both f0 and f1 are on NODES and f2 and f3 are on cells. f1 and f2 share the same support.
         f0 is on a nodal support that is not matchable with any cells (including NORM_POINT1)
         This test is a more aggressive version of test26.
@@ -4792,7 +4792,7 @@
         mml2=mml.prepare()
         self.assertTrue(isinstance(mml2,MEDUMeshMultiLev))
         ncc,a0,a1,a2,a3,a4,a5=mml2.buildVTUArrays()
-        self.assertTrue(not ncc)# false beacause 2D in MED file
+        self.assertTrue(not ncc)# false because 2D in MED file
         self.assertTrue(a0.isEqual(DataArrayDouble([(5.5,0.5,0),(5.5,-0.5,0),(6.5,0.5,0),(6.5,-0.5,0),(6.5,1.5,0),(7.5,0.5,0),(7.5,-0.5,0),(7.5,1.5,0),(7.5,2.5,0),(8.5,0.5,0),(8.5,-0.5,0),(8.5,1.5,0),(8.5,2.5,0),(8.5,3.5,0),(8.55,0.5,0),(8.55,-0.5,0),(8.55,1.5,0),(8.55,2.5,0),(8.55,3.5,0)]),1e-12))
         self.assertTrue(a1.isEqual(DataArrayByte([9,9,9,9,9,9,7,7,7,7])))
         self.assertTrue(a2.isEqual(DataArrayInt([0,5,10,15,20,25,30,35,40,45])))# the bug was here.
@@ -4959,7 +4959,7 @@
         pass
 
     def test35(self):
-        """ Emulate MEDReader in // mode context. Here a Simple mesh having more nodes than really needed. This test focuses on that point particulary."""
+        """ Emulate MEDReader in // mode context. Here a Simple mesh having more nodes than really needed. This test focuses on that point particularly."""
         fname="ForMEDReader35.med"
         arrX=DataArrayDouble(7) ; arrX.iota()
         arrY=DataArrayDouble([0.,1.])
@@ -5515,6 +5515,74 @@
         assert(v1.isEqual(DataArrayDouble([101,102,103,104,106,107,108,109,111,112,113,114,116,117,118,119,121,122,123,124]),1e-12))
         pass
 
+    def test42(self):
+        """ EDF14869 - SEG4 """
+        fname="ForMEDReader42.med"
+        meshName="mesh"
+        #
+        a0exp=DataArrayDouble([0.,1.,0.3,0.7])
+        m=MEDCouplingUMesh("mesh",1)
+        m.setCoords(a0exp)
+        m.allocateCells()
+        m.insertNextCell(NORM_SEG4,[0,1,2,3])
+        mm=MEDFileUMesh() ; mm[0]=m
+        #
+        f=MEDCouplingFieldDouble(ON_CELLS) ; f.setMesh(m) ; f.setName("Field")
+        arr=DataArrayDouble(m.getNumberOfCells()) ; arr.iota() ; arr*=0.1 ; f.setArray(arr) ; f.checkConsistencyLight()
+        ff=MEDFileField1TS() ; ff.setFieldNoProfileSBT(f)
+        fmts=MEDFileFieldMultiTS() ; fmts.pushBackTimeStep(ff)
+        #
+        ms=MEDFileMeshes() ; ms.pushMesh(mm)
+        fields=MEDFileFields() ; fields.pushField(fmts)
+        ms.write(fname,2) ; fields.write(fname,0)
+        #
+        ms=MEDFileMeshes(fname) 
+        fields=MEDFileFields(fname,False)
+        fields.removeFieldsWithoutAnyTimeStep()
+        fields_per_mesh=[fields.partOfThisLyingOnSpecifiedMeshName(meshName) for meshName in ms.getMeshesNames()]
+        allFMTSLeavesToDisplay=[]
+        for fields in fields_per_mesh:
+            allFMTSLeavesToDisplay2=[]
+            for fmts in fields:
+                tmp=fmts.splitDiscretizations()
+                for itmp in tmp:
+                    self.assertTrue(not itmp.presenceOfMultiDiscPerGeoType())
+                    pass
+                allFMTSLeavesToDisplay2+=tmp
+                pass
+            allFMTSLeavesToDisplay.append(allFMTSLeavesToDisplay2)
+            pass
+        #
+        self.assertEqual(len(allFMTSLeavesToDisplay),1)
+        self.assertEqual(len(allFMTSLeavesToDisplay[0]),1)
+        allFMTSLeavesPerTimeSeries=MEDFileAnyTypeFieldMultiTS.SplitIntoCommonTimeSeries(sum(allFMTSLeavesToDisplay,[]))
+        self.assertEqual(len(allFMTSLeavesPerTimeSeries),1)
+        allFMTSLeavesPerCommonSupport1=MEDFileAnyTypeFieldMultiTS.SplitPerCommonSupport(allFMTSLeavesToDisplay[0],ms[ms.getMeshesNames()[0]])
+        self.assertEqual(len(allFMTSLeavesPerCommonSupport1),1)
+        #
+        mst=MEDFileMeshStruct.New(ms[0])
+        fcscp=allFMTSLeavesPerCommonSupport1[0][1]
+        mml=fcscp.buildFromScratchDataSetSupport(0,fields)
+        mml2=mml.prepare()
+        self.assertTrue(isinstance(mml2,MEDUMeshMultiLev))
+        ncc,a0,a1,a2,a3,a4,a5=mml2.buildVTUArrays()
+        self.assertTrue(not ncc)
+        self.assertTrue(a0.isEqual(a0exp.changeNbOfComponents(3,0.),1e-12))
+        self.assertTrue(a1.isEqual(DataArrayByte([35])))# VTK_CUBIC_LINE
+        self.assertTrue(a2.isEqual(DataArrayInt([0])))
+        self.assertTrue(a3.isEqual(DataArrayInt([4,0,1,2,3])))
+        self.assertTrue(a4 is None)
+        self.assertTrue(a5 is None)
+        self.assertTrue(mml2.retrieveGlobalNodeIdsIfAny() is None)
+        for i in range(1):
+            ffCell=allFMTSLeavesPerCommonSupport1[0][0][0][i]
+            fsst=MEDFileField1TSStructItem.BuildItemFrom(ffCell,mst)
+            ffCell.loadArraysIfNecessary()
+            v=mml2.buildDataArray(fsst,fields,ffCell.getUndergroundDataArray())
+            self.assertEqual(v.getHiddenCppPointer(),ffCell.getUndergroundDataArray().getHiddenCppPointer())
+            self.assertTrue(v.isEqual(DataArrayDouble([0.0]),1e-14))
+        pass
+    
     pass
 
 if __name__ == "__main__":
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTypemaps.i MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTypemaps.i
--- MEDCOUPLING_old/src/MEDLoader/Swig/MEDLoaderTypemaps.i	2018-04-19 17:04:36.768223341 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/MEDLoaderTypemaps.i	2018-04-19 17:25:17.786798325 +0200
@@ -16,7 +16,7 @@
 //
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
-// Author : Anthony Geay (CEA/DEN)
+// Author : Anthony Geay (EDF R&D)
 
 #include <vector>
 
@@ -402,3 +402,41 @@
     }
 }
 
+template<class T>
+PyObject *MEDFileField1TS_getFieldWithProfile(const typename MLFieldTraits<T>::F1TSType *self, TypeOfField type, int meshDimRelToMax, const MEDFileMesh *mesh) 
+{
+  DataArrayInt *ret1(NULL);
+  typename MEDCoupling::Traits<T>::ArrayType *ret0(self->getFieldWithProfile(type,meshDimRelToMax,mesh,ret1));
+  PyObject *ret(PyTuple_New(2));
+  PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(ret0),SWIGTITraits<T>::TI, SWIG_POINTER_OWN | 0 ));
+  PyTuple_SetItem(ret,1,SWIG_NewPointerObj(SWIG_as_voidptr(ret1),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
+  return ret;
+}
+
+template<class T>
+PyObject *MEDFileField1TS_getUndergroundDataArrayExt(const typename MLFieldTraits<T>::F1TSType *self)
+{
+  std::vector< std::pair<std::pair<INTERP_KERNEL::NormalizedCellType,int>,std::pair<int,int> > > elt1Cpp;
+  typename MEDCoupling::Traits<T>::ArrayType *elt0=self->getUndergroundDataArrayExt(elt1Cpp);
+  if(elt0)
+    elt0->incrRef();
+  PyObject *ret=PyTuple_New(2);
+  PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(elt0),SWIGTITraits<T>::TI, SWIG_POINTER_OWN | 0 ));
+  std::size_t sz=elt1Cpp.size();
+  PyObject *elt=PyList_New(sz);
+  for(std::size_t i=0;i<sz;i++)
+    {
+      PyObject *elt1=PyTuple_New(2);
+      PyObject *elt2=PyTuple_New(2);
+      PyTuple_SetItem(elt2,0,SWIG_From_int((int)elt1Cpp[i].first.first));
+      PyTuple_SetItem(elt2,1,SWIG_From_int(elt1Cpp[i].first.second));
+      PyObject *elt3=PyTuple_New(2);
+      PyTuple_SetItem(elt3,0,SWIG_From_int(elt1Cpp[i].second.first));
+      PyTuple_SetItem(elt3,1,SWIG_From_int(elt1Cpp[i].second.second));
+      PyTuple_SetItem(elt1,0,elt2);
+      PyTuple_SetItem(elt1,1,elt3);
+      PyList_SetItem(elt,i,elt1);
+    }
+  PyTuple_SetItem(ret,1,elt);
+  return ret;
+}
diff -Naur MEDCOUPLING_old/src/MEDLoader/Swig/SauvLoaderTest.py MEDCOUPLING_new/src/MEDLoader/Swig/SauvLoaderTest.py
--- MEDCOUPLING_old/src/MEDLoader/Swig/SauvLoaderTest.py	2018-04-19 17:04:36.768223341 +0200
+++ MEDCOUPLING_new/src/MEDLoader/Swig/SauvLoaderTest.py	2018-04-19 17:25:17.769797989 +0200
@@ -248,6 +248,58 @@
         os.remove(sauvFile)
         pass
 
+    def testSauvReaderOnBigMesh(self):
+        # create a box with 1 million cells
+        mesh_dim = 3
+        nb_segs = [100, 100, 100]
+        box_sizes = [1., 1., 1.]
+        compo_names = ["x", "y", "z"]
+        box_steps = [box_sizes[i]/nb_segs[i] for i in range(mesh_dim)]
+        mesh = MEDCouplingCMesh.New("Mesh_box")
+
+        # axes coords
+        axes_arrays = []
+        for i in range(mesh_dim):
+          axe_coords = [j*box_steps[i] for j in range(nb_segs[i]+1)]
+
+          axe_arr = DataArrayDouble.New(axe_coords)
+          axe_arr.setInfoOnComponent(0,compo_names[i])
+
+          axes_arrays.append(axe_arr)
+
+        mesh.setCoords(*axes_arrays)
+        umesh = mesh.buildUnstructured()
+
+        m=MEDFileUMesh.New()
+        m.setMeshAtLevel(0,umesh)
+
+        # MED file data
+        ms=MEDFileMeshes.New()
+        ms.setMeshAtPos(0,m)
+        meddata=MEDFileData.New()
+        meddata.setMeshes(ms)
+
+        # write to SAUV
+        sauvFile = "box.sauv"
+        sw=SauvWriter();
+        sw.setMEDFileDS(meddata);
+        sw.write(sauvFile);
+
+        # read SAUV
+        sr=SauvReader(sauvFile);
+        d2=sr.loadInMEDFileDS();
+        mm = d2.getMeshes()
+        m = mm.getMeshAtPos(0)
+
+        # check
+        coords = m.getCoords()
+        nb_coords_values = coords.getNbOfElems()
+        nb_coords_values_expected = mesh_dim*((nb_segs[0]+1)*(nb_segs[1]+1)*(nb_segs[2]+1))
+        self.assertEqual(nb_coords_values, nb_coords_values_expected)
+
+        os.remove( sauvFile )
+        pass
+
     @unittest.skipUnless(HasXDR(),"requires XDR")
     def testMissingGroups(self):
         """test for issue 0021749: [CEA 601] Some missing groups in mesh after reading a SAUV file with SauvReader."""
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/CMakeLists.txt MEDCOUPLING_new/src/MEDPartitioner/CMakeLists.txt
--- MEDCOUPLING_old/src/MEDPartitioner/CMakeLists.txt	2018-04-19 17:04:36.769223361 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/CMakeLists.txt	2018-04-19 17:25:17.685796329 +0200
@@ -46,6 +46,11 @@
 # VERY IMPORTANT PUT METIS BEFORE SCOTCH because
 # metis.h is also in SCOTCH install dir !!!
 ########
+IF(MEDCOUPLING_PARTITIONER_PTSCOTCH)
+  ADD_DEFINITIONS(${PTSCOTCH_DEFINITIONS})
+  INCLUDE_DIRECTORIES(${PTSCOTCH_INCLUDE_DIRS})
+ENDIF(MEDCOUPLING_PARTITIONER_PTSCOTCH)
+
 IF(MEDCOUPLING_PARTITIONER_SCOTCH)
   ADD_DEFINITIONS(${SCOTCH_DEFINITIONS})
   INCLUDE_DIRECTORIES(${SCOTCH_INCLUDE_DIRS})
@@ -103,8 +108,9 @@
   ${STDLIB}
   ${LIBXML2_LIBRARIES}
   interpkernel
-  medcoupling
+  medcouplingcpp
   medloader
+  -lpthread
 )
 IF(MEDCOUPLING_PARTITIONER_PARMETIS)
   SET(medpartitionercpp_HEADERS_HXX ${medpartitionercpp_HEADERS_HXX} MEDPARTITIONER_ParMetisGraph.hxx)
@@ -124,6 +130,12 @@
   SET(medpartitionercpp_DEFINITIONS "${medpartitionercpp_DEFINITIONS} ${SCOTCH_DEFINITIONS}")
   SET(medpartitionercpp_LDFLAGS ${medpartitionercpp_LDFLAGS} ${SCOTCH_LIBRARIES})
 ENDIF(MEDCOUPLING_PARTITIONER_SCOTCH)
+IF(MEDCOUPLING_PARTITIONER_PTSCOTCH)
+  SET(medpartitionercpp_HEADERS_HXX ${medpartitionercpp_HEADERS_HXX} MEDPARTITIONER_PTScotchGraph.hxx)
+  SET(medpartitionercpp_SOURCES ${medpartitionercpp_SOURCES} MEDPARTITIONER_PTScotchGraph.cxx)
+  SET(medpartitionercpp_DEFINITIONS "${medpartitionercpp_DEFINITIONS} ${PTSCOTCH_DEFINITIONS}")
+  SET(medpartitionercpp_LDFLAGS ${medpartitionercpp_LDFLAGS} ${PTSCOTCH_LIBRARIES})
+ENDIF(MEDCOUPLING_PARTITIONER_PTSCOTCH)
 
 IF(${MEDCOUPLING_USE_MPI})
   SET(medpartitionercpp_SOURCES ${medpartitionercpp_SOURCES} MEDPARTITIONER_UtilsPara.cxx MEDPARTITIONER_JointFinder.cxx)
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/medpartitioner.cxx MEDCOUPLING_new/src/MEDPartitioner/medpartitioner.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/medpartitioner.cxx	2018-04-19 17:04:36.772223421 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/medpartitioner.cxx	2018-04-19 17:25:17.722797060 +0200
@@ -72,7 +72,7 @@
   //sequential : no MPI
   MyGlobals::_World_Size=1;
   MyGlobals::_Rank=0;
-  MyGlobals::_Creates_Boundary_Faces=0;
+  MyGlobals::_Create_Boundary_Faces=0;
   MyGlobals::_Create_Joints=0;
 
   // Primitive parsing of command-line options
@@ -86,8 +86,8 @@
   //user can choose!
                "\t--split-method=<string>  : name of the splitting library (metis/scotch), default is metis\n"
 #endif
-               "\t--creates-boundary-faces : creates boundary faces mesh in the output files\n"
-               "\t--creates-joints         : creates joints in the output files\n"
+               "\t--create-boundary-faces  : creates boundary faces mesh in the output files\n"
+               "\t--create-joints          : creates joints in the output files\n"
                "\t--dump-cpu-memory        : dumps passed CPU time and maximal increase of used memory\n"
                );
 
@@ -112,7 +112,7 @@
       else if (TestArg(argv[i],"--output-file",value)) output=value;
       else if (TestArg(argv[i],"--split-method",value)) library=value;
       else if (TestArg(argv[i],"--ndomains",value)) ndomains=atoi(value.c_str());
-      else if (TestArg(argv[i],"--creates-boundary-faces",value)) MyGlobals::_Creates_Boundary_Faces=1;
+      else if (TestArg(argv[i],"--create-boundary-faces",value)) MyGlobals::_Create_Boundary_Faces=1;
       else if (TestArg(argv[i],"--create-joints",value)) MyGlobals::_Create_Joints=1;
       else if (TestArg(argv[i],"--dump-cpu-memory",value)) mesure_memory=true;
       else 
@@ -153,7 +153,7 @@
       cout << "  output-file = " << output << endl;
       cout << "  split-method = " << library << endl;
       cout << "  ndomains = " << ndomains << endl;
-      cout << "  creates_boundary_faces = " << MyGlobals::_Creates_Boundary_Faces << endl;
+      cout << "  create_boundary_faces = " << MyGlobals::_Create_Boundary_Faces << endl;
       cout << "  create-joints = " << MyGlobals::_Create_Joints<< endl;
       cout << "  dump-cpu-memory = " << mesure_memory<< endl;
       cout << "  verbose = " << MyGlobals::_Verbose << endl;
@@ -267,7 +267,7 @@
       if (MyGlobals::_Is0verbose) 
         cout << "generalInformations : \n"<<ReprVectorOfString(finalInformations);
     
-      //new_collection.setSubdomainBoundaryCreates(creates_boundary_faces);
+      //new_collection.setSubdomainBoundaryCreates(create_boundary_faces);
       if (MyGlobals::_Is0verbose) cout << "Writing "<<ndomains<<" output files "<<output<<"xx.med"<<" and "<<output<<".xml"<<endl;
       new_collection.write(output);
   
@@ -302,7 +302,7 @@
     }
   catch(...)
     {
-      cerr<<"an unknown type exception error was occured"<<endl;
+      cerr<<"an unknown type exception error has occurred"<<endl;
       fflush(stderr);
       return 1;
     }
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_Graph.hxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_Graph.hxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_Graph.hxx	2018-04-19 17:04:36.770223381 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_Graph.hxx	2018-04-19 17:25:17.719797001 +0200
@@ -38,7 +38,7 @@
   class MEDPARTITIONER_EXPORT Graph
   {
   public:
-    typedef enum {METIS,SCOTCH} splitter_type;
+    typedef enum {METIS,SCOTCH,PTSCOTCH} splitter_type;
 
     Graph();
     //creates a graph from a SKYLINEARRAY- WARNING!! Graph takes ownership of the array.
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.cxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.cxx	2018-04-19 17:04:36.770223381 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.cxx	2018-04-19 17:25:17.723797080 +0200
@@ -30,6 +30,9 @@
 #ifdef MED_ENABLE_SCOTCH
 #  include "MEDPARTITIONER_ScotchGraph.hxx"
 #endif
+#ifdef MED_ENABLE_PTSCOTCH
+#  include "MEDPARTITIONER_PTScotchGraph.hxx"
+#endif
 #include "MEDPARTITIONER_MeshCollectionDriver.hxx"
 
 #include "MEDCouplingUMesh.hxx"
@@ -38,12 +41,16 @@
 #include <iostream>
 #include <vector>
 
-MEDPARTITIONER::MEDPartitioner::MEDPartitioner(const std::string& filename, int ndomains, const std::string& library,bool creates_boundary_faces, bool create_joints, bool mesure_memory):
+const char MEDPARTITIONER::MEDPartitioner::METIS_PART_ALG[]="Metis";
+const char MEDPARTITIONER::MEDPartitioner::SCOTCH_PART_ALG[]="Scotch";
+const char MEDPARTITIONER::MEDPartitioner::PTSCOTCH_PART_ALG[]="PTScotch";
+
+MEDPARTITIONER::MEDPartitioner::MEDPartitioner(const std::string& filename, int ndomains, const std::string& library,bool create_boundary_faces, bool create_joints, bool mesure_memory):
   _input_collection( 0 ), _output_collection( 0 ), _new_topology( 0 )
 {
   MyGlobals::_World_Size = 1;
   MyGlobals::_Rank = 0;
-  MyGlobals::_Creates_Boundary_Faces = creates_boundary_faces;
+  MyGlobals::_Create_Boundary_Faces = create_boundary_faces;
   MyGlobals::_Create_Joints = create_joints;
 
   ParaDomainSelector parallelizer(mesure_memory);
@@ -54,17 +61,17 @@
     (MEDPARTITIONER::ParallelTopology*) _input_collection->getTopology();
   aPT->setGlobalNumerotationDefault( _input_collection->getParaDomainSelector() );
   _input_collection->prepareFieldDescriptions();
-  createPartitionCollection(ndomains, library, creates_boundary_faces, create_joints, mesure_memory);
+  createPartitionCollection(ndomains, library, create_boundary_faces, create_joints, mesure_memory);
 
   parallelizer.evaluateMemory();
 }
 
-MEDPARTITIONER::MEDPartitioner::MEDPartitioner(const MEDCoupling::MEDFileData* filedata, int ndomains, const std::string& library,bool creates_boundary_faces, bool create_joints, bool mesure_memory):
+MEDPARTITIONER::MEDPartitioner::MEDPartitioner(const MEDCoupling::MEDFileData* filedata, int ndomains, const std::string& library,bool create_boundary_faces, bool create_joints, bool mesure_memory):
   _input_collection( 0 ), _output_collection( 0 ), _new_topology( 0 )
 {
   MyGlobals::_World_Size = 1;
   MyGlobals::_Rank = 0;
-  MyGlobals::_Creates_Boundary_Faces = creates_boundary_faces;
+  MyGlobals::_Create_Boundary_Faces = create_boundary_faces;
   MyGlobals::_Create_Joints = create_joints;
 
   ParaDomainSelector parallelizer(mesure_memory);
@@ -76,17 +83,17 @@
     (MEDPARTITIONER::ParallelTopology*) _input_collection->getTopology();
   aPT->setGlobalNumerotationDefault( _input_collection->getParaDomainSelector() );
   _input_collection->prepareFieldDescriptions();
-  createPartitionCollection(ndomains, library, creates_boundary_faces, create_joints, mesure_memory);
+  createPartitionCollection(ndomains, library, create_boundary_faces, create_joints, mesure_memory);
 
   parallelizer.evaluateMemory();
 }
 
-MEDPARTITIONER::MEDPartitioner::MEDPartitioner(const MEDCoupling::MEDFileData* filedata, MEDPARTITIONER ::Graph* graph, bool creates_boundary_faces, bool create_joints, bool mesure_memory):
+MEDPARTITIONER::MEDPartitioner::MEDPartitioner(const MEDCoupling::MEDFileData* filedata, MEDPARTITIONER ::Graph* graph, bool create_boundary_faces, bool create_joints, bool mesure_memory):
   _input_collection( 0 ), _output_collection( 0 ), _new_topology( 0 )
 {
   MyGlobals::_World_Size = 1;
   MyGlobals::_Rank = 0;
-  MyGlobals::_Creates_Boundary_Faces = creates_boundary_faces;
+  MyGlobals::_Create_Boundary_Faces = create_boundary_faces;
   MyGlobals::_Create_Joints = create_joints;
 
   ParaDomainSelector parallelizer(mesure_memory);
@@ -113,7 +120,7 @@
   delete _new_topology; _new_topology = 0;
 }
 
-void MEDPARTITIONER::MEDPartitioner::createPartitionCollection(int ndomains, const std::string& library,bool creates_boundary_faces, bool create_joints, bool mesure_memory)
+void MEDPARTITIONER::MEDPartitioner::createPartitionCollection(int ndomains, const std::string& library,bool create_boundary_faces, bool create_joints, bool mesure_memory)
 {
   //ParallelTopology* aPT = (ParallelTopology*) _input_collection->getTopology();
   if (library == "metis")
@@ -137,18 +144,18 @@
   return _output_collection->retrieveDriver()->getMEDFileData();
 }
 
-MEDPARTITIONER::Graph* MEDPARTITIONER::MEDPartitioner::Graph(MEDCoupling::MEDCouplingSkyLineArray* graph, Graph::splitter_type split, int* edgeweight)
+MEDPARTITIONER::Graph* MEDPARTITIONER::MEDPartitioner::Graph(MEDCoupling::MEDCouplingSkyLineArray* graph, Graph::splitter_type split, int* edgeweight, DataArrayInt *vlbloctab)
 {
   MEDPARTITIONER::Graph* cellGraph=0;
   // will be destroyed by XXXGraph class:
-  MEDCoupling::MEDCouplingSkyLineArray* arr = MEDCoupling::MEDCouplingSkyLineArray::New(graph->getIndexArray(), graph->getValuesArray());
+  MEDCoupling::MCAuto<MEDCoupling::MEDCouplingSkyLineArray> arr(MEDCoupling::MEDCouplingSkyLineArray::New(graph->getIndexArray(), graph->getValuesArray()));
   switch (split)
     {
     case Graph::METIS:
       if ( !cellGraph )
         {
 #ifdef MED_ENABLE_METIS
-          cellGraph=new METISGraph(arr,edgeweight);
+          cellGraph=new METISGraph(arr.retn(),edgeweight);
 #endif
         }
       if ( !cellGraph )
@@ -156,11 +163,73 @@
       break;
     case Graph::SCOTCH:
 #ifdef MED_ENABLE_SCOTCH
-      cellGraph=new SCOTCHGraph(arr,edgeweight);
+      cellGraph=new SCOTCHGraph(arr.retn(),edgeweight);
 #else
       throw INTERP_KERNEL::Exception("MEDPartitioner::Graph : SCOTCH is not available. Check your products, please.");
 #endif
       break;
+    case Graph::PTSCOTCH:
+      {
+#ifdef MED_ENABLE_PTSCOTCH
+        cellGraph=new PTSCOTCHGraph(arr.retn(),edgeweight,vlbloctab);
+#else
+        throw INTERP_KERNEL::Exception("MEDPartitioner::Graph : PTSCOTCH is not available. Check your products, please.");
+#endif
+        break;
+      }
+    default:
+      throw INTERP_KERNEL::Exception("MEDPartitioner::Graph : Not managed split type engine !");
     }
   return cellGraph;
 }
+
+std::vector<std::string> MEDPARTITIONER::MEDPartitioner::AvailableAlgorithms()
+{
+  std::vector<std::string> ret;
+#ifdef MED_ENABLE_METIS
+  ret.push_back(std::string(METIS_PART_ALG));
+#endif
+#ifdef MED_ENABLE_SCOTCH
+  ret.push_back(std::string(SCOTCH_PART_ALG));
+#endif
+#ifdef MED_ENABLE_PTSCOTCH
+  ret.push_back(std::string(PTSCOTCH_PART_ALG));
+#endif
+  return ret;
+}
+
+bool MEDPARTITIONER::MEDPartitioner::HasMetisAlg()
+{
+#ifdef MED_ENABLE_METIS
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool MEDPARTITIONER::MEDPartitioner::HasScotchAlg()
+{
+#ifdef MED_ENABLE_SCOTCH
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool MEDPARTITIONER::MEDPartitioner::HasPTScotchAlg()
+{
+#ifdef MED_ENABLE_PTSCOTCH
+  return true;
+#else
+  return false;
+#endif
+}
+
+std::vector<std::string> MEDPARTITIONER::MEDPartitioner::AllAlgorithms()
+{
+  std::vector<std::string> ret;
+  ret.push_back(std::string(METIS_PART_ALG));
+  ret.push_back(std::string(SCOTCH_PART_ALG));
+  ret.push_back(std::string(PTSCOTCH_PART_ALG));
+  return ret;
+}
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.hxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.hxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.hxx	2018-04-19 17:04:36.770223381 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MEDPartitioner.hxx	2018-04-19 17:25:17.679796210 +0200
@@ -22,6 +22,7 @@
 
 #include "MEDPARTITIONER.hxx"
 #include "MEDPARTITIONER_Graph.hxx"
+#include "MCType.hxx"
 
 #include <map>
 #include <vector>
@@ -29,6 +30,7 @@
 namespace MEDCoupling
 {
   class MEDFileData;
+  class DataArrayInt;
 }
 
 namespace MEDPARTITIONER
@@ -39,21 +41,30 @@
   class MEDPARTITIONER_EXPORT MEDPartitioner
   {
   public:
-    MEDPartitioner(const std::string& filename, int ndomains=1, const std::string& library="metis",bool creates_boundary_faces=false, bool create_joints=false, bool mesure_memory=false);
-    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, int ndomains=1, const std::string& library="metis",bool creates_boundary_faces=false, bool create_joints=false, bool mesure_memory=false);
-    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, Graph* graph, bool creates_boundary_faces=false, bool create_joints=false, bool mesure_memory=false);
-    static MEDPARTITIONER::Graph* Graph(MEDCoupling::MEDCouplingSkyLineArray* graph, Graph::splitter_type split=Graph::METIS, int* edgeweight=0);
+    MEDPartitioner(const std::string& filename, int ndomains=1, const std::string& library="metis",bool create_boundary_faces=false, bool create_joints=false, bool mesure_memory=false);
+    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, int ndomains=1, const std::string& library="metis",bool create_boundary_faces=false, bool create_joints=false, bool mesure_memory=false);
+    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, Graph* graph, bool create_boundary_faces=false, bool create_joints=false, bool mesure_memory=false);
+    static MEDPARTITIONER::Graph* Graph(MEDCoupling::MEDCouplingSkyLineArray* graph, Graph::splitter_type split=Graph::METIS, int* edgeweight=0, DataArrayInt* vlbloctab=0);
+    static std::vector<std::string> AvailableAlgorithms();
+    static std::vector<std::string> AllAlgorithms();
+    static bool HasMetisAlg();
+    static bool HasScotchAlg();
+    static bool HasPTScotchAlg();
     void write(const std::string& filename);
     MEDCoupling::MEDFileData* getMEDFileData();
     ~MEDPartitioner();
 
     MEDCoupling::MEDFileData *convertToMEDFileData(MeshCollection* meshcollection);
-    void createPartitionCollection(int ndomains, const std::string& library,bool creates_boundary_faces, bool create_joints, bool mesure_memory);
+    void createPartitionCollection(int ndomains, const std::string& library,bool create_boundary_faces, bool create_joints, bool mesure_memory);
 
   private:
     MeshCollection* _input_collection;
     MeshCollection* _output_collection;
     Topology*       _new_topology;
+  public:
+    static const char METIS_PART_ALG[];
+    static const char SCOTCH_PART_ALG[];
+    static const char PTSCOTCH_PART_ALG[];
   };
 }
 #endif
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.cxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.cxx	2018-04-19 17:04:36.770223381 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.cxx	2018-04-19 17:25:17.714796902 +0200
@@ -71,7 +71,7 @@
     _domain_selector( 0 ),
     _i_non_empty_mesh(-1),
     _driver_type(MEDPARTITIONER::MedXml),
-    _subdomain_boundary_creates( MyGlobals::_Creates_Boundary_Faces ),
+    _subdomain_boundary_creates( MyGlobals::_Create_Boundary_Faces ),
     _family_splitting(false),
     _create_empty_groups(false),
     _joint_finder(0)
@@ -100,7 +100,7 @@
     _i_non_empty_mesh(-1),
     _name(initialCollection._name),
     _driver_type(MEDPARTITIONER::MedXml),
-    _subdomain_boundary_creates(MyGlobals::_Creates_Boundary_Faces),
+    _subdomain_boundary_creates(MyGlobals::_Create_Boundary_Faces),
     _family_splitting(family_splitting),
     _create_empty_groups(create_empty_groups),
     _joint_finder(0)
@@ -1508,7 +1508,7 @@
     _domain_selector( 0 ),
     _i_non_empty_mesh(-1),
     _driver_type(MEDPARTITIONER::Undefined),
-    _subdomain_boundary_creates(MyGlobals::_Creates_Boundary_Faces),
+    _subdomain_boundary_creates(MyGlobals::_Create_Boundary_Faces),
     _family_splitting(false),
     _create_empty_groups(false),
     _joint_finder(0)
@@ -1552,7 +1552,7 @@
     _domain_selector( &domainSelector ),
     _i_non_empty_mesh(-1),
     _driver_type(MEDPARTITIONER::Undefined),
-    _subdomain_boundary_creates(MyGlobals::_Creates_Boundary_Faces),
+    _subdomain_boundary_creates(MyGlobals::_Create_Boundary_Faces),
     _family_splitting(false),
     _create_empty_groups(false),
     _joint_finder(0)
@@ -1712,7 +1712,7 @@
     _i_non_empty_mesh(-1),
     _name(meshname),
     _driver_type(MEDPARTITIONER::MedXml),
-    _subdomain_boundary_creates(MyGlobals::_Creates_Boundary_Faces),
+    _subdomain_boundary_creates(MyGlobals::_Create_Boundary_Faces),
     _family_splitting(false),
     _create_empty_groups(false),
     _joint_finder(0)
@@ -1768,7 +1768,7 @@
  * 
  * The method creates as many MED-files as there are domains in the 
  * collection. It also creates a master file that lists all the MED files.
- * The MED files created in ths manner contain joints that describe the 
+ * The MED files created in this manner contain joints that describe the 
  * connectivity between subdomains.
  * 
  * \param filename name of the master file that will contain the list of the MED files
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MeshCollectionDriver.cxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MeshCollectionDriver.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MeshCollectionDriver.cxx	2018-04-19 17:04:36.770223381 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MeshCollectionDriver.cxx	2018-04-19 17:25:17.693796487 +0200
@@ -234,7 +234,7 @@
     }
 
   // MEDCoupling::MEDCouplingUMesh* boundaryMesh=0;
-  // if (MyGlobals::_Creates_Boundary_Faces>0)
+  // if (MyGlobals::_Create_Boundary_Faces>0)
   //   {
   //     //try to write Boundary meshes
   //     bool keepCoords=false; //TODO or true
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.hxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.hxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.hxx	2018-04-19 17:04:36.770223381 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_MeshCollection.hxx	2018-04-19 17:25:17.682796269 +0200
@@ -222,7 +222,7 @@
     std::map<std::string, int> _family_info;
     std::map<std::string, std::vector<std::string> > _group_info;
   
-    //list of groups that are not to be splitted
+    //list of groups that are not to be split
     std::vector<std::string> _indivisible_regions;
 
     //name of global mesh
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/medpartitioner_para.cxx MEDCOUPLING_new/src/MEDPartitioner/medpartitioner_para.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/medpartitioner_para.cxx	2018-04-19 17:04:36.772223421 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/medpartitioner_para.cxx	2018-04-19 17:25:17.689796408 +0200
@@ -102,7 +102,7 @@
 //user can choose! (not yet)
                "\t--split-method=<string>  : name of the splitting library (metis/scotch), default is metis\n"
 #endif
-               "\t--creates-boundary-faces : creates boundary faces mesh in the output files\n"
+               "\t--create-boundary-faces : creates boundary faces mesh in the output files\n"
                "\t--dump-cpu-memory        : dumps passed CPU time and maximal increase of used memory\n"
                //"\t--randomize=<number>     : random seed for other partitionning (only on one proc)\n"
                //"\t--atomize                : do the opposite of a good partitionner (only on one proc)\n"
@@ -131,7 +131,7 @@
       else if (TestArg(argv[i],"--ndomains",value)) ndomains=atoi(value.c_str());
       else if (TestArg(argv[i],"--randomize",value)) MyGlobals::_Randomize=atoi(value.c_str());
       else if (TestArg(argv[i],"--atomize",value)) MyGlobals::_Atomize=atoi(value.c_str());
-      else if (TestArg(argv[i],"--creates-boundary-faces",value)) MyGlobals::_Creates_Boundary_Faces=1;
+      else if (TestArg(argv[i],"--create-boundary-faces",value)) MyGlobals::_Create_Boundary_Faces=1;
       else if (TestArg(argv[i],"--dump-cpu-memory",value)) mesure_memory=true;
       else 
         {
@@ -196,7 +196,7 @@
       cout << "  output-file = " << output << endl;
       cout << "  split-method = " << library << endl;
       cout << "  ndomains = " << ndomains << endl;
-      cout << "  creates_boundary_faces = " << MyGlobals::_Creates_Boundary_Faces << endl;
+      cout << "  create_boundary_faces = " << MyGlobals::_Create_Boundary_Faces << endl;
       cout << "  dump-cpu-memory = " << mesure_memory<< endl;
       cout << "  verbose = " << MyGlobals::_Verbose << endl;
     }
@@ -303,7 +303,7 @@
       if (MyGlobals::_Is0verbose) 
         cout << "generalInformations : \n"<<ReprVectorOfString(finalInformations);
     
-      //new_collection.setSubdomainBoundaryCreates(creates_boundary_faces);
+      //new_collection.setSubdomainBoundaryCreates(create_boundary_faces);
       if (MyGlobals::_Is0verbose) cout << "Writing "<<ndomains<<" output files "<<output<<"xx.med"<<" and "<<output<<".xml"<<endl;
       new_collection.write(output);
   
@@ -343,7 +343,7 @@
     }
   catch(...)
     {
-      cerr<<"proc "<<MyGlobals::_Rank<<" : an unknown type exception error was occured"<<endl;
+      cerr<<"proc "<<MyGlobals::_Rank<<" : an unknown type exception error has occurred"<<endl;
       fflush(stderr);
       MPI_Finalize();
       return 1;
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_ParaDomainSelector.cxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_ParaDomainSelector.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_ParaDomainSelector.cxx	2018-04-19 17:04:36.771223401 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_ParaDomainSelector.cxx	2018-04-19 17:25:17.676796151 +0200
@@ -56,7 +56,7 @@
   _world_size=1;
   _rank=0;
   if (MyGlobals::_Verbose>10)
-    std::cout << "WARNING : ParaDomainSelector contructor without parallel_mode World_Size=1 by default" << std::endl;
+    std::cout << "WARNING : ParaDomainSelector constructor without parallel_mode World_Size=1 by default" << std::endl;
 #endif
   MyGlobals::_World_Size=_world_size;
   MyGlobals::_Rank=_rank;
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_ParallelTopology.cxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_ParallelTopology.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_ParallelTopology.cxx	2018-04-19 17:04:36.771223401 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_ParallelTopology.cxx	2018-04-19 17:25:17.716796941 +0200
@@ -63,7 +63,7 @@
     parallel_mode = (!meshes[idomain]);
 
   if (MyGlobals::_Is0verbose>20 && !parallel_mode)
-    std::cout << "WARNING : ParallelTopology contructor without parallel_mode" << std::endl;
+    std::cout << "WARNING : ParallelTopology constructor without parallel_mode" << std::endl;
   for (int idomain=0; idomain<_nb_domain; idomain++)
     {
       if ( !meshes[idomain] ) continue;
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.cxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.cxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.cxx	2018-04-19 17:25:17.711796843 +0200
@@ -0,0 +1,123 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+
+#include "MEDPARTITIONER_PTScotchGraph.hxx"
+#include "MEDPARTITIONER_Utils.hxx"
+
+#include "MEDCouplingSkyLineArray.hxx"
+#include "MEDCouplingMemArray.hxx"
+#include "MCType.hxx"
+
+#include <cstdio>
+#include <mpi.h>
+
+#ifdef MED_ENABLE_PTSCOTCH
+extern "C"
+{
+#define restrict
+#include "ptscotch.h"
+}
+#endif
+
+using namespace MEDPARTITIONER;
+
+
+PTSCOTCHGraph::PTSCOTCHGraph(MEDCoupling::MEDCouplingSkyLineArray *graph, int *edgeweight, DataArrayInt *vlbloctab):Graph(graph,edgeweight),_vlbloctab(vlbloctab)
+{
+}
+
+PTSCOTCHGraph::~PTSCOTCHGraph()
+{
+}
+
+void PTSCOTCHGraph::partGraph(int ndomain, const std::string& options_string, ParaDomainSelector* sel)
+{
+  if (MyGlobals::_Verbose>10)
+    std::cout << "proc " << MyGlobals::_Rank << " : PTSCOTCHGraph::partGraph" << std::endl;
+  
+  //number of graph vertices
+  int n = _graph->getNumberOf();
+  //graph
+  int * xadj=const_cast<int*>(_graph->getIndex());
+  int * adjncy=const_cast<int*>(_graph->getValues());
+  //ndomain
+  int nparts=ndomain;
+
+#if !defined(MED_ENABLE_PTSCOTCH)
+  throw INTERP_KERNEL::Exception("PTSCOTCHGraph::partGraph : PTSCOTCH is not available. Check your products, please.");
+#else
+  //output parameters
+  int* partition = new int[n+1];
+  
+  int* vlbloctab = _vlbloctab?const_cast<int*>(_vlbloctab->begin()):0;
+  
+  SCOTCH_Dgraph scotch_graph;
+  SCOTCH_dgraphInit(&scotch_graph, MPI_COMM_WORLD);
+  SCOTCH_dgraphBuild(&scotch_graph,
+                     0,             // baseval               , base first indice 0
+                     n,             // vertlocnbr            , nb of local graph nodes
+                     n,             // vertlocmax            , should be set to vertlocnbr for graphs without holes
+                     xadj,          // vertloctab[vertnbr+1] , index vertex table
+                     0,             // vendloctab            , index end vertex table if disjoint, set to zero
+                     _cell_weight,  // veloloctab            , graph vertices loads, set to zero
+                     vlbloctab,     // vlblocltab            , vertex label array : global vertex index
+                     xadj[n],       // edgelocnbr            , number of edges
+                     xadj[n],       // edgelocsiz            , same as edgelocnbr if edgeloctab is compact
+                     adjncy,        // edgeloctab[edgelocnbr], global indexes of edges
+                     0,             // edgegsttab            , optional, should be computed internally, set to zero
+                     _edge_weight); // edloloctab            , graph edges loads, set to zero
+  
+  SCOTCH_Strat scotch_strategy;
+  SCOTCH_stratInit(&scotch_strategy);
+  
+  //!user-defined options for the strategy
+  if (options_string!="")
+    SCOTCH_stratGraphMap(&scotch_strategy,options_string.c_str());
+
+  if (nparts>1)
+    {
+      if (MyGlobals::_Verbose>10) std::cout << "SCOTCHGraph::graphPart SCOTCH_graphPart" << std::endl;
+      SCOTCH_dgraphPart(&scotch_graph,nparts,&scotch_strategy,partition);
+    }
+  else  //partition for 1 subdomain
+    {
+    for (int i=0; i<n+1; i++)
+      partition[i]=0;
+    }
+  
+  SCOTCH_stratExit(&scotch_strategy);
+  SCOTCH_dgraphExit(&scotch_graph);
+
+  std::vector<int> index(n+1);
+  std::vector<int> value(n);
+  index[0]=0;
+  for (int i=0; i<n; i++)
+    {
+      index[i+1]=index[i]+1;
+      value[i]=partition[i];
+    }
+  delete [] partition;
+  
+  //creating a skylinearray with no copy of the index and partition array
+  //the fifth argument true specifies that only the pointers are passed 
+  //to the object
+  _partition = MEDCoupling::MEDCouplingSkyLineArray::New(index,value);
+#endif
+}
+
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.hxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.hxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.hxx	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_PTScotchGraph.hxx	2018-04-19 17:25:17.681796250 +0200
@@ -0,0 +1,47 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+
+#ifndef __MEDPARTITIONER_PTSCOTCHGRAPH_HXX__
+#define __MEDPARTITIONER_PTSCOTCHGRAPH_HXX__
+
+#include "MEDPARTITIONER.hxx"
+#include "MEDPARTITIONER_Graph.hxx"
+#include "MCType.hxx"
+#include <string>
+
+namespace MEDCoupling
+{
+  class DataArrayInt;
+}
+
+namespace MEDPARTITIONER
+{
+  class MEDPARTITIONER_EXPORT PTSCOTCHGraph : public Graph
+  {
+  public:
+    PTSCOTCHGraph() { }
+    PTSCOTCHGraph(MEDCoupling::MEDCouplingSkyLineArray* , int *edgeweight=0, DataArrayInt *vlbloctab=0);
+    virtual ~PTSCOTCHGraph();
+    void partGraph(int ndomain, const std::string& options_string="", ParaDomainSelector* sel=0);
+  protected:
+    MEDCoupling::DataArrayInt *_vlbloctab;
+  };
+}
+
+#endif
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_Utils.cxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_Utils.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_Utils.cxx	2018-04-19 17:04:36.771223401 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_Utils.cxx	2018-04-19 17:25:17.710796823 +0200
@@ -44,7 +44,7 @@
 int MEDPARTITIONER::MyGlobals::_World_Size=-1;
 int MEDPARTITIONER::MyGlobals::_Randomize=0;
 int MEDPARTITIONER::MyGlobals::_Atomize=0;
-int MEDPARTITIONER::MyGlobals::_Creates_Boundary_Faces=0;
+int MEDPARTITIONER::MyGlobals::_Create_Boundary_Faces=0;
 int MEDPARTITIONER::MyGlobals::_Create_Joints=0;
 std::vector<std::string> MEDPARTITIONER::MyGlobals::_File_Names;
 std::vector<std::string> MEDPARTITIONER::MyGlobals::_Mesh_Names;
@@ -364,7 +364,7 @@
       iss >> sizeVector;
       std::string keymap=enTete.substr(foundKey+7,foundSizeVector-foundKey-7);
       for (int ii=1; ii<=sizeVector; ii++)
-        res[keymap].push_back(vs[ii]); //add unconditionnaly,so merge duplicates in second vector
+        res[keymap].push_back(vs[ii]); //add unconditionally,so merge duplicates in second vector
     }
   return res;
 }
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_Utils.hxx MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_Utils.hxx
--- MEDCOUPLING_old/src/MEDPartitioner/MEDPARTITIONER_Utils.hxx	2018-04-19 17:04:36.771223401 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/MEDPARTITIONER_Utils.hxx	2018-04-19 17:25:17.686796348 +0200
@@ -89,7 +89,7 @@
   std::vector<std::string> GetInfosOfField(const char *fileName, const char *meshName, const int idomain );
 
 #ifdef HAVE_MPI
-  //not adviced, interblocking, use sendAndReceive
+  //not advised, interblocking, use sendAndReceive
   //void SendVectorOfString(const std::vector<std::string>& vec, const int target);
   //std::vector<std::string> RecvVectorOfString(const int source);
   //TODO void sendRecvVectorOfString(const std::vector<std::string>& vec, const int source, const int target);
@@ -126,7 +126,7 @@
     static int _World_Size;
     static int _Randomize;
     static int _Atomize;
-    static int _Creates_Boundary_Faces;
+    static int _Create_Boundary_Faces;
     static int _Create_Joints;
     static int _Is0verbose; //trace cout if rank 0 and verbose
     static std::vector<std::string> _File_Names;    //on [iold]
diff -Naur MEDCOUPLING_old/src/MEDPartitioner/Test/MEDPARTITIONERTest.cxx MEDCOUPLING_new/src/MEDPartitioner/Test/MEDPARTITIONERTest.cxx
--- MEDCOUPLING_old/src/MEDPartitioner/Test/MEDPARTITIONERTest.cxx	2018-04-19 17:04:36.772223421 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner/Test/MEDPARTITIONERTest.cxx	2018-04-19 17:25:17.703796685 +0200
@@ -1421,7 +1421,7 @@
 
   const char xmlName[] = "tmp_testCreateBoundaryFaces2D";
   {
-    MyGlobals::_Creates_Boundary_Faces = true;
+    MyGlobals::_Create_Boundary_Faces = true;
     MeshCollection new_collection(collection,new_topo.get());
 
     CPPUNIT_ASSERT_EQUAL(ndomains,new_collection.getNbOfLocalMeshes());
diff -Naur MEDCOUPLING_old/src/MEDPartitioner_Swig/CMakeLists.txt MEDCOUPLING_new/src/MEDPartitioner_Swig/CMakeLists.txt
--- MEDCOUPLING_old/src/MEDPartitioner_Swig/CMakeLists.txt	2018-04-19 17:04:36.772223421 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner_Swig/CMakeLists.txt	2018-04-19 17:25:17.233787394 +0200
@@ -34,7 +34,7 @@
 
 INCLUDE_DIRECTORIES(
   ${PYTHON_INCLUDE_DIRS}
-  ${PTHREAD_INCLUDE_DIR} # pthread dependancy due to python2.7 library
+  ${PTHREAD_INCLUDE_DIR} # pthread dependency due to python2.7 library
   ${NUMPY_INCLUDE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_BINARY_DIR}
diff -Naur MEDCOUPLING_old/src/MEDPartitioner_Swig/MEDPartitionerCommon.i MEDCOUPLING_new/src/MEDPartitioner_Swig/MEDPartitionerCommon.i
--- MEDCOUPLING_old/src/MEDPartitioner_Swig/MEDPartitionerCommon.i	2018-04-19 17:04:36.772223421 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner_Swig/MEDPartitionerCommon.i	2018-04-19 17:25:17.235787434 +0200
@@ -17,42 +17,28 @@
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
 
-%module MEDPartitioner
-
-%include std_string.i
-
 %{
-#include "MEDFileData.hxx"
-
 #include "MEDPARTITIONER_MEDPartitioner.hxx"
 #include "MEDPARTITIONER.hxx"
 #include "MEDPARTITIONER_Graph.hxx"
 
-using namespace MEDCoupling;
-using namespace INTERP_KERNEL;
 using namespace MEDPARTITIONER;
 %}
 
-%feature("autodoc", "1");
-%feature("docstring");
+
 
 %newobject MEDPARTITIONER::MEDPartitioner::New;
 %newobject MEDPARTITIONER::MEDPartitioner::Graph;
 %newobject MEDPARTITIONER::MEDPartitioner::Graph::getGraph;
 %newobject MEDPARTITIONER::MEDPartitioner::Graph::getPartition;
 %newobject MEDPARTITIONER::MEDPartitioner::getMEDFileData;
-%feature("unref") MEDCoupling::MEDFileData "$this->decrRef();"
-
-%nodefaultctor;
-
-%rename (InterpKernelException) INTERP_KERNEL::Exception;
 
 namespace MEDPARTITIONER
 {
   class Graph
   {
   public:
-    typedef enum {METIS,SCOTCH} splitter_type;
+    typedef enum {METIS,SCOTCH,PTSCOTCH} splitter_type;
   public:
     virtual void partGraph(int ndomain, const std::string& options_string="", ParaDomainSelector *sel=0) throw(INTERP_KERNEL::Exception);
     MEDCoupling::MEDCouplingSkyLineArray *getGraph() const
@@ -75,10 +61,12 @@
   class MEDPartitioner
   {
   public:
-    MEDPartitioner(const std::string& filename, int ndomains=1, const std::string& library="metis",bool creates_boundary_faces=false, bool create_joints=false, bool mesure_memory=false) throw(INTERP_KERNEL::Exception);
-    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, int ndomains=1, const std::string& library="metis",bool creates_boundary_faces=false, bool create_joints=false, bool mesure_memory=false) throw(INTERP_KERNEL::Exception);
-    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, Graph* graph, bool creates_boundary_faces=false, bool create_joints=false, bool mesure_memory=false) throw(INTERP_KERNEL::Exception);
-    static MEDPARTITIONER::Graph* Graph(MEDCoupling::MEDCouplingSkyLineArray* graph, Graph::splitter_type split=Graph::METIS, int* edgeweight=0) throw(INTERP_KERNEL::Exception);
+    MEDPartitioner(const std::string& filename, int ndomains=1, const std::string& library="metis",bool create_boundary_faces=false, bool create_joints=false, bool mesure_memory=false) throw(INTERP_KERNEL::Exception);
+    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, int ndomains=1, const std::string& library="metis",bool create_boundary_faces=false, bool create_joints=false, bool mesure_memory=false) throw(INTERP_KERNEL::Exception);
+    MEDPartitioner(const MEDCoupling::MEDFileData* fileData, Graph* graph, bool create_boundary_faces=false, bool create_joints=false, bool mesure_memory=false) throw(INTERP_KERNEL::Exception);
+    static MEDPARTITIONER::Graph* Graph(MEDCoupling::MEDCouplingSkyLineArray* graph, Graph::splitter_type split=Graph::METIS, int* edgeweight=0, MEDCoupling::DataArrayInt* vlbloctab=0) throw(INTERP_KERNEL::Exception);
+    static std::vector<std::string> AvailableAlgorithms();
+    static std::vector<std::string> AllAlgorithms();
     MEDCoupling::MEDFileData* getMEDFileData() throw(INTERP_KERNEL::Exception);
     void write(const std::string& filename) throw(INTERP_KERNEL::Exception);
   };
diff -Naur MEDCOUPLING_old/src/MEDPartitioner_Swig/MEDPartitioner.i MEDCOUPLING_new/src/MEDPartitioner_Swig/MEDPartitioner.i
--- MEDCOUPLING_old/src/MEDPartitioner_Swig/MEDPartitioner.i	2018-04-19 17:04:36.772223421 +0200
+++ MEDCOUPLING_new/src/MEDPartitioner_Swig/MEDPartitioner.i	2018-04-19 17:25:17.237787473 +0200
@@ -17,5 +17,25 @@
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
 
+%module MEDPartitioner
+
+%{
+#include "MEDFileData.hxx"
+
+using namespace MEDCoupling;
+using namespace INTERP_KERNEL;
+%}
+
+%include std_string.i
+
+%feature("autodoc", "1");
+%feature("docstring");
+
+%feature("unref") MEDCoupling::MEDFileData "$this->decrRef();"
+
+%nodefaultctor;
+
+%rename (InterpKernelException) INTERP_KERNEL::Exception;
+
 %include "MEDPartitionerCommon.i"
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/CMakeLists.txt MEDCOUPLING_new/src/ParaMEDMEM/CMakeLists.txt
--- MEDCOUPLING_old/src/ParaMEDMEM/CMakeLists.txt	2018-04-19 17:04:36.773223441 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/CMakeLists.txt	2018-04-19 17:25:17.312788956 +0200
@@ -61,7 +61,7 @@
   )
 
 ADD_LIBRARY(paramedmem ${paramedmem_SOURCES})
-TARGET_LINK_LIBRARIES(paramedmem medcoupling ${MPI_LIBRARIES})
+TARGET_LINK_LIBRARIES(paramedmem medcouplingcpp ${MPI_LIBRARIES})
 INSTALL(TARGETS paramedmem EXPORT ${PROJECT_NAME}TargetGroup DESTINATION ${MEDCOUPLING_INSTALL_LIBS})
 
 FILE(GLOB paramedmem_HEADERS_HXX "${CMAKE_CURRENT_SOURCE_DIR}/*.hxx")
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/CommInterface.cxx MEDCOUPLING_new/src/ParaMEDMEM/CommInterface.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/CommInterface.cxx	2018-04-19 17:04:36.773223441 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/CommInterface.cxx	2018-04-19 17:25:17.318789074 +0200
@@ -29,7 +29,7 @@
     (but this is not strictly respected overall in practice ...). It is used in all
     the \ref parallel "DEC related classes".
 
-    It is typically instanciated after the MPI_Init() call in a program and is afterwards passed as a
+    It is typically instantiated after the MPI_Init() call in a program and is afterwards passed as a
     parameter to the constructors of various \ref parallel "parallel objects" so that they access the
     MPI library via this common interface.
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/DisjointDEC.cxx MEDCOUPLING_new/src/ParaMEDMEM/DisjointDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/DisjointDEC.cxx	2018-04-19 17:04:36.773223441 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/DisjointDEC.cxx	2018-04-19 17:25:17.333789371 +0200
@@ -53,7 +53,7 @@
    * \c ICoCo::Field, or directly a \c MEDCoupling::MEDCouplingFieldDouble instance.
    * See the various signatures of the method DisjointDEC::attachLocalField()
    *
-   * The derivations of this class should be considered for practical instanciation:
+   * The derivations of this class should be considered for practical instantiation:
    * - \ref InterpKernelDEC-det "InterpKernelDEC"
    * - \ref ExplicitCoincidentDEC-det "ExplicitCoincidentDEC"
    * - \ref StructuredCoincidentDEC-det "StructuredCoincidentDEC"
@@ -221,7 +221,7 @@
 
   /**
    * Check that the sources and targets procs form a partition of the world communicator referenced in the groups.
-   * This world communicator is not necessarily MPI_WORLD_COMM, but it has to be covered completly for the DECs to work.
+   * This world communicator is not necessarily MPI_WORLD_COMM, but it has to be covered completely for the DECs to work.
    */
   void DisjointDEC::checkPartitionGroup() const
   {
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/ElementLocator.hxx MEDCOUPLING_new/src/ParaMEDMEM/ElementLocator.hxx
--- MEDCOUPLING_old/src/ParaMEDMEM/ElementLocator.hxx	2018-04-19 17:04:36.774223460 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/ElementLocator.hxx	2018-04-19 17:25:17.302788758 +0200
@@ -22,6 +22,7 @@
 
 #include "InterpolationOptions.hxx"
 #include "MEDCouplingNatureOfField.hxx"
+#include "MCType.hxx"
 
 #include <mpi.h>
 #include <vector>
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/InterpKernelDEC.cxx MEDCOUPLING_new/src/ParaMEDMEM/InterpKernelDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/InterpKernelDEC.cxx	2018-04-19 17:04:36.774223460 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/InterpKernelDEC.cxx	2018-04-19 17:25:17.306788837 +0200
@@ -201,7 +201,7 @@
       {
         //locate the distant meshes
         ElementLocator locator(*_local_field, *_target_group, *_source_group);
-        //transfering option from InterpKernelDEC to ElementLocator   
+        //transferring option from InterpKernelDEC to ElementLocator   
         locator.copyOptions(*this);
         MEDCouplingPointSet* distant_mesh=0; 
         int* distant_ids=0;
@@ -232,7 +232,7 @@
     if (_target_group->containsMyRank())
       {
         ElementLocator locator(*_local_field, *_source_group, *_target_group);
-        //transfering option from InterpKernelDEC to ElementLocator
+        //transferring option from InterpKernelDEC to ElementLocator
         locator.copyOptions(*this);
         MEDCouplingPointSet* distant_mesh=0;
         int* distant_ids=0;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/InterpolationMatrix.cxx MEDCOUPLING_new/src/ParaMEDMEM/InterpolationMatrix.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/InterpolationMatrix.cxx	2018-04-19 17:04:36.774223460 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/InterpolationMatrix.cxx	2018-04-19 17:25:17.352789747 +0200
@@ -81,7 +81,7 @@
      \brief Adds the contribution of a distant subdomain to the*
      interpolation matrix.
      The method adds contribution to the interpolation matrix.
-     For each row of the matrix, elements are addded as
+     For each row of the matrix, elements are added as
      a (column, coeff) pair in the _coeffs array. This column number refers
      to an element on the target side via the _col_offsets array.
      It is made of a series of (iproc, ielem) pairs.
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/MPIAccess.cxx MEDCOUPLING_new/src/ParaMEDMEM/MPIAccess.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/MPIAccess.cxx	2018-04-19 17:04:36.775223480 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/MPIAccess.cxx	2018-04-19 17:25:17.348789668 +0200
@@ -170,7 +170,7 @@
     "_MapOfRequestStruct".
     That structure RequestStruct give the possibility to manage
     the structures MPI_Request and MPI_Status * of MPI. It give
-    also the possibility to get informations about that request :
+    also the possibility to get information about that request :
     target, send/recv, tag, [a]synchronous, type, outcount.
 
     . That identifier is used to control an asynchronous request
@@ -391,7 +391,7 @@
   // Receive (read) in synchronous mode count values of type datatype in buffer from source
   // (returns RequestId identifier even if the corresponding structure is deleted :
   // it is only in order to have the same signature as the asynchronous mode)
-  // The output argument OutCount is optionnal : *OutCount <= count
+  // The output argument OutCount is optional : *OutCount <= count
   int MPIAccess::recv(void* buffer, int count, MPI_Datatype datatype, int source, int &RequestId, int *OutCount)
   {
     int sts = MPI_SUCCESS ;
@@ -1003,7 +1003,7 @@
     return _comm_interface.requestFree( request ) ;
   }
   
-  // Print all informations of all known requests for debugging purpose
+  // Print all information of all known requests for debugging purpose
   void MPIAccess::check() const
   {
     int i = 0 ;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/MPIAccessDEC.cxx MEDCOUPLING_new/src/ParaMEDMEM/MPIAccessDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/MPIAccessDEC.cxx	2018-04-19 17:04:36.775223480 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/MPIAccessDEC.cxx	2018-04-19 17:25:17.326789233 +0200
@@ -441,12 +441,12 @@
     . We assume that buffers are allocated with a new double[]. so a
     delete [] is done.
 
-    . The structure SendBuffStruct permit to keep the adress of the buffer
+    . The structure SendBuffStruct permit to keep the address of the buffer
     and to manage a reference counter of that buffer. It contains
     also MPI_Datatype for the delete [] (double *) ... when the counter
     is null.
 
-    . The map _MapOfSendBuffers etablish the correspondance between each
+    . The map _MapOfSendBuffers establish the correspondence between each
     RequestId given by a MPI_Access->ISend(...) and a SendBuffStruct
     for each "target" of a part of the buffer.
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/NonCoincidentDEC.cxx MEDCOUPLING_new/src/ParaMEDMEM/NonCoincidentDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/NonCoincidentDEC.cxx	2018-04-19 17:04:36.775223480 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/NonCoincidentDEC.cxx	2018-04-19 17:25:17.341789529 +0200
@@ -217,7 +217,7 @@
           {
             elem_numbers = const_cast<fvm_lnum_t*> (support->getNumber(types[itype]));
            
-            //creating work arrays to store list of elems for partial suports
+            //creating work arrays to store list of elems for partial supports
             if (itype>0)
               {
                 fvm_lnum_t* temp = new int[nbelems];
@@ -372,7 +372,7 @@
     int nbcomp = _local_field->getField()->getNumberOfComponents();
     double* distant_values = new double [_nb_distant_points*nbcomp];
 
-    //cheap interpolation :  the value of the cell is transfered to the point
+    //cheap interpolation :  the value of the cell is transferred to the point
     for (int i=0; i<_nb_distant_points; i++)
       for (int j=0; j <nbcomp; j++)
         distant_values[i*nbcomp+j]=values[(_distant_locations[i]-1)*nbcomp+j];
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/OverlapDEC.cxx MEDCOUPLING_new/src/ParaMEDMEM/OverlapDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/OverlapDEC.cxx	2018-04-19 17:04:36.775223480 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/OverlapDEC.cxx	2018-04-19 17:25:17.331789332 +0200
@@ -79,11 +79,11 @@
     Starting from the global interaction previously computed in \ref ParaMEDMEMOverlapDECAlgoStep1
     "Step 1", each proc computes the TODO list per proc.
     The following rules is chosen : a pair (x,y) can be treated by either proc \#x or proc \#y,
-    in order to reduce the amount of data transfert among
+    in order to reduce the amount of data transfers among
     processors. The algorithm chosen for load balancing is the following : Each processor has
     an empty \b local TODO list at the beginning. Then for each pair (k,m) in
     \b global TODO list, if proc\#k has less temporary local list than proc\#m pair, (k,m) is added
-    to temparary local TODO list of proc\#k.
+    to temporary local TODO list of proc\#k.
     If proc\#m has less temporary local TODO list than proc\#k pair, (k,m) is added to temporary
     local TODO list of proc\#m.
     If proc\#k and proc\#m have the same amount of temporary local TODO list pair, (k,m) is added to
@@ -135,7 +135,7 @@
     seen in \ref ParaMEDMEMOverlapDECAlgoStep2 "here in Step2".
 
     As will be dealt in Step 6, for final matrix-vector computations, the resulting matrix of the
-    couple (k,m) whereever it is computed (proc \#k or proc \#m)
+    couple (k,m) wherever it is computed (proc \#k or proc \#m)
     will be stored in \b proc\#m.
 
     - If proc \#k is in charge (performs the matrix computation) for this couple (k,m), target ids
@@ -154,7 +154,7 @@
      in charge of the matrix, proc \#m receives the source ids
     from remote proc \#k, and thus the matrix is directly correct, no need for renumbering as
      in \ref ParaMEDMEMOverlapDECAlgoStep5 "Step 5". However proc \#k must
-    keep track of the ids sent to proc \#m for te matrix-vector computation.
+    keep track of the ids sent to proc \#m for the matrix-vector computation.
     This is incarnated by OverlapMapping::keepTracksOfSourceIds in proc k.
 
     This step is performed in MEDCoupling::OverlapElementLocator::exchangeMeshes method.
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/OverlapElementLocator.cxx MEDCOUPLING_new/src/ParaMEDMEM/OverlapElementLocator.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/OverlapElementLocator.cxx	2018-04-19 17:04:36.776223501 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/OverlapElementLocator.cxx	2018-04-19 17:25:17.344789588 +0200
@@ -481,8 +481,8 @@
   }
 
   /*!
-   * This method recieves source remote mesh on proc 'procId' if sourceOrTarget==True
-   * This method recieves target remote mesh on proc 'procId' if sourceOrTarget==False
+   * This method receives source remote mesh on proc 'procId' if sourceOrTarget==True
+   * This method receives target remote mesh on proc 'procId' if sourceOrTarget==False
    */
   void OverlapElementLocator::receiveRemoteMeshFrom(int procId, bool sourceOrTarget)
   {
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/OverlapMapping.cxx MEDCOUPLING_new/src/ParaMEDMEM/OverlapMapping.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/OverlapMapping.cxx	2018-04-19 17:04:36.776223501 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/OverlapMapping.cxx	2018-04-19 17:25:17.359789885 +0200
@@ -415,7 +415,7 @@
  * This is the last step after all2Alls for matrix exchange.
  * _the_matrix_st is the final matrix : 
  *      - The first entry is srcId in current proc.
- *      - The second is the pseudo id of source proc (correspondance with true id is in attribute _the_matrix_st_source_proc_id and _the_matrix_st_source_ids)
+ *      - The second is the pseudo id of source proc (correspondence with true id is in attribute _the_matrix_st_source_proc_id and _the_matrix_st_source_ids)
  *      - the third is the srcId in the pseudo source proc
  */
 void OverlapMapping::unserializationST(int nbOfTrgElems,
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM/ParaFIELD.cxx MEDCOUPLING_new/src/ParaMEDMEM/ParaFIELD.cxx
--- MEDCOUPLING_old/src/ParaMEDMEM/ParaFIELD.cxx	2018-04-19 17:04:36.776223501 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM/ParaFIELD.cxx	2018-04-19 17:25:17.308788877 +0200
@@ -172,7 +172,7 @@
    * This method returns, if it exists, an array with only one component and as many as tuples as _field has.
    * This array gives for every element on which this->_field lies, its global number, if this->_field is nodal.
    * For example if _field is a nodal field : returned array will be the nodal global numbers.
-   * The content of this method is used to inform Working side to accumulate data recieved by lazy side.
+   * The content of this method is used to inform Working side to accumulate data received by lazy side.
    */
   DataArrayInt* ParaFIELD::returnCumulativeGlobalNumbering() const
   {
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM_Swig/CMakeLists.txt MEDCOUPLING_new/src/ParaMEDMEM_Swig/CMakeLists.txt
--- MEDCOUPLING_old/src/ParaMEDMEM_Swig/CMakeLists.txt	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM_Swig/CMakeLists.txt	2018-04-19 17:25:17.361789924 +0200
@@ -30,39 +30,33 @@
 ENDIF()
 SET(SWIG_MODULE_ParaMEDMEM_EXTRA_FLAGS "${NUMPY_DEFINITIONS};${SCIPY_DEFINITIONS}")
 
-SET (ParaMEDMEM_SWIG_DPYS_FILES
-    ParaMEDMEM.typemap)
-
 INCLUDE_DIRECTORIES(
   ${PYTHON_INCLUDE_DIRS}
   ${NUMPY_INCLUDE_DIR}
-  ${MEDFILE_INCLUDE_DIRS}
-  ${HDF5_INCLUDE_DIRS}
   ${MPI_INCLUDE_DIRS}
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/../ParaMEDMEM
   ${CMAKE_CURRENT_SOURCE_DIR}/../ICoCo
   ${CMAKE_CURRENT_SOURCE_DIR}/../MEDCoupling_Swig
-  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDLoader/Swig
-  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDLoader
   ${CMAKE_CURRENT_SOURCE_DIR}/../MEDCoupling
   ${CMAKE_CURRENT_SOURCE_DIR}/../INTERP_KERNEL
   ${CMAKE_CURRENT_SOURCE_DIR}/../INTERP_KERNEL/Bases
   )
 
-SET (SWIG_MODULE_ParaMEDMEM_EXTRA_DEPS ${ParaMEDMEM_SWIG_DPYS_FILES}
+SET (SWIG_MODULE_ParaMEDMEM_EXTRA_DEPS
     ${paramedmem_HEADERS_HXX}
     ${medloader_HEADERS_HXX}
     ${medcoupling_HEADERS_HXX} ${medcoupling_HEADERS_TXX}
     ${interpkernel_HEADERS_HXX} ${interpkernel_HEADERS_TXX})
 
 SWIG_ADD_MODULE(ParaMEDMEM python ParaMEDMEM.i)
-SWIG_LINK_LIBRARIES(ParaMEDMEM ${PYTHON_LIBRARIES} paramedmem medloader)
+SWIG_LINK_LIBRARIES(ParaMEDMEM ${PYTHON_LIBRARIES} paramedmem)
 SWIG_CHECK_GENERATION(ParaMEDMEM)
 
 INSTALL(TARGETS _ParaMEDMEM DESTINATION ${MEDCOUPLING_INSTALL_PYTHON})
-INSTALL(FILES ParaMEDMEM.i DESTINATION ${MEDCOUPLING_INSTALL_HEADERS})
-INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/ParaMEDMEM.py test_InterpKernelDEC.py test_NonCoincidentDEC.py test_StructuredCoincidentDEC.py DESTINATION ${MEDCOUPLING_INSTALL_SCRIPT_PYTHON})
+INSTALL(FILES ParaMEDMEM.i ParaMEDMEMCommon.i DESTINATION ${MEDCOUPLING_INSTALL_HEADERS})
+INSTALL(FILES test_InterpKernelDEC.py test_NonCoincidentDEC.py test_StructuredCoincidentDEC.py DESTINATION ${MEDCOUPLING_INSTALL_SCRIPT_PYTHON})
+SALOME_INSTALL_SCRIPTS(${CMAKE_CURRENT_BINARY_DIR}/ParaMEDMEM.py ${MEDCOUPLING_INSTALL_PYTHON})
 
 SALOME_INSTALL_SCRIPTS(${CMAKE_CURRENT_BINARY_DIR}/ParaMEDMEM.py ${MEDCOUPLING_INSTALL_SCRIPT_PYTHON})
 INSTALL(FILES test_InterpKernelDEC.py test_NonCoincidentDEC.py test_StructuredCoincidentDEC.py DESTINATION ${MEDCOUPLING_INSTALL_SCRIPT_PYTHON})
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM_Swig/ParaMEDMEMCommon.i MEDCOUPLING_new/src/ParaMEDMEM_Swig/ParaMEDMEMCommon.i
--- MEDCOUPLING_old/src/ParaMEDMEM_Swig/ParaMEDMEMCommon.i	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/ParaMEDMEM_Swig/ParaMEDMEMCommon.i	2018-04-19 17:25:17.364789984 +0200
@@ -0,0 +1,102 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+
+%include std_set.i
+
+%template() std::set<int>;
+
+%{
+#include "CommInterface.hxx"
+#include "ProcessorGroup.hxx"
+#include "Topology.hxx"
+#include "MPIProcessorGroup.hxx"
+#include "DEC.hxx"
+#include "InterpKernelDEC.hxx"
+#include "NonCoincidentDEC.hxx"
+#include "StructuredCoincidentDEC.hxx"
+#include "ParaMESH.hxx"
+#include "ParaFIELD.hxx"
+#include "ICoCoMEDField.hxx"
+#include "ComponentTopology.hxx"
+
+using namespace INTERP_KERNEL;
+using namespace MEDCoupling;
+using namespace ICoCo;
+%}
+
+%include "InterpolationOptions.hxx"
+%include "CommInterface.hxx"
+%include "ProcessorGroup.hxx"
+%include "DECOptions.hxx"
+%include "ParaMESH.hxx"
+%include "ParaFIELD.hxx"
+%include "MPIProcessorGroup.hxx"
+%include "ComponentTopology.hxx"
+%include "DEC.hxx"
+%include "DisjointDEC.hxx"
+%include "InterpKernelDEC.hxx"
+%include "StructuredCoincidentDEC.hxx"
+
+%include "ICoCoField.hxx"
+%rename(ICoCoMEDField) ICoCo::MEDField;
+%include "ICoCoMEDField.hxx"
+
+%nodefaultctor;
+
+/* This object can be used only if MED_ENABLE_FVM is defined*/
+#ifdef MED_ENABLE_FVM
+class NonCoincidentDEC : public DEC
+{
+public:
+  NonCoincidentDEC(ProcessorGroup& source, ProcessorGroup& target);
+};
+#endif
+
+%extend MEDCoupling::ParaMESH
+{
+  PyObject *getGlobalNumberingCell2() const
+  {
+    const int *tmp=self->getGlobalNumberingCell();
+    int size=self->getCellMesh()->getNumberOfCells();
+    PyObject *ret=PyList_New(size);
+    for(int i=0;i<size;i++)
+      PyList_SetItem(ret,i,PyInt_FromLong(tmp[i])); 
+    return ret;
+  }
+
+  PyObject *getGlobalNumberingFace2() const
+  {
+    const int *tmp=self->getGlobalNumberingFace();
+    int size=self->getFaceMesh()->getNumberOfCells();
+    PyObject *ret=PyList_New(size);
+    for(int i=0;i<size;i++)
+      PyList_SetItem(ret,i,PyInt_FromLong(tmp[i])); 
+    return ret;
+  }
+
+  PyObject *getGlobalNumberingNode2() const
+  {
+    const int *tmp=self->getGlobalNumberingNode();
+    int size=self->getCellMesh()->getNumberOfNodes();
+    PyObject *ret=PyList_New(size);
+    for(int i=0;i<size;i++)
+      PyList_SetItem(ret,i,PyInt_FromLong(tmp[i])); 
+    return ret;
+  }
+}
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM_Swig/ParaMEDMEM.i MEDCOUPLING_new/src/ParaMEDMEM_Swig/ParaMEDMEM.i
--- MEDCOUPLING_old/src/ParaMEDMEM_Swig/ParaMEDMEM.i	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM_Swig/ParaMEDMEM.i	2018-04-19 17:25:17.366790023 +0200
@@ -17,281 +17,33 @@
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
 
-%module ParaMEDMEM
-
-%include "ParaMEDMEM.typemap"
-%include "MEDLoaderCommon.i"
-
-%{
-#include "CommInterface.hxx"
-#include "ProcessorGroup.hxx"
-#include "Topology.hxx"
-#include "MPIProcessorGroup.hxx"
-#include "DEC.hxx"
-#include "InterpKernelDEC.hxx"
-#include "NonCoincidentDEC.hxx"
-#include "StructuredCoincidentDEC.hxx"
-#include "ParaMESH.hxx"
-#include "ParaFIELD.hxx"
-#include "ICoCoMEDField.hxx"
-#include "ComponentTopology.hxx"
-
-#include <mpi.h>
-
-using namespace MEDCoupling;
-using namespace ICoCo;
-      
-enum mpi_constants { mpi_comm_world, mpi_comm_self, mpi_double, mpi_int };
-%}
-
-%include "CommInterface.hxx"
-%include "ProcessorGroup.hxx"
-%include "DECOptions.hxx"
-%include "ParaMESH.hxx"
-%include "ParaFIELD.hxx"
-%include "MPIProcessorGroup.hxx"
-%include "ComponentTopology.hxx"
-%include "DEC.hxx"
-%include "InterpKernelDEC.hxx"
-%include "StructuredCoincidentDEC.hxx"
-
-%rename(ICoCoMEDField) ICoCo::MEDField;
-%include "ICoCoMEDField.hxx"
-
-%nodefaultctor;
-
-/* This object can be used only if MED_ENABLE_FVM is defined*/
-#ifdef MED_ENABLE_FVM
-class NonCoincidentDEC : public DEC
-{
-public:
-  NonCoincidentDEC(ProcessorGroup& source, ProcessorGroup& target);
-};
-#endif
-
-%extend MEDCoupling::ParaMESH
-{
-  PyObject *getGlobalNumberingCell2() const
-  {
-    const int *tmp=self->getGlobalNumberingCell();
-    int size=self->getCellMesh()->getNumberOfCells();
-    PyObject *ret=PyList_New(size);
-    for(int i=0;i<size;i++)
-      PyList_SetItem(ret,i,PyInt_FromLong(tmp[i])); 
-    return ret;
-  }
-
-  PyObject *getGlobalNumberingFace2() const
-  {
-    const int *tmp=self->getGlobalNumberingFace();
-    int size=self->getFaceMesh()->getNumberOfCells();
-    PyObject *ret=PyList_New(size);
-    for(int i=0;i<size;i++)
-      PyList_SetItem(ret,i,PyInt_FromLong(tmp[i])); 
-    return ret;
-  }
+// Author : Anthony Geay (EDF R&D)
 
-  PyObject *getGlobalNumberingNode2() const
-  {
-    const int *tmp=self->getGlobalNumberingNode();
-    int size=self->getCellMesh()->getNumberOfNodes();
-    PyObject *ret=PyList_New(size);
-    for(int i=0;i<size;i++)
-      PyList_SetItem(ret,i,PyInt_FromLong(tmp[i])); 
-    return ret;
-  }
-}
-
-//=============================================================================================
-// Interface for MPI-realization-specific constants like MPI_COMM_WORLD.
-//
-// Type and values of constants like MPI_COMM_WORLD depends on MPI realization
-// and usually such constants actually are macros. To have such symbols in python
-// and translate them into correct values we use the following technique.
-// We define some constants (enum mpi_constants) and map them into real MPI values
-// using typemaps, and we create needed python symbols equal to 'mpi_constants'
-// via %pythoncode directive.
-
-// Constants corresponding to similar MPI definitions
-enum mpi_constants { mpi_comm_world, mpi_comm_self, mpi_double, mpi_int };
-
-// Map mpi_comm_world and mpi_comm_self -> MPI_COMM_WORLD and MPI_COMM_SELF
-%typemap(in) MPI_Comm
-{ 
-  switch (PyInt_AsLong($input))
-    {
-    case mpi_comm_world: $1 = MPI_COMM_WORLD; break;
-    case mpi_comm_self:  $1 = MPI_COMM_SELF;  break;
-    default:
-      PyErr_SetString(PyExc_TypeError,"unexpected value of MPI_Comm");
-      return NULL;
-    }
-}
-// Map mpi_double and mpi_int -> MPI_DOUBLE and MPI_INT
-%typemap(in) MPI_Datatype
-{ 
-  switch (PyInt_AsLong($input))
-    {
-    case mpi_double:     $1 = MPI_DOUBLE;     break;
-    case mpi_int:        $1 = MPI_INT;        break;
-    default:
-      PyErr_SetString(PyExc_TypeError,"unexpected value of MPI_Datatype");
-      return NULL;
-    }
-}
-// The following code gets inserted into the result python file:
-// create needed python symbols
-%pythoncode %{
-MPI_COMM_WORLD = mpi_comm_world
-MPI_COMM_SELF  = mpi_comm_self
-MPI_DOUBLE     = mpi_double
-MPI_INT        = mpi_int
-%}
-//=============================================================================================
-
-// ==============
-// MPI_Comm_size
-// ==============
-%inline %{ PyObject* MPI_Comm_size(MPI_Comm comm)
-  {
-    int res = 0;
-    int err = MPI_Comm_size(comm, &res);
-    if ( err != MPI_SUCCESS )
-      {
-        PyErr_SetString(PyExc_RuntimeError,"Erorr in MPI_Comm_size()");
-        return NULL;
-      }
-    return PyInt_FromLong( res );
-  } %}
-
-// ==============
-// MPI_Comm_rank
-// ==============
-%inline %{ PyObject* MPI_Comm_rank(MPI_Comm comm)
-  {
-    int res = 0;
-    int err = MPI_Comm_rank(comm, &res);
-    if ( err != MPI_SUCCESS )
-      {
-        PyErr_SetString(PyExc_RuntimeError,"Erorr in MPI_Comm_rank()");
-        return NULL;
-      }
-    return PyInt_FromLong( res );
-  } 
-  %}
-
-int MPI_Init(int *argc, char ***argv );
-int MPI_Barrier(MPI_Comm comm);
-int MPI_Finalize();
+%module ParaMEDMEM
 
-// ==========
-// MPI_Bcast
-// ==========
+#define MEDCOUPLING_EXPORT
+#define INTERPKERNEL_EXPORT
 
-%inline %{ PyObject* MPI_Bcast(PyObject* buffer, int nb, MPI_Datatype type, int root, MPI_Comm c)
-  {
-    // buffer must be a list
-    if (!PyList_Check(buffer))
-      {
-        PyErr_SetString(PyExc_TypeError, "buffer is expected to be a list");
-        return NULL;
-      }
-    // check list size
-    int aSize = PyList_Size(buffer);
-    if ( aSize != nb )
-      {
-        std::ostringstream stream; stream << "buffer is expected to be of size " << nb;
-        PyErr_SetString(PyExc_ValueError, stream.str().c_str());
-        return NULL;
-      }
-    // allocate and fill a buffer
-    void* aBuf = 0;
-    int* intBuf = 0;
-    double* dblBuf = 0;
-    if ( type == MPI_DOUBLE )
-      {
-        aBuf = (void*) ( dblBuf = new double[ nb ] );
-        for ( int i = 0; i < aSize; ++i )
-          dblBuf[i] = PyFloat_AS_DOUBLE( PyList_GetItem( buffer, i ));
-      }
-    else if ( type == MPI_INT )
-      {
-        aBuf = (void*) ( intBuf = new int[ nb ] );
-        for ( int i = 0; i < aSize; ++i )
-          intBuf[i] = int( PyInt_AS_LONG( PyList_GetItem( buffer, i )));
-      }
-    else
-      {
-        PyErr_SetString(PyExc_TypeError, "Only MPI_DOUBLE and MPI_INT supported");
-        return NULL;
-      }
-    // call MPI_Bcast
-    int err = MPI_Bcast(aBuf, nb, type, root, c);
-    // treat error
-    if ( err != MPI_SUCCESS )
-      {
-        PyErr_SetString(PyExc_RuntimeError,"Erorr in MPI_Bcast()");
-        delete [] intBuf; delete [] dblBuf;
-        return NULL;
-      }
-    // put recieved data into the list
-    int pyerr = 0;
-    if ( type == MPI_DOUBLE )
-      {
-        for ( int i = 0; i < aSize && !pyerr; ++i )
-          pyerr = PyList_SetItem(buffer, i, PyFloat_FromDouble( dblBuf[i] ));
-        delete [] dblBuf;
-      }
-    else
-      {
-        for ( int i = 0; i < aSize && !pyerr; ++i )
-          pyerr = PyList_SetItem(buffer, i, PyInt_FromLong( intBuf[i] ));
-        delete [] intBuf;
-      }
-    if ( pyerr )
-      {
-        PyErr_SetString(PyExc_RuntimeError, "Error of PyList_SetItem()");
-        return NULL;
-      }
-    return PyInt_FromLong( err );
+%include "MEDCouplingCommon.i"
 
-  }
-  %}
+%include "ParaMEDMEMCommon.i"
 
 %pythoncode %{
-def ParaMEDMEMDataArrayDoublenew(cls,*args):
-    import _ParaMEDMEM
-    return _ParaMEDMEM.DataArrayDouble____new___(cls,args)
-def ParaMEDMEMDataArrayDoubleIadd(self,*args):
+def MEDCouplingDataArrayDoubleIadd(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayDouble____iadd___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleIsub(self,*args):
+def MEDCouplingDataArrayDoubleIsub(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayDouble____isub___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleImul(self,*args):
+def MEDCouplingDataArrayDoubleImul(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayDouble____imul___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleIdiv(self,*args):
+def MEDCouplingDataArrayDoubleIdiv(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayDouble____idiv___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleIpow(self,*args):
+def MEDCouplingDataArrayDoubleIpow(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayDouble____ipow___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleTupleIadd(self,*args):
-    import _ParaMEDMEM
-    return _ParaMEDMEM.DataArrayDoubleTuple____iadd___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleTupleIsub(self,*args):
-    import _ParaMEDMEM
-    return _ParaMEDMEM.DataArrayDoubleTuple____isub___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleTupleImul(self,*args):
-    import _ParaMEDMEM
-    return _ParaMEDMEM.DataArrayDoubleTuple____imul___(self, self, *args)
-def ParaMEDMEMDataArrayDoubleTupleIdiv(self,*args):
-    import _ParaMEDMEM
-    return _ParaMEDMEM.DataArrayDoubleTuple____idiv___(self, self, *args)
-def MEDCouplingFieldDoublenew(cls,*args):
-    import _ParaMEDMEM
-    return _ParaMEDMEM.MEDCouplingFieldDouble____new___(cls,args)
 def MEDCouplingFieldDoubleIadd(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.MEDCouplingFieldDouble____iadd___(self, self, *args)
@@ -307,42 +59,69 @@
 def MEDCouplingFieldDoubleIpow(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.MEDCouplingFieldDouble____ipow___(self, self, *args)
-def ParaMEDMEMDataArrayIntnew(cls,*args):
-    import _ParaMEDMEM
-    return _ParaMEDMEM.DataArrayInt____new___(cls,args)
-def ParaMEDMEMDataArrayIntIadd(self,*args):
+def MEDCouplingDataArrayIntIadd(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayInt____iadd___(self, self, *args)
-def ParaMEDMEMDataArrayIntIsub(self,*args):
+def MEDCouplingDataArrayIntIsub(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayInt____isub___(self, self, *args)
-def ParaMEDMEMDataArrayIntImul(self,*args):
+def MEDCouplingDataArrayIntImul(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayInt____imul___(self, self, *args)
-def ParaMEDMEMDataArrayIntIdiv(self,*args):
+def MEDCouplingDataArrayIntIdiv(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayInt____idiv___(self, self, *args)
-def ParaMEDMEMDataArrayIntImod(self,*args):
+def MEDCouplingDataArrayIntImod(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayInt____imod___(self, self, *args)
-def ParaMEDMEMDataArrayIntIpow(self,*args):
+def MEDCouplingDataArrayIntIpow(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayInt____ipow___(self, self, *args)
-def ParaMEDMEMDataArrayIntTupleIadd(self,*args):
+def MEDCouplingDataArrayFloatIadd(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayFloat____iadd___(self, self, *args)
+def MEDCouplingDataArrayFloatIsub(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayFloat____isub___(self, self, *args)
+def MEDCouplingDataArrayFloatImul(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayFloat____imul___(self, self, *args)
+def MEDCouplingDataArrayFloatIdiv(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayFloat____idiv___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleIadd(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayDoubleTuple____iadd___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleIsub(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayDoubleTuple____isub___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleImul(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayDoubleTuple____imul___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleIdiv(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DataArrayDoubleTuple____idiv___(self, self, *args)
+def MEDCouplingDataArrayIntTupleIadd(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayIntTuple____iadd___(self, self, *args)
-def ParaMEDMEMDataArrayIntTupleIsub(self,*args):
+def MEDCouplingDataArrayIntTupleIsub(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayIntTuple____isub___(self, self, *args)
-def ParaMEDMEMDataArrayIntTupleImul(self,*args):
+def MEDCouplingDataArrayIntTupleImul(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayIntTuple____imul___(self, self, *args)
-def ParaMEDMEMDataArrayIntTupleIdiv(self,*args):
+def MEDCouplingDataArrayIntTupleIdiv(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayIntTuple____idiv___(self, self, *args)
-def ParaMEDMEMDataArrayIntTupleImod(self,*args):
+def MEDCouplingDataArrayIntTupleImod(self,*args):
     import _ParaMEDMEM
     return _ParaMEDMEM.DataArrayIntTuple____imod___(self, self, *args)
+def MEDCouplingDenseMatrixIadd(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DenseMatrix____iadd___(self, self, *args)
+def MEDCouplingDenseMatrixIsub(self,*args):
+    import _ParaMEDMEM
+    return _ParaMEDMEM.DenseMatrix____isub___(self, self, *args)
 %}
 
 %include "MEDCouplingFinalize.i"
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM_Swig/ParaMEDMEM.typemap MEDCOUPLING_new/src/ParaMEDMEM_Swig/ParaMEDMEM.typemap
--- MEDCOUPLING_old/src/ParaMEDMEM_Swig/ParaMEDMEM.typemap	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM_Swig/ParaMEDMEM.typemap	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-// Copyright (C) 2007-2016  CEA/DEN, EDF R&D
-//
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-//
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-//
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-//
-// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
-//
-
-%include std_set.i
-%include std_string.i
-
-%template() std::set<int>;
-
-// Creates "int *argc, char ***argv" parameters from input list
-%typemap(in) (int *argc, char ***argv) {
-  int i;
-  if (!PyList_Check($input)) {
-    PyErr_SetString(PyExc_ValueError, "Expecting a list");
-    return NULL;
-  }
-  int aSize = PyList_Size($input);
-  $1 = &aSize;
-  char** aStrs = (char **) malloc((aSize+1)*sizeof(char *));
-  for (i = 0; i < aSize; i++) {
-    PyObject *s = PyList_GetItem($input,i);
-    if (PyString_Check(s))
-      aStrs[i] = PyString_AsString(s);
-%#if PY_VERSION_HEX >= 0x03000000
-    else if (PyUnicode_Check(s))
-      aStrs[i] = PyUnicode_AsUTF8(s);
-%#endif
-    else {
-        free(aStrs);
-        PyErr_SetString(PyExc_ValueError, "List items must be strings");
-        return NULL;
-    }
-  }
-  aStrs[i] = 0;
-  $2 = &aStrs;
-}
-
-%typemap(freearg) (int *argc, char ***argv) {
-   if ($2) free(*($2));
-}
-
-/*  MACRO: IN typemap for std::set<TYPE> C++ object */
-%define TYPEMAP_INPUT_SET_BY_VALUE( TYPE )
-{
-  /* typemap in for set<TYPE> */
-  /* Check if is a list */
-  if (PyList_Check($input))
-  {
-    int size = PyList_Size($input);
-    std::set< TYPE > tmpSet;
-
-    for (int i=0; i < size; i++)
-    {
-      PyObject * tmp = PyList_GetItem($input,i);
-      TYPE elem = PyInt_AsLong(tmp);
-      tmpSet.insert(elem);
-    }
-    $1 = tmpSet;
-  }
-  else
-  {
-    PyErr_SetString(PyExc_TypeError,"not a list");
-    return NULL;
-  }
-}
-%enddef
-
-%typemap(in) std::set<int>
-{ 
-  TYPEMAP_INPUT_SET_BY_VALUE( int ) 
-}
-%typecheck(SWIG_TYPECHECK_POINTER) std::set<int> {
-  $1 = PyList_Check($input) ? 1 : 0;
-}
diff -Naur MEDCOUPLING_old/src/ParaMEDMEM_Swig/test_InterpKernelDEC.py MEDCOUPLING_new/src/ParaMEDMEM_Swig/test_InterpKernelDEC.py
--- MEDCOUPLING_old/src/ParaMEDMEM_Swig/test_InterpKernelDEC.py	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEM_Swig/test_InterpKernelDEC.py	2018-04-19 17:25:17.361789924 +0200
@@ -20,15 +20,17 @@
 #
 
 from ParaMEDMEM import *
+from MEDLoader import ReadUMeshFromFile
 import sys, os
 import unittest
 import math
+from mpi4py import MPI
+
 
 class ParaMEDMEMBasicsTest(unittest.TestCase):
     def testInterpKernelDEC_2D(self):
-        MPI_Init(sys.argv)
-        size = MPI_Comm_size(MPI_COMM_WORLD)
-        rank = MPI_Comm_rank(MPI_COMM_WORLD)
+        size = MPI.COMM_WORLD.size
+        rank = MPI.COMM_WORLD.rank
         if size != 5:
             raise RuntimeError("Expect MPI_COMM_WORLD size == 5")
         print(rank)
@@ -56,7 +58,7 @@
         filename_xml1 = os.path.join(data_dir, "share/resources/med/square1_split")
         filename_xml2 = os.path.join(data_dir, "share/resources/med/square2_split")
 
-        MPI_Barrier(MPI_COMM_WORLD)
+        MPI.COMM_WORLD.Barrier()
         if source_group.containsMyRank():
             filename = filename_xml1 + str(rank+1) + ".med"
             meshname = "Mesh_2_" + str(rank+1)
@@ -68,8 +70,7 @@
             nb_local=mesh.getNumberOfCells()
             value = [1.0]*nb_local
             parafield.getField().setValues(value)
-            icocofield = ICoCoMEDField(mesh,parafield.getField())
-            dec.setMethod("P0")
+            icocofield = ICoCoMEDField(parafield.getField())
             dec.attachLocalField(icocofield)
             pass
         else:
@@ -83,8 +84,7 @@
             nb_local=mesh.getNumberOfCells()
             value = [0.0]*nb_local
             parafield.getField().setValues(value)
-            icocofield = ICoCoMEDField(mesh,parafield.getField())
-            dec.setMethod("P0")
+            icocofield = ICoCoMEDField(parafield.getField())
             dec.attachLocalField(icocofield)
             pass
 
@@ -113,8 +113,8 @@
         paramesh   =0
         parafield  =0
         icocofield =0
-        MPI_Barrier(MPI_COMM_WORLD)
-        MPI_Finalize()
+        MPI.COMM_WORLD.Barrier()
+        MPI.Finalize()
         pass
     pass
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/ParaMEDMEMTest_Gauthier1.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/ParaMEDMEMTest_Gauthier1.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/ParaMEDMEMTest_Gauthier1.cxx	2018-04-19 17:04:36.797223919 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/ParaMEDMEMTest_Gauthier1.cxx	2018-04-19 17:25:17.893800440 +0200
@@ -46,7 +46,7 @@
 void afficheGauthier1(const ParaFIELD& field, const double *vals, int lgth)
 {
   const DataArrayDouble *valsOfField(field.getField()->getArray());
-  CPPUNIT_ASSERT_EQUAL(lgth,valsOfField->getNumberOfTuples());
+  CPPUNIT_ASSERT_EQUAL(lgth,(int)valsOfField->getNumberOfTuples());
   for (int ele=0;ele<valsOfField->getNumberOfTuples();ele++)
     CPPUNIT_ASSERT_DOUBLES_EQUAL(vals[ele],valsOfField->getIJ(ele,0),1e-12);
 }
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_1.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_1.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_1.cxx	2018-04-19 17:04:36.797223919 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_1.cxx	2018-04-19 17:25:17.899800559 +0200
@@ -63,7 +63,7 @@
       return;
     }
 
-  /* Connection to remote programm */
+  /* Connection to remote program */
   MPI2Connector *mpio = new MPI2Connector;
   gcom = mpio->remoteMPI2Connect(service);
   MPI_Comm_size( gcom, &gsize );
@@ -108,7 +108,7 @@
   dec.synchronize();
   dec.setForcedRenormalization(false);
   dec.sendData();
-  /* Deconnection of remote programm */
+  /* Deconnection of remote program */
   mpio->remoteMPI2Disconnect(service);
   /* clean-up */
   delete mpio;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_2.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_2.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_2.cxx	2018-04-19 17:04:36.797223919 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/ParaMEDMEMTestMPI2_2.cxx	2018-04-19 17:25:17.914800855 +0200
@@ -63,7 +63,7 @@
       return;
     }
 
-  /* Connection to remote programm */
+  /* Connection to remote program */
   MPI2Connector *mpio = new MPI2Connector;
   gcom = mpio->remoteMPI2Connect(service);
   
@@ -113,7 +113,7 @@
   const double *expected=targetResults[grank-(gsize-lsize)];
   CPPUNIT_ASSERT_DOUBLES_EQUAL(expected[0],res[0],1e-13);
   CPPUNIT_ASSERT_DOUBLES_EQUAL(expected[1],res[1],1e-13);
-  /* Deconnection of remote programm */
+  /* Deconnection of remote program */
   mpio->remoteMPI2Disconnect(service);
   /* clean-up */
   delete mpio;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllDEC.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllDEC.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllDEC.cxx	2018-04-19 17:25:17.894800460 +0200
@@ -77,7 +77,7 @@
     strstream << "usage :" << endl
               << "mpirun -np <nbprocs> test_AllToAllDEC" << endl
               << " (nbprocs >=2)" << endl
-              << "test must be runned with more than 1 proc and less than 12 procs"
+              << "test must be run with more than 1 proc and less than 12 procs"
               << endl ;
     cerr << strstream.str() << endl ;
     CPPUNIT_FAIL( strstream.str() ) ;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllTimeDEC.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllTimeDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllTimeDEC.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllTimeDEC.cxx	2018-04-19 17:25:17.895800480 +0200
@@ -82,7 +82,7 @@
     strstream << "usage :" << endl
               << "mpirun -np <nbprocs> test_AllToAllTimeDEC" << endl
               << " (nbprocs >=2)" << endl
-              << "test must be runned with more than 1 proc and less than 12 procs"
+              << "test must be run with more than 1 proc and less than 12 procs"
               << endl ;
     cerr << strstream.str() << endl ;
     CPPUNIT_FAIL( strstream.str() ) ;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllvDEC.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllvDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllvDEC.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllvDEC.cxx	2018-04-19 17:25:17.875800084 +0200
@@ -81,7 +81,7 @@
     strstream << "usage :" << endl
               << "mpirun -np <nbprocs> test_AllToAllvDEC" << endl
               << " (nbprocs >=2)" << endl
-              << "test must be runned with more than 1 proc and less than 12 procs"
+              << "test must be run with more than 1 proc and less than 12 procs"
               << endl ;
     cerr << strstream.str() << endl ;
     CPPUNIT_FAIL( strstream.str() ) ;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllvTimeDEC.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllvTimeDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllvTimeDEC.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllvTimeDEC.cxx	2018-04-19 17:25:17.909800757 +0200
@@ -86,7 +86,7 @@
     strstream << "usage :" << endl
               << "mpirun -np <nbprocs> test_AllToAllTimeDEC" << endl
               << " (nbprocs >=2)" << endl
-              << "test must be runned with more than 1 proc and less than 12 procs"
+              << "test must be run with more than 1 proc and less than 12 procs"
               << endl ;
     cerr << strstream.str() << endl ;
     CPPUNIT_FAIL( strstream.str() ) ;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllvTimeDoubleDEC.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllvTimeDoubleDEC.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_AllToAllvTimeDoubleDEC.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_AllToAllvTimeDoubleDEC.cxx	2018-04-19 17:25:17.887800322 +0200
@@ -84,7 +84,7 @@
     strstream << "usage :" << endl
               << "mpirun -np <nbprocs> test_AllToAllTimeDEC" << endl
               << " (nbprocs >=2)" << endl
-              << "test must be runned with more than 1 proc and less than 12 procs"
+              << "test must be run with more than 1 proc and less than 12 procs"
               << endl ;
     cerr << strstream.str() << endl ;
     CPPUNIT_FAIL( strstream.str() ) ;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Cancel.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Cancel.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Cancel.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Cancel.cxx	2018-04-19 17:25:17.880800183 +0200
@@ -58,7 +58,7 @@
 
   if ( size < 2 ) {
     ostringstream strstream ;
-    strstream << "test_MPI_Access_Cancel must be runned with 2 procs" << endl ;
+    strstream << "test_MPI_Access_Cancel must be run with 2 procs" << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
     return;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_ISend_IRecv.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_ISend_IRecv.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_ISend_IRecv.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_ISend_IRecv.cxx	2018-04-19 17:25:17.878800144 +0200
@@ -52,8 +52,8 @@
   MPI_Comm_rank(MPI_COMM_WORLD,&myrank) ;
 
   if ( size < 3 ) {
-      cerr << "test_MPI_Access_Cyclic_ISend_IRecv must be runned with 3 procs" << endl ;
-    //CPPUNIT_FAIL("test_MPI_Access_Cyclic_ISend_IRecv must be runned with 3 procs") ;
+      cerr << "test_MPI_Access_Cyclic_ISend_IRecv must be run with 3 procs" << endl ;
+    //CPPUNIT_FAIL("test_MPI_Access_Cyclic_ISend_IRecv must be run with 3 procs") ;
     return;
   }
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_Send_Recv.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_Send_Recv.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_Send_Recv.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Cyclic_Send_Recv.cxx	2018-04-19 17:25:17.870799986 +0200
@@ -51,8 +51,8 @@
   MPI_Comm_rank(MPI_COMM_WORLD,&myrank) ;
 
   if ( size < 3 ) {
-      cerr << "test_MPI_Access_Send_Recv must be runned with 3 procs" << endl ;
-    //CPPUNIT_FAIL("test_MPI_Access_Send_Recv must be runned with 3 procs") ;
+      cerr << "test_MPI_Access_Send_Recv must be run with 3 procs" << endl ;
+    //CPPUNIT_FAIL("test_MPI_Access_Send_Recv must be run with 3 procs") ;
     return;
   }
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_IProbe.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_IProbe.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_IProbe.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_IProbe.cxx	2018-04-19 17:25:17.909800757 +0200
@@ -58,7 +58,7 @@
 
   if ( size < 2 ) {
     ostringstream strstream ;
-    strstream << "test_MPI_Access_IProbe must be runned with 2 procs" << endl ;
+    strstream << "test_MPI_Access_IProbe must be run with 2 procs" << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
     return;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_BottleNeck.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_BottleNeck.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_BottleNeck.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_BottleNeck.cxx	2018-04-19 17:25:17.916800895 +0200
@@ -54,7 +54,7 @@
 
   if ( size < 2 ) {
     ostringstream strstream ;
-    strstream << "test_MPI_Access_ISend_IRecv_BottleNeck must be runned with 2 procs"
+    strstream << "test_MPI_Access_ISend_IRecv_BottleNeck must be run with 2 procs"
               << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv.cxx	2018-04-19 17:25:17.877800124 +0200
@@ -52,8 +52,8 @@
   MPI_Comm_rank(MPI_COMM_WORLD,&myrank) ;
 
   if ( size < 2 ) {
-      cerr << "test_MPI_Access_ISend_IRecv must be runned with 2 procs" << endl ;
-    //CPPUNIT_FAIL("test_MPI_Access_ISend_IRecv must be runned with 2 procs") ;
+      cerr << "test_MPI_Access_ISend_IRecv must be run with 2 procs" << endl ;
+    //CPPUNIT_FAIL("test_MPI_Access_ISend_IRecv must be run with 2 procs") ;
     return;
   }
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length_1.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length_1.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length_1.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length_1.cxx	2018-04-19 17:25:17.882800223 +0200
@@ -51,7 +51,7 @@
 
   if ( size < 2 ) {
     ostringstream strstream ;
-    strstream << "test_MPI_Access_ISend_IRecv_Length_1 must be runned with 2 procs" << endl ;
+    strstream << "test_MPI_Access_ISend_IRecv_Length_1 must be run with 2 procs" << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
     return;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISend_IRecv_Length.cxx	2018-04-19 17:25:17.874800065 +0200
@@ -53,7 +53,7 @@
 
   if ( size < 2 ) {
     ostringstream strstream ;
-    strstream << "test_MPI_Access_ISend_IRecv_Length must be runned with 2 procs" << endl ;
+    strstream << "test_MPI_Access_ISend_IRecv_Length must be run with 2 procs" << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
     return;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISendRecv.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISendRecv.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_ISendRecv.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_ISendRecv.cxx	2018-04-19 17:25:17.888800342 +0200
@@ -52,8 +52,8 @@
   MPI_Comm_rank(MPI_COMM_WORLD,&myrank) ;
 
   if ( size < 2 ) {
-      cerr << "test_MPI_Access_ISendRecv must be runned with 2 procs" << endl ;
-    //CPPUNIT_FAIL("test_MPI_Access_ISendRecv must be runned with 2 procs") ;
+      cerr << "test_MPI_Access_ISendRecv must be run with 2 procs" << endl ;
+    //CPPUNIT_FAIL("test_MPI_Access_ISendRecv must be run with 2 procs") ;
     return;
   }
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Probe.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Probe.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Probe.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Probe.cxx	2018-04-19 17:25:17.913800836 +0200
@@ -52,8 +52,8 @@
   MPI_Comm_rank(MPI_COMM_WORLD,&myrank) ;
 
   if ( size < 2 ) {
-      cerr << "test_MPI_Access_Probe must be runned with 2 procs" << endl ;
-    //CPPUNIT_FAIL("test_MPI_Access_Probe must be runned with 2 procs") ;
+      cerr << "test_MPI_Access_Probe must be run with 2 procs" << endl ;
+    //CPPUNIT_FAIL("test_MPI_Access_Probe must be run with 2 procs") ;
     return;
   }
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv.cxx	2018-04-19 17:25:17.868799946 +0200
@@ -50,8 +50,8 @@
   MPI_Comm_rank(MPI_COMM_WORLD,&myrank) ;
 
   if ( size < 2 ) {
-    cerr << "test_MPI_Access_Send_Recv must be runned with 2 procs" << endl ;
-    //CPPUNIT_FAIL("test_MPI_Access_Send_Recv must be runned with 2 procs") ;
+    cerr << "test_MPI_Access_Send_Recv must be run with 2 procs" << endl ;
+    //CPPUNIT_FAIL("test_MPI_Access_Send_Recv must be run with 2 procs") ;
     return;
   }
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_SendRecv.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_SendRecv.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_SendRecv.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_SendRecv.cxx	2018-04-19 17:25:17.897800519 +0200
@@ -52,8 +52,8 @@
   MPI_Comm_rank(MPI_COMM_WORLD,&myrank) ;
 
   if ( size < 2 ) {
-      cerr << "MPIAccessTest::test_MPI_Access_SendRecv must be runned with 2 procs" << endl ;
-    //CPPUNIT_FAIL("test_MPI_Access_SendRecv must be runned with 2 procs") ;
+      cerr << "MPIAccessTest::test_MPI_Access_SendRecv must be run with 2 procs" << endl ;
+    //CPPUNIT_FAIL("test_MPI_Access_SendRecv must be run with 2 procs") ;
     return;
   }
 
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv_Length.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv_Length.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv_Length.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Send_Recv_Length.cxx	2018-04-19 17:25:17.881800203 +0200
@@ -53,7 +53,7 @@
 
   if ( size < 2 ) {
     ostringstream strstream ;
-    strstream << "test_MPI_Access_Send_Recv_Length must be runned with 2 procs" << endl ;
+    strstream << "test_MPI_Access_Send_Recv_Length must be run with 2 procs" << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
     return;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Time_0.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Time_0.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Time_0.cxx	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Time_0.cxx	2018-04-19 17:25:17.906800697 +0200
@@ -74,7 +74,7 @@
     strstream << "usage :" << endl
               << "mpirun -np <nbprocs> test_MPI_Access_Time_0" <<endl
               << " nbprocs =2" << endl
-              << "test must be runned with 2 procs" << endl ;
+              << "test must be run with 2 procs" << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
     return;
diff -Naur MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Time.cxx MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Time.cxx
--- MEDCOUPLING_old/src/ParaMEDMEMTest/test_MPI_Access_Time.cxx	2018-04-19 17:04:36.799223959 +0200
+++ MEDCOUPLING_new/src/ParaMEDMEMTest/test_MPI_Access_Time.cxx	2018-04-19 17:25:17.903800638 +0200
@@ -53,7 +53,7 @@
 
   if ( size < 2 ) {
     ostringstream strstream ;
-    strstream << "test_MPI_Access_Time must be runned with 2 procs" << endl ;
+    strstream << "test_MPI_Access_Time must be run with 2 procs" << endl ;
     cerr << strstream.str() << endl ;
     //CPPUNIT_FAIL( strstream.str() ) ;
     return;
diff -Naur MEDCOUPLING_old/src/PyWrapping/CMakeLists.txt MEDCOUPLING_new/src/PyWrapping/CMakeLists.txt
--- MEDCOUPLING_old/src/PyWrapping/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/PyWrapping/CMakeLists.txt	2018-04-19 17:25:17.668795993 +0200
@@ -0,0 +1,109 @@
+# Copyright (C) 2017  CEA/DEN, EDF R&D
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+# See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+# Author : Anthony Geay (EDF R&D)
+
+FIND_PACKAGE(SWIG REQUIRED)
+INCLUDE(${SWIG_USE_FILE})
+
+ADD_DEFINITIONS(${PYTHON_DEFINITIONS} ${NUMPY_DEFINITIONS} ${SCIPY_DEFINITIONS})
+
+SET_SOURCE_FILES_PROPERTIES(medcoupling.i PROPERTIES CPLUSPLUS ON)
+IF ("${PYTHON_VERSION_MAJOR}" STREQUAL "3")
+  SET_SOURCE_FILES_PROPERTIES(medcoupling.i PROPERTIES SWIG_FLAGS "-py3")
+ELSE()
+  SET_SOURCE_FILES_PROPERTIES(medcoupling.i PROPERTIES SWIG_DEFINITIONS "-shadow")
+ENDIF()
+SET(SWIG_MODULE_medcoupling_EXTRA_FLAGS "${NUMPY_DEFINITIONS};${SCIPY_DEFINITIONS}")
+
+SET(medcoupling_SWIG_DPYS_FILES medcoupling.i)
+
+INCLUDE_DIRECTORIES(
+  ${PYTHON_INCLUDE_DIRS}
+  ${NUMPY_INCLUDE_DIR}
+  ${MEDFILE_INCLUDE_DIRS}
+  ${HDF5_INCLUDE_DIRS}
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDLoader
+  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDLoader/Swig
+  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDCoupling_Swig
+  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDCoupling
+  ${CMAKE_CURRENT_SOURCE_DIR}/../INTERP_KERNEL
+  ${CMAKE_CURRENT_SOURCE_DIR}/../INTERP_KERNEL/Bases
+  ${CMAKE_CURRENT_SOURCE_DIR}/../INTERP_KERNEL/Geometric2D
+  ${CMAKE_CURRENT_SOURCE_DIR}/../INTERP_KERNEL/ExprEval
+  ${CMAKE_CURRENT_SOURCE_DIR}/../INTERP_KERNEL/GaussPoints
+  ${CMAKE_CURRENT_SOURCE_DIR}/../RENUMBER
+  ${CMAKE_CURRENT_SOURCE_DIR}/../RENUMBER_Swig
+  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDPartitioner
+  ${CMAKE_CURRENT_SOURCE_DIR}/../MEDPartitioner_Swig
+  ${CMAKE_CURRENT_SOURCE_DIR}/../ICoCo
+  ${CMAKE_CURRENT_SOURCE_DIR}/../ParaMEDMEM
+  ${CMAKE_CURRENT_SOURCE_DIR}/../ParaMEDMEM_Swig
+  ${PROJECT_BINARY_DIR}/doc
+  )
+
+SET(medcoupling_LIB_dependancies ${PYTHON_LIBRARIES} ${PLATFORM_LIBS} medcouplingremapper)
+
+IF(NOT MEDCOUPLING_MICROMED)
+  LIST(APPEND SWIG_MODULE_medcoupling_EXTRA_FLAGS -DWITH_MED_FILE)
+  LIST(APPEND medcoupling_LIB_dependancies medloader)
+
+  IF(MEDCOUPLING_ENABLE_RENUMBER)
+    LIST(APPEND SWIG_MODULE_medcoupling_EXTRA_FLAGS -DWITH_RENUMBER)
+    LIST(APPEND medcoupling_LIB_dependancies renumbercpp)
+  ENDIF(MEDCOUPLING_ENABLE_RENUMBER)
+  
+  IF(MEDCOUPLING_ENABLE_PARTITIONER)
+    LIST(APPEND SWIG_MODULE_medcoupling_EXTRA_FLAGS -DWITH_PARTITIONER)
+    LIST(APPEND medcoupling_LIB_dependancies medpartitionercpp)
+  ENDIF(MEDCOUPLING_ENABLE_PARTITIONER)
+ENDIF(NOT MEDCOUPLING_MICROMED)
+
+IF(MEDCOUPLING_USE_MPI)
+  INCLUDE_DIRECTORIES(${MPI_INCLUDE_DIRS})
+  ADD_DEFINITIONS(${MPI_DEFINITIONS})
+  LIST(APPEND SWIG_MODULE_medcoupling_EXTRA_FLAGS -DWITH_PARALLEL_INTERPOLATOR)
+  LIST(APPEND medcoupling_LIB_dependancies paramedmem)
+ENDIF(MEDCOUPLING_USE_MPI)
+
+SWIG_ADD_MODULE(medcoupling python medcoupling.i)
+SWIG_LINK_LIBRARIES(medcoupling ${medcoupling_LIB_dependancies})
+SWIG_CHECK_GENERATION(medcoupling)
+IF(WIN32)
+  SET_TARGET_PROPERTIES(_medcoupling PROPERTIES DEBUG_OUTPUT_NAME _medcoupling_d)
+ENDIF(WIN32)
+
+INSTALL(TARGETS _medcoupling DESTINATION ${MEDCOUPLING_INSTALL_PYTHON})
+INSTALL(FILES medcoupling.i medcoupling_pycode DESTINATION ${MEDCOUPLING_INSTALL_HEADERS})
+SALOME_INSTALL_SCRIPTS(${CMAKE_CURRENT_BINARY_DIR}/medcoupling.py ${MEDCOUPLING_INSTALL_PYTHON})
+
+INCLUDE(tests.set)
+SALOME_GENERATE_TESTS_ENVIRONMENT(tests_env)
+
+FOREACH(test ${BASE_TESTS})
+  GET_FILENAME_COMPONENT(testname ${test} NAME_WE)
+  ADD_TEST(NAME ${testname} COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/${test})
+  SET_TESTS_PROPERTIES(${testname} PROPERTIES ENVIRONMENT "${tests_env}")
+ENDFOREACH()
+
+SET(TEST_INSTALL_DIRECTORY ${MEDCOUPLING_INSTALL_TESTS}/PyWrapping)
+
+INSTALL(FILES CTestTestfileInstall.cmake DESTINATION ${TEST_INSTALL_DIRECTORY} RENAME CTestTestfile.cmake)
+INSTALL(FILES ${BASE_TESTS} DESTINATION ${TEST_INSTALL_DIRECTORY})
+INSTALL(FILES tests.set DESTINATION ${TEST_INSTALL_DIRECTORY})
diff -Naur MEDCOUPLING_old/src/PyWrapping/CTestTestfileInstall.cmake MEDCOUPLING_new/src/PyWrapping/CTestTestfileInstall.cmake
--- MEDCOUPLING_old/src/PyWrapping/CTestTestfileInstall.cmake	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/PyWrapping/CTestTestfileInstall.cmake	2018-04-19 17:25:17.672796072 +0200
@@ -0,0 +1,27 @@
+# Copyright (C) 2017  CEA/DEN, EDF R&D
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+# See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+
+INCLUDE(tests.set)
+
+FOREACH(tfile ${BASE_TESTS})
+  GET_FILENAME_COMPONENT(BASE_NAME ${tfile} NAME_WE)
+  SET(TEST_NAME ${COMPONENT_NAME}_${BASE_NAME})
+  ADD_TEST(${TEST_NAME} python ${tfile})
+  SET_TESTS_PROPERTIES( ${TEST_NAME} PROPERTIES LABELS "${COMPONENT_NAME}" TIMEOUT ${TIMEOUT} )
+ENDFOREACH()
diff -Naur MEDCOUPLING_old/src/PyWrapping/medcoupling.i MEDCOUPLING_new/src/PyWrapping/medcoupling.i
--- MEDCOUPLING_old/src/PyWrapping/medcoupling.i	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/PyWrapping/medcoupling.i	2018-04-19 17:25:17.668795993 +0200
@@ -0,0 +1,254 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+
+// Author : Anthony Geay (EDF R&D)
+
+%module medcoupling
+
+#define MEDCOUPLINGREMAPPER_EXPORT
+#define INTERPKERNEL_EXPORT
+#define MEDCOUPLING_EXPORT
+#define MEDLOADER_EXPORT
+
+%include "MEDCouplingCommon.i"
+
+%include "MEDCouplingRemapperCommon.i"
+
+#ifdef WITH_MED_FILE
+%include "MEDLoaderCommon.i"
+#endif
+
+#ifdef WITH_RENUMBER
+%include "MEDRenumberImpl.i"
+#endif
+
+#ifdef WITH_PARTITIONER
+%include "MEDPartitionerCommon.i"
+#endif
+
+#ifdef WITH_PARALLEL_INTERPOLATOR
+%include "ParaMEDMEMCommon.i"
+#endif
+
+%{
+  static const char SEQ_INTERPOL_EXT[]="Sequential interpolator";
+  static const char MEDFILEIO_EXT[]="MED file I/O";
+  static const char RENUM_EXT[]="Renumberer";
+  static const char PART_EXT[]="Partitioner";
+  static const char PAR_INTERPOL_EXT[]="Parallel interpolator (SPMD paradigm)";
+  
+  static const char *EXTENSIONS[]={SEQ_INTERPOL_EXT,MEDFILEIO_EXT,RENUM_EXT,PART_EXT,PAR_INTERPOL_EXT};
+  static const int NB_OF_EXTENSIONS=sizeof(EXTENSIONS)/sizeof(const char *);
+%}
+
+%inline
+{
+  std::vector<std::string> AllPossibleExtensions()
+  {
+    std::vector<std::string> ret(EXTENSIONS,EXTENSIONS+NB_OF_EXTENSIONS);
+    return ret;
+  }
+
+  bool HasMEDFileExt()
+  {
+#ifdef WITH_MED_FILE
+    return true;
+#else
+    return false;
+#endif
+  }
+
+  bool HasRenumberExt()
+  {
+#ifdef WITH_RENUMBER
+    return true;
+#else
+    return false;
+#endif
+  }
+
+  bool HasPartitionerExt()
+  {
+#ifdef WITH_PARTITIONER
+    return true;
+#else
+    return false;
+#endif
+  }
+
+  bool HasScotchPartitionerAlg()
+  {
+#ifdef WITH_PARTITIONER
+    return MEDPartitioner::HasScotchAlg();
+#else
+    return false;
+#endif    
+  }
+
+  bool HasPTScotchPartitionerAlg()
+  {
+#ifdef WITH_PARTITIONER
+    return MEDPartitioner::HasPTScotchAlg();
+#else
+    return false;
+#endif    
+  }
+
+  bool HasMetisPartitionerAlg()
+  {
+#ifdef WITH_PARTITIONER
+    return MEDPartitioner::HasMetisAlg();
+#else
+    return false;
+#endif    
+  }
+  
+  bool HasParallelInterpolatorExt()
+  {
+#ifdef WITH_PARALLEL_INTERPOLATOR
+    return true;
+#else
+    return false;
+#endif
+  }
+  
+  std::vector<std::string> ActiveExtensions()
+  {
+    std::vector<std::string> ret;
+    ret.push_back(std::string(SEQ_INTERPOL_EXT));
+#ifdef WITH_MED_FILE
+    ret.push_back(std::string(MEDFILEIO_EXT));
+#endif
+#ifdef WITH_RENUMBER
+    ret.push_back(std::string(RENUM_EXT));
+#endif
+#ifdef WITH_PARTITIONER
+    ret.push_back(std::string(PART_EXT));
+#endif
+#ifdef WITH_PARALLEL_INTERPOLATOR
+    ret.push_back(std::string(PAR_INTERPOL_EXT));
+#endif
+    return ret;
+  }
+}
+
+%pythoncode %{
+def MEDCouplingDataArrayDoubleIadd(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDouble____iadd___(self, self, *args)
+def MEDCouplingDataArrayDoubleIsub(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDouble____isub___(self, self, *args)
+def MEDCouplingDataArrayDoubleImul(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDouble____imul___(self, self, *args)
+def MEDCouplingDataArrayDoubleIdiv(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDouble____idiv___(self, self, *args)
+def MEDCouplingDataArrayDoubleIpow(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDouble____ipow___(self, self, *args)
+def MEDCouplingFieldDoubleIadd(self,*args):
+    import _medcoupling
+    return _medcoupling.MEDCouplingFieldDouble____iadd___(self, self, *args)
+def MEDCouplingFieldDoubleIsub(self,*args):
+    import _medcoupling
+    return _medcoupling.MEDCouplingFieldDouble____isub___(self, self, *args)
+def MEDCouplingFieldDoubleImul(self,*args):
+    import _medcoupling
+    return _medcoupling.MEDCouplingFieldDouble____imul___(self, self, *args)
+def MEDCouplingFieldDoubleIdiv(self,*args):
+    import _medcoupling
+    return _medcoupling.MEDCouplingFieldDouble____idiv___(self, self, *args)
+def MEDCouplingFieldDoubleIpow(self,*args):
+    import _medcoupling
+    return _medcoupling.MEDCouplingFieldDouble____ipow___(self, self, *args)
+def MEDCouplingDataArrayIntIadd(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayInt____iadd___(self, self, *args)
+def MEDCouplingDataArrayIntIsub(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayInt____isub___(self, self, *args)
+def MEDCouplingDataArrayIntImul(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayInt____imul___(self, self, *args)
+def MEDCouplingDataArrayIntIdiv(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayInt____idiv___(self, self, *args)
+def MEDCouplingDataArrayIntImod(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayInt____imod___(self, self, *args)
+def MEDCouplingDataArrayIntIpow(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayInt____ipow___(self, self, *args)
+def MEDCouplingDataArrayFloatIadd(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayFloat____iadd___(self, self, *args)
+def MEDCouplingDataArrayFloatIsub(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayFloat____isub___(self, self, *args)
+def MEDCouplingDataArrayFloatImul(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayFloat____imul___(self, self, *args)
+def MEDCouplingDataArrayFloatIdiv(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayFloat____idiv___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleIadd(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDoubleTuple____iadd___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleIsub(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDoubleTuple____isub___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleImul(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDoubleTuple____imul___(self, self, *args)
+def MEDCouplingDataArrayDoubleTupleIdiv(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayDoubleTuple____idiv___(self, self, *args)
+def MEDCouplingDataArrayIntTupleIadd(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayIntTuple____iadd___(self, self, *args)
+def MEDCouplingDataArrayIntTupleIsub(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayIntTuple____isub___(self, self, *args)
+def MEDCouplingDataArrayIntTupleImul(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayIntTuple____imul___(self, self, *args)
+def MEDCouplingDataArrayIntTupleIdiv(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayIntTuple____idiv___(self, self, *args)
+def MEDCouplingDataArrayIntTupleImod(self,*args):
+    import _medcoupling
+    return _medcoupling.DataArrayIntTuple____imod___(self, self, *args)
+def MEDCouplingDenseMatrixIadd(self,*args):
+    import _medcoupling
+    return _medcoupling.DenseMatrix____iadd___(self, self, *args)
+def MEDCouplingDenseMatrixIsub(self,*args):
+    import _medcoupling
+    return _medcoupling.DenseMatrix____isub___(self, self, *args)
+%}
+
+%include "MEDCouplingFinalize.i"
+
+#ifdef WITH_MED_FILE
+%include "MEDLoaderFinalize.i"
+#endif
+
+%include "medcoupling_pycode"
+
diff -Naur MEDCOUPLING_old/src/PyWrapping/medcoupling_pycode MEDCOUPLING_new/src/PyWrapping/medcoupling_pycode
--- MEDCOUPLING_old/src/PyWrapping/medcoupling_pycode	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/PyWrapping/medcoupling_pycode	2018-04-19 17:25:17.670796032 +0200
@@ -0,0 +1,102 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+
+// Author : Anthony Geay (EDF R&D)
+
+%pythoncode %{
+
+def ExtensionsStr(sz=60):
+    tab=["No","Yes"]
+    isOK=[(elt,tab[int(elt in ActiveExtensions())]) for elt in AllPossibleExtensions()]
+    return "\n".join([a+" "+('{:.>%d}'%(sz-len(a)-1)).format(' %s'%b) for a,b in isOK])
+
+def ShowExtensions(sz=60):
+    print(ExtensionsStr(sz))
+    pass
+
+def AdvancedExtensionsStr(sz=60):
+    def SubExtension(allPossibilities,extensionsActivated,pad,tab, sts):
+        for elt2 in allPossibilities:
+            elt3="%s algorithm for %s"%(elt2,elt)
+            sts.append(pad+elt3+" "+('{:.>%d}'%(sz-len(pad)-len(elt3)-1)).format(' %s'%tab[int(elt2 in extensionsActivated)]))
+            pass
+        pass
+    pad="    "
+    tab=["No","Yes"]
+    aext=ActiveExtensions()
+    sts=[]
+    for elt in AllPossibleExtensions():
+        isOK=elt in aext
+        sts.append(elt+" "+('{:.>%d}'%(sz-len(elt)-1)).format(' %s'%tab[isOK]))
+        if not isOK:
+            continue
+        if "Renumb" in elt:
+            SubExtension(AllRenumberMethods(),RenumberAvailableMethods(),pad,tab, sts)
+            pass
+        if "Partit" in elt:
+            SubExtension(MEDPartitioner.AllAlgorithms(),MEDPartitioner.AvailableAlgorithms(),pad,tab, sts)
+            pass
+        pass
+    return "\n".join(sts)
+
+def ShowAdvancedExtensions(sz=60):
+    print(AdvancedExtensionsStr(sz))
+
+def MEDCouplingWriterHelper(mci,fileName,medFunc):
+    import os
+    fileWithoutExt,ext=os.path.splitext(fileName)
+    if ext in [".med",".rmed",""]:
+        outFileName=fileName
+        if ext=="":
+            outFileName=fileWithoutExt+".med"
+        if HasMEDFileExt():
+            medFunc(outFileName,mci,True)
+            pass
+        else:
+            raise InterpKernelException("Request for writing \"%s\" MED file, but MED file is not activated in your medcoupling !")
+        pass
+    elif ext[:3]==".vt" and len(ext)==4:
+        mci.writeVTK(fileName)
+    else:
+        raise InterpKernelException("The extension \"%s\" of input file \"%s\" is not recognized !"%(ext,fileName))
+    pass
+
+if HasMEDFileExt():
+    def MEDCouplingMesh_write(self,fileName):
+        MEDCouplingWriterHelper(self,fileName,WriteMesh)
+
+    def MEDCouplingField_write(self,fileName):
+        MEDCouplingWriterHelper(self,fileName,WriteField)
+
+    def MEDCouplingFieldT_copyTimeInfoFrom(self,mlf1ts):
+        assert(isinstance(mlf1ts,MEDFileAnyTypeField1TS))
+        a,b,c=mlf1ts.getTime()
+        self.setTime(c,a,b)
+        pass
+
+    MEDCouplingMesh.write=MEDCouplingMesh_write
+    del MEDCouplingMesh_write
+    MEDCouplingField.write=MEDCouplingField_write
+    del MEDCouplingField_write
+    MEDCouplingFieldDouble.copyTimeInfoFrom=MEDCouplingFieldT_copyTimeInfoFrom
+    MEDCouplingFieldInt.copyTimeInfoFrom=MEDCouplingFieldT_copyTimeInfoFrom
+    MEDCouplingFieldFloat.copyTimeInfoFrom=MEDCouplingFieldT_copyTimeInfoFrom
+    del MEDCouplingFieldT_copyTimeInfoFrom
+    pass
+%}
diff -Naur MEDCOUPLING_old/src/PyWrapping/TestPyWrapGathered_medcoupling.py MEDCOUPLING_new/src/PyWrapping/TestPyWrapGathered_medcoupling.py
--- MEDCOUPLING_old/src/PyWrapping/TestPyWrapGathered_medcoupling.py	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/PyWrapping/TestPyWrapGathered_medcoupling.py	2018-04-19 17:25:17.671796052 +0200
@@ -0,0 +1,155 @@
+#  -*- coding: iso-8859-1 -*-
+# Copyright (C) 2017  CEA/DEN, EDF R&D
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+# See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+# Author : Anthony Geay (EDF R&D)
+
+from medcoupling import *
+import unittest
+
+class FileCreator(object):
+    def __init__(self,tester,fname):
+        self._tester=tester
+        self._fname=fname
+        pass
+        
+    def fileName(self):
+        return self._fname
+    
+    def __enter__(self):
+        import os
+        if os.path.exists(self._fname):
+            os.remove(self._fname)
+            pass
+        return self
+    
+    def __exit__(self, type, value, traceback):
+        import os
+        if not os.path.exists(self._fname):
+            self._tester.assertTrue(False)
+            pass
+        else:
+            os.remove(self._fname)
+        pass
+        
+class medcouplingTest(unittest.TestCase):
+
+    def test0(self):
+        """ Unconditional test : medcoupling "kernel" classes """
+        f=MEDCouplingFieldDouble(ON_CELLS)
+        g=DataArrayDouble(10,2)
+        h=MEDCouplingUMesh("mesh",3)
+        hh=MEDCouplingRemapper()
+        ee=InterpKernelException("ee")
+        pass
+    
+    @unittest.skipUnless(HasMEDFileExt(),"Requires link to MED file")
+    def test1(self):
+        import sys
+        fname="mctest1.med"
+        arr=DataArrayDouble(10) ; arr.iota()
+        m=MEDCouplingCMesh()
+        m.setCoords(arr,arr)
+        m.setName("mesh")
+        with FileCreator(self,fname) as fc:
+            m.write(fc.fileName())
+        m=m.buildUnstructured()
+        with FileCreator(self,fname) as fc:
+            m.write(fc.fileName())
+        f=MEDCouplingFieldDouble(ON_NODES) ; f.setMesh(m) ; f.setArray(m.getCoords()) ; f.setName("field")
+        with FileCreator(self,fname) as fc:
+            f.write(fc.fileName())
+        f=MEDCouplingFieldFloat(ON_NODES) ; f.setMesh(m)
+        d=DataArrayFloat(m.getNumberOfNodes()) ; d.iota()
+        f.setArray(d) ; f.setName("field1")
+        with FileCreator(self,fname) as fc:
+            f.write(fc.fileName())
+        pass
+
+    @unittest.skipUnless(HasRenumberExt(),"Requires Boost or Metis to activate Renumberer")
+    def test2(self):
+        arr=DataArrayDouble(10) ; arr.iota()
+        m=MEDCouplingCMesh() ; m.setCoords(arr,arr)
+        m=m.buildUnstructured() ; m.setName("mesh")
+        #
+        renf=RenumberingFactory("Boost")
+        neigh,neighi=m.computeNeighborsOfCells()
+        n2o,o2n=renf.renumber(neigh,neighi)
+        mRenum=m[n2o]
+        pass
+
+    @unittest.skipUnless(HasPartitionerExt(),"Requires Partitioner activation")
+    def test3(self):
+        for alg in MEDPartitioner.AvailableAlgorithms():
+            st="Graph.%s"%alg.upper()
+            print(st)
+            self.partitionerTesterHelper(eval(st))
+            pass
+        pass
+    
+    @unittest.skipUnless(HasParallelInterpolatorExt(),"Requires // interpolator activated")
+    def test4(self):
+        interface=CommInterface()
+        pass
+
+    @unittest.skipUnless(HasMEDFileExt(),"Requires link to MED file")
+    def test5(self):
+        f=MEDCouplingFieldDouble(ON_NODES)
+        f.setTime(1.25,3,6)
+        a,b,c=f.getTime()
+        self.assertEqual(b,3) ; self.assertEqual(c,6) ; self.assertAlmostEqual(a,1.25,14);
+        f1ts=MEDFileField1TS()
+        f1ts.setTime(10,13,10.75)
+        f.copyTimeInfoFrom(f1ts)
+        a,b,c=f.getTime()
+        self.assertEqual(b,10) ; self.assertEqual(c,13) ; self.assertAlmostEqual(a,10.75,14);
+        f2=MEDCouplingFieldInt(ON_NODES)
+        f2.copyTimeInfoFrom(f1ts)
+        a,b,c=f2.getTime()
+        self.assertEqual(b,10) ; self.assertEqual(c,13) ; self.assertAlmostEqual(a,10.75,14);
+        f3=MEDCouplingFieldFloat(ON_NODES)
+        f3.copyTimeInfoFrom(f1ts)
+        a,b,c=f3.getTime()
+        self.assertEqual(b,10) ; self.assertEqual(c,13) ; self.assertAlmostEqual(a,10.75,14);
+        pass
+        
+
+    def partitionerTesterHelper(self,algoSelected):
+        arr=DataArrayDouble(10) ; arr.iota()
+        m=MEDCouplingCMesh() ; m.setCoords(arr,arr)
+        m=m.buildUnstructured() ; m.setName("mesh")
+        a,b=m.computeNeighborsOfCells()
+        sk=MEDCouplingSkyLineArray(b,a)
+        g=MEDPartitioner.Graph(sk,algoSelected)
+        g.partGraph(4)
+        procIdOnCells=g.getPartition().getValuesArray()
+        m0=m[procIdOnCells.findIdsEqual(0)] ; m0.setName("m0")
+        pass
+    
+    pass
+
+if __name__ == "__main__":
+    if HasParallelInterpolatorExt():
+        try:
+            from mpi4py import MPI # if not imported test3 may failed due to MPI call of partitioner algorithms.
+        except:
+            pass
+        pass
+    unittest.main()
+    pass
+
diff -Naur MEDCOUPLING_old/src/PyWrapping/tests.set MEDCOUPLING_new/src/PyWrapping/tests.set
--- MEDCOUPLING_old/src/PyWrapping/tests.set	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/PyWrapping/tests.set	2018-04-19 17:25:17.669796013 +0200
@@ -0,0 +1,21 @@
+# Copyright (C) 2017  CEA/DEN, EDF R&D
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+# See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+# Author : Anthony Geay (EDF R&D)
+
+SET(BASE_TESTS TestPyWrapGathered_medcoupling.py)
\ Pas de fin de ligne à la fin du fichier
diff -Naur MEDCOUPLING_old/src/RENUMBER/RenumberingFactory.cxx MEDCOUPLING_new/src/RENUMBER/RenumberingFactory.cxx
--- MEDCOUPLING_old/src/RENUMBER/RenumberingFactory.cxx	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/RENUMBER/RenumberingFactory.cxx	2018-04-19 17:25:18.149805501 +0200
@@ -27,20 +27,27 @@
 #endif
 
 #include <iostream>
-
-using namespace std;
+#include <algorithm>
 
 namespace MED_RENUMBER
 {
-  Renumbering* RenumberingFactory(const string &s)
+  bool CompareRenumMeth(const std::string& s1, const char *s2)
+  {
+    std::string ss1(s1),ss2(s2);
+    std::transform(ss1.begin(), ss1.end(), ss1.begin(), ::tolower);
+    std::transform(ss2.begin(), ss2.end(), ss2.begin(), ::tolower);
+    return ss1==ss2;
+  }
+  
+  Renumbering* RenumberingFactory(const std::string &s)
   {
 #ifdef MED_ENABLE_METIS
 #ifdef ENABLE_BOOST
-    if (s=="METIS")
+    if ( CompareRenumMeth(s,METIS_ALG) )
       {
         return new METISRenumbering;
       }
-    else if(s=="BOOST")
+    else if( CompareRenumMeth(s,BOOST_ALG) )
       {
         return new BOOSTRenumbering;
       }
@@ -51,7 +58,7 @@
       }
 #endif
 #ifndef ENABLE_BOOST
-    if (s=="METIS")
+    if ( CompareRenumMeth(s,METIS_ALG) )
       {
         return new METISRenumbering;
       }
@@ -64,7 +71,7 @@
 #endif
 #ifndef MED_ENABLE_METIS
 #ifdef ENABLE_BOOST
-    if (s=="BOOST")
+    if ( CompareRenumMeth(s,BOOST_ALG) )
       {
         return new BOOSTRenumbering;
       }
@@ -80,4 +87,24 @@
 #endif
 #endif
   }
+
+  std::vector<std::string> AllRenumberMethods()
+  {
+    std::vector<std::string> ret;
+    ret.push_back(std::string(BOOST_ALG));
+    ret.push_back(std::string(METIS_ALG));
+    return ret;
+  }
+  
+  std::vector<std::string> RenumberAvailableMethods()
+  {
+    std::vector<std::string> ret;
+#ifdef ENABLE_BOOST
+    ret.push_back(std::string(BOOST_ALG));
+#endif
+#ifdef MED_ENABLE_METIS
+    ret.push_back(std::string(METIS_ALG));
+#endif
+    return ret;
+  }
 }
diff -Naur MEDCOUPLING_old/src/RENUMBER/RenumberingFactory.hxx MEDCOUPLING_new/src/RENUMBER/RenumberingFactory.hxx
--- MEDCOUPLING_old/src/RENUMBER/RenumberingFactory.hxx	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/RENUMBER/RenumberingFactory.hxx	2018-04-19 17:25:18.150805520 +0200
@@ -28,6 +28,10 @@
 namespace MED_RENUMBER
 {
   RENUMBER_EXPORT Renumbering* RenumberingFactory(const std::string& s);
+  RENUMBER_EXPORT std::vector<std::string> RenumberAvailableMethods();
+  RENUMBER_EXPORT std::vector<std::string> AllRenumberMethods();
+  const char METIS_ALG[]="Metis";
+  const char BOOST_ALG[]="Boost";
 }
 
 #endif /*RENUMBERINGFACTORY_HXX_*/
diff -Naur MEDCOUPLING_old/src/RENUMBER_Swig/CMakeLists.txt MEDCOUPLING_new/src/RENUMBER_Swig/CMakeLists.txt
--- MEDCOUPLING_old/src/RENUMBER_Swig/CMakeLists.txt	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/RENUMBER_Swig/CMakeLists.txt	2018-04-19 17:25:18.157805659 +0200
@@ -29,20 +29,13 @@
 ENDIF()
 SET(SWIG_MODULE_MEDRenumber_EXTRA_FLAGS "${NUMPY_DEFINITIONS};${SCIPY_DEFINITIONS};-DWITHOUT_AUTOFIELD")
 
-IF(Boost_FOUND)
-  SET(SWIG_MODULE_MEDRenumber_EXTRA_FLAGS -DHAS_BOOST ${SWIG_MODULE_MEDRenumber_EXTRA_FLAGS})
-ENDIF(Boost_FOUND)
-
-IF(METIS_FOUND)
-  SET(SWIG_MODULE_MEDRenumber_EXTRA_FLAGS -DHAS_METIS ${SWIG_MODULE_MEDRenumber_EXTRA_FLAGS})
-ENDIF(METIS_FOUND)
-
 SET (MEDRenumber_SWIG_DPYS_FILES
-    MEDRenumberCommon.i)
+  MEDRenumberCommon.i
+  MEDRenumberImpl.i)
 
 INCLUDE_DIRECTORIES(
   ${PYTHON_INCLUDE_DIRS}
-  ${PTHREAD_INCLUDE_DIR} # pthread dependancy due to python2.7 library
+  ${PTHREAD_INCLUDE_DIR} # pthread dependency due to python2.7 library
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${NUMPY_INCLUDE_DIR}
   ${CMAKE_CURRENT_BINARY_DIR}
@@ -67,7 +60,7 @@
 
 SALOME_INSTALL_SCRIPTS(${CMAKE_CURRENT_BINARY_DIR}/MEDRenumber.py ${MEDCOUPLING_INSTALL_PYTHON})
 
-INSTALL(FILES MEDRenumber.i MEDRenumberCommon.i DESTINATION ${MEDCOUPLING_INSTALL_HEADERS})
+INSTALL(FILES MEDRenumber.i MEDRenumberCommon.i MEDRenumberImpl.i DESTINATION ${MEDCOUPLING_INSTALL_HEADERS})
 INSTALL(FILES MEDRenumberTest.py DESTINATION ${MEDCOUPLING_INSTALL_SCRIPT_PYTHON})
 
 SALOME_ACCUMULATE_ENVIRONMENT(PYTHONPATH ${CMAKE_CURRENT_BINARY_DIR}/../MEDCoupling_Swig)
diff -Naur MEDCOUPLING_old/src/RENUMBER_Swig/MEDRenumberCommon.i MEDCOUPLING_new/src/RENUMBER_Swig/MEDRenumberCommon.i
--- MEDCOUPLING_old/src/RENUMBER_Swig/MEDRenumberCommon.i	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/RENUMBER_Swig/MEDRenumberCommon.i	2018-04-19 17:25:18.159805698 +0200
@@ -18,8 +18,6 @@
 //
 // Author : Anthony Geay (CEA/DEN)
 
-%module MEDRenumber
-
 %include std_vector.i
 %include std_string.i
 
@@ -28,12 +26,8 @@
 #include "MCAuto.hxx"
 #include "MEDCouplingDataArrayTypemaps.i"
 
-#include "RenumberingFactory.hxx"
-#include "RENUMBER_Renumbering.hxx"
-
 using namespace MEDCoupling;
 using namespace INTERP_KERNEL;
- using namespace MED_RENUMBER;
 %}
 
 %template(ivec) std::vector<int>;
@@ -49,8 +43,6 @@
 %feature("autodoc", "1");
 %feature("docstring");
 
-%newobject MED_RENUMBER::RenumberingFactory;
-
 %nodefaultctor;
 
 %rename (InterpKernelException) INTERP_KERNEL::Exception;
@@ -66,47 +58,7 @@
   }
 %}
 
-class Renumbering
-{
-public:
-  %extend
-  {
-    virtual PyObject *renumber(const MEDCoupling::DataArrayInt *graph, const MEDCoupling::DataArrayInt *index_graph) throw(INTERP_KERNEL::Exception)
-    {
-      if(!graph || !index_graph)
-        throw INTERP_KERNEL::Exception("wrap of Renumbering::renumber : One of the input arrays is NULL !");
-      if(!graph->isAllocated() || !index_graph->isAllocated())
-        throw INTERP_KERNEL::Exception("wrap of Renumbering::renumber : One of the input arrays is not allocated !");
-      MEDCoupling::DataArrayInt *out0(0),*out1(0);
-      self->renumber(graph->begin(),index_graph->begin(),index_graph->getNumberOfTuples()-1,out0,out1);
-      PyObject *ret=PyTuple_New(2);
-      PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(out0),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
-      PyTuple_SetItem(ret,1,SWIG_NewPointerObj(SWIG_as_voidptr(out1),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
-      return ret;
-    }
-  }
-  virtual ~Renumbering();
-};
-
-namespace MED_RENUMBER
-{
-  Renumbering *RenumberingFactory(const std::string& s) throw(INTERP_KERNEL::Exception);
-}
-
-%inline
-{
-  std::vector<std::string> RenumberAvailableMethods()throw(INTERP_KERNEL::Exception)
-  {
-    std::vector<std::string> ret;
-#ifdef HAS_BOOST
-    ret.push_back(std::string("BOOST"));
-#endif
-#ifdef HAS_METIS
-    ret.push_back(std::string("METIS"));
-#endif
-    return ret;
-  }
-}
+%include "MEDRenumberImpl.i"
 
 %pythoncode %{
 import os
diff -Naur MEDCOUPLING_old/src/RENUMBER_Swig/MEDRenumber.i MEDCOUPLING_new/src/RENUMBER_Swig/MEDRenumber.i
--- MEDCOUPLING_old/src/RENUMBER_Swig/MEDRenumber.i	2018-04-19 17:04:36.800223979 +0200
+++ MEDCOUPLING_new/src/RENUMBER_Swig/MEDRenumber.i	2018-04-19 17:25:18.156805639 +0200
@@ -17,12 +17,11 @@
 // See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
 //
 
+%module MEDRenumber
+
 %include "MEDRenumberCommon.i"
 
 %pythoncode %{
-def MEDCouplingDataArrayDoublenew(cls,*args):
-    import _MEDRenumber
-    return _MEDRenumber.DataArrayDouble____new___(cls,args)
 def MEDCouplingDataArrayDoubleIadd(self,*args):
     import _MEDRenumber
     return _MEDRenumber.DataArrayDouble____iadd___(self, self, *args)
@@ -38,9 +37,6 @@
 def MEDCouplingDataArrayDoubleIpow(self,*args):
     import _MEDRenumber
     return _MEDRenumber.DataArrayDouble____ipow___(self, self, *args)
-def MEDCouplingDataArrayIntnew(cls,*args):
-    import _MEDRenumber
-    return _MEDRenumber.DataArrayInt____new___(cls,args)
 def MEDCouplingDataArrayIntIadd(self,*args):
     import _MEDRenumber
     return _MEDRenumber.DataArrayInt____iadd___(self, self, *args)
@@ -59,12 +55,6 @@
 def MEDCouplingDataArrayIntIpow(self,*args):
     import _MEDRenumber
     return _MEDRenumber.DataArrayInt____ipow___(self, self, *args)
-def MEDCouplingDataArrayBytenew(cls,*args):
-    import _MEDRenumber
-    return _MEDRenumber.DataArrayByte____new___(cls,args)
-def MEDCouplingDataArrayFloatnew(cls,*args):
-    import _MEDRenumber
-    return _MEDRenumber.DataArrayFloat____new___(cls,args)
 def MEDCouplingDataArrayFloatIadd(self,*args):
     import _MEDRenumber
     return _MEDRenumber.DataArrayFloat____iadd___(self, self, *args)
@@ -109,14 +99,14 @@
 
 %pythoncode %{
 InterpKernelException.__reduce__=INTERPKERNELExceptionReduce
-DataArrayDouble.__new__=classmethod(MEDCouplingDataArrayDoublenew)
+DataArrayDouble.__reduce__=MEDCouplingDataArrayDoubleReduce
 DataArrayDouble.__iadd__=MEDCouplingDataArrayDoubleIadd
 DataArrayDouble.__isub__=MEDCouplingDataArrayDoubleIsub
 DataArrayDouble.__imul__=MEDCouplingDataArrayDoubleImul
 DataArrayDouble.__idiv__=MEDCouplingDataArrayDoubleIdiv
 DataArrayDouble.__ipow__=MEDCouplingDataArrayDoubleIpow
 
-DataArrayInt.__new__=classmethod(MEDCouplingDataArrayIntnew)
+DataArrayInt.__reduce__=MEDCouplingDataArrayIntReduce
 DataArrayInt.__iadd__=MEDCouplingDataArrayIntIadd
 DataArrayInt.__isub__=MEDCouplingDataArrayIntIsub
 DataArrayInt.__imul__=MEDCouplingDataArrayIntImul
@@ -136,12 +126,12 @@
 DataArrayIntTuple.__imod__=MEDCouplingDataArrayIntTupleImod
 
 del INTERPKERNELExceptionReduce
-del MEDCouplingDataArrayDoublenew
+del MEDCouplingDataArrayDoubleReduce
+del MEDCouplingDataArrayIntReduce
 del MEDCouplingDataArrayDoubleIadd
 del MEDCouplingDataArrayDoubleIsub
 del MEDCouplingDataArrayDoubleImul
 del MEDCouplingDataArrayDoubleIdiv
-del MEDCouplingDataArrayIntnew
 del MEDCouplingDataArrayIntIadd
 del MEDCouplingDataArrayIntIsub
 del MEDCouplingDataArrayIntImul
diff -Naur MEDCOUPLING_old/src/RENUMBER_Swig/MEDRenumberImpl.i MEDCOUPLING_new/src/RENUMBER_Swig/MEDRenumberImpl.i
--- MEDCOUPLING_old/src/RENUMBER_Swig/MEDRenumberImpl.i	1970-01-01 01:00:00.000000000 +0100
+++ MEDCOUPLING_new/src/RENUMBER_Swig/MEDRenumberImpl.i	2018-04-19 17:25:18.161805738 +0200
@@ -0,0 +1,57 @@
+// Copyright (C) 2017  CEA/DEN, EDF R&D
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+//
+// Author : Anthony Geay (EDF R&D)
+
+%{
+#include "RenumberingFactory.hxx"
+#include "RENUMBER_Renumbering.hxx"
+  
+using namespace MED_RENUMBER;
+%}
+
+%newobject MED_RENUMBER::RenumberingFactory;
+
+class Renumbering
+{
+public:
+  %extend
+  {
+    virtual PyObject *renumber(const MEDCoupling::DataArrayInt *graph, const MEDCoupling::DataArrayInt *index_graph) throw(INTERP_KERNEL::Exception)
+    {
+      if(!graph || !index_graph)
+        throw INTERP_KERNEL::Exception("wrap of Renumbering::renumber : One of the input arrays is NULL !");
+      if(!graph->isAllocated() || !index_graph->isAllocated())
+        throw INTERP_KERNEL::Exception("wrap of Renumbering::renumber : One of the input arrays is not allocated !");
+      MEDCoupling::DataArrayInt *out0(0),*out1(0);
+      self->renumber(graph->begin(),index_graph->begin(),index_graph->getNumberOfTuples()-1,out0,out1);
+      PyObject *ret=PyTuple_New(2);
+      PyTuple_SetItem(ret,0,SWIG_NewPointerObj(SWIG_as_voidptr(out0),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
+      PyTuple_SetItem(ret,1,SWIG_NewPointerObj(SWIG_as_voidptr(out1),SWIGTYPE_p_MEDCoupling__DataArrayInt, SWIG_POINTER_OWN | 0 ));
+      return ret;
+    }
+  }
+  virtual ~Renumbering();
+};
+
+namespace MED_RENUMBER
+{
+  Renumbering *RenumberingFactory(const std::string& s) throw(INTERP_KERNEL::Exception);
+  std::vector<std::string> RenumberAvailableMethods();
+  std::vector<std::string> AllRenumberMethods();
+}
