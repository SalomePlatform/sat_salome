--- /dev/null
+++ netgen/CMakeLists.txt
@@ -0,0 +1,75 @@
+# Copyright (C) 2016 OPEN CASCADE
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+# See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8.8 FATAL_ERROR)
+INCLUDE(CMakeDependentOption)
+
+PROJECT(netgen C CXX)
+
+# Ensure a proper linker behavior:
+CMAKE_POLICY(SET CMP0003 NEW)
+
+# Versioning
+# ===========
+# Project name, upper case
+STRING(TOUPPER ${PROJECT_NAME} PROJECT_NAME_UC)
+
+SET(${PROJECT_NAME_UC}_MAJOR_VERSION 5)
+SET(${PROJECT_NAME_UC}_MINOR_VERSION 3)
+SET(${PROJECT_NAME_UC}_PATCH_VERSION 1)
+SET(${PROJECT_NAME_UC}_VERSION
+  ${${PROJECT_NAME_UC}_MAJOR_VERSION}.${${PROJECT_NAME_UC}_MINOR_VERSION}.${${PROJECT_NAME_UC}_PATCH_VERSION})
+
+# Common CMake macros
+# ===================
+LIST(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
+# Detect platform
+INCLUDE(FindPLATFORM) 
+# Detect OCCT
+INCLUDE(FindCAS)
+
+# Detect ZLIB on Windows
+IF(WIN32)
+  SET(ZLIB_ROOT_DIR $ENV{ZLIB_ROOT_DIR})
+  IF(EXISTS ${ZLIB_ROOT_DIR})
+    SET(ZLIB_ROOT ${ZLIB_ROOT_DIR})
+    INCLUDE(FindZLIB)
+    IF (NOT ${ZLIB_FOUND})
+      MESSAGE(FATAL_ERROR "We absolutely need the zlib library, please check zlib installation !")
+    ENDIF()
+  ELSE()
+    MESSAGE(FATAL_ERROR "We absolutely need the zlib library, please define ZLIB_ROOT_DIR !")
+  ENDIF()
+ENDIF()
+
+
+# Common definitions
+# ==================
+ADD_DEFINITIONS(-DNO_PARALLEL_THREADS)
+ADD_DEFINITIONS(-DOCCGEOMETRY)
+
+# Target directories
+SET(NETGEN_INSTALL_BINS "${CMAKE_INSTALL_PREFIX}/bin" CACHE PATH "Install path: netgen binaries")
+SET(NETGEN_INSTALL_LIBS "${CMAKE_INSTALL_PREFIX}/lib" CACHE PATH "Install path: netgen libs")
+SET(NETGEN_INSTALL_HEADERS "${CMAKE_INSTALL_PREFIX}/include" CACHE PATH "Install path: netgen headers")
+SET(NETGEN_INSTALL_CMAKE "${CMAKE_INSTALL_PREFIX}/cmake" CACHE PATH "Install path: netgen cmake files")
+
+# Sub-directories
+ADD_SUBDIRECTORY(nglib)
+ADD_SUBDIRECTORY(cmake)
+
--- netgen_ref/Makefile.am
+++ netgen/Makefile.am
@@ -2,7 +2,7 @@
 
 METASOURCES = AUTO
 
-SUBDIRS = libsrc ng tutorials doc windows nglib
+SUBDIRS = libsrc nglib #tutorials doc windows nglib
 
 # TESTS = ng/netgen -batchmode
 
--- netgen_ref/Makefile.in
+++ netgen/Makefile.in
@@ -280,7 +280,7 @@
 top_srcdir = @top_srcdir@
 ACLOCAL_AMFLAGS = -I m4
 METASOURCES = AUTO
-SUBDIRS = libsrc ng tutorials doc windows nglib
+SUBDIRS = libsrc nglib #tutorials doc windows nglib
 all: config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
--- /dev/null
+++ netgen/cmake/CMakeLists.txt
@@ -0,0 +1,22 @@
+# Copyright (C) 2016 OPEN CASCADE
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+# See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+
+IF(WIN32)
+ INSTALL(FILES FindZLIB.cmake DESTINATION ${NETGEN_INSTALL_CMAKE})
+ENDIF()
\ No newline at end of file
--- /dev/null
+++ netgen/cmake/FindCAS.cmake
@@ -0,0 +1,152 @@
+#  Copyright (C) 2007-2016  CEA/DEN, EDF R&D, OPEN CASCADE
+#
+#  This library is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU Lesser General Public
+#  License as published by the Free Software Foundation; either
+#  version 2.1 of the License.
+#
+#  This library is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public
+#  License along with this library; if not, write to the Free Software
+#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+#  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+
+SET(CASROOT $ENV{CASROOT})
+ADD_DEFINITIONS(-DLIN -DLINTEL -DCSFDB)
+ADD_DEFINITIONS(-DNo_exception)
+ADD_DEFINITIONS(-DHAVE_LIMITS_H)
+
+IF(CMAKE_SIZEOF_VOID_P STREQUAL 8)
+  ADD_DEFINITIONS(-D_OCC64)
+ENDIF(CMAKE_SIZEOF_VOID_P STREQUAL 8)
+
+IF(NOT WINDOWS)
+  FIND_LIBRARY(Xmu Xmu)
+  IF(Xmu)
+    SET(CAS_LDPATH ${Xmu})
+  ENDIF(Xmu)
+ENDIF(NOT WINDOWS)
+
+IF(WINDOWS)
+  IF(CMAKE_BUILD_TYPE STREQUAL Debug)
+    SET(CASROOT_LIBDIR ${CASROOT}/win32/libd ${CASROOT}/win64/vc14/lib)
+  ELSE(CMAKE_BUILD_TYPE STREQUAL Release)
+    SET(CASROOT_LIBDIR ${CASROOT}/win32/lib ${CASROOT}/win64/vc14/lib)
+  ENDIF(CMAKE_BUILD_TYPE STREQUAL Debug)
+ELSE(WINDOWS)
+  SET(CASROOT_LIBDIR ${CASROOT}/lib)
+ENDIF(WINDOWS)
+
+SET(_CAS_VERSION_FILE_NAME Standard_Version.hxx)
+
+# Include directories:
+FIND_PATH(CAS_INCLUDE_DIRS ${_CAS_VERSION_FILE_NAME} PATHS ${CASROOT} PATH_SUFFIXES include/opencascade)
+IF(CAS_INCLUDE_DIRS)
+ELSE()
+  FIND_PATH(CAS_INCLUDE_DIRS ${_CAS_VERSION_FILE_NAME} PATHS ${CASROOT} PATH_SUFFIXES include inc)
+ENDIF()
+
+
+FIND_LIBRARY(BinLPlugin BinLPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(BinPlugin BinPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(BinTObjPlugin BinTObjPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(BinXCAFPlugin BinXCAFPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(FWOSPlugin FWOSPlugin PATHS ${CASROOT_LIBDIR})
+
+FIND_LIBRARY(PTKernel PTKernel PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(StdLPlugin StdLPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(StdPlugin StdPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKAdvTools TKAdvTools PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKBin TKBin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKBinL TKBinL PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKBinTObj TKBinTObj PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKBinXCAF TKBinXCAF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKBO TKBO PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKBool TKBool PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKBRep TKBRep PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKCAF TKCAF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKCDF TKCDF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKernel TKernel PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKFeat TKFeat PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKFillet TKFillet PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKG2d TKG2d PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKG3d TKG3d PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKGeomAlgo TKGeomAlgo PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKGeomBase TKGeomBase PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKHLR TKHLR PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKIGES TKIGES PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKLCAF TKLCAF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKMath TKMath PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKMesh TKMesh PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKMeshVS TKMeshVS PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKNIS TKNIS PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKOffset TKOffset PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKOpenGl TKOpenGl PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKPCAF TKPCAF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKPLCAF TKPLCAF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKPrim TKPrim PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKPShape TKPShape PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKService TKService PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKShapeSchema TKShapeSchema PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKShHealing TKShHealing PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKStdLSchema TKStdLSchema PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKStdSchema TKStdSchema PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKSTEP TKSTEP PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKSTEP209 TKSTEP209 PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKSTEPAttr TKSTEPAttr PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKSTEPBase TKSTEPBase PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKSTL TKSTL PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKTObj TKTObj PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKTopAlgo TKTopAlgo PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKV2d TKV2d PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKV3d TKV3d PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKVRML TKVRML PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXCAF TKXCAF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXCAFSchema TKXCAFSchema PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXDEIGES TKXDEIGES PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXDESTEP TKXDESTEP PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXMesh TKXMesh PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXml TKXml PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXmlL TKXmlL PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXmlTObj TKXmlTObj PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXmlXCAF TKXmlXCAF PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(TKXSBase TKXSBase PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(XCAFPlugin XCAFPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(XmlLPlugin XmlLPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(XmlPlugin XmlPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(XmlTObjPlugin XmlTObjPlugin PATHS ${CASROOT_LIBDIR})
+FIND_LIBRARY(XmlXCAFPlugin XmlXCAFPlugin PATHS ${CASROOT_LIBDIR})
+
+SET(CAS_KERNEL ${TKernel} ${TKMath})
+SET(CAS_OCAF ${TKernel} ${TKMath} ${TKCDF} ${TKLCAF})
+SET(CAS_VIEWER ${TKService} ${TKV3d} ${TKG3d} ${TKGeomBase} ${TKBRep})
+SET(CAS_OCAFVIS ${TKCAF} ${TKBRep} ${TKG2d})
+SET(CAS_MODELER ${TKG3d} ${TKGeomBase} ${TKGeomAlgo} ${TKBRep} ${TKTopAlgo} ${TKG2d})
+
+SET(TKV3d_EA ${TKernel} ${TKMath} ${TKV3d})
+SET(TKBool_EA ${TKernel} ${TKMath} ${TKBRep} ${TKG2d} ${TKG3d} ${TKGeomBase} ${TKGeomAlgo} ${TKTopAlgo} ${TKBool})
+SET(TKBRep_EA ${TKernel} ${TKMath} ${TKBRep})
+SET(TKIGES_EA ${TKernel} ${TKMath} ${TKXSBase} ${TKBRep} ${TKIGES})
+SET(TKSTEP_EA ${TKernel} ${TKMath} ${TKXSBase} ${TKBRep} ${TKSTEP})
+SET(TKSTL_EA ${TKernel} ${TKMath} ${TKSTL})
+SET(TKCAF_EA ${TKPrim} ${TKCAF})
+
+SET(TKV3d ${TKV3d_EA})
+SET(TKBool ${TKBool_EA})
+SET(TKBRep ${TKBRep_EA})
+SET(TKIGES ${TKIGES_EA})
+SET(TKSTEP ${TKSTEP_EA})
+SET(TKSTL ${TKSTL_EA})
+SET(TKCAF ${TKCAF_EA})
+
+#LIBRARIES
+SET(OCCLIBS ${CAS_LDPATH})
+SET(OCCLIBS ${OCCLIBS} ${TKernel} ${TKGeomBase} ${TKMath} ${TKG2d} ${TKG3d} ${TKXSBase} ${TKOffset} ${TKFillet} ${TKShHealing})
+SET(OCCLIBS ${OCCLIBS} ${TKMesh} ${TKMeshVS} ${TKTopAlgo} ${TKGeomAlgo} ${TKBool} ${TKPrim} ${TKBO} ${TKIGES} ${TKBRep})
+SET(OCCLIBS ${OCCLIBS} ${TKSTEPBase} ${TKSTEP} ${TKSTL} ${TKSTEPAttr} ${TKSTEP209} ${TKXDESTEP} ${TKXDEIGES} ${TKXCAF} ${TKLCAF})
\ No newline at end of file
--- /dev/null
+++ netgen/cmake/FindPLATFORM.cmake
@@ -0,0 +1,96 @@
+#  Copyright (C) 2007-2016  CEA/DEN, EDF R&D, OPEN CASCADE
+#
+#  This library is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU Lesser General Public
+#  License as published by the Free Software Foundation; either
+#  version 2.1 of the License.
+#
+#  This library is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public
+#  License along with this library; if not, write to the Free Software
+#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+#  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+
+MARK_AS_ADVANCED(ISSUE)
+FIND_FILE(ISSUE issue /etc)
+IF(ISSUE)
+  SET(WINDOWS 0)
+ELSE()
+  SET(WINDOWS 1)
+ENDIF(ISSUE)
+
+IF(WINDOWS)
+  SET(MACHINE WINDOWS)
+ELSE(WINDOWS)
+  SET(MACHINE PCLINUX)
+ENDIF(WINDOWS)
+
+SET(CMAKE_INSTALL_PREFIX_ENV $ENV{CMAKE_INSTALL_PREFIX})
+IF(CMAKE_INSTALL_PREFIX_ENV)
+  SET(CMAKE_INSTALL_PREFIX ${CMAKE_INSTALL_PREFIX_ENV} CACHE PATH "installation prefix" FORCE)
+ENDIF(CMAKE_INSTALL_PREFIX_ENV)
+
+IF(NOT CMAKE_BUILD_TYPE)
+  SET(CMAKE_BUILD_TYPE $ENV{CMAKE_BUILD_TYPE})
+ENDIF(NOT CMAKE_BUILD_TYPE)
+
+IF(NOT CMAKE_BUILD_TYPE)
+  SET(CMAKE_BUILD_TYPE Release)
+ENDIF(NOT CMAKE_BUILD_TYPE)
+
+IF(WINDOWS)
+ELSE(WINDOWS)
+  SET(ADD_WERROR ON)
+  SET(NAMES ACCEPT_SALOME_WARNINGS ACCEPT_${MODULE}_WARNINGS I_AM_A_TROLL_I_DO_NOT_FIX_${MODULE}_WARNINGS)
+  FOREACH(name ${NAMES})
+    SET(VAL $ENV{${name}})
+    IF(X${VAL} STREQUAL X0)
+      SET(ADD_WERROR ON)
+    ENDIF(X${VAL} STREQUAL X0)
+    IF(X${VAL} STREQUAL X1)
+      SET(ADD_WERROR OFF)
+    ENDIF(X${VAL} STREQUAL X1)
+  ENDFOREACH(name ${NAMES})
+  IF(ADD_WERROR)
+    SET(CMAKE_C_FLAGS "-Werror")
+    SET(CMAKE_CXX_FLAGS "-Werror")
+  ENDIF(ADD_WERROR)
+ENDIF(WINDOWS)
+
+IF(CMAKE_BUILD_TYPE)
+  IF(WINDOWS)
+    MARK_AS_ADVANCED(CLEAR CMAKE_CONFIGURATION_TYPES)
+    SET(CMAKE_CONFIGURATION_TYPES ${CMAKE_BUILD_TYPE} CACHE STRING "compilation types" FORCE)
+  ELSE(WINDOWS)
+    IF(CMAKE_BUILD_TYPE STREQUAL Debug)
+      SET(CMAKE_C_FLAGS_DEBUG "-g")
+      SET(CMAKE_CXX_FLAGS_DEBUG "-g")
+    ENDIF(CMAKE_BUILD_TYPE STREQUAL Debug)
+    IF(CMAKE_BUILD_TYPE STREQUAL Release)
+      SET(CMAKE_C_FLAGS_RELEASE "-O1 -DNDEBUG")
+      SET(CMAKE_CXX_FLAGS_RELEASE "-O1 -DNDEBUG")
+    ENDIF(CMAKE_BUILD_TYPE STREQUAL Release)
+  ENDIF(WINDOWS)
+ENDIF(CMAKE_BUILD_TYPE)
+
+SET(PLATFORM_CPPFLAGS)
+SET(PLATFORM_LDFLAGS)
+SET(PLATFORM_LIBADD)
+IF(WINDOWS)
+  ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS)  # To disable windows warnings for strcpy, fopen, ...
+  ADD_DEFINITIONS(-D_SCL_SECURE_NO_WARNINGS)  # To disable windows warnings std::copy, std::transform, ...
+  ADD_DEFINITIONS(-DWNT)
+  ADD_DEFINITIONS(-DPPRO_NT) # For medfile
+  ADD_DEFINITIONS(-D_USE_MATH_DEFINES) # At least for MEDMEM
+  ADD_DEFINITIONS(-D_WIN32_WINNT=0x0500) # Windows 2000 or later API is required
+  SET(PLATFORM_LIBADD ${PLATFORM_LIBADD} Ws2_32.lib)
+  SET(PLATFORM_LIBADD ${PLATFORM_LIBADD} Userenv.lib) # At least for GEOM suit
+ELSE(WINDOWS)
+  SET(PLATFORM_LIBADD ${PLATFORM_LIBADD} -ldl)
+ENDIF(WINDOWS) 
\ No newline at end of file
--- /dev/null
+++ netgen/cmake/FindZLIB.cmake
@@ -0,0 +1,45 @@
+#  Copyright (C) 2007-2016  CEA/DEN, EDF R&D, OPEN CASCADE
+#
+#  This library is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU Lesser General Public
+#  License as published by the Free Software Foundation; either
+#  version 2.1 of the License.
+#
+#  This library is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public
+#  License along with this library; if not, write to the Free Software
+#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+#  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+
+SET(_ZLIB_SDIRS)
+
+# Search in ZLIB_ROOT_DIR first
+IF(ZLIB_ROOT_DIR)
+  SET(_ZLIB_SEARCH_ROOT PATHS ${ZLIB_ROOT_DIR} NO_DEFAULT_PATH)
+  list(APPEND _ZLIB_SDIRS _ZLIB_SEARCH_ROOT)
+ENDIF()
+
+SET(ZLIB_NAMES z zlib zdll zlib1 zlibd zlibd1 zlib1d)
+
+# Try each search configuration.
+FOREACH(search ${_ZLIB_SDIRS})
+  FIND_PATH(ZLIB_INCLUDE_DIR NAMES zlib.h        ${${search}} PATH_SUFFIXES include)
+  FIND_LIBRARY(ZLIB_LIBRARY  NAMES ${ZLIB_NAMES} ${search} PATH_SUFFIXES lib)
+ENDFOREACH()
+
+MARK_AS_ADVANCED(ZLIB_LIBRARY ZLIB_INCLUDE_DIR)
+
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(ZLIB REQUIRED_VARS ZLIB_LIBRARY ZLIB_INCLUDE_DIR)
+
+IF(ZLIB_FOUND)
+    SET(ZLIB_INCLUDE_DIRS ${ZLIB_INCLUDE_DIR})
+    SET(ZLIB_LIBRARIES ${ZLIB_LIBRARY})
+ENDIF()
--- netgen_ref/configure.ac
+++ netgen/configure.ac
@@ -20,7 +20,7 @@
 CXXFLAGS="$CXXFLAGS $OPENMP_CXXFLAGS"
 # LDFLAGS="$LDFLAGS $OPENMP_CXXFLAGS"
 
-AM_PROG_AR
+m4_ifdef([AM_PROG_AR], [AM_PROG_AR])
 AC_PROG_LIBTOOL
 LT_INIT
 
@@ -42,8 +42,8 @@
 
 if test a$occon = atrue ; then
 
-	AC_SUBST([OCCFLAGS], ["-DOCCGEOMETRY -I$occdir/inc -I/usr/include/opencascade"])
-	AC_SUBST([OCCLIBS], ["-L$occdir/lib -lTKernel -lTKGeomBase -lTKMath -lTKG2d -lTKG3d -lTKXSBase -lTKOffset -lTKFillet -lTKShHealing -lTKMesh -lTKMeshVS -lTKTopAlgo -lTKGeomAlgo -lTKBool -lTKPrim -lTKBO -lTKIGES -lTKBRep -lTKSTEPBase -lTKSTEP -lTKSTL -lTKSTEPAttr -lTKSTEP209 -lTKXDESTEP -lTKXDEIGES -lTKXCAF -lTKLCAF -lFWOSPlugin"])
+	AC_SUBST([OCCFLAGS], ["-DOCCGEOMETRY -I$occdir/include/opencascade"])
+	AC_SUBST([OCCLIBS], ["-L$occdir/lib -lTKernel -lTKGeomBase -lTKMath -lTKG2d -lTKG3d -lTKXSBase -lTKOffset -lTKFillet -lTKShHealing -lTKMesh -lTKMeshVS -lTKTopAlgo -lTKGeomAlgo -lTKBool -lTKPrim -lTKBO -lTKIGES -lTKBRep -lTKSTEPBase -lTKSTEP -lTKSTL -lTKSTEPAttr -lTKSTEP209 -lTKXDESTEP -lTKXDEIGES -lTKXCAF -lTKLCAF"])
 
 #  -lTKDCAF
 
--- netgen_ref/libsrc/csg/Makefile.am
+++ netgen/libsrc/csg/Makefile.am
@@ -8,7 +8,7 @@
 AM_CPPFLAGS = -I$(top_srcdir)/libsrc/include  $(TCL_INCLUDES)
 METASOURCES = AUTO
 
-lib_LTLIBRARIES = libcsg.la
+noinst_LTLIBRARIES = libcsg.la
 
 
 libcsg_la_SOURCES = algprim.cpp brick.cpp   \
@@ -17,12 +17,9 @@
 manifold.cpp meshsurf.cpp polyhedra.cpp revolution.cpp singularref.cpp \
 solid.cpp specpoin.cpp spline3d.cpp surface.cpp triapprox.cpp
 
-libcsg_la_LIBADD =  $(top_builddir)/libsrc/meshing/libmesh.la
 
-
-
 if NGGUI
-lib_LTLIBRARIES += libcsgvis.la 
+lib_LTLIBRARIES = libcsgvis.la 
 
 libcsgvis_la_SOURCES = vscsg.cpp csgpkg.cpp
 libcsgvis_la_LIBADD = libcsg.la
--- netgen_ref/libsrc/csg/specpoin.hpp
+++ netgen/libsrc/csg/specpoin.hpp
@@ -8,10 +8,12 @@
 /* Date:   01. Okt. 95                                                    */
 /**************************************************************************/
 
+#include <myadt.hpp>
+
 namespace netgen
 {
 
-  extern DLL_HEADER MeshingParameters mparam;
+  DLL_HEADER extern MeshingParameters mparam;
 
   /*
 
--- netgen_ref/libsrc/general/array.hpp
+++ netgen/libsrc/general/array.hpp
@@ -50,7 +50,7 @@
     {
 #ifdef DEBUG
       if (i-BASE < 0 || i-BASE >= size)
-	cout << "array<" << typeid(T).name() << "> out of range, i = " << i << ", s = " << size << endl;
+	std::cout << "array<" << typeid(T).name() << "> out of range, i = " << i << ", s = " << size << std::endl;
 #endif
 
       return data[i-BASE]; 
@@ -69,9 +69,9 @@
     {
 #ifdef DEBUG
       if (i < 1 || i > size)
-	cout << "Array<" << typeid(T).name() 
+	std::cout << "Array<" << typeid(T).name() 
 	     << ">::Elem out of range, i = " << i
-	     << ", s = " << size << endl;
+	     << ", s = " << size << std::endl;
 #endif
 
       return ((T*)data)[i-1]; 
@@ -82,8 +82,8 @@
     {
 #ifdef DEBUG
       if (i < 1 || i > size)
-	cout << "Array<" << typeid(T).name() << ">::Get out of range, i = " << i
-	     << ", s = " << size << endl;
+	std::cout << "Array<" << typeid(T).name() << ">::Get out of range, i = " << i
+	     << ", s = " << size << std::endl;
 #endif
 
       return ((const T*)data)[i-1]; 
@@ -94,8 +94,8 @@
     { 
 #ifdef DEBUG
       if (i < 1 || i > size)
-	cout << "Array<" << typeid(T).name() << ">::Set out of range, i = " << i
-	     << ", s = " << size << endl;
+	std::cout << "Array<" << typeid(T).name() << ">::Set out of range, i = " << i
+	     << ", s = " << size << std::endl;
 #endif
 
       ((T*)data)[i-1] = el; 
@@ -151,7 +151,7 @@
   inline ostream & operator<< (ostream & s, const FlatArray<T,BASE,TIND> & a)
   {
     for (TIND i = a.Begin(); i < a.End(); i++)
-      s << i << ": " << a[i] << endl;
+      s << i << ": " << a[i] << std::endl;
     return s;
   }
 
@@ -435,7 +435,7 @@
   inline ostream & operator<< (ostream & s, const IndirectArray<T1,T2> & ia)
   {
     for (int i = ia.Begin(); i < ia.End(); i++)
-      s << i << ": " << ia[i] << endl;
+      s << i << ": " << ia[i] << std::endl;
     return s;
   }
   
@@ -551,7 +551,7 @@
     void PrintMemInfo (ostream & ost) const
     {
       ost << Size() << " elements of size " << sizeof(T) << " = " 
-	  << Size() * sizeof(T) << endl;
+	  << Size() * sizeof(T) << std::endl;
     }
 
     MoveableArray & operator= (const T & el)
@@ -593,7 +593,7 @@
   inline ostream & operator<< (ostream & ost, MoveableArray<T> & a)
   {
     for (int i = 0; i < a.Size(); i++)
-      ost << i << ": " << a[i] << endl;
+      ost << i << ": " << a[i] << std::endl;
     return ost;
   }
   */
--- netgen_ref/libsrc/general/hashtabl.hpp
+++ netgen/libsrc/general/hashtabl.hpp
@@ -182,9 +182,9 @@
   ///
   void PrintMemInfo (ostream & ost) const
   {
-    ost << "Hash: " << endl;
+    ost << "Hash: " << std::endl;
     hash.PrintMemInfo (ost);
-    ost << "Cont: " << endl;
+    ost << "Cont: " << std::endl;
     cont.PrintMemInfo (ost);
   }
 
@@ -212,7 +212,7 @@
 
     void operator++ (int)
     {
-      // cout << "begin Operator ++: bagnr = " << bagnr << " -  pos = " << pos << endl;
+      // std::cout << "begin Operator ++: bagnr = " << bagnr << " -  pos = " << pos << std::endl;
       pos++;
       while (bagnr < ht.GetNBags() && 
 	     pos == ht.GetBagSize(bagnr+1))
@@ -220,7 +220,7 @@
 	  pos = 0;
 	  bagnr++;
 	}
-      // cout << "end Operator ++: bagnr = " << bagnr << " - pos = " << pos << endl;
+      // std::cout << "end Operator ++: bagnr = " << bagnr << " - pos = " << pos << std::endl;
     }
 
     bool operator != (int i) const
@@ -264,7 +264,7 @@
   for (typename INDEX_2_HASHTABLE<T>::Iterator it = ht.Begin();
        it != ht.End(); it++)
     {
-      ost << ht.GetHash(it) << ": " << ht.GetData(it) << endl;
+      ost << ht.GetHash(it) << ": " << ht.GetData(it) << std::endl;
     }
 
   return ost;
@@ -375,7 +375,7 @@
 
     void operator++ (int)
     {
-      // cout << "begin Operator ++: bagnr = " << bagnr << " -  pos = " << pos << endl;
+      // std::cout << "begin Operator ++: bagnr = " << bagnr << " -  pos = " << pos << std::endl;
       pos++;
       while (bagnr < ht.GetNBags() && 
 	     pos == ht.GetBagSize(bagnr+1))
@@ -383,7 +383,7 @@
 	  pos = 0;
 	  bagnr++;
 	}
-      // cout << "end Operator ++: bagnr = " << bagnr << " - pos = " << pos << endl;
+      // std::cout << "end Operator ++: bagnr = " << bagnr << " - pos = " << pos << std::endl;
     }
 
     bool operator != (int i) const
@@ -433,7 +433,7 @@
   for (typename INDEX_3_HASHTABLE<T>::Iterator it = ht.Begin();
        it != ht.End(); it++)
     {
-      ost << ht.GetHash(it) << ": " << ht.GetData(it) << endl;
+      ost << ht.GetHash(it) << ": " << ht.GetData(it) << std::endl;
     }
 
   return ost;
@@ -747,7 +747,7 @@
 	INDEX_2 hash;
 	T data;
 	ht.GetData (i, hash, data);
-	ost << "hash = " << hash << ", data = " << data << endl;
+	ost << "hash = " << hash << ", data = " << data << std::endl;
       }
   return ost;
 }
@@ -917,9 +917,9 @@
 
   void PrintMemInfo (ostream & ost) const
   {
-    cout << "Hashtable: " << Size() 
+    std::cout << "Hashtable: " << Size() 
          << " entries of size " << sizeof(INDEX_3) << " + " << sizeof(T) 
-         << " = " << Size() * (sizeof(INDEX_3) + sizeof(T)) << " bytes" << endl;
+         << " = " << Size() * (sizeof(INDEX_3) + sizeof(T)) << " bytes" << std::endl;
     
   }
 
@@ -947,7 +947,7 @@
 	INDEX_3 hash;
 	T data;
 	ht.GetData (i, hash, data);
-	ost << "hash = " << hash << ", data = " << data << endl;
+	ost << "hash = " << hash << ", data = " << data << std::endl;
       }
   return ost;
 }
@@ -1079,9 +1079,9 @@
 template<class T>
 inline void INDEX_3_HASHTABLE<T> :: PrintMemInfo (ostream & ost) const
   {
-    ost << "Hash: " << endl;
+    ost << "Hash: " << std::endl;
     hash.PrintMemInfo (ost);
-    ost << "Cont: " << endl;
+    ost << "Cont: " << std::endl;
     cont.PrintMemInfo (ost);
   }
 
@@ -1146,9 +1146,9 @@
 template<class T>
 inline void INDEX_HASHTABLE<T> :: PrintMemInfo (ostream & ost) const
   {
-    ost << "Hash: " << endl;
+    ost << "Hash: " << std::endl;
     hash.PrintMemInfo (ost);
-    ost << "Cont: " << endl;
+    ost << "Cont: " << std::endl;
     cont.PrintMemInfo (ost);
   }
 
@@ -1249,11 +1249,11 @@
 inline void INDEX_2_CLOSED_HASHTABLE<T> :: 
 PrintMemInfo (ostream & ost) const
 {
-  cout << "Hashtable: " << Size() 
+  std::cout << "Hashtable: " << Size() 
        << " entries of size " << sizeof(INDEX_2) << " + " << sizeof(T) 
        << " = " << Size() * (sizeof(INDEX_2) + sizeof(T)) << " bytes." 
        << " Used els: " << UsedElements() 
-       << endl;
+       << std::endl;
 }
 
 
@@ -1356,9 +1356,9 @@
 inline void INDEX_3_CLOSED_HASHTABLE<T> :: 
 PrintMemInfo (ostream & ost) const
 {
-  cout << "Hashtable: " << Size() 
+  std::cout << "Hashtable: " << Size() 
        << " entries of size " << sizeof(INDEX_3) << " + " << sizeof(T) 
-       << " = " << Size() * (sizeof(INDEX_3) + sizeof(T)) << " bytes" << endl;
+       << " = " << Size() * (sizeof(INDEX_3) + sizeof(T)) << " bytes" << std::endl;
 }
 */
 
--- netgen_ref/libsrc/general/table.hpp
+++ netgen/libsrc/general/table.hpp
@@ -210,7 +210,7 @@
   { 
 #ifdef DEBUG
     if (i-BASE < 0 || i-BASE >= data.Size())
-      cout << "table out of range, i = " << i << ", s = " << data.Size() << endl;
+      std::cout << "table out of range, i = " << i << ", s = " << data.Size() << std::endl;
 #endif
 
     return FlatArray<T> (data[i-BASE].size, (T*)data[i-BASE].col);
--- netgen_ref/libsrc/general/template.hpp
+++ netgen/libsrc/general/template.hpp
@@ -26,10 +26,10 @@
 DLL_HEADER extern ostream * testout;
 
 /** use instead of cout */
-extern ostream * mycout;
+DLL_HEADER extern ostream * mycout;
 
 /** error output stream */
-extern ostream * myerr;
+DLL_HEADER extern ostream * myerr;
 
 /** Error messages display.
   Error messages are displayed by this function */
--- netgen_ref/libsrc/geom2d/Makefile.am
+++ netgen/libsrc/geom2d/Makefile.am
@@ -4,16 +4,15 @@
 
 METASOURCES = AUTO
 
-lib_LTLIBRARIES = libgeom2d.la 
+noinst_LTLIBRARIES = libgeom2d.la 
 
 if NGGUI
-lib_LTLIBRARIES += libgeom2dvis.la 
+lib_LTLIBRARIES = libgeom2dvis.la 
 endif
 
 
 
 libgeom2d_la_SOURCES = genmesh2d.cpp geom2dmesh.cpp geometry2d.cpp
-libgeom2d_la_LIBADD = 	$(top_builddir)/libsrc/meshing/libmesh.la
 
 libgeom2dvis_la_SOURCES = geom2dpkg.cpp vsgeom2d.cpp
 libgeom2dvis_la_LIBADD = libgeom2d.la
--- netgen_ref/libsrc/gprim/spline.hpp
+++ netgen/libsrc/gprim/spline.hpp
@@ -55,7 +55,7 @@
     /// returns a (not necessarily unit-length) tangent vector for 0 <= t <= 1
     virtual Vec<D> GetTangent (const double t) const
     { 
-      cerr << "GetTangent not implemented for spline base-class"  << endl; 
+      std::cerr << "GetTangent not implemented for spline base-class"  << std::endl; 
       Vec<D> dummy; return dummy;
     }
 
@@ -100,10 +100,10 @@
     virtual string GetType(void) const {return "splinebase";}
 
     virtual void Project (const Point<D> point, Point<D> & point_on_curve, double & t) const
-    { cerr << "Project not implemented for spline base-class" << endl;}
+    { std::cerr << "Project not implemented for spline base-class" << std::endl;}
 
     virtual void GetRawData (Array<double> & data) const
-    { cerr << "GetRawData not implemented for spline base-class" << endl;}
+    { std::cerr << "GetRawData not implemented for spline base-class" << std::endl;}
 
   };
 
@@ -300,7 +300,7 @@
 
 
   template<int D>
-  void SplineSeg<D> :: PrintCoeff (ostream & ost) const
+  void SplineSeg<D> :: PrintCoeff (std::ostream & ost) const
   {
     Vector u(6);
 
@@ -308,7 +308,7 @@
 
     for ( int i=0; i<6; i++)
       ost << u[i] << "  ";
-    ost << endl;
+    ost << std::endl;
   }
 
 
--- netgen_ref/libsrc/include/mystdlib.h
+++ netgen/libsrc/include/mystdlib.h
@@ -66,6 +66,7 @@
 #  ifdef MSVC_EXPRESS
 #   include <pthread.h>
 #  else
+    #define _AFXDLL
 #   include <afxwin.h>
 #   include <afxmt.h>
 #  endif // MSVC_EXPRESS
--- netgen_ref/libsrc/interface/Makefile.am
+++ netgen/libsrc/interface/Makefile.am
@@ -2,14 +2,11 @@
 
 AM_CPPFLAGS = -I$(top_srcdir)/libsrc/include -I$(top_srcdir)/libsrc/interface  $(MPI_INCLUDES) $(TCL_INCLUDES) -DOPENGL
 METASOURCES = AUTO
-lib_LTLIBRARIES = libinterface.la
+noinst_LTLIBRARIES = libinterface.la
 libinterface_la_SOURCES = nginterface.cpp nginterface_v2.cpp \
 	read_fnf_mesh.cpp readtetmesh.cpp readuser.cpp writeabaqus.cpp writediffpack.cpp \
 	writedolfin.cpp writeelmer.cpp writefeap.cpp writefluent.cpp writegmsh.cpp writejcm.cpp \
 	writepermas.cpp writetecplot.cpp writetet.cpp writetochnog.cpp writeuser.cpp \
 	wuchemnitz.cpp writegmsh2.cpp writeOpenFOAM15x.cpp 
-
-
-libinterface_la_LIBADD = $(top_builddir)/libsrc/meshing/libmesh.la
 
 # libinterface_la_LDFLAGS = -rdynamic
--- netgen_ref/libsrc/interface/nginterface.cpp
+++ netgen/libsrc/interface/nginterface.cpp
@@ -1,3 +1,18 @@
+#ifdef _MSC_VER
+#ifndef MSVC_EXPRESS
+
+#define _AFXDLL
+#define WINVER 0x0A00
+#define _WIN32_WINNT 0x0A00
+
+#include <Afxwin.h>
+#include <winsock2.h>
+#include <winsock.h>
+#include <windows.h>
+
+#endif
+#endif
+
 #include <mystdlib.h>
 
 #include <meshing.hpp>
@@ -10,7 +25,6 @@
 
 #include "nginterface.h"
 #include "../visualization/soldata.hpp"
-
 
 #ifdef _MSC_VER
 // Philippose - 30/01/2009
--- netgen_ref/libsrc/linalg/densemat.hpp
+++ netgen/libsrc/linalg/densemat.hpp
@@ -62,24 +62,24 @@
 #ifdef DEBUG
     if (prod.Size() != height)
       {
-	(*myerr) << "Mult: wrong vector size " << endl;
+	(*myerr) << "Mult: wrong vector size " << std::endl;
       }
     if (!height) 
       {
-	cout << "DenseMatrix::Mult height = 0" << endl;
+	std::cout << "DenseMatrix::Mult height = 0" << std::endl;
       }
     if (!width) 
       {
-	cout << "DenseMatrix::Mult width = 0" << endl;
+	std::cout << "DenseMatrix::Mult width = 0" << std::endl;
       }
     
     if (width != v.Size())
       {
-	(*myerr) << "\nMatrix and Vector don't fit" << endl;
+	(*myerr) << "\nMatrix and Vector don't fit" << std::endl;
       }
     else if (Height() != prod.Size())
       {
-	(*myerr) << "Base_Matrix::operator*(Vector): prod vector not ok" << endl;
+	(*myerr) << "Base_Matrix::operator*(Vector): prod vector not ok" << std::endl;
       }
     else
 #endif
@@ -208,7 +208,7 @@
     /*    
     if (prod.Size() != height)
       {
-	cerr << "MatrixFixWidth::Mult: wrong vector size " << endl;
+	cerr << "MatrixFixWidth::Mult: wrong vector size " << std::endl;
 	assert (1);
       }
     */    
@@ -268,7 +268,7 @@
     {
       for (int j = 0; j < m.Width(); j++)
 	ost << m.Get(i+1,j+1) << " ";
-      ost << endl;
+      ost << std::endl;
     }
   return ost;
 };
--- netgen_ref/libsrc/meshing/Makefile.am
+++ netgen/libsrc/meshing/Makefile.am
@@ -15,7 +15,7 @@
 
 METASOURCES = AUTO
 
-lib_LTLIBRARIES = libmesh.la
+noinst_LTLIBRARIES = libmesh.la
 
 libmesh_la_SOURCES = adfront2.cpp adfront3.cpp bisect.cpp boundarylayer.cpp \
 	clusters.cpp curvedelems.cpp delaunay.cpp delaunay2d.cpp	    \
@@ -30,8 +30,5 @@
 	topology.cpp triarls.cpp validate.cpp zrefine.cpp bcfunctions.cpp   \
 	parallelmesh.cpp  paralleltop.cpp  paralleltop.hpp basegeom.cpp 
 
-libmesh_la_LIBADD =  $(top_builddir)/libsrc/linalg/libla.la \
-	$(top_builddir)/libsrc/gprim/libgprim.la \
-	$(top_builddir)/libsrc/general/libgen.la \
-	-lz
+libmesh_la_LIBADD = -lz
 
--- netgen_ref/libsrc/meshing/classifyhpel.hpp
+++ netgen/libsrc/meshing/classifyhpel.hpp
@@ -64,11 +64,11 @@
 	
 	if (debug)
 	  {
-	    cout << "debug" << endl;
-	    *testout  << "debug" << endl;
-	    *testout << "ep = " << ep1 << ep2 << ep3 << ep4 << endl;
-	    *testout << "cp = " << cp1 << cp2 << cp3 << cp4 << endl;
-	    *testout << "edge = " << isedge1 << isedge2 << isedge3 << isedge4 << isedge5 << isedge6 << endl;
+	    std::cout << "debug" << std::endl;
+	    *testout  << "debug" << std::endl;
+	    *testout << "ep = " << ep1 << ep2 << ep3 << ep4 << std::endl;
+	    *testout << "cp = " << cp1 << cp2 << cp3 << cp4 << std::endl;
+	    *testout << "edge = " << isedge1 << isedge2 << isedge3 << isedge4 << isedge5 << isedge6 << std::endl;
 	  }
 
 
@@ -402,18 +402,18 @@
       }
   
   
-  if (debug) cout << "type = " << type << endl;
+  if (debug) std::cout << "type = " << type << std::endl;
 
   if (type == HP_NONE)
     {
       //     cnt_undef++;
-      (*testout) << "undefined element" << endl
-		 << "cp = " << cp1 << cp2 << cp3 << cp4 << endl
-		 << "ep = " << ep1 << ep2 << ep3 << ep4 << endl
+      (*testout) << "undefined element" << std::endl
+		 << "cp = " << cp1 << cp2 << cp3 << cp4 << std::endl
+		 << "ep = " << ep1 << ep2 << ep3 << ep4 << std::endl
 		 << "isedge = " << isedge1 << isedge2 << isedge3 
-		 << isedge4 << isedge5 << isedge6 << endl
-		 << "isface = " << isface1 << isface2 << isface3 << isface4 << endl;
-      cout << "undefined element !!! " << endl;
+		 << isedge4 << isedge5 << isedge6 << std::endl
+		 << "isface = " << isface1 << isface2 << isface3 << isface4 << std::endl;
+      std::cout << "undefined element !!! " << std::endl;
 
       
     }
@@ -597,7 +597,7 @@
 	  
 	case 2:
 	  if(sve[0] <= 1) 
-	    cout << " **** WARNING: Edge between to different singular faces should be marked singular " << endl; 
+	    std::cout << " **** WARNING: Edge between to different singular faces should be marked singular " << std::endl; 
 		      
 	  if(sve[1] <= 1)   
 	    if(sve[2] <=1) 
@@ -638,9 +638,9 @@
     }
 	 
   /*
-   *testout << " Prism with pnums " << endl; 
+   *testout << " Prism with pnums " << std::endl; 
    for(int j=0;j<6;j++) *testout << el.pnums[j] << "\t"; 
-   *testout << endl; 
+   *testout << std::endl; 
    */
   
   if(type != HP_NONE) 
@@ -650,9 +650,9 @@
       for(int k=0;k<6;k++) el.pnums[k] = pnums[k]; 
     }
 
-  /* *testout << " Classified Prism with pnums " << endl; 
+  /* *testout << " Classified Prism with pnums " << std::endl; 
      for(int j=0;j<6;j++) *testout << el.pnums[j] << "\t"; 
-     *testout << endl; 
+     *testout << std::endl; 
      */ 
   return(type); 
 }
@@ -673,7 +673,7 @@
   i3.Sort();
   bool sing_face = faces.Used (i3);
   
-  // *testout << " facepoint " << facepoint << endl;  
+  // *testout << " facepoint " << facepoint << std::endl;  
       
 
   // Try all rotations of the trig 
@@ -688,7 +688,7 @@
 	  pnums[m] = el.PNum(p[m]); // global vertex number 
 	  // *testout << pnums[m] << " \t "; 
 	}
-      // *testout << endl ; 
+      // *testout << std::endl ; 
       
       if(dim == 3) 
 	{
@@ -696,9 +696,9 @@
 	  for(int k=0;k<3;k++)
 	    if(!sing_face)
 	      { 
-		//	*testout << " fp [" << k << "] = " << facepoint[pnums[k]] << endl;   
-		//	*testout << " fd.DomainIn()" <<  fd.DomainIn() << endl; 
-		//	*testout  << " fd.DomainOut()" <<  fd.DomainOut() << endl; 
+		//	*testout << " fp [" << k << "] = " << facepoint[pnums[k]] << std::endl;   
+		//	*testout << " fd.DomainIn()" <<  fd.DomainIn() << std::endl; 
+		//	*testout  << " fd.DomainOut()" <<  fd.DomainOut() << std::endl; 
 		if( facepoint[pnums[k]]  && (facepoint[pnums[k]] ==-1 || 
 					     facepoint[pnums[k]] == fd.DomainIn() ||   facepoint[pnums[k]] == fd.DomainOut()))
 		  point_sing[p[k]-1] = 1; 
@@ -707,7 +707,7 @@
 
 	  /*	  *testout << " pointsing NACH FACEPOints ... FALLS EDGEPOINT UMSETZEN" ; 
             for (int k=0;k<3;k++) *testout << "\t" << point_sing[p[k]-1] ;
-            *testout << endl; */
+            *testout << std::endl; */
 	}
       
       const ELEMENT_EDGE * eledges = MeshTopology::GetEdges1(TRIG); 
@@ -746,13 +746,13 @@
 	      
 	      /*  *testout << " pointsing NACH edges UND FACEEDGES UMSETZEN ... " ; 
                   for (int k=0;k<3;k++) *testout << "\t" << point_sing[p[k]-1] ; 
-                  *testout << endl;          
+                  *testout << std::endl;          
                   */
 	    }
 	}
       /*
-       *testout << " dim " << dim << endl; 
-       *testout << " edgepoint_dom " << edgepoint_dom << endl; 
+       *testout << " dim " << dim << std::endl; 
+       *testout << " edgepoint_dom " << edgepoint_dom << std::endl; 
        */
       if(dim==2)
 	{
@@ -796,7 +796,7 @@
 	if(cornerpoint.Test(el.PNum(p[k]))) 
 	  point_sing[p[k]-1] = 3; 
       
-      *testout << "point_sing = " << point_sing[0] << point_sing[1] << point_sing[2] << endl;
+      *testout << "point_sing = " << point_sing[0] << point_sing[1] << point_sing[2] << std::endl;
 
       if(edge_sing[0] + edge_sing[1] + edge_sing[2] == 0) 
         { 
@@ -854,21 +854,21 @@
           else if (edge_sing[2] && edge_sing[1] && edge_sing[0])
             type = HP_TRIG_3SINGEDGES; 
      
-      //  cout << " run for " <<  j << " gives type " << type << endl; 
-      //*testout << " run for " <<  j << " gives type " << type << endl; 
+      //  std::cout << " run for " <<  j << " gives type " << type << std::endl; 
+      //*testout << " run for " <<  j << " gives type " << type << std::endl; 
 
       if(type!=HP_NONE) break;
     }
 
-  *testout << "type = " << type << endl;
+  *testout << "type = " << type << std::endl;
     
   for(int k=0;k<3;k++) el[k] = pnums[k]; 
   /*if(type != HP_NONE) 
     {
      
-    cout << " TRIG with pnums " << pnums[0] << "\t"  << 
-    pnums[1] << "\t"  << pnums[2] << endl; 
-    cout << " type "  << type << endl; 
+    std::cout << " TRIG with pnums " << pnums[0] << "\t"  << 
+    pnums[1] << "\t"  << pnums[2] << std::endl; 
+    std::cout << " type "  << type << std::endl; 
     }
   */
       return(type);
@@ -921,7 +921,7 @@
       ep3 |= cp3;
       
       
-      // (*testout) << "cp = " << cp1 << cp2 << cp3 << ", ep = " << ep1 << ep2 << ep3 << endl;
+      // (*testout) << "cp = " << cp1 << cp2 << cp3 << ", ep = " << ep1 << ep2 << ep3 << std::endl;
 
       int p[3] = { el.PNumMod (j), el.PNumMod (j+1), el.PNumMod (j+2)};
       if(ep1)
@@ -980,7 +980,7 @@
 	      ep1 = 1; ep3=1;
 	    }
 	  
-	  // cout << " isedge " << isedge1 << " \t " << isedge2 << " \t " << isedge3 << endl;  
+	  // std::cout << " isedge " << isedge1 << " \t " << isedge2 << " \t " << isedge3 << std::endl;  
 	
 	  if (!sing_face)
             {
@@ -1031,11 +1031,11 @@
       
 		  
       /*
-        cout << " used " << face_edges.Used (INDEX_2::Sort (el.PNumMod(j), el.PNumMod(j+1))) << endl; 
+        std::cout << " used " << face_edges.Used (INDEX_2::Sort (el.PNumMod(j), el.PNumMod(j+1))) << std::endl; 
 
-        cout << " isedge " << isedge1 << " \t " << isedge2 << " \t " << isedge3 << endl; 
-        cout << " ep " << ep1 << "\t" << ep2 << " \t " << ep3 << endl; 
-        cout << " cp " << cp1 << "\t" << cp2 << " \t " << cp3 << endl; 
+        std::cout << " isedge " << isedge1 << " \t " << isedge2 << " \t " << isedge3 << std::endl; 
+        std::cout << " ep " << ep1 << "\t" << ep2 << " \t " << ep3 << std::endl; 
+        std::cout << " cp " << cp1 << "\t" << cp2 << " \t " << cp3 << std::endl; 
       */
 		  
 
@@ -1127,9 +1127,9 @@
   /*if(type != HP_NONE) 
     {
      
-    cout << " TRIG with pnums " << pnums[0] << "\t"  << 
-    pnums[1] << "\t"  << pnums[2] << endl; 
-    cout << " type "  << type << endl; 
+    std::cout << " TRIG with pnums " << pnums[0] << "\t"  << 
+    pnums[1] << "\t"  << pnums[2] << std::endl; 
+    std::cout << " type "  << type << std::endl; 
     }
   */
   return(type);
@@ -1144,7 +1144,7 @@
   int ep1(-1), ep2(-1), ep3(-1), ep4(-1), cp1(-1), cp2(-1), cp3(-1), cp4(-1);
   int isedge1, isedge2, isedge3, isedge4;
 
-  *testout << "edges = " << edges << endl;
+  *testout << "edges = " << edges << std::endl;
   
   for (int j = 1; j <= 4; j++)
     {
@@ -1301,9 +1301,9 @@
       int sumep = ep1 + ep2 + ep3 + ep4;
       int sumedge = isedge1 + isedge2 + isedge3 + isedge4;
 
-      *testout << "isedge = " << isedge1 << isedge2 << isedge3 << isedge4 << endl;
-      *testout << "iscp = " << cp1 << cp2 << cp3 << cp4 << endl;
-      *testout << "isep = " << ep1 << ep2 << ep3 << ep4 << endl;
+      *testout << "isedge = " << isedge1 << isedge2 << isedge3 << isedge4 << std::endl;
+      *testout << "iscp = " << cp1 << cp2 << cp3 << cp4 << std::endl;
+      *testout << "isep = " << ep1 << ep2 << ep3 << ep4 << std::endl;
 
       switch (sumedge)
         {
@@ -1463,23 +1463,23 @@
           pnums[3] = el.PNumMod (j+3);
           for (int k=0;k<4;k++) el[k] = pnums[k]; 
 	
-          /*  cout << " QUAD with pnums " << pnums[0] << "\t"  << 
+          /*  std::cout << " QUAD with pnums " << pnums[0] << "\t"  << 
               pnums[1] << "\t"  << pnums[2] << "\t"  << pnums[3] 
-              << endl << " of type " << type << endl; */
+              << std::endl << " of type " << type << std::endl; */
 		   		      
           break;
         }
     }
   if (type == HP_NONE)
     {
-      (*testout) << "undefined element" << endl
-                 << "cp = " << cp1 << cp2 << cp3 << cp4 << endl
-                 << "ep = " << ep1 << ep2 << ep3 << ep4 << endl
+      (*testout) << "undefined element" << std::endl
+                 << "cp = " << cp1 << cp2 << cp3 << cp4 << std::endl
+                 << "ep = " << ep1 << ep2 << ep3 << ep4 << std::endl
                  << "isedge = " << isedge1 << isedge2 << isedge3 
-                 << isedge4 << endl;
+                 << isedge4 << std::endl;
     }
 	    
-  *testout << "quad type = " << type << endl;
+  *testout << "quad type = " << type << std::endl;
 
   return type;  
 }	    
@@ -1574,9 +1574,9 @@
 	    int pnums[8]; 
 	    for(int l=0;l<8;l++) pnums[l] = el[p[l]-1];
 	    for(int l=0;l<8;l++) el[l] = pnums[l];
-	    /* cout << " HEX with pnums " << pnums[0] << "\t"  << 
+	    /* std::cout << " HEX with pnums " << pnums[0] << "\t"  << 
                pnums[1] << "\t"  << pnums[2] << "\t"  << pnums[3] << "\t"  << 
-               pnums[4] << "\t"  <<  pnums[5] << endl << " of type " << type << endl; */
+               pnums[4] << "\t"  <<  pnums[5] << std::endl << " of type " << type << std::endl; */
 	    break; 
 	  }
       }
@@ -1623,7 +1623,7 @@
   else
     hpel.type = HP_SEGM_SINGCORNERS;
   
-  // cout << " SEGM found with " << hpel[0] << " \t" << hpel[1] << endl << " of type " << hpel.type << endl; 
+  // std::cout << " SEGM found with " << hpel[0] << " \t" << hpel[1] << std::endl << " of type " << hpel.type << std::endl; 
   return(hpel.type) ; 
 } 
 
--- netgen_ref/libsrc/meshing/findip.hpp
+++ netgen/libsrc/meshing/findip.hpp
@@ -75,6 +75,9 @@
   static int timer = NgProfiler::CreateTimer ("FindInnerPoint");
   NgProfiler::RegionTimer reg (timer);
 
+  if ( points.Size() < 3 )
+    return 0;
+
   Array<Vec3d> a;
   Array<double> c;
   Mat<3> m, inv;
--- netgen_ref/libsrc/meshing/global.hpp
+++ netgen/libsrc/meshing/global.hpp
@@ -8,6 +8,8 @@
 /* Date:   01. Okt. 95                                                    */
 /**************************************************************************/
 
+#include <myadt.hpp>
+
 /*
   global functions and variables
 */
@@ -29,7 +31,7 @@
 
   extern Array<int> tets_in_qualclass;
 
-  class multithreadt
+  class DLL_HEADER multithreadt
   {
   public:
     int pause;
@@ -44,7 +46,7 @@
     multithreadt();
   };
 
-  extern volatile multithreadt multithread;
+  DLL_HEADER extern volatile multithreadt multithread;
 
   DLL_HEADER extern string ngdir;
   extern DebugParameters debugparam;
--- netgen_ref/libsrc/meshing/improve3.cpp
+++ netgen/libsrc/meshing/improve3.cpp
@@ -1219,6 +1219,7 @@
 
 	      tetused = 0;
 	      tetused[0] = 1;
+              int nbtetused = 0;
 
 	      for (int l = 2; l < nsuround; l++)
 		{
@@ -1239,10 +1240,12 @@
 			      
 			      tetused[k] = 1; 
 			      suroundpts[l] = newpi;
+                              ++nbtetused;
 			    }			
 		      }
 		}
-
+              if ( nbtetused < nsuround )
+                continue;
 	      
 	      bad1 = 0;
 	      for (int k = 0; k < nsuround; k++)
--- netgen_ref/libsrc/meshing/meshclass.hpp
+++ netgen/libsrc/meshing/meshclass.hpp
@@ -311,7 +311,7 @@
     { return lockedpoints; }
 
     /// Returns number of domains
-    int GetNDomains() const;
+    DLL_HEADER int GetNDomains() const;
 
     ///
     int GetDimension() const 
@@ -320,7 +320,7 @@
     { dimension = dim; }
 
     /// sets internal tables
-    void CalcSurfacesOfNode ();
+    void DLL_HEADER CalcSurfacesOfNode ();
 
     /// additional (temporarily) fix points 
     void FixPoints (const BitArray & fixpoints);
@@ -390,13 +390,13 @@
     ///
     DLL_HEADER void SetGlobalH (double h);
     ///
-    void SetMinimalH (double h);
+    void DLL_HEADER SetMinimalH (double h);
     ///
     double MaxHDomain (int dom) const;
     ///
     void SetMaxHDomain (const Array<double> & mhd);
     ///
-    double GetH (const Point3d & p) const;
+    double DLL_HEADER GetH (const Point3d & p) const;
     ///
     double GetMinH (const Point3d & pmin, const Point3d & pmax);
     ///
--- netgen_ref/libsrc/meshing/meshtype.cpp
+++ netgen/libsrc/meshing/meshtype.cpp
@@ -1,4 +1,5 @@
 #include <mystdlib.h>
+#include <float.h> // to get DBL_MIN defined
 
 #include "meshing.hpp"  
 
@@ -666,7 +667,8 @@
 
         double det = trans.Det();
 
-        if (det <= 0)
+        // if (det <= 0)
+        if (det <= DBL_MIN) // avoid FPE
           err += 1e12;
         else
           err += frob * frob / det;
@@ -722,7 +724,8 @@
 
             double det = trans(0,0)*trans(1,1)-trans(1,0)*trans(0,1);
 
-            if (det <= 0)
+            // if (det <= 0)
+            if (det <= DBL_MIN)  // avoid FPE
               {
                 dd = 0;
                 return 1e12;
@@ -806,7 +809,8 @@
           = dtrans(0,0) * trans(1,1) - trans(0,1) * dtrans(1,0)
           + trans(0,0) * dtrans(1,1) - dtrans(0,1) * trans(1,0);
 
-        if (det <= 0)
+        // if (det <= 0)
+        if (det <= DBL_MIN) // avoid FPE
           err += 1e12;
         else
           {
@@ -856,7 +860,8 @@
         frob /= 2;
 
         double det = trans.Det();
-        if (det <= 0)
+        //if (det <= 0)
+        if (det <= DBL_MIN) // avoid FPE
           err += 1e12;
         else
           err += frob * frob / det;
@@ -1864,7 +1869,8 @@
       case PYRAMID:
         {
           double noz = 1-p(2);
-          if (noz == 0.0) noz = 1e-10;
+          //if (noz == 0.0) noz = 1e-10;
+          if (noz <= DBL_MIN) noz = 1e-10; // avoid FPE
 
           double xi  = p(0) / noz;
           double eta = p(1) / noz;
@@ -2030,7 +2036,8 @@
 
         double det = -trans.Det();
       
-        if (det <= 0)
+        //if (det <= 0)
+        if (det <= DBL_MIN) // avoid FPE
           err += 1e12;
         else
           err += frob * frob * frob / det;
@@ -2102,7 +2109,8 @@
         ddet *= -1;
 
       
-        if (det <= 0)
+        //if (det <= 0)
+        if (det <= DBL_MIN) // avoid FPE
           err += 1e12;
         else
           {
@@ -2184,7 +2192,7 @@
       
         det *= -1;
       
-        if (det <= 0)
+        if (det <= DBL_MIN)
           err += 1e12;
         else
           {
--- netgen_ref/libsrc/meshing/meshtype.hpp
+++ netgen/libsrc/meshing/meshtype.hpp
@@ -15,6 +15,7 @@
     Classes for NETGEN
   */
 
+class Mesh; // added due to compilation errors on some platforms
 
 
   enum ELEMENT_TYPE { 
@@ -323,19 +324,19 @@
 
   public:
     ///
-    Element2d ();
+    DLL_HEADER Element2d ();
     ///
-    Element2d (int anp);
+    DLL_HEADER Element2d (int anp);
     ///
     DLL_HEADER Element2d (ELEMENT_TYPE type);
     ///
-    Element2d (int pi1, int pi2, int pi3);
+    DLL_HEADER Element2d (int pi1, int pi2, int pi3);
     ///
-    Element2d (int pi1, int pi2, int pi3, int pi4);
+    DLL_HEADER Element2d (int pi1, int pi2, int pi3, int pi4);
     ///
-    ELEMENT_TYPE GetType () const { return typ; }
+    DLL_HEADER ELEMENT_TYPE GetType () const { return typ; }
     /// 
-    void SetType (ELEMENT_TYPE atyp)
+    DLL_HEADER  void SetType (ELEMENT_TYPE atyp)
     {
       typ = atyp;
       switch (typ)
@@ -350,9 +351,9 @@
 	}
     }
     ///
-    int GetNP() const { return np; }
+    DLL_HEADER int GetNP() const { return np; }
     ///
-    int GetNV() const
+    DLL_HEADER int GetNV() const
     {
       if (typ == TRIG || typ == TRIG6)
         return 3;
@@ -360,7 +361,7 @@
         {
 #ifdef DEBUG
           if (typ != QUAD && typ != QUAD6 && typ != QUAD8)
-            PrintSysError ("element2d::GetNV not implemented for typ", typ)
+            PrintSysError ("element2d::GetNV not implemented for typ", typ);
 #endif
           return 4;
         }
@@ -384,95 +385,95 @@
     }
 
     ///
-    PointIndex & operator[] (int i) { return pnum[i]; }
+    DLL_HEADER  PointIndex & operator[] (int i) { return pnum[i]; }
     ///
-    const PointIndex & operator[] (int i) const { return pnum[i]; }
+    DLL_HEADER const PointIndex & operator[] (int i) const { return pnum[i]; }
 
-    FlatArray<const PointIndex> PNums () const 
+    DLL_HEADER  FlatArray<const PointIndex> PNums () const 
     { return FlatArray<const PointIndex> (np, &pnum[0]); }
     
     ///
-    PointIndex & PNum (int i) { return pnum[i-1]; }
+    DLL_HEADER PointIndex & PNum (int i) { return pnum[i-1]; }
     ///
-    const PointIndex & PNum (int i) const { return pnum[i-1]; }
+    DLL_HEADER const PointIndex & PNum (int i) const { return pnum[i-1]; }
     ///
-    PointIndex & PNumMod (int i) { return pnum[(i-1) % np]; }
+    DLL_HEADER PointIndex & PNumMod (int i) { return pnum[(i-1) % np]; }
     ///
-    const PointIndex & PNumMod (int i) const { return pnum[(i-1) % np]; }
+    DLL_HEADER const PointIndex & PNumMod (int i) const { return pnum[(i-1) % np]; }
     ///
 
     ///
-    PointGeomInfo & GeomInfoPi (int i) { return geominfo[i-1]; }
+    DLL_HEADER PointGeomInfo & GeomInfoPi (int i) { return geominfo[i-1]; }
     ///
-    const PointGeomInfo & GeomInfoPi (int i) const { return geominfo[i-1]; }
+    DLL_HEADER const PointGeomInfo & GeomInfoPi (int i) const { return geominfo[i-1]; }
     ///
-    PointGeomInfo & GeomInfoPiMod (int i) { return geominfo[(i-1) % np]; }
+    DLL_HEADER PointGeomInfo & GeomInfoPiMod (int i) { return geominfo[(i-1) % np]; }
     ///
-    const PointGeomInfo & GeomInfoPiMod (int i) const { return geominfo[(i-1) % np]; }
+    DLL_HEADER const PointGeomInfo & GeomInfoPiMod (int i) const { return geominfo[(i-1) % np]; }
 
 
-    void SetIndex (int si) { index = si; }
+    DLL_HEADER void SetIndex (int si) { index = si; }
     ///
-    int GetIndex () const { return index; }
+    DLL_HEADER int GetIndex () const { return index; }
 
-    int GetOrder () const { return orderx; }
-    void SetOrder (int aorder) { orderx = ordery = aorder; }
+    DLL_HEADER int GetOrder () const { return orderx; }
+    DLL_HEADER void SetOrder (int aorder) { orderx = ordery = aorder; }
 
 
-    void GetOrder (int & ox, int & oy) const { ox = orderx, oy =ordery;};
-    void GetOrder (int & ox, int & oy, int & oz) const { ox = orderx; oy = ordery; oz=0; }
-    void SetOrder (int ox, int oy, int  /* oz */) { orderx = ox; ordery = oy;}
-    void SetOrder (int ox, int oy) { orderx = ox; ordery = oy;}
+    DLL_HEADER void GetOrder (int & ox, int & oy) const { ox = orderx, oy =ordery;};
+    DLL_HEADER void GetOrder (int & ox, int & oy, int & oz) const { ox = orderx; oy = ordery; oz=0; }
+    DLL_HEADER void SetOrder (int ox, int oy, int  /* oz */) { orderx = ox; ordery = oy;}
+    DLL_HEADER void SetOrder (int ox, int oy) { orderx = ox; ordery = oy;}
 
 
     ///
-    void GetBox (const T_POINTS & points, Box3d & box) const;
+    DLL_HEADER void GetBox (const T_POINTS & points, Box3d & box) const;
     /// invert orientation
-    inline void Invert ();
+    DLL_HEADER inline void Invert ();
     ///
-    void Invert2 ();
+    DLL_HEADER void Invert2 ();
     /// first point number is smallest
-    inline void NormalizeNumbering ();
+    DLL_HEADER inline void NormalizeNumbering ();
     ///
-    void NormalizeNumbering2 ();
+    DLL_HEADER void NormalizeNumbering2 ();
 
-    bool BadElement() const { return badel; }
+    DLL_HEADER bool BadElement() const { return badel; }
 
     // friend ostream & operator<<(ostream  & s, const Element2d & el);
     friend class Mesh;
 
 
     /// get number of 'integration points'
-    int GetNIP () const;
-    void GetIntegrationPoint (int ip, Point2d & p, double & weight) const;
+    DLL_HEADER int GetNIP () const;
+    DLL_HEADER void GetIntegrationPoint (int ip, Point2d & p, double & weight) const;
 
-    void GetTransformation (int ip, const Array<Point2d> & points,
+    DLL_HEADER void GetTransformation (int ip, const Array<Point2d> & points,
 			    class DenseMatrix & trans) const;
-    void GetTransformation (int ip, class DenseMatrix & pmat,
+    DLL_HEADER void GetTransformation (int ip, class DenseMatrix & pmat,
 			    class DenseMatrix & trans) const;
 
-    void GetShape (const Point2d & p, class Vector & shape) const;
-    void GetShapeNew (const Point<2> & p, class FlatVector & shape) const;
+    DLL_HEADER void GetShape (const Point2d & p, class Vector & shape) const;
+    DLL_HEADER void GetShapeNew (const Point<2> & p, class FlatVector & shape) const;
     /// matrix 2 * np
-    void GetDShape (const Point2d & p, class DenseMatrix & dshape) const;
-    void GetDShapeNew (const Point<2> & p, class MatrixFixWidth<2> & dshape) const;
+    DLL_HEADER void GetDShape (const Point2d & p, class DenseMatrix & dshape) const;
+    DLL_HEADER void GetDShapeNew (const Point<2> & p, class MatrixFixWidth<2> & dshape) const;
     /// matrix 2 * np
-    void GetPointMatrix (const Array<Point2d> & points,
+    DLL_HEADER void GetPointMatrix (const Array<Point2d> & points,
 			 class DenseMatrix & pmat) const; 
 
-    void ComputeIntegrationPointData () const;
+    DLL_HEADER void ComputeIntegrationPointData () const;
   
 
-    double CalcJacobianBadness (const Array<Point2d> & points) const;
-    double CalcJacobianBadness (const T_POINTS & points, 
+    DLL_HEADER double CalcJacobianBadness (const Array<Point2d> & points) const;
+    DLL_HEADER double CalcJacobianBadness (const T_POINTS & points, 
 				const Vec<3> & n) const;
-    double CalcJacobianBadnessDirDeriv (const Array<Point2d> & points,
+    DLL_HEADER double CalcJacobianBadnessDirDeriv (const Array<Point2d> & points,
 					int pi, Vec2d & dir, double & dd) const;
 
 
 
-    void Delete () { deleted = 1; pnum[0] = pnum[1] = pnum[2] = pnum[3] = PointIndex::BASE-1; }
-    bool IsDeleted () const 
+    DLL_HEADER void Delete () { deleted = 1; pnum[0] = pnum[1] = pnum[2] = pnum[3] = PointIndex::BASE-1; }
+    DLL_HEADER bool IsDeleted () const 
     {
 #ifdef DEBUG
       if (pnum[0] < PointIndex::BASE && !deleted)
@@ -483,27 +484,27 @@
 
     // Philippose - 08 August 2010
     // Access functions for the new property: visible
-    void Visible(bool vis = 1) 
+    DLL_HEADER void Visible(bool vis = 1) 
     { visible = vis; }
-    bool IsVisible () const 
+    DLL_HEADER bool IsVisible () const 
     { return visible; }
    
-    void SetRefinementFlag (bool rflag = 1) 
+    DLL_HEADER void SetRefinementFlag (bool rflag = 1) 
     { refflag = rflag; }
-    bool TestRefinementFlag () const
+    DLL_HEADER bool TestRefinementFlag () const
     { return refflag; }
 
-    void SetStrongRefinementFlag (bool rflag = 1) 
+    DLL_HEADER void SetStrongRefinementFlag (bool rflag = 1) 
     { strongrefflag = rflag; }
-    bool TestStrongRefinementFlag () const
+    DLL_HEADER bool TestStrongRefinementFlag () const
     { return strongrefflag; }
 
   
-    SurfaceElementIndex NextElement() { return next; }
+    DLL_HEADER SurfaceElementIndex NextElement() { return next; }
 
-    bool operator==(const Element2d & el2) const;
+    DLL_HEADER bool operator==(const Element2d & el2) const;
 
-    int HasFace(const Element2d& el) const;
+    DLL_HEADER int HasFace(const Element2d& el) const;
     ///
     int meshdocval;
     ///
@@ -516,7 +517,7 @@
   };
 
 
-  ostream & operator<<(ostream  & s, const Element2d & el);
+  DLL_HEADER ostream & operator<<(ostream  & s, const Element2d & el);
 
 
 
@@ -618,7 +619,7 @@
 	  return 8;
 	default:
 #ifdef DEBUG
-	  PrintSysError ("Element3d::GetNV not implemented for typ ", typ)
+	  PrintSysError ("Element3d::GetNV not implemented for typ ", typ);
 #endif
 	    ;
 	}
@@ -682,7 +683,7 @@
 	case PRISM12: return 5;
 	default:
 #ifdef DEBUG
-	  PrintSysError ("element3d::GetNFaces not implemented for typ", typ)
+	  PrintSysError ("element3d::GetNFaces not implemented for typ", typ);
 #endif
 	    ;
 	}
--- netgen_ref/libsrc/occ/Makefile.am
+++ netgen/libsrc/occ/Makefile.am
@@ -14,10 +14,10 @@
 
 METASOURCES = AUTO
 
-lib_LTLIBRARIES = libocc.la
+noinst_LTLIBRARIES = libocc.la
 
 if NGGUI
-lib_LTLIBRARIES += liboccvis.la 
+lib_LTLIBRARIES = liboccvis.la 
 endif
 
 
--- netgen_ref/libsrc/occ/Partition_Inter2d.cxx
+++ netgen/libsrc/occ/Partition_Inter2d.cxx
@@ -47,9 +47,7 @@
 #include <TopOpeBRep_EdgesIntersector.hxx>
 #include <TopOpeBRep_Point2d.hxx>
 #include <TopTools_ListIteratorOfListOfShape.hxx>
-#include <TopTools_ListOfShape.hxx>
 #include <TopTools_MapIteratorOfMapOfShape.hxx>
-#include <TopTools_MapOfShape.hxx>
 #include <TopoDS.hxx>
 #include <TopoDS_Edge.hxx>
 #include <TopoDS_Vertex.hxx>
--- netgen_ref/libsrc/occ/Partition_Inter2d.hxx
+++ netgen/libsrc/occ/Partition_Inter2d.hxx
@@ -27,7 +27,9 @@
 #ifndef _Partition_Inter2d_HeaderFile
 #define _Partition_Inter2d_HeaderFile
 
-#ifndef _Handle_BRepAlgo_AsDes_HeaderFile
+#include <Standard_Version.hxx>
+
+#if OCC_VERSION_MAJOR < 7
 #include <Handle_BRepAlgo_AsDes.hxx>
 #endif
 #ifndef _Standard_Real_HeaderFile
@@ -36,11 +38,13 @@
 #ifndef _Standard_Boolean_HeaderFile
 #include <Standard_Boolean.hxx>
 #endif
+
+#include <TopTools_MapOfShape.hxx>
+#include <TopTools_ListOfShape.hxx>
+
 class BRepAlgo_AsDes;
 class TopoDS_Face;
-class TopTools_MapOfShape;
 class TopoDS_Vertex;
-class TopTools_ListOfShape;
 class TopoDS_Edge;
 
 
--- netgen_ref/libsrc/occ/Partition_Inter3d.cxx
+++ netgen/libsrc/occ/Partition_Inter3d.cxx
@@ -48,7 +48,6 @@
 #include <TopOpeBRepTool_BoxSort.hxx>
 #include <TopTools_DataMapIteratorOfDataMapOfShapeListOfShape.hxx>
 #include <TopTools_ListIteratorOfListOfShape.hxx>
-#include <TopTools_ListOfShape.hxx>
 #include <TopoDS.hxx>
 #include <TopoDS_Compound.hxx>
 #include <TopoDS_Edge.hxx>
@@ -206,7 +205,7 @@
   Handle (Geom_Surface) S   = BRep_Tool::Surface(F,L);
 
   if (S->IsKind(STANDARD_TYPE(Geom_RectangularTrimmedSurface))) {
-    S = (*(Handle_Geom_RectangularTrimmedSurface*)&S)->BasisSurface();
+    S = Handle(Geom_RectangularTrimmedSurface)::DownCast (S)->BasisSurface();
   }
   if (!S->IsUPeriodic() && !S->IsVPeriodic())
     return;
--- netgen_ref/libsrc/occ/Partition_Inter3d.hxx
+++ netgen/libsrc/occ/Partition_Inter3d.hxx
@@ -27,7 +27,9 @@
 #ifndef _Partition_Inter3d_HeaderFile
 #define _Partition_Inter3d_HeaderFile
 
-#ifndef _Handle_BRepAlgo_AsDes_HeaderFile
+#include <Standard_Version.hxx>
+
+#if OCC_VERSION_MAJOR < 7
 #include <Handle_BRepAlgo_AsDes.hxx>
 #endif
 #ifndef _TopTools_DataMapOfShapeListOfShape_HeaderFile
@@ -36,6 +38,9 @@
 #ifndef _TopTools_MapOfShape_HeaderFile
 #include <TopTools_MapOfShape.hxx>
 #endif
+#ifndef _TopTools_ListOfShape_HeaderFile
+#include <TopTools_ListOfShape.hxx>
+#endif
 #ifndef _TopTools_DataMapOfShapeShape_HeaderFile
 #include <TopTools_DataMapOfShapeShape.hxx>
 #endif
@@ -43,10 +48,7 @@
 #include <Standard_Boolean.hxx>
 #endif
 class BRepAlgo_AsDes;
-class TopTools_ListOfShape;
-class TopTools_DataMapOfShapeShape;
 class TopoDS_Face;
-class TopTools_MapOfShape;
 class TopoDS_Shape;
 class TopoDS_Vertex;
 class TopoDS_Edge;
@@ -83,13 +85,13 @@
    void FacesPartition(const TopoDS_Face& F1,const TopoDS_Face& F2) ;
    Standard_Boolean IsDone(const TopoDS_Face& F1,const TopoDS_Face& F2) const;
    TopTools_MapOfShape& TouchedFaces() ;
-   Handle_BRepAlgo_AsDes AsDes() const;
+   Handle(BRepAlgo_AsDes) AsDes() const;
    TopTools_MapOfShape& NewEdges() ;
    Standard_Boolean HasSameDomainF(const TopoDS_Shape& F) const;
    Standard_Boolean IsSameDomainF(const TopoDS_Shape& F1,const TopoDS_Shape& F2) const;
    const TopTools_ListOfShape& SameDomain(const TopoDS_Face& F) const;
    TopoDS_Vertex ReplaceSameDomainV(const TopoDS_Vertex& V,const TopoDS_Edge& E) const;
-   Handle_BRepAlgo_AsDes SectionEdgesAD() const;
+   Handle(BRepAlgo_AsDes) SectionEdgesAD() const;
    Standard_Boolean IsSectionEdge(const TopoDS_Edge& E) const;
    Standard_Boolean HasSectionEdge(const TopoDS_Face& F) const;
    Standard_Boolean IsSplitOn(const TopoDS_Edge& NewE,const TopoDS_Edge& OldE,const TopoDS_Face& F) const;
@@ -121,11 +123,11 @@
 
    // Fields PRIVATE
    //
-   Handle_BRepAlgo_AsDes myAsDes;
+   Handle(BRepAlgo_AsDes) myAsDes;
    TopTools_DataMapOfShapeListOfShape myDone;
    TopTools_MapOfShape myTouched;
    TopTools_MapOfShape myNewEdges;
-   Handle_BRepAlgo_AsDes mySectionEdgesAD;
+   Handle(BRepAlgo_AsDes) mySectionEdgesAD;
    TopTools_DataMapOfShapeListOfShape mySameDomainFM;
    TopTools_DataMapOfShapeShape mySameDomainVM;
 
--- netgen_ref/libsrc/occ/Partition_Loop.hxx
+++ netgen/libsrc/occ/Partition_Loop.hxx
@@ -38,8 +38,6 @@
 #endif
 class TopoDS_Face;
 class TopoDS_Edge;
-class TopTools_ListOfShape;
-
 
 #ifndef _Standard_HeaderFile
 #include <Standard.hxx>
--- netgen_ref/libsrc/occ/Partition_Loop2d.cxx
+++ netgen/libsrc/occ/Partition_Loop2d.cxx
@@ -210,7 +210,7 @@
     Cc->D1(uc, PC, CTg1);
     if (!isForward) CTg1.Reverse();
 
-    Standard_Real anglemin = 3 * PI, tolAng = 1.e-8;
+    Standard_Real anglemin = 3 * M_PI, tolAng = 1.e-8;
 
     // select an edge whose first derivative is most left of CTg1
     // ie an angle between Tg1 and CTg1 is least
@@ -234,7 +234,7 @@
       // -PI < angle < PI
       Standard_Real angle = Tg1.Angle(CTg1);
 
-      if (PI - Abs(angle) <= tolAng)
+      if (M_PI - Abs(angle) <= tolAng)
       {
         // an angle is too close to PI; assure that an angle sign really
         // reflects an edge position: +PI - an edge is worst,
--- netgen_ref/libsrc/occ/Partition_Loop2d.hxx
+++ netgen/libsrc/occ/Partition_Loop2d.hxx
@@ -24,7 +24,6 @@
 #endif
 class TopoDS_Face;
 class TopoDS_Edge;
-class TopTools_ListOfShape;
 class BRepAlgo_Image;
 
 
--- netgen_ref/libsrc/occ/Partition_Loop3d.hxx
+++ netgen/libsrc/occ/Partition_Loop3d.hxx
@@ -13,6 +13,9 @@
 #ifndef _TopTools_ListOfShape_HeaderFile
 #include <TopTools_ListOfShape.hxx>
 #endif
+#ifndef _TopTools_MapOfOrientedShape_HeaderFile
+#include <TopTools_MapOfOrientedShape.hxx>
+#endif
 #ifndef _TopTools_IndexedDataMapOfShapeListOfShape_HeaderFile
 #include <TopTools_IndexedDataMapOfShapeListOfShape.hxx>
 #endif
@@ -23,8 +26,6 @@
 #include <Standard_Real.hxx>
 #endif
 class TopoDS_Shape;
-class TopTools_ListOfShape;
-class TopTools_MapOfOrientedShape;
 class TopoDS_Edge;
 class TopoDS_Face;
 class gp_Vec;
--- netgen_ref/libsrc/occ/Partition_Spliter.cxx
+++ netgen/libsrc/occ/Partition_Spliter.cxx
@@ -48,7 +48,6 @@
 #include <TopTools_IndexedDataMapOfShapeListOfShape.hxx>
 #include <TopTools_IndexedMapOfShape.hxx>
 #include <TopTools_ListIteratorOfListOfShape.hxx>
-#include <TopTools_ListOfShape.hxx>
 #include <TopTools_MapIteratorOfMapOfShape.hxx>
 #include <TopTools_SequenceOfShape.hxx>
 
--- netgen_ref/libsrc/occ/Partition_Spliter.hxx
+++ netgen/libsrc/occ/Partition_Spliter.hxx
@@ -28,9 +28,6 @@
 #ifndef _TopTools_DataMapOfShapeShape_HeaderFile
 #include <TopTools_DataMapOfShapeShape.hxx>
 #endif
-#ifndef _Handle_BRepAlgo_AsDes_HeaderFile
-#include <Handle_BRepAlgo_AsDes.hxx>
-#endif
 #ifndef _BRepAlgo_Image_HeaderFile
 #include <BRepAlgo_Image.hxx>
 #endif
@@ -45,7 +42,6 @@
 #endif
 class BRepAlgo_AsDes;
 class TopoDS_Shape;
-class TopTools_ListOfShape;
 class TopoDS_Edge;
 
 
@@ -129,7 +125,7 @@
    TopTools_DataMapOfShapeShape myFaceShapeMap;
    TopTools_DataMapOfShapeShape myInternalFaces;
    TopTools_DataMapOfShapeShape myIntNotClFaces;
-   Handle_BRepAlgo_AsDes myAsDes;
+   Handle(BRepAlgo_AsDes) myAsDes;
    BRepAlgo_Image myImagesFaces;
    BRepAlgo_Image myImagesEdges;
    BRepAlgo_Image myImageShape;
--- netgen_ref/libsrc/occ/occconstruction.cpp
+++ netgen/libsrc/occ/occconstruction.cpp
@@ -28,7 +28,7 @@
 #include <BRepAlgoAPI_Common.hxx>
 #include <BRepAlgoAPI_Fuse.hxx>
 #include <BRepAlgoAPI_Section.hxx>
-#include <BRepOffsetAPI_Sewing.hxx>
+//#include <BRepOffsetAPI_Sewing.hxx>
 //#include <BRepAlgo_Sewing.hxx>
 #include <BRepOffsetAPI_MakeOffsetShape.hxx>
 #include <ShapeFix_Shape.hxx>
--- netgen_ref/libsrc/occ/occgenmesh.cpp
+++ netgen/libsrc/occ/occgenmesh.cpp
@@ -1,1467 +1,1570 @@
-#ifdef OCCGEOMETRY
-
-#include <mystdlib.h>
-#include <occgeom.hpp>
-#include <meshing.hpp>
-
-
-namespace netgen
-{
-
-#include "occmeshsurf.hpp"
-
-#define TCL_OK 0
-#define TCL_ERROR 1
-
-#define DIVIDEEDGESECTIONS 1000
-#define IGNORECURVELENGTH 1e-4
-#define VSMALL 1e-10
-
-
-   bool merge_solids = 1;
-
-
-  // can you please explain what you intend to compute here (JS) !!!
-   double Line :: Dist (Line l)
-   {
-      Vec<3> n = p1-p0;
-      Vec<3> q = l.p1-l.p0;
-      double nq = n*q;
-
-      Point<3> p = p0 + 0.5*n;
-      double lambda = (p-l.p0)*n / (nq + VSMALL);
-
-      if (lambda >= 0 && lambda <= 1)
-      {
-         double d = (p-l.p0-lambda*q).Length();
-         //        if (d < 1e-3) d = 1e99;
-         return d;
-      }
-      else
-         return 1e99;
-   }
-
-
-
-   double Line :: Length ()
-   {
-      return (p1-p0).Length();
-   }
-
-
-
-   inline Point<3> occ2ng (const gp_Pnt & p)
-   {
-      return  Point<3> (p.X(), p.Y(), p.Z());
-   }
-
-
-
-   double ComputeH (double kappa)
-   {
-      double hret;
-      kappa *= mparam.curvaturesafety;
-
-      if (mparam.maxh * kappa < 1)
-         hret = mparam.maxh;
-      else
-         hret = 1 / (kappa + VSMALL);
-
-      if (mparam.maxh < hret)
-         hret = mparam.maxh;
-
-      return (hret);
-   }
-
-
-
-
-   void RestrictHTriangle (gp_Pnt2d & par0, gp_Pnt2d & par1, gp_Pnt2d & par2,
-                           BRepLProp_SLProps * prop, Mesh & mesh, int depth, double h = 0)
-   {
-      int ls = -1;
-
-      gp_Pnt pnt0,pnt1,pnt2;
-
-      prop->SetParameters (par0.X(), par0.Y());
-      pnt0 = prop->Value();
-
-      prop->SetParameters (par1.X(), par1.Y());
-      pnt1 = prop->Value();
-
-      prop->SetParameters (par2.X(), par2.Y());
-      pnt2 = prop->Value();
-
-      double aux;
-      double maxside = pnt0.Distance(pnt1);
-      ls = 2;
-      aux = pnt1.Distance(pnt2);
-      if(aux > maxside)
-      {
-         maxside = aux;
-         ls = 0;
-      }
-      aux = pnt2.Distance(pnt0);
-      if(aux > maxside)
-      {
-         maxside = aux;
-         ls = 1;
-      }
-
-
-
-      gp_Pnt2d parmid;
-
-      parmid.SetX( (par0.X()+par1.X()+par2.X()) / 3 );
-      parmid.SetY( (par0.Y()+par1.Y()+par2.Y()) / 3 );
-
-      if (depth%3 == 0)
-      {
-         double curvature = 0;
-
-         prop->SetParameters (parmid.X(), parmid.Y());
-         if (!prop->IsCurvatureDefined())
-         {
-            (*testout) << "curvature not defined!" << endl;
-            return;
-         }
-         curvature = max(fabs(prop->MinCurvature()),
-            fabs(prop->MaxCurvature()));
-
-         prop->SetParameters (par0.X(), par0.Y());
-         if (!prop->IsCurvatureDefined())
-         {
-            (*testout) << "curvature not defined!" << endl;
-            return;
-         }
-         curvature = max(curvature,max(fabs(prop->MinCurvature()),
-            fabs(prop->MaxCurvature())));
-
-         prop->SetParameters (par1.X(), par1.Y());
-         if (!prop->IsCurvatureDefined())
-         {
-            (*testout) << "curvature not defined!" << endl;
-            return;
-         }
-         curvature = max(curvature,max(fabs(prop->MinCurvature()),
-            fabs(prop->MaxCurvature())));
-
-         prop->SetParameters (par2.X(), par2.Y());
-         if (!prop->IsCurvatureDefined())
-         {
-            (*testout) << "curvature not defined!" << endl;
-            return;
-         }
-         curvature = max(curvature,max(fabs(prop->MinCurvature()),
-            fabs(prop->MaxCurvature())));
-
-         //(*testout) << "curvature " << curvature << endl;
-
-         if (curvature < 1e-3)
-         {
-            //(*testout) << "curvature too small (" << curvature << ")!" << endl;
-            return;
-            // return war bis 10.2.05 auskommentiert
-         }
-
-
-
-         h = ComputeH (curvature+1e-10);
-
-         if(h < 1e-4*maxside)
-            return;
-
-
-         if (h > 30) return;
-      }
-
-      if (h < maxside && depth < 10)
-      {
-         //cout << "\r h " << h << flush;
-         gp_Pnt2d pm;
-
-         //cout << "h " << h << " maxside " << maxside << " depth " << depth << endl;
-         //cout << "par0 " << par0.X() << " " << par0.Y()
-         //<< " par1 " << par1.X() << " " << par1.Y()
-         //   << " par2 " << par2.X() << " " << par2.Y()<< endl;
-
-         if(ls == 0)
-         {
-            pm.SetX(0.5*(par1.X()+par2.X())); pm.SetY(0.5*(par1.Y()+par2.Y()));
-            RestrictHTriangle(pm, par2, par0, prop, mesh, depth+1, h);
-            RestrictHTriangle(pm, par0, par1, prop, mesh, depth+1, h);
-         }
-         else if(ls == 1)
-         {
-            pm.SetX(0.5*(par0.X()+par2.X())); pm.SetY(0.5*(par0.Y()+par2.Y()));
-            RestrictHTriangle(pm, par1, par2, prop, mesh, depth+1, h);
-            RestrictHTriangle(pm, par0, par1, prop, mesh, depth+1, h);
-         }
-         else if(ls == 2)
-         {
-            pm.SetX(0.5*(par0.X()+par1.X())); pm.SetY(0.5*(par0.Y()+par1.Y()));
-            RestrictHTriangle(pm, par1, par2, prop, mesh, depth+1, h);
-            RestrictHTriangle(pm, par2, par0, prop, mesh, depth+1, h);
-         }
-
-      }
-      else
-      {
-         gp_Pnt pnt;
-         Point3d p3d;
-
-         prop->SetParameters (parmid.X(), parmid.Y());
-         pnt = prop->Value();
-         p3d = Point3d(pnt.X(), pnt.Y(), pnt.Z());
-         mesh.RestrictLocalH (p3d, h);
-
-         p3d = Point3d(pnt0.X(), pnt0.Y(), pnt0.Z());
-         mesh.RestrictLocalH (p3d, h);
-
-         p3d = Point3d(pnt1.X(), pnt1.Y(), pnt1.Z());
-         mesh.RestrictLocalH (p3d, h);
-
-         p3d = Point3d(pnt2.X(), pnt2.Y(), pnt2.Z());
-         mesh.RestrictLocalH (p3d, h);
-
-         //(*testout) << "p = " << p3d << ", h = " << h << ", maxside = " << maxside << endl;
-
-      }
-   }
-
-
-
-   void DivideEdge (TopoDS_Edge & edge, Array<MeshPoint> & ps,
-                    Array<double> & params, Mesh & mesh)
-   {
-      double s0, s1;
-      double maxh = mparam.maxh;
-      int nsubedges = 1;
-      gp_Pnt pnt, oldpnt;
-      double svalue[DIVIDEEDGESECTIONS];
-
-      GProp_GProps system;
-      BRepGProp::LinearProperties(edge, system);
-      double L = system.Mass();
-
-      Handle(Geom_Curve) c = BRep_Tool::Curve(edge, s0, s1);
-
-      double hvalue[DIVIDEEDGESECTIONS+1];
-      hvalue[0] = 0;
-      pnt = c->Value(s0);
-
-      double olddist = 0;
-      double dist = 0;
-
-      int tmpVal = (int)(DIVIDEEDGESECTIONS);
-
-      for (int i = 1; i <= tmpVal; i++)
-      {
-         oldpnt = pnt;
-         pnt = c->Value(s0+(i/double(DIVIDEEDGESECTIONS))*(s1-s0));
-         hvalue[i] = hvalue[i-1] +
-            1.0/mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))*
-            pnt.Distance(oldpnt);
-
-         //(*testout) << "mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z())) " << mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))
-         //	   <<  " pnt.Distance(oldpnt) " << pnt.Distance(oldpnt) << endl;
-
-         olddist = dist;
-         dist = pnt.Distance(oldpnt);
-      }
-
-      //  nsubedges = int(ceil(hvalue[DIVIDEEDGESECTIONS]));
-      nsubedges = max (1, int(floor(hvalue[DIVIDEEDGESECTIONS]+0.5)));
-
-      ps.SetSize(nsubedges-1);
-      params.SetSize(nsubedges+1);
-
-      int i = 1;
-      int i1 = 0;
-      do
-      {
-         if (hvalue[i1]/hvalue[DIVIDEEDGESECTIONS]*nsubedges >= i)
-         {
-            params[i] = s0+(i1/double(DIVIDEEDGESECTIONS))*(s1-s0);
-            pnt = c->Value(params[i]);
-            ps[i-1] = MeshPoint (Point3d(pnt.X(), pnt.Y(), pnt.Z()));
-            i++;
-         }
-         i1++;
-         if (i1 > DIVIDEEDGESECTIONS)
-         {
-            nsubedges = i;
-            ps.SetSize(nsubedges-1);
-            params.SetSize(nsubedges+1);
-            cout << "divide edge: local h too small" << endl;
-         }
-      } while (i < nsubedges);
-
-      params[0] = s0;
-      params[nsubedges] = s1;
-
-      if (params[nsubedges] <= params[nsubedges-1])
-      {
-         cout << "CORRECTED" << endl;
-         ps.SetSize (nsubedges-2);
-         params.SetSize (nsubedges);
-         params[nsubedges] = s1;
-      }
-   }
-
-
-
-
-   void OCCFindEdges (OCCGeometry & geom, Mesh & mesh)
-   {
-      const char * savetask = multithread.task;
-      multithread.task = "Edge meshing";
-
-      (*testout) << "edge meshing" << endl;
-
-      int nvertices = geom.vmap.Extent();
-      int nedges = geom.emap.Extent();
-
-      (*testout) << "nvertices = " << nvertices << endl;
-      (*testout) << "nedges = " << nedges << endl;
-
-      double eps = 1e-6 * geom.GetBoundingBox().Diam();
-
-      for (int i = 1; i <= nvertices; i++)
-      {
-         gp_Pnt pnt = BRep_Tool::Pnt (TopoDS::Vertex(geom.vmap(i)));
-         MeshPoint mp( Point<3>(pnt.X(), pnt.Y(), pnt.Z()) );
-
-         bool exists = 0;
-         if (merge_solids)
-            for (PointIndex pi = 1; pi <= mesh.GetNP(); pi++)
-               if ( Dist2 (mesh[pi], Point<3>(mp)) < eps*eps)
-               {
-                  exists = 1;
-                  break;
-               }
-
-               if (!exists)
-                  mesh.AddPoint (mp);
-      }
-
-      (*testout) << "different vertices = " << mesh.GetNP() << endl;
-
-
-      int first_ep = mesh.GetNP()+1;
-
-      Array<int> face2solid[2];
-      for (int i = 0; i<2; i++)
-      {
-         face2solid[i].SetSize (geom.fmap.Extent());
-         face2solid[i] = 0;
-      }
-
-      int solidnr = 0;
-      for (TopExp_Explorer exp0(geom.shape, TopAbs_SOLID); exp0.More(); exp0.Next())
-      {
-         solidnr++;
-         for (TopExp_Explorer exp1(exp0.Current(), TopAbs_FACE); exp1.More(); exp1.Next())
-         {
-            TopoDS_Face face = TopoDS::Face(exp1.Current());
-            int facenr = geom.fmap.FindIndex(face);
-
-            if (face2solid[0][facenr-1] == 0)
-               face2solid[0][facenr-1] = solidnr;
-            else
-               face2solid[1][facenr-1] = solidnr;
-         }
-      }
-
-
-      int total = 0;
-      for (int i3 = 1; i3 <= geom.fmap.Extent(); i3++)
-         for (TopExp_Explorer exp2(geom.fmap(i3), TopAbs_WIRE); exp2.More(); exp2.Next())
-            for (TopExp_Explorer exp3(exp2.Current(), TopAbs_EDGE); exp3.More(); exp3.Next())
-               total++;
-
-
-      int facenr = 0;
-      int edgenr = 0;
-
-
-      (*testout) << "faces = " << geom.fmap.Extent() << endl;
-      int curr = 0;
-
-      for (int i3 = 1; i3 <= geom.fmap.Extent(); i3++)
-      {
-         TopoDS_Face face = TopoDS::Face(geom.fmap(i3));
-         facenr = geom.fmap.FindIndex (face);       // sollte doch immer == i3 sein ??? JS
-
-         int solidnr0 = face2solid[0][i3-1];
-         int solidnr1 = face2solid[1][i3-1];
-
-         /* auskommentiert am 3.3.05 von robert
-         for (exp2.Init (geom.somap(solidnr0), TopAbs_FACE); exp2.More(); exp2.Next())
-         {
-         TopoDS_Face face2 = TopoDS::Face(exp2.Current());
-         if (geom.fmap.FindIndex(face2) == facenr)
-         {
-         //		      if (face.Orientation() != face2.Orientation()) swap (solidnr0, solidnr1);
-         }
-         }
-         */
-
-         mesh.AddFaceDescriptor (FaceDescriptor(facenr, solidnr0, solidnr1, 0));
-
-         // Philippose - 06/07/2009
-         // Add the face colour to the mesh data
-         Quantity_Color face_colour;
-
-         if(!(geom.face_colours.IsNull())
-            && (geom.face_colours->GetColor(face,XCAFDoc_ColorSurf,face_colour)))
-         {
-            mesh.GetFaceDescriptor(facenr).SetSurfColour(Vec3d(face_colour.Red(),face_colour.Green(),face_colour.Blue()));
-         }
-         else
-         {
-            mesh.GetFaceDescriptor(facenr).SetSurfColour(Vec3d(0.0,1.0,0.0));
-         }
-         // ACHTUNG! STIMMT NICHT ALLGEMEIN (RG)
-
-
-         Handle(Geom_Surface) occface = BRep_Tool::Surface(face);
-
-         for (TopExp_Explorer exp2 (face, TopAbs_WIRE); exp2.More(); exp2.Next())
-         {
-            TopoDS_Shape wire = exp2.Current();
-
-            for (TopExp_Explorer exp3 (wire, TopAbs_EDGE); exp3.More(); exp3.Next())
-            {
-               curr++;
-               (*testout) << "edge nr " << curr << endl;
-
-               multithread.percent = 100 * curr / double (total);
-               if (multithread.terminate) return;
-
-               TopoDS_Edge edge = TopoDS::Edge (exp3.Current());
-               if (BRep_Tool::Degenerated(edge))
-               {
-                  //(*testout) << "ignoring degenerated edge" << endl;
-                  continue;
-               }
-
-               if (geom.vmap.FindIndex(TopExp::FirstVertex (edge)) ==
-                  geom.vmap.FindIndex(TopExp::LastVertex (edge)))
-               {
-                  GProp_GProps system;
-                  BRepGProp::LinearProperties(edge, system);
-
-                  if (system.Mass() < eps)
-                  {
-                     cout << "ignoring edge " << geom.emap.FindIndex (edge)
-                        << ". closed edge with length < " << eps << endl;
-                     continue;
-                  }
-               }
-
-
-               Handle(Geom2d_Curve) cof;
-               double s0, s1;
-               cof = BRep_Tool::CurveOnSurface (edge, face, s0, s1);
-
-               int geomedgenr = geom.emap.FindIndex(edge);
-
-               Array <MeshPoint> mp;
-               Array <double> params;
-
-               DivideEdge (edge, mp, params, mesh);
- 
-               Array <int> pnums;
-               pnums.SetSize (mp.Size()+2);
-
-               if (!merge_solids)
-               {
-                  pnums[0] = geom.vmap.FindIndex (TopExp::FirstVertex (edge));
-                  pnums[pnums.Size()-1] = geom.vmap.FindIndex (TopExp::LastVertex (edge));
-               }
-               else
-               {
-                  Point<3> fp = occ2ng (BRep_Tool::Pnt (TopExp::FirstVertex (edge)));
-                  Point<3> lp = occ2ng (BRep_Tool::Pnt (TopExp::LastVertex (edge)));
-
-                  pnums[0] = -1;
-                  pnums.Last() = -1;
-                  for (PointIndex pi = 1; pi < first_ep; pi++)
-                  {
-                     if (Dist2 (mesh[pi], fp) < eps*eps) pnums[0] = pi;
-                     if (Dist2 (mesh[pi], lp) < eps*eps) pnums.Last() = pi;
-                  }
-               }
-
-
-               for (int i = 1; i <= mp.Size(); i++)
-               {
-                  bool exists = 0;
-                  int j;
-                  for (j = first_ep; j <= mesh.GetNP(); j++)
-                     if ((mesh.Point(j)-Point<3>(mp[i-1])).Length() < eps)
-                     {
-                        exists = 1;
-                        break;
-                     }
-
-                     if (exists)
-                        pnums[i] = j;
-                     else
-                     {
-                        mesh.AddPoint (mp[i-1]);
-                        (*testout) << "add meshpoint " << mp[i-1] << endl;
-                        pnums[i] = mesh.GetNP();
-                     }
-               }
-               (*testout) << "NP = " << mesh.GetNP() << endl;
-
-               //(*testout) << pnums[pnums.Size()-1] << endl;
-
-               for (int i = 1; i <= mp.Size()+1; i++)
-               {
-                  edgenr++;
-                  Segment seg;
-
-                  seg[0] = pnums[i-1];
-                  seg[1] = pnums[i];
-                  seg.edgenr = edgenr;
-                  seg.si = facenr;
-                  seg.epgeominfo[0].dist = params[i-1];
-                  seg.epgeominfo[1].dist = params[i];
-                  seg.epgeominfo[0].edgenr = geomedgenr;
-                  seg.epgeominfo[1].edgenr = geomedgenr;
-
-                  gp_Pnt2d p2d;
-                  p2d = cof->Value(params[i-1]);
-                  //			if (i == 1) p2d = cof->Value(s0);
-                  seg.epgeominfo[0].u = p2d.X();
-                  seg.epgeominfo[0].v = p2d.Y();
-                  p2d = cof->Value(params[i]);
-                  //			if (i == mp.Size()+1) p2d = cof -> Value(s1);
-                  seg.epgeominfo[1].u = p2d.X();
-                  seg.epgeominfo[1].v = p2d.Y();
-
-                  /*
-                  if (occface->IsUPeriodic())
-                  {
-                  cout << "U Periodic" << endl;
-                  if (fabs(seg.epgeominfo[1].u-seg.epgeominfo[0].u) >
-                  fabs(seg.epgeominfo[1].u-
-                  (seg.epgeominfo[0].u-occface->UPeriod())))
-                  seg.epgeominfo[0].u = p2d.X()+occface->UPeriod();
-
-                  if (fabs(seg.epgeominfo[1].u-seg.epgeominfo[0].u) >
-                  fabs(seg.epgeominfo[1].u-
-                  (seg.epgeominfo[0].u+occface->UPeriod())))
-                  seg.epgeominfo[0].u = p2d.X()-occface->UPeriod();
-                  }
-
-                  if (occface->IsVPeriodic())
-                  {
-                  cout << "V Periodic" << endl;
-                  if (fabs(seg.epgeominfo[1].v-seg.epgeominfo[0].v) >
-                  fabs(seg.epgeominfo[1].v-
-                  (seg.epgeominfo[0].v-occface->VPeriod())))
-                  seg.epgeominfo[0].v = p2d.Y()+occface->VPeriod();
-
-                  if (fabs(seg.epgeominfo[1].v-seg.epgeominfo[0].v) >
-                  fabs(seg.epgeominfo[1].v-
-                  (seg.epgeominfo[0].v+occface->VPeriod())))
-                  seg.epgeominfo[0].v = p2d.Y()-occface->VPeriod();
-                  }
-                  */
-
-                  if (edge.Orientation() == TopAbs_REVERSED)
-                  {
-                     swap (seg[0], seg[1]);
-                     swap (seg.epgeominfo[0].dist, seg.epgeominfo[1].dist);
-                     swap (seg.epgeominfo[0].u, seg.epgeominfo[1].u);
-                     swap (seg.epgeominfo[0].v, seg.epgeominfo[1].v);
-                  }
-
-                  mesh.AddSegment (seg);
-
-                  //edgesegments[geomedgenr-1]->Append(mesh.GetNSeg());
-
-               }
-            }
-         }
-      }
-
-      //	for(i=1; i<=mesh.GetNSeg(); i++)
-      //		(*testout) << "edge " << mesh.LineSegment(i).edgenr << " face " << mesh.LineSegment(i).si
-      //				<< " p1 " << mesh.LineSegment(i)[0] << " p2 " << mesh.LineSegment(i)[1] << endl;
-      //	exit(10);
-
-      mesh.CalcSurfacesOfNode();
-      multithread.task = savetask;
-   }
-
-
-
-
-   void OCCMeshSurface (OCCGeometry & geom, Mesh & mesh, int perfstepsend)
-   {
-      int i, j, k;
-      int changed;
-
-      const char * savetask = multithread.task;
-      multithread.task = "Surface meshing";
-
-      geom.facemeshstatus = 0;
-
-      int noldp = mesh.GetNP();
-
-      double starttime = GetTime();
-
-      Array<int> glob2loc(noldp);
-
-      //int projecttype = PARAMETERSPACE;
-
-      int projecttype = PARAMETERSPACE;
-
-      int notrys = 1;
-
-      int surfmesherror = 0;
-
-      for (k = 1; k <= mesh.GetNFD(); k++)
-      {
-         if(1==0 && !geom.fvispar[k-1].IsDrawable())
-         {
-            (*testout) << "ignoring face " << k << endl;
-            cout << "ignoring face " << k << endl;
-            continue;
-         }
-
-         (*testout) << "mesh face " << k << endl;
-         multithread.percent = 100 * k / (mesh.GetNFD() + VSMALL);
-         geom.facemeshstatus[k-1] = -1;
-
-
-         /*
-         if (k != 42)
-         {
-         cout << "skipped" << endl;
-         continue;
-         }
-         */
-
-
-         FaceDescriptor & fd = mesh.GetFaceDescriptor(k);
-
-         int oldnf = mesh.GetNSE();
-
-         Box<3> bb = geom.GetBoundingBox();
-
-         //      int projecttype = PLANESPACE;
-
-         Meshing2OCCSurfaces meshing(TopoDS::Face(geom.fmap(k)), bb, projecttype);
-
-         if (meshing.GetProjectionType() == PLANESPACE)
-            PrintMessage (2, "Face ", k, " / ", mesh.GetNFD(), " (plane space projection)");
-         else
-            PrintMessage (2, "Face ", k, " / ", mesh.GetNFD(), " (parameter space projection)");
-
-         if (surfmesherror)
-            cout << "Surface meshing error occured before (in " << surfmesherror << " faces)" << endl;
-
-         //      Meshing2OCCSurfaces meshing(f2, bb);
-         meshing.SetStartTime (starttime);
-
-         //(*testout) << "Face " << k << endl << endl;
-
-
-         if (meshing.GetProjectionType() == PLANESPACE)
-         {
-            int cntp = 0;
-            glob2loc = 0;
-            for (i = 1; i <= mesh.GetNSeg(); i++)
-            {
-               Segment & seg = mesh.LineSegment(i);
-               if (seg.si == k)
-               {
-                  for (j = 1; j <= 2; j++)
-                  {
-                     int pi = (j == 1) ? seg[0] : seg[1];
-                     if (!glob2loc.Get(pi))
-                     {
-                        meshing.AddPoint (mesh.Point(pi), pi);
-                        cntp++;
-                        glob2loc.Elem(pi) = cntp;
-                     }
-                  }
-               }
-            }
-
-            for (i = 1; i <= mesh.GetNSeg(); i++)
-            {
-               Segment & seg = mesh.LineSegment(i);
-               if (seg.si == k)
-               {
-                  PointGeomInfo gi0, gi1;
-                  gi0.trignum = gi1.trignum = k;
-                  gi0.u = seg.epgeominfo[0].u;
-                  gi0.v = seg.epgeominfo[0].v;
-                  gi1.u = seg.epgeominfo[1].u;
-                  gi1.v = seg.epgeominfo[1].v;
-
-                  meshing.AddBoundaryElement (glob2loc.Get(seg[0]), glob2loc.Get(seg[1]), gi0, gi1);
-                  //(*testout) << gi0.u << " " << gi0.v << endl;
-                  //(*testout) << gi1.u << " " << gi1.v << endl;
-               }
-            }
-         }
-         else
-         {
-            int cntp = 0;
-
-            for (i = 1; i <= mesh.GetNSeg(); i++)
-               if (mesh.LineSegment(i).si == k)
-                  cntp+=2;
-
-
-            Array< PointGeomInfo > gis;
-
-            gis.SetAllocSize (cntp);
-            gis.SetSize (0);
-
-            for (i = 1; i <= mesh.GetNSeg(); i++)
-            {
-               Segment & seg = mesh.LineSegment(i);
-               if (seg.si == k)
-               {
-                  PointGeomInfo gi0, gi1;
-                  gi0.trignum = gi1.trignum = k;
-                  gi0.u = seg.epgeominfo[0].u;
-                  gi0.v = seg.epgeominfo[0].v;
-                  gi1.u = seg.epgeominfo[1].u;
-                  gi1.v = seg.epgeominfo[1].v;
-
-                  int locpnum[2] = {0, 0};
-
-                  for (j = 0; j < 2; j++)
-                  {
-                     PointGeomInfo gi = (j == 0) ? gi0 : gi1;
-
-                     int l;
-                     for (l = 0; l < gis.Size() && locpnum[j] == 0; l++)
-                     {
-                        double dist = sqr (gis[l].u-gi.u)+sqr(gis[l].v-gi.v);
-
-                        if (dist < 1e-10)
-                           locpnum[j] = l+1;
-                     }
-
-                     if (locpnum[j] == 0)
-                     {
-                        int pi = (j == 0) ? seg[0] : seg[1];
-                        meshing.AddPoint (mesh.Point(pi), pi);
-
-                        gis.SetSize (gis.Size()+1);
-                        gis[l] = gi;
-                        locpnum[j] = l+1;
-                     }
-                  }
-
-                  meshing.AddBoundaryElement (locpnum[0], locpnum[1], gi0, gi1);
-                  //(*testout) << gi0.u << " " << gi0.v << endl;
-                  //(*testout) << gi1.u << " " << gi1.v << endl;
-
-               }
-            }
-         }
-
-
-
-
-
-         // Philippose - 15/01/2009
-         double maxh = geom.face_maxh[k-1];
-         //double maxh = mparam.maxh;
-         mparam.checkoverlap = 0;
-         //      int noldpoints = mesh->GetNP();
-         int noldsurfel = mesh.GetNSE();
-
-         GProp_GProps sprops;
-         BRepGProp::SurfaceProperties(TopoDS::Face(geom.fmap(k)),sprops);
-         meshing.SetMaxArea(2.*sprops.Mass());
-
-         MESHING2_RESULT res;
-
-         try {
-	   res = meshing.GenerateMesh (mesh, mparam, maxh, k);
-         }
-
-         catch (SingularMatrixException)
-         {
-            (*myerr) << "Singular Matrix" << endl;
-            res = MESHING2_GIVEUP;
-         }
-
-         catch (UVBoundsException)
-         {
-            (*myerr) << "UV bounds exceeded" << endl;
-            res = MESHING2_GIVEUP;
-         }
-
-         projecttype = PARAMETERSPACE;
-
-         if (res != MESHING2_OK)
-         {
-            if (notrys == 1)
-            {
-               for (int i = noldsurfel+1; i <= mesh.GetNSE(); i++)
-                  mesh.DeleteSurfaceElement (i);
-
-               mesh.Compress();
-
-               cout << "retry Surface " << k << endl;
-
-               k--;
-               projecttype*=-1;
-               notrys++;
-               continue;
-            }
-            else
-            {
-               geom.facemeshstatus[k-1] = -1;
-               PrintError ("Problem in Surface mesh generation");
-               surfmesherror++;
-               //	      throw NgException ("Problem in Surface mesh generation");
-            }
-         }
-         else
-         {
-            geom.facemeshstatus[k-1] = 1;
-         }
-
-         notrys = 1;
-
-         for (i = oldnf+1; i <= mesh.GetNSE(); i++)
-            mesh.SurfaceElement(i).SetIndex (k);
-
-      }
-
-//      ofstream problemfile("occmesh.rep");
-
-//      problemfile << "SURFACEMESHING" << endl << endl;
-
-      if (surfmesherror)
-      {
-         cout << "WARNING! NOT ALL FACES HAVE BEEN MESHED" << endl;
-         cout << "SURFACE MESHING ERROR OCCURED IN " << surfmesherror << " FACES:" << endl;
-         for (int i = 1; i <= geom.fmap.Extent(); i++)
-            if (geom.facemeshstatus[i-1] == -1)
-            {
-               cout << "Face " << i << endl;
-//               problemfile << "problem with face " << i << endl;
-//               problemfile << "vertices: " << endl;
-               TopExp_Explorer exp0,exp1,exp2;
-               for ( exp0.Init(TopoDS::Face (geom.fmap(i)), TopAbs_WIRE); exp0.More(); exp0.Next() )
-               {
-                  TopoDS_Wire wire = TopoDS::Wire(exp0.Current());
-                  for ( exp1.Init(wire,TopAbs_EDGE); exp1.More(); exp1.Next() )
-                  {
-                     TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-                     for ( exp2.Init(edge,TopAbs_VERTEX); exp2.More(); exp2.Next() )
-                     {
-                        TopoDS_Vertex vertex = TopoDS::Vertex(exp2.Current());
-                        gp_Pnt point = BRep_Tool::Pnt(vertex);
-//                        problemfile << point.X() << " " << point.Y() << " " << point.Z() << endl;
-                     }
-                  }
-               }
-//               problemfile << endl;
-
-            }
-            cout << endl << endl;
-            cout << "for more information open IGES/STEP Topology Explorer" << endl;
-//            problemfile.close();
-            throw NgException ("Problem in Surface mesh generation");
-      }
-      else
-      {
-//         problemfile << "OK" << endl << endl;
-//         problemfile.close();
-      }
-
-
-
-
-      if (multithread.terminate || perfstepsend < MESHCONST_OPTSURFACE)
-         return;
-
-      multithread.task = "Optimizing surface";
-
-      static int timer_opt2d = NgProfiler::CreateTimer ("Optimization 2D");
-      NgProfiler::StartTimer (timer_opt2d);
-
-      for (k = 1; k <= mesh.GetNFD(); k++)
-      {
-         //      if (k != 42) continue;
-         //      if (k != 36) continue;
-
-         //      (*testout) << "optimize face " << k << endl;
-         multithread.percent = 100 * k / (mesh.GetNFD() + VSMALL);
-
-         FaceDescriptor & fd = mesh.GetFaceDescriptor(k);
-
-         PrintMessage (1, "Optimize Surface ", k);
-         for (i = 1; i <= mparam.optsteps2d; i++)
-         {
-            //	  (*testout) << "optstep " << i << endl;
-            if (multithread.terminate) return;
-
-            {
-               MeshOptimize2dOCCSurfaces meshopt(geom);
-               meshopt.SetFaceIndex (k);
-               meshopt.SetImproveEdges (0);
-               meshopt.SetMetricWeight (mparam.elsizeweight);
-               //meshopt.SetMetricWeight (0.2);
-               meshopt.SetWriteStatus (0);
-
-               //	    (*testout) << "EdgeSwapping (mesh, (i > mparam.optsteps2d/2))" << endl;
-               meshopt.EdgeSwapping (mesh, (i > mparam.optsteps2d/2));
-            }
-
-            if (multithread.terminate) return;
-            {
-               MeshOptimize2dOCCSurfaces meshopt(geom);
-               meshopt.SetFaceIndex (k);
-               meshopt.SetImproveEdges (0);
-               //meshopt.SetMetricWeight (0.2);
-               meshopt.SetMetricWeight (mparam.elsizeweight);
-               meshopt.SetWriteStatus (0);
-
-               //	    (*testout) << "ImproveMesh (mesh)" << endl;
-               meshopt.ImproveMesh (mesh, mparam);
-            }
-
-            {
-               MeshOptimize2dOCCSurfaces meshopt(geom);
-               meshopt.SetFaceIndex (k);
-               meshopt.SetImproveEdges (0);
-               //meshopt.SetMetricWeight (0.2);
-               meshopt.SetMetricWeight (mparam.elsizeweight);
-               meshopt.SetWriteStatus (0);
-
-               //	    (*testout) << "CombineImprove (mesh)" << endl;
-               meshopt.CombineImprove (mesh);
-            }
-
-            if (multithread.terminate) return;
-            {
-               MeshOptimize2dOCCSurfaces meshopt(geom);
-               meshopt.SetFaceIndex (k);
-               meshopt.SetImproveEdges (0);
-               //meshopt.SetMetricWeight (0.2);
-               meshopt.SetMetricWeight (mparam.elsizeweight);
-               meshopt.SetWriteStatus (0);
-
-               //	    (*testout) << "ImproveMesh (mesh)" << endl;
-               meshopt.ImproveMesh (mesh, mparam);
-            }
-         }
-
-      }
-
-
-      mesh.CalcSurfacesOfNode();
-      mesh.Compress();
-
-      NgProfiler::StopTimer (timer_opt2d);
-
-      multithread.task = savetask;
-   }
-
-
-
-   void OCCSetLocalMeshSize(OCCGeometry & geom, Mesh & mesh)
-   {
-      mesh.SetGlobalH (mparam.maxh);
-      mesh.SetMinimalH (mparam.minh);
-
-      Array<double> maxhdom;
-      maxhdom.SetSize (geom.NrSolids());
-      maxhdom = mparam.maxh;
-
-      mesh.SetMaxHDomain (maxhdom);
-
-      Box<3> bb = geom.GetBoundingBox();
-      bb.Increase (bb.Diam()/10);
-
-      mesh.SetLocalH (bb.PMin(), bb.PMax(), 0.5);
-
-      if (mparam.uselocalh)
-      {
-         const char * savetask = multithread.task;
-         multithread.percent = 0;
-
-         mesh.SetLocalH (bb.PMin(), bb.PMax(), mparam.grading);
-
-         int nedges = geom.emap.Extent();
-
-		 double mincurvelength = IGNORECURVELENGTH;
-         double maxedgelen = 0;
-         double minedgelen = 1e99;
-
-		 if(occparam.resthminedgelenenable) 
-		 {
-			mincurvelength = occparam.resthminedgelen;
-			if(mincurvelength < IGNORECURVELENGTH) mincurvelength = IGNORECURVELENGTH;
-		 }
-
-         multithread.task = "Setting local mesh size (elements per edge)";
-
-         // setting elements per edge
-
-         for (int i = 1; i <= nedges && !multithread.terminate; i++)
-         {
-            TopoDS_Edge e = TopoDS::Edge (geom.emap(i));
-            multithread.percent = 100 * (i-1)/double(nedges);
-            if (BRep_Tool::Degenerated(e)) continue;
-
-            GProp_GProps system;
-            BRepGProp::LinearProperties(e, system);
-            double len = system.Mass();
-
-            if (len < mincurvelength)
-            {
-               (*testout) << "ignored" << endl;
-               continue;
-            }
-
-            double localh = len/mparam.segmentsperedge;
-            double s0, s1;
-
-            // Philippose - 23/01/2009
-            // Find all the parent faces of a given edge
-            // and limit the mesh size of the edge based on the
-            // mesh size limit of the face
-            TopTools_IndexedDataMapOfShapeListOfShape edge_face_map;
-            edge_face_map.Clear();
-
-            TopExp::MapShapesAndAncestors(geom.shape, TopAbs_EDGE, TopAbs_FACE, edge_face_map);
-            const TopTools_ListOfShape& parent_faces = edge_face_map.FindFromKey(e);
-
-            TopTools_ListIteratorOfListOfShape parent_face_list;
-
-            for(parent_face_list.Initialize(parent_faces); parent_face_list.More(); parent_face_list.Next())
-            {
-               TopoDS_Face parent_face = TopoDS::Face(parent_face_list.Value());
-
-               int face_index = geom.fmap.FindIndex(parent_face);
-
-               if(face_index >= 1) localh = min(localh,geom.face_maxh[face_index - 1]);
-            }
-
-            Handle(Geom_Curve) c = BRep_Tool::Curve(e, s0, s1);
-
-            maxedgelen = max (maxedgelen, len);
-            minedgelen = min (minedgelen, len);
-
-            // Philippose - 23/01/2009
-            // Modified the calculation of maxj, because the
-            // method used so far always results in maxj = 2,
-            // which causes the localh to be set only at the
-            // starting, mid and end of the edge.
-            // Old Algorithm:
-            // int maxj = 2 * (int) ceil (localh/len);
-            int maxj = max((int) ceil(len/localh), 2);
-
-            for (int j = 0; j <= maxj; j++)
-            {
-               gp_Pnt pnt = c->Value (s0+double(j)/maxj*(s1-s0));
-               mesh.RestrictLocalH (Point3d(pnt.X(), pnt.Y(), pnt.Z()), localh);
-            }
-         }
-
-         multithread.task = "Setting local mesh size (edge curvature)";
-
-         // setting edge curvature
-
-         int nsections = 20;
-
-         for (int i = 1; i <= nedges && !multithread.terminate; i++)
-         {
-            double maxcur = 0;
-            multithread.percent = 100 * (i-1)/double(nedges);
-            TopoDS_Edge edge = TopoDS::Edge (geom.emap(i));
-            if (BRep_Tool::Degenerated(edge)) continue;
-            double s0, s1;
-            Handle(Geom_Curve) c = BRep_Tool::Curve(edge, s0, s1);
-            BRepAdaptor_Curve brepc(edge);
-            BRepLProp_CLProps prop(brepc, 2, 1e-5);
-
-            for (int j = 1; j <= nsections; j++)
-            {
-               double s = s0 + j/(double) nsections * (s1-s0);
-               prop.SetParameter (s);
-               double curvature = prop.Curvature();
-               if(curvature> maxcur) maxcur = curvature;
-
-               if (curvature >= 1e99)
-                  continue;
-
-               gp_Pnt pnt = c->Value (s);
-
-               mesh.RestrictLocalH (Point3d(pnt.X(), pnt.Y(), pnt.Z()), ComputeH (fabs(curvature)));
-            }
-            // (*testout) << "edge " << i << " max. curvature: " << maxcur << endl;
-         }
-
-         multithread.task = "Setting local mesh size (face curvature)";
-
-         // setting face curvature
-
-         int nfaces = geom.fmap.Extent();
-
-         for (int i = 1; i <= nfaces && !multithread.terminate; i++)
-         {
-            multithread.percent = 100 * (i-1)/double(nfaces);
-            TopoDS_Face face = TopoDS::Face(geom.fmap(i));
-            TopLoc_Location loc;
-            Handle(Geom_Surface) surf = BRep_Tool::Surface (face);
-            Handle(Poly_Triangulation) triangulation = BRep_Tool::Triangulation (face, loc);
-
-            if (triangulation.IsNull()) continue;
-
-            BRepAdaptor_Surface sf(face, Standard_True);
-            BRepLProp_SLProps prop(sf, 2, 1e-5);
-
-            int ntriangles = triangulation -> NbTriangles();
-            for (int j = 1; j <= ntriangles; j++)
-            {
-               gp_Pnt p[3];
-               gp_Pnt2d par[3];
-
-               for (int k = 1; k <=3; k++)
-               {
-                  int n = triangulation->Triangles()(j)(k);
-                  p[k-1] = triangulation->Nodes()(n).Transformed(loc);
-                  par[k-1] = triangulation->UVNodes()(n);
-               }
-
-               //double maxside = 0;
-               //maxside = max (maxside, p[0].Distance(p[1]));
-               //maxside = max (maxside, p[0].Distance(p[2]));
-               //maxside = max (maxside, p[1].Distance(p[2]));
-               //cout << "\rFace " << i << " pos11 ntriangles " << ntriangles << " maxside " << maxside << flush;
-
-               RestrictHTriangle (par[0], par[1], par[2], &prop, mesh, 0);
-               //cout << "\rFace " << i << " pos12 ntriangles " << ntriangles << flush;
-            }
-         }
-
-         // setting close edges
-
-         if (occparam.resthcloseedgeenable)
-         {
-            multithread.task = "Setting local mesh size (close edges)";
-
-            int sections = 100;
-
-            Array<Line> lines(sections*nedges);
-
-            Box3dTree* searchtree =
-               new Box3dTree (bb.PMin(), bb.PMax());
-
-            int nlines = 0;
-            for (int i = 1; i <= nedges && !multithread.terminate; i++)
-            {
-               TopoDS_Edge edge = TopoDS::Edge (geom.emap(i));
-               if (BRep_Tool::Degenerated(edge)) continue;
-
-               double s0, s1;
-               Handle(Geom_Curve) c = BRep_Tool::Curve(edge, s0, s1);
-               BRepAdaptor_Curve brepc(edge);
-               BRepLProp_CLProps prop(brepc, 1, 1e-5);
-               prop.SetParameter (s0);
-
-               gp_Vec d0 = prop.D1().Normalized();
-               double s_start = s0;
-               int count = 0;
-               for (int j = 1; j <= sections; j++)
-               {
-                  double s = s0 + (s1-s0)*(double)j/(double)sections;
-                  prop.SetParameter (s);
-                  gp_Vec d1 = prop.D1().Normalized();
-                  double cosalpha = fabs(d0*d1);
-                  if ((j == sections) || (cosalpha < cos(10.0/180.0*M_PI)))
-                  {
-                     count++;
-                     gp_Pnt p0 = c->Value (s_start);
-                     gp_Pnt p1 = c->Value (s);
-                     lines[nlines].p0 = Point<3> (p0.X(), p0.Y(), p0.Z());
-                     lines[nlines].p1 = Point<3> (p1.X(), p1.Y(), p1.Z());
-
-                     Box3d box;
-                     box.SetPoint (Point3d(lines[nlines].p0));
-                     box.AddPoint (Point3d(lines[nlines].p1));
-
-                     searchtree->Insert (box.PMin(), box.PMax(), nlines+1);
-                     nlines++;
-
-                     s_start = s;
-                     d0 = d1;
-                  }
-               }
-            }
-
-            Array<int> linenums;
-
-            for (int i = 0; i < nlines; i++)
-            {
-               multithread.percent = (100*i)/double(nlines);
-               Line & line = lines[i];
-
-               Box3d box;
-               box.SetPoint (Point3d(line.p0));
-               box.AddPoint (Point3d(line.p1));
-               double maxhline = max (mesh.GetH(box.PMin()),
-                  mesh.GetH(box.PMax()));
-               box.Increase(maxhline);
-
-               double mindist = 1e99;
-               linenums.SetSize(0);
-               searchtree->GetIntersecting(box.PMin(),box.PMax(),linenums);
-
-               for (int j = 0; j < linenums.Size(); j++)
-               {
-                  int num = linenums[j]-1;
-                  if (i == num) continue;
-                  if ((line.p0-lines[num].p0).Length2() < 1e-15) continue;
-                  if ((line.p0-lines[num].p1).Length2() < 1e-15) continue;
-                  if ((line.p1-lines[num].p0).Length2() < 1e-15) continue;
-                  if ((line.p1-lines[num].p1).Length2() < 1e-15) continue;
-                  mindist = min (mindist, line.Dist(lines[num]));
-               }
-
-               mindist /= (occparam.resthcloseedgefac + VSMALL);
-
-               if (mindist < 1e-3)
-               {
-                  (*testout) << "extremely small local h: " << mindist
-                     << " --> setting to 1e-3" << endl;
-                  (*testout) << "somewhere near " << line.p0 << " - " << line.p1 << endl;
-                  mindist = 1e-3;
-               }
-
-               mesh.RestrictLocalHLine(line.p0, line.p1, mindist);
-            }
-         }
-
-         multithread.task = savetask;
-
-      }
-
-      // Philippose - 09/03/2009
-      // Added the capability to load the mesh size from a 
-      // file also for OpenCascade Geometry
-      // Note: 
-      // ** If the "uselocalh" option is ticked in 
-      // the "mesh options...insider" menu, the mesh 
-      // size will be further modified by the topology 
-      // analysis routines.
-      // ** To use the mesh size file as the sole source 
-      // for defining the mesh size, uncheck the "uselocalh"
-      // option.
-      mesh.LoadLocalMeshSize (mparam.meshsizefilename);
-   }
-
-
-
-  int OCCGenerateMesh (OCCGeometry & geom, Mesh *& mesh, MeshingParameters & mparam,
-		       int perfstepsstart, int perfstepsend)
-   {
-      multithread.percent = 0;
-
-      if (perfstepsstart <= MESHCONST_ANALYSE)
-      {
-         delete mesh;
-         mesh = new Mesh();
-         mesh->geomtype = Mesh::GEOM_OCC;
-
-         OCCSetLocalMeshSize(geom,*mesh);
-      }
-
-      if (multithread.terminate || perfstepsend <= MESHCONST_ANALYSE)
-         return TCL_OK;
-
-      if (perfstepsstart <= MESHCONST_MESHEDGES)
-      {
-         OCCFindEdges (geom, *mesh);
-
-         /*
-         cout << "Removing redundant points" << endl;
-
-         int i, j;
-         int np = mesh->GetNP();
-         Array<int> equalto;
-
-         equalto.SetSize (np);
-         equalto = 0;
-
-         for (i = 1; i <= np; i++)
-         {
-         for (j = i+1; j <= np; j++)
-         {
-         if (!equalto[j-1] && (Dist2 (mesh->Point(i), mesh->Point(j)) < 1e-12))
-         equalto[j-1] = i;
-         }
-         }
-
-         for (i = 1; i <= np; i++)
-         if (equalto[i-1])
-         {
-         cout << "Point " << i << " is equal to Point " << equalto[i-1] << endl;
-         for (j = 1; j <= mesh->GetNSeg(); j++)
-         {
-         Segment & seg = mesh->LineSegment(j);
-         if (seg[0] == i) seg[0] = equalto[i-1];
-         if (seg[1] == i) seg[1] = equalto[i-1];
-         }
-         }
-
-         cout << "Removing degenerated segments" << endl;
-         for (j = 1; j <= mesh->GetNSeg(); j++)
-         {
-         Segment & seg = mesh->LineSegment(j);
-         if (seg[0] == seg[1])
-         {
-         mesh->DeleteSegment(j);
-         cout << "Deleting Segment " << j << endl;
-         }
-         }
-
-         mesh->Compress();
-         */
-
-         /*
-         for (int i = 1; i <= geom.fmap.Extent(); i++)
-         {
-         Handle(Geom_Surface) hf1 =
-         BRep_Tool::Surface(TopoDS::Face(geom.fmap(i)));
-         for (int j = i+1; j <= geom.fmap.Extent(); j++)
-         {
-         Handle(Geom_Surface) hf2 =
-         BRep_Tool::Surface(TopoDS::Face(geom.fmap(j)));
-         if (hf1 == hf2) cout << "face " << i << " and face " << j << " lie on same surface" << endl;
-         }
-         }
-         */
-
-#ifdef LOG_STREAM
-         (*logout) << "Edges meshed" << endl
-            << "time = " << GetTime() << " sec" << endl
-            << "points: " << mesh->GetNP() << endl;
-#endif
-      }
-
-      if (multithread.terminate || perfstepsend <= MESHCONST_MESHEDGES)
-         return TCL_OK;
-
-      if (perfstepsstart <= MESHCONST_MESHSURFACE)
-      {
-         OCCMeshSurface (geom, *mesh, perfstepsend);
-         if (multithread.terminate) return TCL_OK;
-
-#ifdef LOG_STREAM
-         (*logout) << "Surfaces meshed" << endl
-            << "time = " << GetTime() << " sec" << endl
-            << "points: " << mesh->GetNP() << endl;
-#endif
-
-#ifdef STAT_STREAM
-         (*statout) << mesh->GetNSeg() << " & "
-            << mesh->GetNSE() << " & - &"
-            << GetTime() << " & " << endl;
-#endif
-
-         //      MeshQuality2d (*mesh);
-         mesh->CalcSurfacesOfNode();
-      }
-
-      if (multithread.terminate || perfstepsend <= MESHCONST_OPTSURFACE)
-         return TCL_OK;
-
-      if (perfstepsstart <= MESHCONST_MESHVOLUME)
-      {
-         multithread.task = "Volume meshing";
-
-         MESHING3_RESULT res = MeshVolume (mparam, *mesh);
-
-/*
-         ofstream problemfile("occmesh.rep",ios_base::app);
-
-         problemfile << "VOLUMEMESHING" << endl << endl;
-         if(res != MESHING3_OK)
-            problemfile << "ERROR" << endl << endl;
-         else
-            problemfile << "OK" << endl
-            << mesh->GetNE() << " elements" << endl << endl;
-
-         problemfile.close();
-*/
-
-         if (res != MESHING3_OK) return TCL_ERROR;
-
-         if (multithread.terminate) return TCL_OK;
-
-         RemoveIllegalElements (*mesh);
-         if (multithread.terminate) return TCL_OK;
-
-         MeshQuality3d (*mesh);
-
-#ifdef STAT_STREAM
-         (*statout) << GetTime() << " & ";
-#endif
-
-#ifdef LOG_STREAM
-         (*logout) << "Volume meshed" << endl
-            << "time = " << GetTime() << " sec" << endl
-            << "points: " << mesh->GetNP() << endl;
-#endif
-      }
-
-      if (multithread.terminate || perfstepsend <= MESHCONST_MESHVOLUME)
-         return TCL_OK;
-
-      if (perfstepsstart <= MESHCONST_OPTVOLUME)
-      {
-         multithread.task = "Volume optimization";
-
-         OptimizeVolume (mparam, *mesh);
-         if (multithread.terminate) return TCL_OK;
-
-#ifdef STAT_STREAM
-         (*statout) << GetTime() << " & "
-            << mesh->GetNE() << " & "
-            << mesh->GetNP() << " " << '\\' << '\\' << " \\" << "hline" << endl;
-#endif
-
-#ifdef LOG_STREAM
-         (*logout) << "Volume optimized" << endl
-            << "time = " << GetTime() << " sec" << endl
-            << "points: " << mesh->GetNP() << endl;
-#endif
-
-         // cout << "Optimization complete" << endl;
-
-      }
-
-      (*testout) << "NP: " << mesh->GetNP() << endl;
-      for (int i = 1; i <= mesh->GetNP(); i++)
-         (*testout) << mesh->Point(i) << endl;
-
-      (*testout) << endl << "NSegments: " << mesh->GetNSeg() << endl;
-      for (int i = 1; i <= mesh->GetNSeg(); i++)
-         (*testout) << mesh->LineSegment(i) << endl;
-
-      return TCL_OK;
-   }
-}
-
-#endif
+#ifdef OCCGEOMETRY
+
+#include <mystdlib.h>
+#include <occgeom.hpp>
+#include <meshing.hpp>
+
+
+namespace netgen
+{
+
+#include "occmeshsurf.hpp"
+
+#define TCL_OK 0
+#define TCL_ERROR 1
+
+#define DIVIDEEDGESECTIONS 1000
+#define IGNORECURVELENGTH 1e-4
+#define VSMALL 1e-10
+
+
+   DLL_HEADER bool merge_solids = 1;
+
+
+  // can you please explain what you intend to compute here (JS) !!!
+   double Line :: Dist (Line l)
+   {
+      Vec<3> n = p1-p0;
+      Vec<3> q = l.p1-l.p0;
+      double nq = n*q;
+
+      Point<3> p = p0 + 0.5*n;
+      double lambda = (p-l.p0)*n / (nq + VSMALL);
+
+      if (lambda >= 0 && lambda <= 1)
+      {
+         double d = (p-l.p0-lambda*q).Length();
+         //        if (d < 1e-3) d = 1e99;
+         return d;
+      }
+      else
+         return 1e99;
+   }
+
+
+
+   double Line :: Length ()
+   {
+      return (p1-p0).Length();
+   }
+
+
+
+   inline Point<3> occ2ng (const gp_Pnt & p)
+   {
+      return  Point<3> (p.X(), p.Y(), p.Z());
+   }
+
+
+
+   double ComputeH (double kappa)
+   {
+      double hret;
+      kappa *= mparam.curvaturesafety;
+
+      if (mparam.maxh * kappa < 1)
+         hret = mparam.maxh;
+      else
+         hret = 1 / (kappa + VSMALL);
+
+      if (mparam.maxh < hret)
+         hret = mparam.maxh;
+
+      return (hret);
+   }
+
+
+
+
+   void RestrictHTriangle (gp_Pnt2d & par0, gp_Pnt2d & par1, gp_Pnt2d & par2,
+                           BRepLProp_SLProps * prop, Mesh & mesh, int depth, double h = 0)
+   {
+      int ls = -1;
+
+      gp_Pnt pnt0,pnt1,pnt2;
+
+      prop->SetParameters (par0.X(), par0.Y());
+      pnt0 = prop->Value();
+
+      prop->SetParameters (par1.X(), par1.Y());
+      pnt1 = prop->Value();
+
+      prop->SetParameters (par2.X(), par2.Y());
+      pnt2 = prop->Value();
+
+      double aux;
+      double maxside = pnt0.Distance(pnt1);
+      ls = 2;
+      aux = pnt1.Distance(pnt2);
+      if(aux > maxside)
+      {
+         maxside = aux;
+         ls = 0;
+      }
+      aux = pnt2.Distance(pnt0);
+      if(aux > maxside)
+      {
+         maxside = aux;
+         ls = 1;
+      }
+
+
+
+      gp_Pnt2d parmid;
+
+      parmid.SetX( (par0.X()+par1.X()+par2.X()) / 3 );
+      parmid.SetY( (par0.Y()+par1.Y()+par2.Y()) / 3 );
+
+      if (depth%3 == 0)
+      {
+         double curvature = 0;
+
+         prop->SetParameters (parmid.X(), parmid.Y());
+         if (!prop->IsCurvatureDefined())
+         {
+            (*testout) << "curvature not defined!" << std::endl;
+            return;
+         }
+         curvature = max(fabs(prop->MinCurvature()),
+            fabs(prop->MaxCurvature()));
+
+         prop->SetParameters (par0.X(), par0.Y());
+         if (!prop->IsCurvatureDefined())
+         {
+            (*testout) << "curvature not defined!" << std::endl;
+            return;
+         }
+         curvature = max(curvature,max(fabs(prop->MinCurvature()),
+            fabs(prop->MaxCurvature())));
+
+         prop->SetParameters (par1.X(), par1.Y());
+         if (!prop->IsCurvatureDefined())
+         {
+            (*testout) << "curvature not defined!" << std::endl;
+            return;
+         }
+         curvature = max(curvature,max(fabs(prop->MinCurvature()),
+            fabs(prop->MaxCurvature())));
+
+         prop->SetParameters (par2.X(), par2.Y());
+         if (!prop->IsCurvatureDefined())
+         {
+            (*testout) << "curvature not defined!" << std::endl;
+            return;
+         }
+         curvature = max(curvature,max(fabs(prop->MinCurvature()),
+            fabs(prop->MaxCurvature())));
+
+         //(*testout) << "curvature " << curvature << std::endl;
+
+         if (curvature < 1e-3)
+         {
+            //(*testout) << "curvature too small (" << curvature << ")!" << std::endl;
+            return;
+            // return war bis 10.2.05 auskommentiert
+         }
+
+
+
+         h = ComputeH (curvature+1e-10);
+
+         if(h < 1e-4*maxside)
+            return;
+
+         // commented to restrict H on a large sphere for example
+         //if (h > 30) return;
+      }
+
+      if (h < maxside && depth < 10)
+      {
+         //std::cout << "\r h " << h << flush;
+         gp_Pnt2d pm;
+
+         //std::cout << "h " << h << " maxside " << maxside << " depth " << depth << std::endl;
+         //std::cout << "par0 " << par0.X() << " " << par0.Y()
+         //<< " par1 " << par1.X() << " " << par1.Y()
+         //   << " par2 " << par2.X() << " " << par2.Y()<< std::endl;
+
+         if(ls == 0)
+         {
+            pm.SetX(0.5*(par1.X()+par2.X())); pm.SetY(0.5*(par1.Y()+par2.Y()));
+            RestrictHTriangle(pm, par2, par0, prop, mesh, depth+1, h);
+            RestrictHTriangle(pm, par0, par1, prop, mesh, depth+1, h);
+         }
+         else if(ls == 1)
+         {
+            pm.SetX(0.5*(par0.X()+par2.X())); pm.SetY(0.5*(par0.Y()+par2.Y()));
+            RestrictHTriangle(pm, par1, par2, prop, mesh, depth+1, h);
+            RestrictHTriangle(pm, par0, par1, prop, mesh, depth+1, h);
+         }
+         else if(ls == 2)
+         {
+            pm.SetX(0.5*(par0.X()+par1.X())); pm.SetY(0.5*(par0.Y()+par1.Y()));
+            RestrictHTriangle(pm, par1, par2, prop, mesh, depth+1, h);
+            RestrictHTriangle(pm, par2, par0, prop, mesh, depth+1, h);
+         }
+
+      }
+      else
+      {
+         gp_Pnt pnt;
+         Point3d p3d;
+
+         prop->SetParameters (parmid.X(), parmid.Y());
+         pnt = prop->Value();
+         p3d = Point3d(pnt.X(), pnt.Y(), pnt.Z());
+         mesh.RestrictLocalH (p3d, h);
+
+         p3d = Point3d(pnt0.X(), pnt0.Y(), pnt0.Z());
+         mesh.RestrictLocalH (p3d, h);
+
+         p3d = Point3d(pnt1.X(), pnt1.Y(), pnt1.Z());
+         mesh.RestrictLocalH (p3d, h);
+
+         p3d = Point3d(pnt2.X(), pnt2.Y(), pnt2.Z());
+         mesh.RestrictLocalH (p3d, h);
+
+         //(*testout) << "p = " << p3d << ", h = " << h << ", maxside = " << maxside << std::endl;
+
+      }
+   }
+
+
+
+   void DivideEdge (TopoDS_Edge & edge, Array<MeshPoint> & ps,
+                    Array<double> & params, Mesh & mesh)
+   {
+      double s0, s1;
+      double maxh = mparam.maxh;
+      int nsubedges = 1;
+      gp_Pnt pnt, oldpnt;
+      double svalue[DIVIDEEDGESECTIONS];
+
+      GProp_GProps system;
+      BRepGProp::LinearProperties(edge, system);
+      double L = system.Mass();
+
+      Handle(Geom_Curve) c = BRep_Tool::Curve(edge, s0, s1);
+
+      double hvalue[DIVIDEEDGESECTIONS+1];
+      hvalue[0] = 0;
+      pnt = c->Value(s0);
+
+      //double olddist = 0; -- useless variables
+      //double dist = 0;
+
+      int tmpVal = (int)(DIVIDEEDGESECTIONS);
+
+      for (int i = 1; i <= tmpVal; i++)
+      {
+         oldpnt = pnt;
+         pnt = c->Value(s0+(i/double(DIVIDEEDGESECTIONS))*(s1-s0));
+         // -- no more than 1 segment per <edge length>/DIVIDEEDGESECTIONS
+         hvalue[i] = hvalue[i-1] +
+         //   1.0/mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))*
+         //   pnt.Distance(oldpnt);
+           min( 1.0,
+            1.0/mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))*
+                pnt.Distance(oldpnt));
+
+         //(*testout) << "mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z())) " << mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))
+         //	   <<  " pnt.Distance(oldpnt) " << pnt.Distance(oldpnt) << std::endl;
+
+         //olddist = dist; -- useless variables
+         //dist = pnt.Distance(oldpnt);
+      }
+
+      //  nsubedges = int(ceil(hvalue[DIVIDEEDGESECTIONS]));
+      nsubedges = max (1, int(floor(hvalue[DIVIDEEDGESECTIONS]+0.5)));
+
+      ps.SetSize(nsubedges-1);
+      params.SetSize(nsubedges+1);
+
+      int i = 1;
+      int i1 = 0;
+      do
+      {
+         if (hvalue[i1]/hvalue[DIVIDEEDGESECTIONS]*nsubedges >= i)
+         {
+            // -- for nsubedges comparable to DIVIDEEDGESECTIONS
+            //params[i] = s0+(i1/double(DIVIDEEDGESECTIONS))*(s1-s0);
+            double d1 = i1 - (hvalue[i1] - i*hvalue[DIVIDEEDGESECTIONS]/nsubedges)/(hvalue[i1]-hvalue[i1-1]);
+            params[i] = s0+(d1/double(DIVIDEEDGESECTIONS))*(s1-s0);
+            pnt = c->Value(params[i]);
+            ps[i-1] = MeshPoint (Point3d(pnt.X(), pnt.Y(), pnt.Z()));
+            i++;
+         }
+         i1++;
+         if (i1 > DIVIDEEDGESECTIONS)
+         {
+            nsubedges = i;
+            ps.SetSize(nsubedges-1);
+            params.SetSize(nsubedges+1);
+            std::cout << "divide edge: local h too small" << std::endl;
+         }
+      } while (i < nsubedges);
+
+      params[0] = s0;
+      params[nsubedges] = s1;
+
+      if (params[nsubedges] <= params[nsubedges-1])
+      {
+         std::cout << "CORRECTED" << std::endl;
+         ps.SetSize (nsubedges-2);
+         params.SetSize (nsubedges);
+         params[nsubedges] = s1;
+      }
+   }
+
+
+
+
+   void OCCFindEdges (OCCGeometry & geom, Mesh & mesh)
+   {
+      const char * savetask = multithread.task;
+      multithread.task = "Edge meshing";
+
+      (*testout) << "edge meshing" << std::endl;
+
+      int nvertices = geom.vmap.Extent();
+      int nedges = geom.emap.Extent();
+
+      (*testout) << "nvertices = " << nvertices << std::endl;
+      (*testout) << "nedges = " << nedges << std::endl;
+
+      double eps = 1e-6 * geom.GetBoundingBox().Diam();
+      const double eps2 = eps * eps; // -- small optimization
+
+      int first_vp = mesh.GetNP()+1; // -- to support SALOME sub-meshes
+
+      for (int i = 1; i <= nvertices; i++)
+      {
+         gp_Pnt pnt = BRep_Tool::Pnt (TopoDS::Vertex(geom.vmap(i)));
+         MeshPoint mp( Point<3>(pnt.X(), pnt.Y(), pnt.Z()) );
+
+         bool exists = 0;
+         if (merge_solids)
+            for (PointIndex pi = 1; pi <= mesh.GetNP(); pi++)
+               //if ( Dist2 (mesh[pi], Point<3>(mp)) < eps*eps)              
+               if ( Dist2 (mesh[pi], Point<3>(mp)) < eps2 ) // -- small optimization
+               {
+                  exists = 1;
+                  break;
+               }
+
+               if (!exists)
+                  mesh.AddPoint (mp);
+      }
+
+      (*testout) << "different vertices = " << mesh.GetNP() << std::endl;
+
+
+      int first_ep = mesh.GetNP()+1;
+
+      Array<int> face2solid[2];
+      for (int i = 0; i<2; i++)
+      {
+         face2solid[i].SetSize (geom.fmap.Extent());
+         face2solid[i] = 0;
+      }
+
+      int solidnr = 0;
+      for (TopExp_Explorer exp0(geom.shape, TopAbs_SOLID); exp0.More(); exp0.Next())
+      {
+         solidnr++;
+         for (TopExp_Explorer exp1(exp0.Current(), TopAbs_FACE); exp1.More(); exp1.Next())
+         {
+            TopoDS_Face face = TopoDS::Face(exp1.Current());
+            int facenr = geom.fmap.FindIndex(face);
+            if ( facenr < 1 ) continue; // -- to support SALOME sub-meshes
+
+            if (face2solid[0][facenr-1] == 0)
+               face2solid[0][facenr-1] = solidnr;
+            else
+               face2solid[1][facenr-1] = solidnr;
+         }
+      }
+
+
+      int total = 0;
+      for (int i3 = 1; i3 <= geom.fmap.Extent(); i3++)
+         for (TopExp_Explorer exp2(geom.fmap(i3), TopAbs_WIRE); exp2.More(); exp2.Next())
+            for (TopExp_Explorer exp3(exp2.Current(), TopAbs_EDGE); exp3.More(); exp3.Next())
+               total++;
+
+
+      int facenr = 0;
+      int edgenr = 0;
+
+      edgenr = mesh.GetNSeg(); // to support SALOME sub-meshes
+
+      (*testout) << "faces = " << geom.fmap.Extent() << std::endl;
+      int curr = 0;
+
+      for (int i3 = 1; i3 <= geom.fmap.Extent(); i3++)
+      {
+         TopoDS_Face face = TopoDS::Face(geom.fmap(i3));
+         facenr = geom.fmap.FindIndex (face);       // sollte doch immer == i3 sein ??? JS
+
+         int solidnr0 = face2solid[0][i3-1];
+         int solidnr1 = face2solid[1][i3-1];
+
+         /* auskommentiert am 3.3.05 von robert
+         for (exp2.Init (geom.somap(solidnr0), TopAbs_FACE); exp2.More(); exp2.Next())
+         {
+         TopoDS_Face face2 = TopoDS::Face(exp2.Current());
+         if (geom.fmap.FindIndex(face2) == facenr)
+         {
+         //		      if (face.Orientation() != face2.Orientation()) swap (solidnr0, solidnr1);
+         }
+         }
+         */
+
+         mesh.AddFaceDescriptor (FaceDescriptor(facenr, solidnr0, solidnr1, 0));
+
+         // Philippose - 06/07/2009
+         // Add the face colour to the mesh data
+         Quantity_Color face_colour;
+
+         if(!(geom.face_colours.IsNull())
+            && (geom.face_colours->GetColor(face,XCAFDoc_ColorSurf,face_colour)))
+         {
+            mesh.GetFaceDescriptor(facenr).SetSurfColour(Vec3d(face_colour.Red(),face_colour.Green(),face_colour.Blue()));
+         }
+         else
+         {
+            mesh.GetFaceDescriptor(facenr).SetSurfColour(Vec3d(0.0,1.0,0.0));
+         }
+         // ACHTUNG! STIMMT NICHT ALLGEMEIN (RG)
+
+
+         Handle(Geom_Surface) occface = BRep_Tool::Surface(face);
+
+         for (TopExp_Explorer exp2 (face, TopAbs_WIRE); exp2.More(); exp2.Next())
+         {
+            TopoDS_Shape wire = exp2.Current();
+
+            for (TopExp_Explorer exp3 (wire, TopAbs_EDGE); exp3.More(); exp3.Next())
+            {
+               curr++;
+               (*testout) << "edge nr " << curr << std::endl;
+
+               multithread.percent = 100 * curr / double (total);
+               if (multithread.terminate) return;
+
+               TopoDS_Edge edge = TopoDS::Edge (exp3.Current());
+               if (BRep_Tool::Degenerated(edge))
+               {
+                  //(*testout) << "ignoring degenerated edge" << std::endl;
+                  continue;
+               }
+               if ( geom.emap.FindIndex(edge) < 1 ) continue; // to support SALOME sub-meshes
+
+               if (geom.vmap.FindIndex(TopExp::FirstVertex (edge)) ==
+                  geom.vmap.FindIndex(TopExp::LastVertex (edge)))
+               {
+                  GProp_GProps system;
+                  BRepGProp::LinearProperties(edge, system);
+
+                  if (system.Mass() < eps)
+                  {
+                     std::cout << "ignoring edge " << geom.emap.FindIndex (edge)
+                        << ". closed edge with length < " << eps << std::endl;
+                     continue;
+                  }
+               }
+
+
+               Handle(Geom2d_Curve) cof;
+               double s0, s1;
+               cof = BRep_Tool::CurveOnSurface (edge, face, s0, s1);
+
+               int geomedgenr = geom.emap.FindIndex(edge);
+
+               Array <MeshPoint> mp;
+               Array <double> params;
+
+               DivideEdge (edge, mp, params, mesh);
+ 
+               Array <int> pnums;
+               pnums.SetSize (mp.Size()+2);
+
+               if (!merge_solids)
+               {
+                 //pnums[0] = geom.vmap.FindIndex (TopExp::FirstVertex (edge));
+                 //pnums[pnums.Size()-1] = geom.vmap.FindIndex (TopExp::LastVertex (edge));
+                 MeshPoint dfltP ( Point<3> ( 0, 0, 0 ) );
+                 int *ipp[] = { &pnums[0], &pnums[pnums.Size()-1] };
+                 TopoDS_Iterator vIt( edge, false );
+                 TopoDS_Vertex v[2];
+                 v[0] = TopoDS::Vertex( vIt.Value() ); vIt.Next();
+                 v[1] = TopoDS::Vertex( vIt.Value() );
+                 if ( v[0].Orientation() == TopAbs_REVERSED )
+                   std::swap( v[0], v[1] );
+                 for ( int i = 0; i < 2; ++i)
+                 {
+                   int &ip = *ipp[i];
+                   ip = geom.vmap.FindIndex ( v[i] );
+                   if ( ip == 0 || ip > nvertices )
+                   {
+                     int iv = ip;
+                     if ( ip == 0 )
+                       ip = iv = geom.vmap.Add( v[i] );
+                     gp_Pnt pnt = BRep_Tool::Pnt( v[i] );
+                     MeshPoint mp( Point<3>(pnt.X(), pnt.Y(), pnt.Z()) );
+                     for (PointIndex pi = 1; pi < first_vp; pi++)
+                       if ( Dist2 (mesh.Point(pi), Point<3>(mp)) < 1e-100 )
+                       {
+                         ip = pi;
+                         if ( mesh.Point(ip).GetLayer() != dfltP.GetLayer() && mesh.Point(ip).GetLayer() != iv )
+                           continue;
+                         if ( mesh.Point(ip).GetLayer() == dfltP.GetLayer())
+                           mesh.Point(ip) = MeshPoint( mesh.Point(ip), iv );
+                         break;
+                       }
+               }
+               else
+               {
+                     ip += first_vp - 1;
+                   }
+                 }
+               }
+               else
+               {
+                 TopoDS_Iterator vIt( edge, false );
+                 TopoDS_Vertex v1 = TopoDS::Vertex( vIt.Value() ); vIt.Next();
+                 TopoDS_Vertex v2 = TopoDS::Vertex( vIt.Value() );
+                 if ( v1.Orientation() == TopAbs_REVERSED )
+                   std::swap( v1, v2 );
+                 const bool isClosedEdge = v1.IsSame( v2 );
+                 
+                  Point<3> fp = occ2ng (BRep_Tool::Pnt (v1));
+                  Point<3> lp = occ2ng (BRep_Tool::Pnt (v2));
+                  double tol2 = min( eps*eps, 1e-6 * Dist2( fp, lp ));
+                  if ( isClosedEdge )
+                    tol2 = BRep_Tool::Tolerance( v1 ) * BRep_Tool::Tolerance( v1 );
+
+                  pnums[0] = -1;
+                  pnums.Last() = -1;
+                  for (PointIndex pi = 1; pi < first_ep; pi++)
+                  {
+                    if (Dist2 (mesh[pi], fp) < tol2) pnums[0] = pi;
+                    if (Dist2 (mesh[pi], lp) < tol2) pnums.Last() = pi;
+                  }
+                  if (( isClosedEdge && pnums[0] != pnums.Last() ) ||
+                      ( !isClosedEdge && pnums[0] == pnums.Last() ))
+                    pnums[0] = pnums.Last() = -1;
+                  if ( pnums[0] == -1 || pnums.Last() == -1 )
+                  {
+                    // take into account a possible large gap between a vertex and an edge curve
+                    // end and a large vertex tolerance covering the whole edge
+                    if ( pnums[0] == -1 )
+                    {
+                      double tol = BRep_Tool::Tolerance( v1 );
+                      for (PointIndex pi = 1; pi < first_ep; pi++)
+                        if (pi != pnums.Last() && Dist2 (mesh[pi], fp) < 2*tol*tol)
+                          pnums[0] = pi;
+
+                      if ( pnums[0] == -1 )
+                        pnums[0] = first_ep-1- nvertices + geom.vmap.FindIndex ( v1 );
+                    }
+                    if ( isClosedEdge )
+                    {
+                      pnums.Last() = pnums[0];
+                    }
+                    else
+                    {
+                      if ( pnums.Last() == -1 )
+                      {
+                        double tol = BRep_Tool::Tolerance( v2 );
+                        for (PointIndex pi = 1; pi < first_ep; pi++)
+                          if (pi != pnums[0] && Dist2 (mesh[pi], lp) < 2*tol*tol)
+                            pnums.Last() = pi;
+
+                        if ( pnums.Last() == -1 )
+                          pnums.Last() = first_ep-1-nvertices + geom.vmap.FindIndex ( v2 );
+                      }
+
+                      if ( Dist2( fp, mesh[PointIndex(pnums[0])]) >
+                           Dist2( lp, mesh[PointIndex(pnums.Last())]))
+                      std::swap( pnums[0], pnums.Last() );
+                    }
+                  }
+               }
+
+
+               for (int i = 1; i <= mp.Size(); i++)
+               {
+                  bool exists = 0;
+                  int j;
+                  for (j = first_ep; j <= mesh.GetNP(); j++)
+                  {
+                     if (!merge_solids && mesh.Point(j).GetLayer() != geomedgenr ) continue; // to support SALOME fuse edges
+                     if ((mesh.Point(j)-Point<3>(mp[i-1])).Length() < eps)
+                     {
+                        exists = 1;
+                        break;
+                     }
+                  }
+
+                     if (exists)
+                        pnums[i] = j;
+                     else
+                     {
+                        mesh.AddPoint (mp[i-1], geomedgenr); // to support SALOME fuse edges
+                        (*testout) << "add meshpoint " << mp[i-1] << std::endl;
+                        pnums[i] = mesh.GetNP();
+                     }
+               }
+               (*testout) << "NP = " << mesh.GetNP() << std::endl;
+
+               //(*testout) << pnums[pnums.Size()-1] << std::endl;
+
+               for (int i = 1; i <= mp.Size()+1; i++)
+               {
+                  edgenr++;
+                  Segment seg;
+
+                  seg[0] = pnums[i-1];
+                  seg[1] = pnums[i];
+                  seg.edgenr = edgenr;
+                  seg.si = facenr;
+                  seg.epgeominfo[0].dist = params[i-1];
+                  seg.epgeominfo[1].dist = params[i];
+                  seg.epgeominfo[0].edgenr = geomedgenr;
+                  seg.epgeominfo[1].edgenr = geomedgenr;
+
+                  gp_Pnt2d p2d;
+                  p2d = cof->Value(params[i-1]);
+                  //			if (i == 1) p2d = cof->Value(s0);
+                  seg.epgeominfo[0].u = p2d.X();
+                  seg.epgeominfo[0].v = p2d.Y();
+                  p2d = cof->Value(params[i]);
+                  //			if (i == mp.Size()+1) p2d = cof -> Value(s1);
+                  seg.epgeominfo[1].u = p2d.X();
+                  seg.epgeominfo[1].v = p2d.Y();
+
+                  /*
+                  if (occface->IsUPeriodic())
+                  {
+                  std::cout << "U Periodic" << std::endl;
+                  if (fabs(seg.epgeominfo[1].u-seg.epgeominfo[0].u) >
+                  fabs(seg.epgeominfo[1].u-
+                  (seg.epgeominfo[0].u-occface->UPeriod())))
+                  seg.epgeominfo[0].u = p2d.X()+occface->UPeriod();
+
+                  if (fabs(seg.epgeominfo[1].u-seg.epgeominfo[0].u) >
+                  fabs(seg.epgeominfo[1].u-
+                  (seg.epgeominfo[0].u+occface->UPeriod())))
+                  seg.epgeominfo[0].u = p2d.X()-occface->UPeriod();
+                  }
+
+                  if (occface->IsVPeriodic())
+                  {
+                  std::cout << "V Periodic" << std::endl;
+                  if (fabs(seg.epgeominfo[1].v-seg.epgeominfo[0].v) >
+                  fabs(seg.epgeominfo[1].v-
+                  (seg.epgeominfo[0].v-occface->VPeriod())))
+                  seg.epgeominfo[0].v = p2d.Y()+occface->VPeriod();
+
+                  if (fabs(seg.epgeominfo[1].v-seg.epgeominfo[0].v) >
+                  fabs(seg.epgeominfo[1].v-
+                  (seg.epgeominfo[0].v+occface->VPeriod())))
+                  seg.epgeominfo[0].v = p2d.Y()-occface->VPeriod();
+                  }
+                  */
+
+                  if (edge.Orientation() == TopAbs_REVERSED)
+                  {
+                     swap (seg[0], seg[1]);
+                     swap (seg.epgeominfo[0].dist, seg.epgeominfo[1].dist);
+                     swap (seg.epgeominfo[0].u, seg.epgeominfo[1].u);
+                     swap (seg.epgeominfo[0].v, seg.epgeominfo[1].v);
+                  }
+
+                  mesh.AddSegment (seg);
+
+                  //edgesegments[geomedgenr-1]->Append(mesh.GetNSeg());
+
+               }
+            }
+         }
+      }
+
+      //	for(i=1; i<=mesh.GetNSeg(); i++)
+      //		(*testout) << "edge " << mesh.LineSegment(i).edgenr << " face " << mesh.LineSegment(i).si
+      //				<< " p1 " << mesh.LineSegment(i)[0] << " p2 " << mesh.LineSegment(i)[1] << std::endl;
+      //	exit(10);
+      for (int j = 1; j <= mesh.GetNP(); j++) // to support SALOME fuse edges: set level to zero
+        mesh.Point(j) = MeshPoint( (Point<3>&) mesh.Point(j) );
+
+      mesh.CalcSurfacesOfNode();
+      multithread.task = savetask;
+   }
+
+
+
+
+   void OCCMeshSurface (OCCGeometry & geom, Mesh & mesh, int perfstepsend)
+   {
+      int i, j, k;
+      int changed;
+
+      const char * savetask = multithread.task;
+      multithread.task = "Surface meshing";
+
+      geom.facemeshstatus = 0;
+
+      int noldp = mesh.GetNP();
+
+      double starttime = GetTime();
+
+      Array<int> glob2loc(noldp);
+
+      //int projecttype = PARAMETERSPACE;
+
+      int projecttype = PARAMETERSPACE;
+
+      int notrys = 1;
+
+      int surfmesherror = 0;
+
+      for (k = 1; k <= mesh.GetNFD(); k++)
+      {
+         if(1==0 && !geom.fvispar[k-1].IsDrawable())
+         {
+            (*testout) << "ignoring face " << k << std::endl;
+            std::cout << "ignoring face " << k << std::endl;
+            continue;
+         }
+
+         (*testout) << "mesh face " << k << std::endl;
+         multithread.percent = 100 * k / (mesh.GetNFD() + VSMALL);
+         geom.facemeshstatus[k-1] = -1;
+
+
+         /*
+         if (k != 42)
+         {
+         std::cout << "skipped" << std::endl;
+         continue;
+         }
+         */
+
+
+         FaceDescriptor & fd = mesh.GetFaceDescriptor(k);
+
+         int oldnf = mesh.GetNSE();
+
+         Box<3> bb = geom.GetBoundingBox();
+
+         //      int projecttype = PLANESPACE;
+
+         Meshing2OCCSurfaces meshing(TopoDS::Face(geom.fmap(k)), bb, projecttype);
+
+         if (meshing.GetProjectionType() == PLANESPACE)
+            PrintMessage (2, "Face ", k, " / ", mesh.GetNFD(), " (plane space projection)");
+         else
+            PrintMessage (2, "Face ", k, " / ", mesh.GetNFD(), " (parameter space projection)");
+
+         if (surfmesherror)
+            std::cout << "Surface meshing error occured before (in " << surfmesherror << " faces)" << std::endl;
+
+         //      Meshing2OCCSurfaces meshing(f2, bb);
+         meshing.SetStartTime (starttime);
+
+         //(*testout) << "Face " << k << std::endl << std::endl;
+
+
+         if (meshing.GetProjectionType() == PLANESPACE)
+         {
+            int cntp = 0;
+            glob2loc = 0;
+            for (i = 1; i <= mesh.GetNSeg(); i++)
+            {
+               Segment & seg = mesh.LineSegment(i);
+               if (seg.si == k)
+               {
+                  for (j = 1; j <= 2; j++)
+                  {
+                     int pi = (j == 1) ? seg[0] : seg[1];
+                     if (!glob2loc.Get(pi))
+                     {
+                        meshing.AddPoint (mesh.Point(pi), pi);
+                        cntp++;
+                        glob2loc.Elem(pi) = cntp;
+                     }
+                  }
+               }
+            }
+
+            for (i = 1; i <= mesh.GetNSeg(); i++)
+            {
+               Segment & seg = mesh.LineSegment(i);
+               if (seg.si == k)
+               {
+                  PointGeomInfo gi0, gi1;
+                  gi0.trignum = gi1.trignum = k;
+                  gi0.u = seg.epgeominfo[0].u;
+                  gi0.v = seg.epgeominfo[0].v;
+                  gi1.u = seg.epgeominfo[1].u;
+                  gi1.v = seg.epgeominfo[1].v;
+
+                  meshing.AddBoundaryElement (glob2loc.Get(seg[0]), glob2loc.Get(seg[1]), gi0, gi1);
+                  //(*testout) << gi0.u << " " << gi0.v << std::endl;
+                  //(*testout) << gi1.u << " " << gi1.v << std::endl;
+               }
+            }
+         }
+         else
+         {
+            int cntp = 0;
+
+            for (i = 1; i <= mesh.GetNSeg(); i++)
+               if (mesh.LineSegment(i).si == k)
+                  cntp+=2;
+
+
+            Array< PointGeomInfo > gis;
+
+            gis.SetAllocSize (cntp);
+            gis.SetSize (0);
+
+            for (i = 1; i <= mesh.GetNSeg(); i++)
+            {
+               Segment & seg = mesh.LineSegment(i);
+               if (seg.si == k)
+               {
+                  PointGeomInfo gi0, gi1;
+                  gi0.trignum = gi1.trignum = k;
+                  gi0.u = seg.epgeominfo[0].u;
+                  gi0.v = seg.epgeominfo[0].v;
+                  gi1.u = seg.epgeominfo[1].u;
+                  gi1.v = seg.epgeominfo[1].v;
+
+                  int locpnum[2] = {0, 0};
+
+                  for (j = 0; j < 2; j++)
+                  {
+                     PointGeomInfo gi = (j == 0) ? gi0 : gi1;
+
+                     int l;
+                     for (l = 0; l < gis.Size() && locpnum[j] == 0; l++)
+                     {
+                        double dist = sqr (gis[l].u-gi.u)+sqr(gis[l].v-gi.v);
+
+                        if (dist < 1e-10)
+                           locpnum[j] = l+1;
+                     }
+
+                     if (locpnum[j] == 0)
+                     {
+                        int pi = (j == 0) ? seg[0] : seg[1];
+                        meshing.AddPoint (mesh.Point(pi), pi);
+
+                        gis.SetSize (gis.Size()+1);
+                        gis[l] = gi;
+                        locpnum[j] = l+1;
+                     }
+                  }
+
+                  meshing.AddBoundaryElement (locpnum[0], locpnum[1], gi0, gi1);
+                  //(*testout) << gi0.u << " " << gi0.v << std::endl;
+                  //(*testout) << gi1.u << " " << gi1.v << std::endl;
+
+               }
+            }
+         }
+
+
+
+
+
+         // Philippose - 15/01/2009
+         double maxh = geom.face_maxh[k-1];
+         //double maxh = mparam.maxh;
+         mparam.checkoverlap = 0;
+         //      int noldpoints = mesh->GetNP();
+         int noldsurfel = mesh.GetNSE();
+
+         GProp_GProps sprops;
+         BRepGProp::SurfaceProperties(TopoDS::Face(geom.fmap(k)),sprops);
+         meshing.SetMaxArea(2.*sprops.Mass());
+
+         MESHING2_RESULT res;
+
+         try {
+	   res = meshing.GenerateMesh (mesh, mparam, maxh, k);
+         }
+
+         catch (SingularMatrixException)
+         {
+            (*myerr) << "Singular Matrix" << std::endl;
+            res = MESHING2_GIVEUP;
+         }
+
+         catch (UVBoundsException)
+         {
+            (*myerr) << "UV bounds exceeded" << std::endl;
+            res = MESHING2_GIVEUP;
+         }
+
+         projecttype = PARAMETERSPACE;
+
+         if (res != MESHING2_OK)
+         {
+            if (notrys == 1)
+            {
+               for (int i = noldsurfel+1; i <= mesh.GetNSE(); i++)
+                  mesh.DeleteSurfaceElement (i);
+
+               mesh.Compress();
+
+               std::cout << "retry Surface " << k << std::endl;
+
+               k--;
+               projecttype*=-1;
+               notrys++;
+               continue;
+            }
+            else
+            {
+               geom.facemeshstatus[k-1] = -1;
+               PrintError ("Problem in Surface mesh generation");
+               surfmesherror++;
+               //	      throw NgException ("Problem in Surface mesh generation");
+            }
+         }
+         else
+         {
+            geom.facemeshstatus[k-1] = 1;
+         }
+
+         notrys = 1;
+
+         for (i = oldnf+1; i <= mesh.GetNSE(); i++)
+            mesh.SurfaceElement(i).SetIndex (k);
+
+      }
+
+//      ofstream problemfile("occmesh.rep");
+
+//      problemfile << "SURFACEMESHING" << std::endl << std::endl;
+
+      if (surfmesherror)
+      {
+         std::cout << "WARNING! NOT ALL FACES HAVE BEEN MESHED" << std::endl;
+         std::cout << "SURFACE MESHING ERROR OCCURED IN " << surfmesherror << " FACES:" << std::endl;
+         for (int i = 1; i <= geom.fmap.Extent(); i++)
+            if (geom.facemeshstatus[i-1] == -1)
+            {
+               std::cout << "Face " << i << std::endl;
+//               problemfile << "problem with face " << i << std::endl;
+//               problemfile << "vertices: " << std::endl;
+               TopExp_Explorer exp0,exp1,exp2;
+               for ( exp0.Init(TopoDS::Face (geom.fmap(i)), TopAbs_WIRE); exp0.More(); exp0.Next() )
+               {
+                  TopoDS_Wire wire = TopoDS::Wire(exp0.Current());
+                  for ( exp1.Init(wire,TopAbs_EDGE); exp1.More(); exp1.Next() )
+                  {
+                     TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+                     for ( exp2.Init(edge,TopAbs_VERTEX); exp2.More(); exp2.Next() )
+                     {
+                        TopoDS_Vertex vertex = TopoDS::Vertex(exp2.Current());
+                        gp_Pnt point = BRep_Tool::Pnt(vertex);
+//                        problemfile << point.X() << " " << point.Y() << " " << point.Z() << std::endl;
+                     }
+                  }
+               }
+//               problemfile << std::endl;
+
+            }
+            std::cout << std::endl << std::endl;
+            std::cout << "for more information open IGES/STEP Topology Explorer" << std::endl;
+//            problemfile.close();
+            throw NgException ("Problem in Surface mesh generation");
+      }
+      else
+      {
+//         problemfile << "OK" << std::endl << std::endl;
+//         problemfile.close();
+      }
+
+
+
+
+      if (multithread.terminate || perfstepsend < MESHCONST_OPTSURFACE)
+         return;
+
+      multithread.task = "Optimizing surface";
+
+      static int timer_opt2d = NgProfiler::CreateTimer ("Optimization 2D");
+      NgProfiler::StartTimer (timer_opt2d);
+
+      for (k = 1; k <= mesh.GetNFD(); k++)
+      {
+         //      if (k != 42) continue;
+         //      if (k != 36) continue;
+
+         //      (*testout) << "optimize face " << k << std::endl;
+         multithread.percent = 100 * k / (mesh.GetNFD() + VSMALL);
+
+         FaceDescriptor & fd = mesh.GetFaceDescriptor(k);
+
+         PrintMessage (1, "Optimize Surface ", k);
+         for (i = 1; i <= mparam.optsteps2d; i++)
+         {
+            //	  (*testout) << "optstep " << i << std::endl;
+            if (multithread.terminate) return;
+
+            {
+               MeshOptimize2dOCCSurfaces meshopt(geom);
+               meshopt.SetFaceIndex (k);
+               meshopt.SetImproveEdges (0);
+               meshopt.SetMetricWeight (mparam.elsizeweight);
+               //meshopt.SetMetricWeight (0.2);
+               meshopt.SetWriteStatus (0);
+
+               //	    (*testout) << "EdgeSwapping (mesh, (i > mparam.optsteps2d/2))" << std::endl;
+               meshopt.EdgeSwapping (mesh, (i > mparam.optsteps2d/2));
+            }
+
+            if (multithread.terminate) return;
+            {
+               MeshOptimize2dOCCSurfaces meshopt(geom);
+               meshopt.SetFaceIndex (k);
+               meshopt.SetImproveEdges (0);
+               //meshopt.SetMetricWeight (0.2);
+               meshopt.SetMetricWeight (mparam.elsizeweight);
+               meshopt.SetWriteStatus (0);
+
+               //	    (*testout) << "ImproveMesh (mesh)" << std::endl;
+               meshopt.ImproveMesh (mesh, mparam);
+            }
+
+            {
+               MeshOptimize2dOCCSurfaces meshopt(geom);
+               meshopt.SetFaceIndex (k);
+               meshopt.SetImproveEdges (0);
+               //meshopt.SetMetricWeight (0.2);
+               meshopt.SetMetricWeight (mparam.elsizeweight);
+               meshopt.SetWriteStatus (0);
+
+               //	    (*testout) << "CombineImprove (mesh)" << std::endl;
+               meshopt.CombineImprove (mesh);
+            }
+
+            if (multithread.terminate) return;
+            {
+               MeshOptimize2dOCCSurfaces meshopt(geom);
+               meshopt.SetFaceIndex (k);
+               meshopt.SetImproveEdges (0);
+               //meshopt.SetMetricWeight (0.2);
+               meshopt.SetMetricWeight (mparam.elsizeweight);
+               meshopt.SetWriteStatus (0);
+
+               //	    (*testout) << "ImproveMesh (mesh)" << std::endl;
+               meshopt.ImproveMesh (mesh, mparam);
+            }
+         }
+
+      }
+
+
+      mesh.CalcSurfacesOfNode();
+      mesh.Compress();
+
+      NgProfiler::StopTimer (timer_opt2d);
+
+      multithread.task = savetask;
+   }
+
+
+
+   void OCCSetLocalMeshSize(OCCGeometry & geom, Mesh & mesh)
+   {
+      mesh.SetGlobalH (mparam.maxh);
+      mesh.SetMinimalH (mparam.minh);
+
+      Array<double> maxhdom;
+      maxhdom.SetSize (geom.NrSolids());
+      maxhdom = mparam.maxh;
+
+      mesh.SetMaxHDomain (maxhdom);
+
+      Box<3> bb = geom.GetBoundingBox();
+      bb.Increase (bb.Diam()/10);
+
+      mesh.SetLocalH (bb.PMin(), bb.PMax(), 0.5);
+
+      if (mparam.uselocalh)
+      {
+         const char * savetask = multithread.task;
+         multithread.percent = 0;
+
+         mesh.SetLocalH (bb.PMin(), bb.PMax(), mparam.grading);
+
+         int nedges = geom.emap.Extent();
+
+		 double mincurvelength = IGNORECURVELENGTH;
+         double maxedgelen = 0;
+         double minedgelen = 1e99;
+
+		 if(occparam.resthminedgelenenable) 
+		 {
+			mincurvelength = occparam.resthminedgelen;
+			if(mincurvelength < IGNORECURVELENGTH) mincurvelength = IGNORECURVELENGTH;
+		 }
+
+         multithread.task = "Setting local mesh size (elements per edge)";
+
+         // setting elements per edge
+
+         for (int i = 1; i <= nedges && !multithread.terminate; i++)
+         {
+            TopoDS_Edge e = TopoDS::Edge (geom.emap(i));
+            multithread.percent = 100 * (i-1)/double(nedges);
+            if (BRep_Tool::Degenerated(e)) continue;
+
+            GProp_GProps system;
+            BRepGProp::LinearProperties(e, system);
+            double len = system.Mass();
+
+            if (len < mincurvelength)
+            {
+               (*testout) << "ignored" << std::endl;
+               continue;
+            }
+
+            double localh = len/mparam.segmentsperedge;
+            double s0, s1;
+
+            // Philippose - 23/01/2009
+            // Find all the parent faces of a given edge
+            // and limit the mesh size of the edge based on the
+            // mesh size limit of the face
+            TopTools_IndexedDataMapOfShapeListOfShape edge_face_map;
+            edge_face_map.Clear();
+
+            TopExp::MapShapesAndAncestors(geom.shape, TopAbs_EDGE, TopAbs_FACE, edge_face_map);
+            const TopTools_ListOfShape& parent_faces = edge_face_map.FindFromKey(e);
+
+            TopTools_ListIteratorOfListOfShape parent_face_list;
+
+            for(parent_face_list.Initialize(parent_faces); parent_face_list.More(); parent_face_list.Next())
+            {
+               TopoDS_Face parent_face = TopoDS::Face(parent_face_list.Value());
+
+               int face_index = geom.fmap.FindIndex(parent_face);
+
+               if(face_index >= 1) localh = min(localh,geom.face_maxh[face_index - 1]);
+            }
+
+            Handle(Geom_Curve) c = BRep_Tool::Curve(e, s0, s1);
+
+            maxedgelen = max (maxedgelen, len);
+            minedgelen = min (minedgelen, len);
+
+            // Philippose - 23/01/2009
+            // Modified the calculation of maxj, because the
+            // method used so far always results in maxj = 2,
+            // which causes the localh to be set only at the
+            // starting, mid and end of the edge.
+            // Old Algorithm:
+            // int maxj = 2 * (int) ceil (localh/len);
+            int maxj = max((int) ceil(len/localh), 2);
+
+            for (int j = 0; j <= maxj; j++)
+            {
+               gp_Pnt pnt = c->Value (s0+double(j)/maxj*(s1-s0));
+               mesh.RestrictLocalH (Point3d(pnt.X(), pnt.Y(), pnt.Z()), localh);
+            }
+         }
+
+         multithread.task = "Setting local mesh size (edge curvature)";
+
+         // setting edge curvature
+
+         int nsections = 20;
+
+         for (int i = 1; i <= nedges && !multithread.terminate; i++)
+         {
+            double maxcur = 0;
+            multithread.percent = 100 * (i-1)/double(nedges);
+            TopoDS_Edge edge = TopoDS::Edge (geom.emap(i));
+            if (BRep_Tool::Degenerated(edge)) continue;
+            double s0, s1;
+            Handle(Geom_Curve) c = BRep_Tool::Curve(edge, s0, s1);
+            BRepAdaptor_Curve brepc(edge);
+            BRepLProp_CLProps prop(brepc, 2, 1e-5);
+
+            for (int j = 1; j <= nsections; j++)
+            {
+               double s = s0 + j/(double) nsections * (s1-s0);
+               prop.SetParameter (s);
+               double curvature = prop.Curvature();
+               if(curvature> maxcur) maxcur = curvature;
+
+               if (curvature >= 1e99)
+                  continue;
+
+               gp_Pnt pnt = c->Value (s);
+
+               mesh.RestrictLocalH (Point3d(pnt.X(), pnt.Y(), pnt.Z()), ComputeH (fabs(curvature)));
+            }
+            // (*testout) << "edge " << i << " max. curvature: " << maxcur << std::endl;
+         }
+
+         multithread.task = "Setting local mesh size (face curvature)";
+
+         // setting face curvature
+
+         int nfaces = geom.fmap.Extent();
+
+         for (int i = 1; i <= nfaces && !multithread.terminate; i++)
+         {
+            multithread.percent = 100 * (i-1)/double(nfaces);
+            TopoDS_Face face = TopoDS::Face(geom.fmap(i));
+            TopLoc_Location loc;
+            Handle(Geom_Surface) surf = BRep_Tool::Surface (face);
+            Handle(Poly_Triangulation) triangulation = BRep_Tool::Triangulation (face, loc);
+
+            if (triangulation.IsNull()) continue;
+
+            BRepAdaptor_Surface sf(face, Standard_True);
+            BRepLProp_SLProps prop(sf, 2, 1e-5);
+
+            int ntriangles = triangulation -> NbTriangles();
+            for (int j = 1; j <= ntriangles; j++)
+            {
+               gp_Pnt p[3];
+               gp_Pnt2d par[3];
+
+               for (int k = 1; k <=3; k++)
+               {
+                  int n = triangulation->Triangles()(j)(k);
+                  p[k-1] = triangulation->Nodes()(n).Transformed(loc);
+                  par[k-1] = triangulation->UVNodes()(n);
+               }
+
+               //double maxside = 0;
+               //maxside = max (maxside, p[0].Distance(p[1]));
+               //maxside = max (maxside, p[0].Distance(p[2]));
+               //maxside = max (maxside, p[1].Distance(p[2]));
+               //std::cout << "\rFace " << i << " pos11 ntriangles " << ntriangles << " maxside " << maxside << flush;
+
+               RestrictHTriangle (par[0], par[1], par[2], &prop, mesh, 0);
+               //std::cout << "\rFace " << i << " pos12 ntriangles " << ntriangles << flush;
+            }
+         }
+
+         // setting close edges
+
+         if (occparam.resthcloseedgeenable)
+         {
+            multithread.task = "Setting local mesh size (close edges)";
+
+            int sections = 100;
+
+            Array<Line> lines(sections*nedges);
+
+            Box3dTree* searchtree =
+               new Box3dTree (bb.PMin(), bb.PMax());
+
+            int nlines = 0;
+            for (int i = 1; i <= nedges && !multithread.terminate; i++)
+            {
+               TopoDS_Edge edge = TopoDS::Edge (geom.emap(i));
+               if (BRep_Tool::Degenerated(edge)) continue;
+
+               double s0, s1;
+               Handle(Geom_Curve) c = BRep_Tool::Curve(edge, s0, s1);
+               BRepAdaptor_Curve brepc(edge);
+               BRepLProp_CLProps prop(brepc, 1, 1e-5);
+               prop.SetParameter (s0);
+
+               gp_Vec d0 = prop.D1().Normalized();
+               double s_start = s0;
+               int count = 0;
+               for (int j = 1; j <= sections; j++)
+               {
+                  double s = s0 + (s1-s0)*(double)j/(double)sections;
+                  prop.SetParameter (s);
+                  gp_Vec d1 = prop.D1().Normalized();
+                  double cosalpha = fabs(d0*d1);
+                  if ((j == sections) || (cosalpha < cos(10.0/180.0*M_PI)))
+                  {
+                     count++;
+                     gp_Pnt p0 = c->Value (s_start);
+                     gp_Pnt p1 = c->Value (s);
+                     lines[nlines].p0 = Point<3> (p0.X(), p0.Y(), p0.Z());
+                     lines[nlines].p1 = Point<3> (p1.X(), p1.Y(), p1.Z());
+
+                     Box3d box;
+                     box.SetPoint (Point3d(lines[nlines].p0));
+                     box.AddPoint (Point3d(lines[nlines].p1));
+
+                     searchtree->Insert (box.PMin(), box.PMax(), nlines+1);
+                     nlines++;
+
+                     s_start = s;
+                     d0 = d1;
+                  }
+               }
+            }
+
+            Array<int> linenums;
+
+            for (int i = 0; i < nlines; i++)
+            {
+               multithread.percent = (100*i)/double(nlines);
+               Line & line = lines[i];
+
+               Box3d box;
+               box.SetPoint (Point3d(line.p0));
+               box.AddPoint (Point3d(line.p1));
+               double maxhline = max (mesh.GetH(box.PMin()),
+                  mesh.GetH(box.PMax()));
+               box.Increase(maxhline);
+
+               double mindist = 1e99;
+               linenums.SetSize(0);
+               searchtree->GetIntersecting(box.PMin(),box.PMax(),linenums);
+
+               for (int j = 0; j < linenums.Size(); j++)
+               {
+                  int num = linenums[j]-1;
+                  if (i == num) continue;
+                  if ((line.p0-lines[num].p0).Length2() < 1e-15) continue;
+                  if ((line.p0-lines[num].p1).Length2() < 1e-15) continue;
+                  if ((line.p1-lines[num].p0).Length2() < 1e-15) continue;
+                  if ((line.p1-lines[num].p1).Length2() < 1e-15) continue;
+                  mindist = min (mindist, line.Dist(lines[num]));
+               }
+
+               mindist /= (occparam.resthcloseedgefac + VSMALL);
+
+               if (mindist < 1e-3)
+               {
+                  (*testout) << "extremely small local h: " << mindist
+                     << " --> setting to 1e-3" << std::endl;
+                  (*testout) << "somewhere near " << line.p0 << " - " << line.p1 << std::endl;
+                  mindist = 1e-3;
+               }
+
+               mesh.RestrictLocalHLine(line.p0, line.p1, mindist);
+            }
+         }
+
+         multithread.task = savetask;
+
+      }
+
+      // Philippose - 09/03/2009
+      // Added the capability to load the mesh size from a 
+      // file also for OpenCascade Geometry
+      // Note: 
+      // ** If the "uselocalh" option is ticked in 
+      // the "mesh options...insider" menu, the mesh 
+      // size will be further modified by the topology 
+      // analysis routines.
+      // ** To use the mesh size file as the sole source 
+      // for defining the mesh size, uncheck the "uselocalh"
+      // option.
+      mesh.LoadLocalMeshSize (mparam.meshsizefilename);
+   }
+
+
+
+  int OCCGenerateMesh (OCCGeometry & geom, Mesh *& mesh, MeshingParameters & mparam,
+		       int perfstepsstart, int perfstepsend)
+   {
+      multithread.percent = 0;
+
+      if (perfstepsstart <= MESHCONST_ANALYSE)
+      {
+         delete mesh;
+         mesh = new Mesh();
+         mesh->geomtype = Mesh::GEOM_OCC;
+
+         OCCSetLocalMeshSize(geom,*mesh);
+      }
+
+      if (multithread.terminate || perfstepsend <= MESHCONST_ANALYSE)
+         return TCL_OK;
+
+      if (perfstepsstart <= MESHCONST_MESHEDGES)
+      {
+         OCCFindEdges (geom, *mesh);
+
+         /*
+         std::cout << "Removing redundant points" << std::endl;
+
+         int i, j;
+         int np = mesh->GetNP();
+         Array<int> equalto;
+
+         equalto.SetSize (np);
+         equalto = 0;
+
+         for (i = 1; i <= np; i++)
+         {
+         for (j = i+1; j <= np; j++)
+         {
+         if (!equalto[j-1] && (Dist2 (mesh->Point(i), mesh->Point(j)) < 1e-12))
+         equalto[j-1] = i;
+         }
+         }
+
+         for (i = 1; i <= np; i++)
+         if (equalto[i-1])
+         {
+         std::cout << "Point " << i << " is equal to Point " << equalto[i-1] << std::endl;
+         for (j = 1; j <= mesh->GetNSeg(); j++)
+         {
+         Segment & seg = mesh->LineSegment(j);
+         if (seg[0] == i) seg[0] = equalto[i-1];
+         if (seg[1] == i) seg[1] = equalto[i-1];
+         }
+         }
+
+         std::cout << "Removing degenerated segments" << std::endl;
+         for (j = 1; j <= mesh->GetNSeg(); j++)
+         {
+         Segment & seg = mesh->LineSegment(j);
+         if (seg[0] == seg[1])
+         {
+         mesh->DeleteSegment(j);
+         std::cout << "Deleting Segment " << j << std::endl;
+         }
+         }
+
+         mesh->Compress();
+         */
+
+         /*
+         for (int i = 1; i <= geom.fmap.Extent(); i++)
+         {
+         Handle(Geom_Surface) hf1 =
+         BRep_Tool::Surface(TopoDS::Face(geom.fmap(i)));
+         for (int j = i+1; j <= geom.fmap.Extent(); j++)
+         {
+         Handle(Geom_Surface) hf2 =
+         BRep_Tool::Surface(TopoDS::Face(geom.fmap(j)));
+         if (hf1 == hf2) std::cout << "face " << i << " and face " << j << " lie on same surface" << std::endl;
+         }
+         }
+         */
+
+#ifdef LOG_STREAM
+         (*logout) << "Edges meshed" << std::endl
+            << "time = " << GetTime() << " sec" << std::endl
+            << "points: " << mesh->GetNP() << std::endl;
+#endif
+      }
+
+      if (multithread.terminate || perfstepsend <= MESHCONST_MESHEDGES)
+         return TCL_OK;
+
+      if (perfstepsstart <= MESHCONST_MESHSURFACE)
+      {
+         OCCMeshSurface (geom, *mesh, perfstepsend);
+         if (multithread.terminate) return TCL_OK;
+
+#ifdef LOG_STREAM
+         (*logout) << "Surfaces meshed" << std::endl
+            << "time = " << GetTime() << " sec" << std::endl
+            << "points: " << mesh->GetNP() << std::endl;
+#endif
+
+#ifdef STAT_STREAM
+         (*statout) << mesh->GetNSeg() << " & "
+            << mesh->GetNSE() << " & - &"
+            << GetTime() << " & " << std::endl;
+#endif
+
+         //      MeshQuality2d (*mesh);
+         mesh->CalcSurfacesOfNode();
+      }
+
+      if (multithread.terminate || perfstepsend <= MESHCONST_OPTSURFACE)
+         return TCL_OK;
+
+      if (perfstepsstart <= MESHCONST_MESHVOLUME)
+      {
+         multithread.task = "Volume meshing";
+
+         MESHING3_RESULT res = MeshVolume (mparam, *mesh);
+
+/*
+         ofstream problemfile("occmesh.rep",ios_base::app);
+
+         problemfile << "VOLUMEMESHING" << std::endl << std::endl;
+         if(res != MESHING3_OK)
+            problemfile << "ERROR" << std::endl << std::endl;
+         else
+            problemfile << "OK" << std::endl
+            << mesh->GetNE() << " elements" << std::endl << std::endl;
+
+         problemfile.close();
+*/
+
+         if (res != MESHING3_OK) return TCL_ERROR;
+
+         if (multithread.terminate) return TCL_OK;
+
+         RemoveIllegalElements (*mesh);
+         if (multithread.terminate) return TCL_OK;
+
+         MeshQuality3d (*mesh);
+
+#ifdef STAT_STREAM
+         (*statout) << GetTime() << " & ";
+#endif
+
+#ifdef LOG_STREAM
+         (*logout) << "Volume meshed" << std::endl
+            << "time = " << GetTime() << " sec" << std::endl
+            << "points: " << mesh->GetNP() << std::endl;
+#endif
+      }
+
+      if (multithread.terminate || perfstepsend <= MESHCONST_MESHVOLUME)
+         return TCL_OK;
+
+      if (perfstepsstart <= MESHCONST_OPTVOLUME)
+      {
+         multithread.task = "Volume optimization";
+
+         OptimizeVolume (mparam, *mesh);
+         if (multithread.terminate) return TCL_OK;
+
+#ifdef STAT_STREAM
+         (*statout) << GetTime() << " & "
+            << mesh->GetNE() << " & "
+            << mesh->GetNP() << " " << '\\' << '\\' << " \\" << "hline" << std::endl;
+#endif
+
+#ifdef LOG_STREAM
+         (*logout) << "Volume optimized" << std::endl
+            << "time = " << GetTime() << " sec" << std::endl
+            << "points: " << mesh->GetNP() << std::endl;
+#endif
+
+         // std::cout << "Optimization complete" << std::endl;
+
+      }
+
+      (*testout) << "NP: " << mesh->GetNP() << std::endl;
+      for (int i = 1; i <= mesh->GetNP(); i++)
+         (*testout) << mesh->Point(i) << std::endl;
+
+      (*testout) << std::endl << "NSegments: " << mesh->GetNSeg() << std::endl;
+      for (int i = 1; i <= mesh->GetNSeg(); i++)
+         (*testout) << mesh->LineSegment(i) << std::endl;
+
+      return TCL_OK;
+   }
+}
+
+#endif
--- netgen_ref/libsrc/occ/occgeom.cpp
+++ netgen/libsrc/occ/occgeom.cpp
@@ -1,1612 +1,1669 @@
-
-#ifdef OCCGEOMETRY
-
-#include <mystdlib.h>
-#include <occgeom.hpp>
-#include "ShapeAnalysis_ShapeTolerance.hxx"
-#include "ShapeAnalysis_ShapeContents.hxx"
-#include "ShapeAnalysis_CheckSmallFace.hxx"
-#include "ShapeAnalysis_DataMapOfShapeListOfReal.hxx"
-#include "ShapeAnalysis_Surface.hxx"
-#include "BRepAlgoAPI_Fuse.hxx"
-#include "BRepCheck_Analyzer.hxx"
-#include "BRepLib.hxx"
-#include "ShapeBuild_ReShape.hxx"
-#include "ShapeFix.hxx"
-#include "ShapeFix_FixSmallFace.hxx"
-#include "Partition_Spliter.hxx"
-
-
-namespace netgen
-{
-   void OCCGeometry :: PrintNrShapes ()
-   {
-      TopExp_Explorer e;
-      int count = 0;
-      for (e.Init(shape, TopAbs_COMPSOLID); e.More(); e.Next()) count++;
-      cout << "CompSolids: " << count << endl;
-
-      cout << "Solids    : " << somap.Extent() << endl;
-      cout << "Shells    : " << shmap.Extent() << endl;
-      cout << "Faces     : " << fmap.Extent() << endl;
-      cout << "Edges     : " << emap.Extent() << endl;
-      cout << "Vertices  : " << vmap.Extent() << endl;
-   }
-
-
-
-
-   void PrintContents (OCCGeometry * geom)
-   {
-      ShapeAnalysis_ShapeContents cont;
-      cont.Clear();
-      cont.Perform(geom->shape);
-
-      (*testout) << "OCC CONTENTS" << endl;
-      (*testout) << "============" << endl;
-      (*testout) << "SOLIDS   : " << cont.NbSolids() << endl;
-      (*testout) << "SHELLS   : " << cont.NbShells() << endl;
-      (*testout) << "FACES    : " << cont.NbFaces() << endl;
-      (*testout) << "WIRES    : " << cont.NbWires() << endl;
-      (*testout) << "EDGES    : " << cont.NbEdges() << endl;
-      (*testout) << "VERTICES : " << cont.NbVertices() << endl;
-
-      TopExp_Explorer e;
-      int count = 0;
-      for (e.Init(geom->shape, TopAbs_COMPOUND); e.More(); e.Next())
-         count++;
-      (*testout) << "Compounds: " << count << endl;
-
-      count = 0;
-      for (e.Init(geom->shape, TopAbs_COMPSOLID); e.More(); e.Next())
-         count++;
-      (*testout) << "CompSolids: " << count << endl;
-
-      (*testout) << endl;
-
-      cout << "Highest entry in topology hierarchy: " << endl;
-      if (count)
-         cout << count << " composite solid(s)" << endl;
-      else
-         if (geom->somap.Extent())
-            cout << geom->somap.Extent() << " solid(s)" << endl;
-         else
-            if (geom->shmap.Extent())
-               cout << geom->shmap.Extent() << " shells(s)" << endl;
-            else
-               if (geom->fmap.Extent())
-                  cout << geom->fmap.Extent() << " face(s)" << endl;
-               else
-                  if (geom->wmap.Extent())
-                     cout << geom->wmap.Extent() << " wire(s)" << endl;
-                  else
-                     if (geom->emap.Extent())
-                        cout << geom->emap.Extent() << " edge(s)" << endl;
-                     else
-                        if (geom->vmap.Extent())
-                           cout << geom->vmap.Extent() << " vertices(s)" << endl;
-                        else
-                           cout << "no entities" << endl;
-
-   }
-
-
-
-   void OCCGeometry :: HealGeometry ()
-   {
-      int nrc = 0, nrcs = 0,
-         nrso = somap.Extent(),
-         nrsh = shmap.Extent(),
-         nrf = fmap.Extent(),
-         nrw = wmap.Extent(),
-         nre = emap.Extent(),
-         nrv = vmap.Extent();
-
-      TopExp_Explorer exp0;
-      TopExp_Explorer exp1;
-
-
-      for (exp0.Init(shape, TopAbs_COMPOUND); exp0.More(); exp0.Next()) nrc++;
-      for (exp0.Init(shape, TopAbs_COMPSOLID); exp0.More(); exp0.Next()) nrcs++;
-
-      double surfacecont = 0;
-
-      {
-         Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-         rebuild->Apply(shape);
-         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-         {
-            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-            if ( BRep_Tool::Degenerated(edge) )
-               rebuild->Remove(edge, false);
-         }
-         shape = rebuild->Apply(shape);
-      }
-
-      BuildFMap();
-
-
-      for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
-      {
-         TopoDS_Face face = TopoDS::Face(exp0.Current());
-
-         GProp_GProps system;
-         BRepGProp::SurfaceProperties(face, system);
-         surfacecont += system.Mass();
-      }
-
-
-      cout << "Starting geometry healing procedure (tolerance: " << tolerance << ")" << endl
-         << "-----------------------------------" << endl;
-
-      {
-         cout << endl << "- repairing faces" << endl;
-
-         Handle(ShapeFix_Face) sff;
-         Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-         rebuild->Apply(shape);
-
-
-         for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
-         {
-            // Variable to hold the colour (if there exists one) of 
-            // the current face being processed
-            Quantity_Color face_colour;
-
-            TopoDS_Face face = TopoDS::Face (exp0.Current());
-
-            if(face_colours.IsNull()
-               || (!(face_colours->GetColor(face,XCAFDoc_ColorSurf,face_colour))))
-            {
-               // Set the default face colour to green (Netgen Standard)
-               // if no colour has been defined for the face
-               face_colour = Quantity_Color(0.0,1.0,0.0,Quantity_TOC_RGB);
-            }
-
-            sff = new ShapeFix_Face (face);
-            sff->FixAddNaturalBoundMode() = Standard_True;
-            sff->FixSmallAreaWireMode() = Standard_True;
-            sff->Perform();
-
-            if(sff->Status(ShapeExtend_DONE1) ||
-               sff->Status(ShapeExtend_DONE2) ||
-               sff->Status(ShapeExtend_DONE3) ||
-               sff->Status(ShapeExtend_DONE4) ||
-               sff->Status(ShapeExtend_DONE5))
-            {
-               cout << "repaired face " << fmap.FindIndex(face) << " ";
-               if(sff->Status(ShapeExtend_DONE1))
-                  cout << "(some wires are fixed)" <<endl;
-               else if(sff->Status(ShapeExtend_DONE2))
-                  cout << "(orientation of wires fixed)" <<endl;
-               else if(sff->Status(ShapeExtend_DONE3))
-                  cout << "(missing seam added)" <<endl;
-               else if(sff->Status(ShapeExtend_DONE4))
-                  cout << "(small area wire removed)" <<endl;
-               else if(sff->Status(ShapeExtend_DONE5))
-                  cout << "(natural bounds added)" <<endl;
-               TopoDS_Face newface = sff->Face();
-
-               rebuild->Replace(face, newface, Standard_False);
-            }
-
-            // Set the original colour of the face to the newly created 
-            // face (after the healing process)
-            face = TopoDS::Face (exp0.Current());
-            face_colours->SetColor(face,face_colour,XCAFDoc_ColorSurf);
-         }
-         shape = rebuild->Apply(shape);
-      }
-
-
-      {
-         Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-         rebuild->Apply(shape);
-         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-         {
-            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-            if ( BRep_Tool::Degenerated(edge) )
-               rebuild->Remove(edge, false);
-         }
-         shape = rebuild->Apply(shape);
-      }
-
-
-      if (fixsmalledges)
-      {
-         cout << endl << "- fixing small edges" << endl;
-
-         Handle(ShapeFix_Wire) sfw;
-         Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-         rebuild->Apply(shape);
-
-
-         for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
-         {
-            TopoDS_Face face = TopoDS::Face(exp0.Current());
-
-            for (exp1.Init (face, TopAbs_WIRE); exp1.More(); exp1.Next())
-            {
-               TopoDS_Wire oldwire = TopoDS::Wire(exp1.Current());
-               sfw = new ShapeFix_Wire (oldwire, face ,tolerance);
-               sfw->ModifyTopologyMode() = Standard_True;
-
-               sfw->ClosedWireMode() = Standard_True;
-
-               bool replace = false;
-
-               replace = sfw->FixReorder() || replace;
-
-               replace = sfw->FixConnected() || replace;
-
-
-
-               if (sfw->FixSmall (Standard_False, tolerance) && ! (sfw->StatusSmall(ShapeExtend_FAIL1) ||
-                  sfw->StatusSmall(ShapeExtend_FAIL2) ||
-                  sfw->StatusSmall(ShapeExtend_FAIL3)))
-               {
-                  cout << "Fixed small edge in wire " << wmap.FindIndex (oldwire) << endl;
-                  replace = true;
-
-               }
-               else if (sfw->StatusSmall(ShapeExtend_FAIL1))
-                  cerr << "Failed to fix small edge in wire " << wmap.FindIndex (oldwire)
-                  << ", edge cannot be checked (no 3d curve and no pcurve)" << endl;
-               else if (sfw->StatusSmall(ShapeExtend_FAIL2))
-                  cerr << "Failed to fix small edge in wire " << wmap.FindIndex (oldwire)
-                  << ", edge is null-length and has different vertives at begin and end, and lockvtx is True or ModifiyTopologyMode is False" << endl;
-               else if (sfw->StatusSmall(ShapeExtend_FAIL3))
-                  cerr << "Failed to fix small edge in wire " << wmap.FindIndex (oldwire)
-                  << ", CheckConnected has failed" << endl;
-
-               replace = sfw->FixEdgeCurves() || replace;
-
-               replace = sfw->FixDegenerated() || replace;
-
-               replace = sfw->FixSelfIntersection() || replace;
-
-               replace = sfw->FixLacking(Standard_True) || replace;
-
-               if(replace)
-               {
-                  TopoDS_Wire newwire = sfw->Wire();
-                  rebuild->Replace(oldwire, newwire, Standard_False);
-               }
-
-               //delete sfw; sfw = NULL;
-
-            }
-         }
-
-         shape = rebuild->Apply(shape);
-
-
-
-         {
-            BuildFMap();
-            Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-            rebuild->Apply(shape);
-
-            for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-            {
-               TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-               if (vmap.FindIndex(TopExp::FirstVertex (edge)) ==
-                  vmap.FindIndex(TopExp::LastVertex (edge)))
-               {
-                  GProp_GProps system;
-                  BRepGProp::LinearProperties(edge, system);
-                  if (system.Mass() < tolerance)
-                  {
-                     cout << "removing degenerated edge " << emap.FindIndex(edge)
-                        << " from vertex " << vmap.FindIndex(TopExp::FirstVertex (edge))
-                        << " to vertex " << vmap.FindIndex(TopExp::LastVertex (edge)) << endl;
-                     rebuild->Remove(edge, false);
-                  }
-               }
-            }
-            shape = rebuild->Apply(shape);
-
-            //delete rebuild; rebuild = NULL;
-         }
-
-
-
-         {
-            Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-            rebuild->Apply(shape);
-            for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-            {
-               TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-               if ( BRep_Tool::Degenerated(edge) )
-                  rebuild->Remove(edge, false);
-            }
-            shape = rebuild->Apply(shape);
-         }
-
-
-
-
-         Handle(ShapeFix_Wireframe) sfwf = new ShapeFix_Wireframe;
-         sfwf->SetPrecision(tolerance);
-         sfwf->Load (shape);
-         sfwf->ModeDropSmallEdges() = Standard_True;
-
-         sfwf->SetPrecision(boundingbox.Diam());
-
-         if (sfwf->FixWireGaps())
-         {
-            cout << endl << "- fixing wire gaps" << endl;
-            if (sfwf->StatusWireGaps(ShapeExtend_OK)) cout << "no gaps found" << endl;
-            if (sfwf->StatusWireGaps(ShapeExtend_DONE1)) cout << "some 2D gaps fixed" << endl;
-            if (sfwf->StatusWireGaps(ShapeExtend_DONE2)) cout << "some 3D gaps fixed" << endl;
-            if (sfwf->StatusWireGaps(ShapeExtend_FAIL1)) cout << "failed to fix some 2D gaps" << endl;
-            if (sfwf->StatusWireGaps(ShapeExtend_FAIL2)) cout << "failed to fix some 3D gaps" << endl;
-         }
-
-         sfwf->SetPrecision(tolerance);
-
-
-         {
-            for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-            {
-               TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-               if ( BRep_Tool::Degenerated(edge) )
-                  cout << "degenerated edge at position 4" << endl;
-            }
-         }
-
-
-
-         if (sfwf->FixSmallEdges())
-         {
-            cout << endl << "- fixing wire frames" << endl;
-            if (sfwf->StatusSmallEdges(ShapeExtend_OK)) cout << "no small edges found" << endl;
-            if (sfwf->StatusSmallEdges(ShapeExtend_DONE1)) cout << "some small edges fixed" << endl;
-            if (sfwf->StatusSmallEdges(ShapeExtend_FAIL1)) cout << "failed to fix some small edges" << endl;
-         }
-
-
-
-         shape = sfwf->Shape();
-
-         //delete sfwf; sfwf = NULL;
-         //delete rebuild; rebuild = NULL;
-
-      }
-
-
-
-
-
-      {
-         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-         {
-            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-            if ( BRep_Tool::Degenerated(edge) )
-               cout << "degenerated edge at position 5" << endl;
-         }
-      }
-
-
-
-
-      if (fixspotstripfaces)
-      {
-
-         cout << endl << "- fixing spot and strip faces" << endl;
-         Handle(ShapeFix_FixSmallFace) sffsm = new ShapeFix_FixSmallFace();
-         sffsm -> Init (shape);
-         sffsm -> SetPrecision (tolerance);
-         sffsm -> Perform();
-
-         shape = sffsm -> FixShape();
-         //delete sffsm; sffsm = NULL;
-      }
-
-
-      {
-         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-         {
-            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-            if ( BRep_Tool::Degenerated(edge) )
-               cout << "degenerated edge at position 6" << endl;
-         }
-      }
-
-
-
-      if (sewfaces)
-      {
-         cout << endl << "- sewing faces" << endl;
-
-         BRepOffsetAPI_Sewing sewedObj(tolerance);
-
-         for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
-         {
-            TopoDS_Face face = TopoDS::Face (exp0.Current());
-            sewedObj.Add (face);
-         }
-
-         sewedObj.Perform();
-
-         if (!sewedObj.SewedShape().IsNull())
-            shape = sewedObj.SewedShape();
-         else
-            cout << " not possible";
-      }
-
-
-
-      {
-         Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-         rebuild->Apply(shape);
-         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-         {
-            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-            if ( BRep_Tool::Degenerated(edge) )
-               rebuild->Remove(edge, false);
-         }
-         shape = rebuild->Apply(shape);
-      }
-
-
-      if (makesolids)
-      {
-         cout << endl << "- making solids" << endl;
-
-         BRepBuilderAPI_MakeSolid ms;
-         int count = 0;
-         for (exp0.Init(shape, TopAbs_SHELL); exp0.More(); exp0.Next())
-         {
-            count++;
-            ms.Add (TopoDS::Shell(exp0.Current()));
-         }
-
-         if (!count)
-         {
-            cout << " not possible (no shells)" << endl;
-         }
-         else
-         {
-            BRepCheck_Analyzer ba(ms);
-            if (ba.IsValid ())
-            {
-               Handle(ShapeFix_Shape) sfs = new ShapeFix_Shape;
-               sfs->Init (ms);
-               sfs->SetPrecision(tolerance);
-               sfs->SetMaxTolerance(tolerance);
-               sfs->Perform();
-               shape = sfs->Shape();
-
-               for (exp0.Init(shape, TopAbs_SOLID); exp0.More(); exp0.Next())
-               {
-                  TopoDS_Solid solid = TopoDS::Solid(exp0.Current());
-                  TopoDS_Solid newsolid = solid;
-                  BRepLib::OrientClosedSolid (newsolid);
-                  Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-                  //		  rebuild->Apply(shape);
-                  rebuild->Replace(solid, newsolid, Standard_False);
-                  TopoDS_Shape newshape = rebuild->Apply(shape, TopAbs_COMPSOLID);//, 1);
-                  //		  TopoDS_Shape newshape = rebuild->Apply(shape);
-                  shape = newshape;
-               }
-
-               //delete sfs; sfs = NULL;
-            }
-            else
-               cout << " not possible" << endl;
-         }
-      }
-
-
-
-      if (splitpartitions)
-      {
-         cout << "- running SALOME partition splitter" << endl;
-
-         TopExp_Explorer e2;
-         Partition_Spliter ps;
-         int count = 0;
-
-         for (e2.Init (shape, TopAbs_SOLID);
-            e2.More(); e2.Next())
-         {
-            count++;
-            ps.AddShape (e2.Current());
-         }
-
-         ps.Compute();
-         shape = ps.Shape();
-
-         cout << " before: " << count << " solids" << endl;
-
-         count = 0;
-         for (e2.Init (shape, TopAbs_SOLID);
-            e2.More(); e2.Next()) count++;
-
-            cout << " after : " << count << " solids" << endl;
-      }
-
-      BuildFMap();
-
-
-
-      {
-         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
-         {
-            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
-            if ( BRep_Tool::Degenerated(edge) )
-               cout << "degenerated edge at position 8" << endl;
-         }
-      }
-
-
-      double newsurfacecont = 0;
-
-
-      for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
-      {
-         TopoDS_Face face = TopoDS::Face(exp0.Current());
-         GProp_GProps system;
-         BRepGProp::SurfaceProperties(face, system);
-         newsurfacecont += system.Mass();
-      }
-
-
-      int nnrc = 0, nnrcs = 0,
-         nnrso = somap.Extent(),
-         nnrsh = shmap.Extent(),
-         nnrf = fmap.Extent(),
-         nnrw = wmap.Extent(),
-         nnre = emap.Extent(),
-         nnrv = vmap.Extent();
-
-      for (exp0.Init(shape, TopAbs_COMPOUND); exp0.More(); exp0.Next()) nnrc++;
-      for (exp0.Init(shape, TopAbs_COMPSOLID); exp0.More(); exp0.Next()) nnrcs++;
-
-      cout << "-----------------------------------" << endl;
-      cout << "Compounds       : " << nnrc << " (" << nrc << ")" << endl;
-      cout << "Composite solids: " << nnrcs << " (" << nrcs << ")" << endl;
-      cout << "Solids          : " << nnrso << " (" << nrso << ")" << endl;
-      cout << "Shells          : " << nnrsh << " (" << nrsh << ")" << endl;
-      cout << "Wires           : " << nnrw << " (" << nrw << ")" << endl;
-      cout << "Faces           : " << nnrf << " (" << nrf << ")" << endl;
-      cout << "Edges           : " << nnre << " (" << nre << ")" << endl;
-      cout << "Vertices        : " << nnrv << " (" << nrv << ")" << endl;
-      cout << endl;
-      cout << "Totol surface area : " << newsurfacecont << " (" << surfacecont << ")" << endl;
-      cout << endl;
-   }
-
-
-
-
-   void OCCGeometry :: BuildFMap()
-   {
-      somap.Clear();
-      shmap.Clear();
-      fmap.Clear();
-      wmap.Clear();
-      emap.Clear();
-      vmap.Clear();
-
-      TopExp_Explorer exp0, exp1, exp2, exp3, exp4, exp5;
-
-      for (exp0.Init(shape, TopAbs_COMPOUND);
-         exp0.More(); exp0.Next())
-      {
-         TopoDS_Compound compound = TopoDS::Compound (exp0.Current());
-         (*testout) << "compound" << endl;
-         int i = 0;
-         for (exp1.Init(compound, TopAbs_SHELL);
-            exp1.More(); exp1.Next())
-         {
-            (*testout) << "shell " << ++i << endl;
-         }
-      }
-
-      for (exp0.Init(shape, TopAbs_SOLID);
-         exp0.More(); exp0.Next())
-      {
-         TopoDS_Solid solid = TopoDS::Solid (exp0.Current());
-
-         if (somap.FindIndex(solid) < 1)
-         {
-            somap.Add (solid);
-
-            for (exp1.Init(solid, TopAbs_SHELL);
-               exp1.More(); exp1.Next())
-            {
-               TopoDS_Shell shell = TopoDS::Shell (exp1.Current());
-               if (shmap.FindIndex(shell) < 1)
-               {
-                  shmap.Add (shell);
-
-                  for (exp2.Init(shell, TopAbs_FACE);
-                     exp2.More(); exp2.Next())
-                  {
-                     TopoDS_Face face = TopoDS::Face(exp2.Current());
-                     if (fmap.FindIndex(face) < 1)
-                     {
-                        fmap.Add (face);
-                        (*testout) << "face " << fmap.FindIndex(face) << " ";
-                        (*testout) << ((face.Orientation() == TopAbs_REVERSED) ? "-" : "+") << ", ";
-                        (*testout) << ((exp2.Current().Orientation() == TopAbs_REVERSED) ? "-" : "+") << endl;
-                        for (exp3.Init(exp2.Current(), TopAbs_WIRE);
-                           exp3.More(); exp3.Next())
-                        {
-                           TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
-                           if (wmap.FindIndex(wire) < 1)
-                           {
-                              wmap.Add (wire);
-
-                              for (exp4.Init(exp3.Current(), TopAbs_EDGE);
-                                 exp4.More(); exp4.Next())
-                              {
-                                 TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
-                                 if (emap.FindIndex(edge) < 1)
-                                 {
-                                    emap.Add (edge);
-                                    for (exp5.Init(exp4.Current(), TopAbs_VERTEX);
-                                       exp5.More(); exp5.Next())
-                                    {
-                                       TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
-                                       if (vmap.FindIndex(vertex) < 1)
-                                          vmap.Add (vertex);
-                                    }
-                                 }
-                              }
-                           }
-                        }
-                     }
-                  }
-               }
-            }
-         }
-      }
-
-      // Free Shells
-      for (exp1.Init(shape, TopAbs_SHELL, TopAbs_SOLID); exp1.More(); exp1.Next())
-      {
-         TopoDS_Shell shell = TopoDS::Shell(exp1.Current());
-         if (shmap.FindIndex(shell) < 1)
-         {
-            shmap.Add (shell);
-
-            (*testout) << "shell " << shmap.FindIndex(shell) << " ";
-            (*testout) << ((shell.Orientation() == TopAbs_REVERSED) ? "-" : "+") << ", ";
-            (*testout) << ((exp1.Current().Orientation() == TopAbs_REVERSED) ? "-" : "+") << endl;
-
-            for (exp2.Init(shell, TopAbs_FACE); exp2.More(); exp2.Next())
-            {
-               TopoDS_Face face = TopoDS::Face(exp2.Current());
-               if (fmap.FindIndex(face) < 1)
-               {
-                  fmap.Add (face);
-
-                  for (exp3.Init(face, TopAbs_WIRE); exp3.More(); exp3.Next())
-                  {
-                     TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
-                     if (wmap.FindIndex(wire) < 1)
-                     {
-                        wmap.Add (wire);
-
-                        for (exp4.Init(wire, TopAbs_EDGE); exp4.More(); exp4.Next())
-                        {
-                           TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
-                           if (emap.FindIndex(edge) < 1)
-                           {
-                              emap.Add (edge);
-                              for (exp5.Init(edge, TopAbs_VERTEX); exp5.More(); exp5.Next())
-                              {
-                                 TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
-                                 if (vmap.FindIndex(vertex) < 1)
-                                    vmap.Add (vertex);
-                              }
-                           }
-                        }
-                     }
-                  }
-               }
-            }
-         }
-      }
-
-
-      // Free Faces
-
-      for (exp2.Init(shape, TopAbs_FACE, TopAbs_SHELL); exp2.More(); exp2.Next())
-      {
-         TopoDS_Face face = TopoDS::Face(exp2.Current());
-         if (fmap.FindIndex(face) < 1)
-         {
-            fmap.Add (face);
-
-            for (exp3.Init(exp2.Current(), TopAbs_WIRE); exp3.More(); exp3.Next())
-            {
-               TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
-               if (wmap.FindIndex(wire) < 1)
-               {
-                  wmap.Add (wire);
-
-                  for (exp4.Init(exp3.Current(), TopAbs_EDGE); exp4.More(); exp4.Next())
-                  {
-                     TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
-                     if (emap.FindIndex(edge) < 1)
-                     {
-                        emap.Add (edge);
-                        for (exp5.Init(exp4.Current(), TopAbs_VERTEX); exp5.More(); exp5.Next())
-                        {
-                           TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
-                           if (vmap.FindIndex(vertex) < 1)
-                              vmap.Add (vertex);
-                        }
-                     }
-                  }
-               }
-            }
-         }
-      }
-
-
-      // Free Wires
-
-      for (exp3.Init(shape, TopAbs_WIRE, TopAbs_FACE); exp3.More(); exp3.Next())
-      {
-         TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
-         if (wmap.FindIndex(wire) < 1)
-         {
-            wmap.Add (wire);
-
-            for (exp4.Init(exp3.Current(), TopAbs_EDGE); exp4.More(); exp4.Next())
-            {
-               TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
-               if (emap.FindIndex(edge) < 1)
-               {
-                  emap.Add (edge);
-                  for (exp5.Init(exp4.Current(), TopAbs_VERTEX); exp5.More(); exp5.Next())
-                  {
-                     TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
-                     if (vmap.FindIndex(vertex) < 1)
-                        vmap.Add (vertex);
-                  }
-               }
-            }
-         }
-      }
-
-
-      // Free Edges
-
-      for (exp4.Init(shape, TopAbs_EDGE, TopAbs_WIRE); exp4.More(); exp4.Next())
-      {
-         TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
-         if (emap.FindIndex(edge) < 1)
-         {
-            emap.Add (edge);
-            for (exp5.Init(exp4.Current(), TopAbs_VERTEX); exp5.More(); exp5.Next())
-            {
-               TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
-               if (vmap.FindIndex(vertex) < 1)
-                  vmap.Add (vertex);
-            }
-         }
-      }
-
-
-      // Free Vertices
-
-      for (exp5.Init(shape, TopAbs_VERTEX, TopAbs_EDGE); exp5.More(); exp5.Next())
-      {
-         TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
-         if (vmap.FindIndex(vertex) < 1)
-            vmap.Add (vertex);
-      }
-
-
-
-
-      facemeshstatus.DeleteAll();
-      facemeshstatus.SetSize (fmap.Extent());
-      facemeshstatus = 0;
-
-      // Philippose - 15/01/2009
-      face_maxh.DeleteAll();
-      face_maxh.SetSize (fmap.Extent());
-      face_maxh = mparam.maxh;
-
-      // Philippose - 15/01/2010      
-      face_maxh_modified.DeleteAll();      
-      face_maxh_modified.SetSize(fmap.Extent());      
-      face_maxh_modified = 0;
-      
-
-      // Philippose - 17/01/2009
-      face_sel_status.DeleteAll();
-      face_sel_status.SetSize (fmap.Extent());
-      face_sel_status = 0;
-
-      fvispar.SetSize (fmap.Extent());
-      evispar.SetSize (emap.Extent());
-      vvispar.SetSize (vmap.Extent());
-
-      fsingular.SetSize (fmap.Extent());
-      esingular.SetSize (emap.Extent());
-      vsingular.SetSize (vmap.Extent());
-
-      fsingular = esingular = vsingular = false;
-   }
-
-
-
-   void OCCGeometry :: SewFaces ()
-   {
-      (*testout) << "Trying to sew faces ..." << endl;
-      cout << "Trying to sew faces ..." << flush;
-
-      BRepOffsetAPI_Sewing sewedObj(1);
- 
-      for (int i = 1; i <= fmap.Extent(); i++)
-      {
-         TopoDS_Face face = TopoDS::Face (fmap(i));
-         sewedObj.Add (face);
-      }
-
-      sewedObj.Perform();
-
-      if (!sewedObj.SewedShape().IsNull())
-      {
-         shape = sewedObj.SewedShape();
-         cout << " done" << endl;
-      }
-      else
-         cout << " not possible";
-   }
-
-
-
-
-
-   void OCCGeometry :: MakeSolid ()
-   {
-      TopExp_Explorer exp0;
-
-      (*testout) << "Trying to build solids ..." << endl;
-      cout << "Trying to build solids ..." << flush;
-
-      BRepBuilderAPI_MakeSolid ms;
-      int count = 0;
-      for (exp0.Init(shape, TopAbs_SHELL); exp0.More(); exp0.Next())
-      {
-         count++;
-         ms.Add (TopoDS::Shell(exp0.Current()));
-      }
-
-      if (!count)
-      {
-         cout << " not possible (no shells)" << endl;
-         return;
-      }
-
-      BRepCheck_Analyzer ba(ms);
-      if (ba.IsValid ())
-      {
-         Handle(ShapeFix_Shape) sfs = new ShapeFix_Shape;
-         sfs->Init (ms);
-
-         sfs->SetPrecision(1e-5);
-         sfs->SetMaxTolerance(1e-5);
-
-         sfs->Perform();
-
-         shape = sfs->Shape();
-
-         for (exp0.Init(shape, TopAbs_SOLID); exp0.More(); exp0.Next())
-         {
-            TopoDS_Solid solid = TopoDS::Solid(exp0.Current());
-            TopoDS_Solid newsolid = solid;
-            BRepLib::OrientClosedSolid (newsolid);
-            Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-            rebuild->Replace(solid, newsolid, Standard_False);
-
-            TopoDS_Shape newshape = rebuild->Apply(shape, TopAbs_SHAPE, 1);
-            shape = newshape;
-         }
-
-         cout << " done" << endl;
-      }
-      else
-         cout << " not possible" << endl;
-   }
-
-
-
-
-   void OCCGeometry :: BuildVisualizationMesh (double deflection)
-   {
-      cout << "Preparing visualization (deflection = " << deflection << ") ... " << flush;
-
-      BRepTools::Clean (shape);
-      // BRepMesh_IncrementalMesh::
-      BRepMesh_IncrementalMesh (shape, deflection, true);
-      cout << "done" << endl;
-   }
-
-
-
-
-   void OCCGeometry :: CalcBoundingBox ()
-   {
-      Bnd_Box bb;
-      BRepBndLib::Add (shape, bb);
-
-      double x1,y1,z1,x2,y2,z2;
-      bb.Get (x1,y1,z1,x2,y2,z2);
-      Point<3> p1 = Point<3> (x1,y1,z1);
-      Point<3> p2 = Point<3> (x2,y2,z2);
-
-      (*testout) << "Bounding Box = [" << p1 << " - " << p2 << "]" << endl;
-      boundingbox = Box<3> (p1,p2);
-      SetCenter();
-   }
-
-
-
-
-   void OCCGeometry :: Project (int surfi, Point<3> & p) const
-   {
-      static int cnt = 0;
-      if (++cnt % 1000 == 0) cout << "Project cnt = " << cnt << endl;
-
-      gp_Pnt pnt(p(0), p(1), p(2));
-
-      double u,v;
-      Handle( Geom_Surface ) thesurf = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
-      Handle( ShapeAnalysis_Surface ) su = new ShapeAnalysis_Surface( thesurf );
-      gp_Pnt2d suval = su->ValueOfUV ( pnt, BRep_Tool::Tolerance( TopoDS::Face(fmap(surfi)) ) );
-      suval.Coord( u, v);
-      pnt = thesurf->Value( u, v );
-
-
-      p = Point<3> (pnt.X(), pnt.Y(), pnt.Z());
-
-   }
-
-
-
-
-   bool OCCGeometry :: FastProject (int surfi, Point<3> & ap, double& u, double& v) const
-   {
-      gp_Pnt p(ap(0), ap(1), ap(2));
-
-      Handle(Geom_Surface) surface = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
-
-      gp_Pnt x = surface->Value (u,v);
-
-      if (p.SquareDistance(x) <= sqr(PROJECTION_TOLERANCE)) return true;
-
-      gp_Vec du, dv;
-
-      surface->D1(u,v,x,du,dv);
-
-      int count = 0;
-
-      gp_Pnt xold;
-      gp_Vec n;
-      double det, lambda, mu;
-
-      do {
-         count++;
-
-         n = du^dv;
-
-         det = Det3 (n.X(), du.X(), dv.X(),
-            n.Y(), du.Y(), dv.Y(),
-            n.Z(), du.Z(), dv.Z());
-
-         if (det < 1e-15) return false;
-
-         lambda = Det3 (n.X(), p.X()-x.X(), dv.X(),
-            n.Y(), p.Y()-x.Y(), dv.Y(),
-            n.Z(), p.Z()-x.Z(), dv.Z())/det;
-
-         mu     = Det3 (n.X(), du.X(), p.X()-x.X(),
-            n.Y(), du.Y(), p.Y()-x.Y(),
-            n.Z(), du.Z(), p.Z()-x.Z())/det;
-
-         u += lambda;
-         v += mu;
-
-         xold = x;
-         surface->D1(u,v,x,du,dv);
-
-      } while (xold.SquareDistance(x) > sqr(PROJECTION_TOLERANCE) && count < 50);
-
-      //    (*testout) << "FastProject count: " << count << endl;
-
-      if (count == 50) return false;
-
-      ap = Point<3> (x.X(), x.Y(), x.Z());
-
-      return true;
-   }
-
-
-
-
-   void OCCGeometry :: WriteOCC_STL(char * filename)
-   {
-      cout << "writing stl..."; cout.flush();
-      StlAPI_Writer writer;
-      writer.RelativeMode() = Standard_False;
-
-      writer.SetDeflection(0.02);
-      writer.Write(shape,filename);
-
-      cout << "done" << endl;
-   }
-
-
-
-   // Philippose - 23/02/2009
-   /* Special IGES File load function including the ability
-   to extract individual surface colours via the extended
-   OpenCascade XDE and XCAF Feature set.
-   */
-   OCCGeometry *LoadOCC_IGES(const char *filename)
-   {
-      OCCGeometry *occgeo;
-      occgeo = new OCCGeometry;
-
-      // Initiate a dummy XCAF Application to handle the IGES XCAF Document
-      static Handle_XCAFApp_Application dummy_app = XCAFApp_Application::GetApplication();
-
-      // Create an XCAF Document to contain the IGES file itself
-      Handle_TDocStd_Document iges_doc;
-
-      // Check if a IGES File is already open under this handle, if so, close it to prevent
-      // Segmentation Faults when trying to create a new document
-      if(dummy_app->NbDocuments() > 0)
-      {
-         dummy_app->GetDocument(1,iges_doc);
-         dummy_app->Close(iges_doc);
-      }
-      dummy_app->NewDocument ("IGES-XCAF",iges_doc);
-
-      IGESCAFControl_Reader reader;
-
-      Standard_Integer stat = reader.ReadFile((char*)filename);
-
-      if(stat != IFSelect_RetDone)
-      {
-         delete occgeo;
-         return NULL;
-      }
-
-      // Enable transfer of colours
-      reader.SetColorMode(Standard_True);
-
-      reader.Transfer(iges_doc);
-
-      // Read in the shape(s) and the colours present in the IGES File
-      Handle_XCAFDoc_ShapeTool iges_shape_contents = XCAFDoc_DocumentTool::ShapeTool(iges_doc->Main());
-      Handle_XCAFDoc_ColorTool iges_colour_contents = XCAFDoc_DocumentTool::ColorTool(iges_doc->Main());
-
-      TDF_LabelSequence iges_shapes;
-      iges_shape_contents->GetShapes(iges_shapes);
-
-      // List out the available colours in the IGES File as Colour Names
-      TDF_LabelSequence all_colours;
-      iges_colour_contents->GetColors(all_colours);
-      PrintMessage(1,"Number of colours in IGES File: ",all_colours.Length());
-      for(int i = 1; i <= all_colours.Length(); i++)
-      {
-         Quantity_Color col;
-         stringstream col_rgb;
-         iges_colour_contents->GetColor(all_colours.Value(i),col);
-         col_rgb << " : (" << col.Red() << "," << col.Green() << "," << col.Blue() << ")";
-         PrintMessage(1, "Colour [", i, "] = ",col.StringName(col.Name()),col_rgb.str());
-      }
-
-
-      // For the IGES Reader, all the shapes can be exported as one compund shape 
-      // using the "OneShape" member
-      occgeo->shape = reader.OneShape();
-      occgeo->face_colours = iges_colour_contents;
-      occgeo->changed = 1;
-      occgeo->BuildFMap();
-
-      occgeo->CalcBoundingBox();
-      PrintContents (occgeo);
-
-      return occgeo;
-   }
-
-
-
-
-
-   // Philippose - 29/01/2009
-   /* Special STEP File load function including the ability
-   to extract individual surface colours via the extended
-   OpenCascade XDE and XCAF Feature set.
-   */
-   OCCGeometry * LoadOCC_STEP (const char * filename)
-   {
-      OCCGeometry * occgeo;
-      occgeo = new OCCGeometry;
-
-      // Initiate a dummy XCAF Application to handle the STEP XCAF Document
-      static Handle_XCAFApp_Application dummy_app = XCAFApp_Application::GetApplication();
-
-      // Create an XCAF Document to contain the STEP file itself
-      Handle_TDocStd_Document step_doc;
-
-      // Check if a STEP File is already open under this handle, if so, close it to prevent
-      // Segmentation Faults when trying to create a new document
-      if(dummy_app->NbDocuments() > 0)
-      {
-         dummy_app->GetDocument(1,step_doc);
-         dummy_app->Close(step_doc);
-      }
-      dummy_app->NewDocument ("STEP-XCAF",step_doc);
-
-      STEPCAFControl_Reader reader;
-
-      // Enable transfer of colours
-      reader.SetColorMode(Standard_True);
-
-      Standard_Integer stat = reader.ReadFile((char*)filename);
-
-      if(stat != IFSelect_RetDone)
-      {
-         delete occgeo;
-         return NULL;
-      }
-
-      reader.Transfer(step_doc);
-
-      // Read in the shape(s) and the colours present in the STEP File
-      Handle_XCAFDoc_ShapeTool step_shape_contents = XCAFDoc_DocumentTool::ShapeTool(step_doc->Main());
-      Handle_XCAFDoc_ColorTool step_colour_contents = XCAFDoc_DocumentTool::ColorTool(step_doc->Main());
-
-      TDF_LabelSequence step_shapes;
-      step_shape_contents->GetShapes(step_shapes);
-
-      // List out the available colours in the STEP File as Colour Names
-      TDF_LabelSequence all_colours;
-      step_colour_contents->GetColors(all_colours);
-      PrintMessage(1,"Number of colours in STEP File: ",all_colours.Length());
-      for(int i = 1; i <= all_colours.Length(); i++)
-      {
-         Quantity_Color col;
-         stringstream col_rgb;
-         step_colour_contents->GetColor(all_colours.Value(i),col);
-         col_rgb << " : (" << col.Red() << "," << col.Green() << "," << col.Blue() << ")";
-         PrintMessage(1, "Colour [", i, "] = ",col.StringName(col.Name()),col_rgb.str());
-      }
-
-
-      // For the STEP File Reader in OCC, the 1st Shape contains the entire 
-      // compound geometry as one shape
-      occgeo->shape = step_shape_contents->GetShape(step_shapes.Value(1));
-      occgeo->face_colours = step_colour_contents;
-      occgeo->changed = 1;
-      occgeo->BuildFMap();
-
-      occgeo->CalcBoundingBox();
-      PrintContents (occgeo);
-
-      return occgeo;
-   }
-
-
-
-
-   OCCGeometry *LoadOCC_BREP (const char *filename)
-   {
-      OCCGeometry * occgeo;
-      occgeo = new OCCGeometry;
-
-      BRep_Builder aBuilder;
-      Standard_Boolean result = BRepTools::Read(occgeo->shape, const_cast<char*> (filename),aBuilder);
-
-      if(!result)
-      {
-         delete occgeo;
-         return NULL;
-      }
-
-      // Philippose - 23/02/2009
-      // Fixed a bug in the OpenCascade XDE Colour handling when 
-      // opening BREP Files, since BREP Files have no colour data.
-      // Hence, the face_colours Handle needs to be created as a NULL handle.
-      occgeo->face_colours = Handle_XCAFDoc_ColorTool();
-      occgeo->face_colours.Nullify();
-      occgeo->changed = 1;
-      occgeo->BuildFMap();
-
-      occgeo->CalcBoundingBox();
-      PrintContents (occgeo);
-
-      return occgeo;
-   }
-
-
-  void OCCGeometry :: Save (string sfilename) const
-  {
-    const char * filename = sfilename.c_str();
-    if (strlen(filename) < 4) 
-      throw NgException ("illegal filename");
-    
-    if (strcmp (&filename[strlen(filename)-3], "igs") == 0)
-      {
-	IGESControl_Writer writer("millimeters", 1);
-	writer.AddShape (shape);
-	writer.Write (filename);
-      }
-    else if (strcmp (&filename[strlen(filename)-3], "stp") == 0)
-      {
-	STEPControl_Writer writer;
-	writer.Transfer (shape, STEPControl_AsIs);
-	writer.Write (filename);
-      }
-    else if (strcmp (&filename[strlen(filename)-3], "stl") == 0)
-      {
-	StlAPI_Writer writer;
-	writer.ASCIIMode() = Standard_True;
-	writer.Write (shape, filename);
-      }
-    else if (strcmp (&filename[strlen(filename)-4], "stlb") == 0)
-      {
-	StlAPI_Writer writer;
-	writer.ASCIIMode() = Standard_False;
-	writer.Write (shape, filename);
-      }
-  }
-
-
-
-  const char * shapesname[] =
-   {" ", "CompSolids", "Solids", "Shells",
-
-   "Faces", "Wires", "Edges", "Vertices"};
-
-  const char * shapename[] =
-   {" ", "CompSolid", "Solid", "Shell",
-   "Face", "Wire", "Edge", "Vertex"};
-
-  const char * orientationstring[] =
-     {"+", "-"};
-
-
-
-
-   void OCCGeometry :: RecursiveTopologyTree (const TopoDS_Shape & sh,
-      stringstream & str,
-      TopAbs_ShapeEnum l,
-      bool isfree,
-      const char * lname)
-   {
-      if (l > TopAbs_VERTEX) return;
-
-      TopExp_Explorer e;
-      int count = 0;
-      int count2 = 0;
-
-      if (isfree)
-         e.Init(sh, l, TopAbs_ShapeEnum(l-1));
-      else
-         e.Init(sh, l);
-
-      for (; e.More(); e.Next())
-      {
-         count++;
-
-         stringstream lname2;
-         lname2 << lname << "/" << shapename[l] << count;
-         str << lname2.str() << " ";
-
-         switch (e.Current().ShapeType())
-	   {
-	   case TopAbs_SOLID:
-	     count2 = somap.FindIndex(TopoDS::Solid(e.Current())); break;
-	   case TopAbs_SHELL:
-	     count2 = shmap.FindIndex(TopoDS::Shell(e.Current())); break;
-	   case TopAbs_FACE:
-	     count2 = fmap.FindIndex(TopoDS::Face(e.Current())); break;
-	   case TopAbs_WIRE:
-	     count2 = wmap.FindIndex(TopoDS::Wire(e.Current())); break;
-	   case TopAbs_EDGE:
-	     count2 = emap.FindIndex(TopoDS::Edge(e.Current())); break;
-	   case TopAbs_VERTEX:
-	     count2 = vmap.FindIndex(TopoDS::Vertex(e.Current())); break;
-	   default:
-	     cout << "RecursiveTopologyTree: Case " << e.Current().ShapeType() << " not handeled" << endl;
-         }
-
-         int nrsubshapes = 0;
-
-         if (l <= TopAbs_WIRE)
-         {
-            TopExp_Explorer e2;
-            for (e2.Init (e.Current(), TopAbs_ShapeEnum (l+1));
-               e2.More(); e2.Next())
-               nrsubshapes++;
-         }
-
-         str << "{" << shapename[l] << " " << count2;
-
-         if (l <= TopAbs_EDGE)
-         {
-            str << " (" << orientationstring[e.Current().Orientation()];
-            if (nrsubshapes != 0) str << ", " << nrsubshapes;
-            str << ") } ";
-         }
-         else
-            str << " } ";
-
-         RecursiveTopologyTree (e.Current(), str, TopAbs_ShapeEnum (l+1),
-            false, (char*)lname2.str().c_str());
-
-      }
-   }
-
-
-
-
-   void OCCGeometry :: GetTopologyTree (stringstream & str)
-   {
-      cout << "Building topology tree ... " << flush;
-      RecursiveTopologyTree (shape, str, TopAbs_COMPSOLID, false, "CompSolids");
-      RecursiveTopologyTree (shape, str, TopAbs_SOLID, true, "FreeSolids");
-      RecursiveTopologyTree (shape, str, TopAbs_SHELL, true, "FreeShells");
-      RecursiveTopologyTree (shape, str, TopAbs_FACE, true, "FreeFaces");
-      RecursiveTopologyTree (shape, str, TopAbs_WIRE, true, "FreeWires");
-      RecursiveTopologyTree (shape, str, TopAbs_EDGE, true, "FreeEdges");
-      RecursiveTopologyTree (shape, str, TopAbs_VERTEX, true, "FreeVertices");
-      str << flush;
-      //  cout << "done" << endl;
-   }
-
-
-
-
-   void OCCGeometry :: CheckIrregularEntities(stringstream & str)
-   {
-      ShapeAnalysis_CheckSmallFace csm;
-
-      csm.SetTolerance (1e-6);
-
-      TopTools_DataMapOfShapeListOfShape mapEdges;
-      ShapeAnalysis_DataMapOfShapeListOfReal mapParam;
-      TopoDS_Compound theAllVert;
-
-      int spotfaces = 0;
-      int stripsupportfaces = 0;
-      int singlestripfaces = 0;
-      int stripfaces = 0;
-      int facessplitbyvertices = 0;
-      int stretchedpinfaces = 0;
-      int smoothpinfaces = 0;
-      int twistedfaces = 0;
-      // int edgessamebutnotidentified = 0;
-
-      cout << "checking faces ... " << flush;
-
-      int i;
-      for (i = 1; i <= fmap.Extent(); i++)
-      {
-         TopoDS_Face face = TopoDS::Face (fmap(i));
-         TopoDS_Edge e1, e2;
-
-         if (csm.CheckSpotFace (face))
-         {
-            if (!spotfaces++)
-               str << "SpotFace {Spot face} ";
-
-            (*testout) << "Face " << i << " is a spot face" << endl;
-            str << "SpotFace/Face" << i << " ";
-            str << "{Face " << i << " } ";
-         }
-
-         if (csm.IsStripSupport (face))
-         {
-            if (!stripsupportfaces++)
-               str << "StripSupportFace {Strip support face} ";
-
-            (*testout) << "Face " << i << " has strip support" << endl;
-            str << "StripSupportFace/Face" << i << " ";
-            str << "{Face " << i << " } ";
-         }
-
-         if (csm.CheckSingleStrip(face, e1, e2))
-         {
-            if (!singlestripfaces++)
-               str << "SingleStripFace {Single strip face} ";
-
-            (*testout) << "Face " << i << " is a single strip (edge " << emap.FindIndex(e1)
-               << " and edge " << emap.FindIndex(e2) << " are identical)" << endl;
-            str << "SingleStripFace/Face" << i << " ";
-            str << "{Face " << i << " (edge " << emap.FindIndex(e1)
-               << " and edge " << emap.FindIndex(e2) << " are identical)} ";
-         }
-
-         if (csm.CheckStripFace(face, e1, e2))
-         {
-            if (!stripfaces++)
-               str << "StripFace {Strip face} ";
-
-            (*testout) << "Face " << i << " is a strip (edge " << emap.FindIndex(e1)
-               << " and edge " << emap.FindIndex(e2)
-               << " are identical)" << endl;
-            str << "StripFace/Face" << i << " ";
-            str << "{Face " << i << " (edge " << emap.FindIndex(e1)
-               << " and edge " << emap.FindIndex(e2) << " are identical)} ";
-         }
-
-         if (int count = csm.CheckSplittingVertices(face, mapEdges, mapParam, theAllVert))
-         {
-            if (!facessplitbyvertices++)
-               str << "FaceSplitByVertices {Face split by vertices} ";
-
-            (*testout) << "Face " << i << " is split by " << count
-               << " vertex/vertices " << endl;
-            str << "FaceSplitByVertices/Face" << i << " ";
-            str << "{Face " << i << " (split by " << count << "vertex/vertices)} ";
-         }
-
-         int whatrow, sens;
-         if (int type = csm.CheckPin (face, whatrow, sens))
-         {
-            if (type == 1)
-            {
-               if (!smoothpinfaces++)
-                  str << "SmoothPinFace {Smooth pin face} ";
-
-               (*testout) << "Face " << i << " is a smooth pin" << endl;
-               str << "SmoothPinFace/Face" << i << " ";
-               str << "{Face " << i << " } ";
-            }
-            else
-            {
-               if (!stretchedpinfaces++)
-                  str << "StretchedPinFace {Stretched pin face} ";
-
-               (*testout) << "Face " << i << " is a streched pin" << endl;
-               str << "StretchedPinFace/Face" << i << " ";
-               str << "{Face " << i << " } ";
-            }
-         }
-
-         double paramu, paramv;
-         if (csm.CheckTwisted (face, paramu, paramv))
-         {
-            if (!twistedfaces++)
-               str << "TwistedFace {Twisted face} ";
-
-            (*testout) << "Face " << i << " is twisted" << endl;
-            str << "TwistedFace/Face" << i << " ";
-            str << "{Face " << i << " } ";
-         }
-      }
-
-      cout << "done" << endl;
-      cout << "checking edges ... " << flush;
-
-      // double dmax;
-      // int cnt = 0;
-      Array <double> edgeLengths;
-      Array <int> order;
-      edgeLengths.SetSize (emap.Extent());
-      order.SetSize (emap.Extent());
-
-      for (i = 1; i <= emap.Extent(); i++)
-      {
-         TopoDS_Edge edge1 = TopoDS::Edge (emap(i));
-         GProp_GProps system;
-         BRepGProp::LinearProperties(edge1, system);
-         edgeLengths[i-1] = system.Mass();
-      }
-
-      Sort (edgeLengths, order);
-
-      str << "ShortestEdges {Shortest edges} ";
-      for (i = 1; i <= min(20, emap.Extent()); i++)
-      {
-         str << "ShortestEdges/Edge" << i;
-         str << " {Edge " << order[i-1] << " (L=" << edgeLengths[order[i-1]-1] << ")} ";
-      }
-
-      str << flush;
-
-      cout << "done" << endl;
-   }
-
-
-
-
-   void OCCGeometry :: GetUnmeshedFaceInfo (stringstream & str)
-   {
-      for (int i = 1; i <= fmap.Extent(); i++)
-      {
-         if (facemeshstatus[i-1] == -1)
-            str << "Face" << i << " {Face " << i << " } ";
-      }
-      str << flush;
-   }
-
-
-
-
-   void OCCGeometry :: GetNotDrawableFaces (stringstream & str)
-   {
-      for (int i = 1; i <= fmap.Extent(); i++)
-      {
-         if (!fvispar[i-1].IsDrawable())
-            str << "Face" << i << " {Face " << i << " } ";
-      }
-      str << flush;
-   }
-
-
-
-
-   bool OCCGeometry :: ErrorInSurfaceMeshing ()
-   {
-      for (int i = 1; i <= fmap.Extent(); i++)
-         if (facemeshstatus[i-1] == -1)
-            return true;
-
-      return false;
-   }
-
-
-
-
-  int OCCGeometry :: GenerateMesh (Mesh*& mesh, MeshingParameters & mparam,
-      int perfstepsstart, int perfstepsend)
-   {
-     return OCCGenerateMesh (*this, mesh, mparam, perfstepsstart, perfstepsend);
-   }
-
-
-
-
-   const Refinement & OCCGeometry :: GetRefinement () const
-   {
-      return * new OCCRefinementSurfaces (*this);
-   }
-
-
-
-
-   OCCParameters :: OCCParameters()
-   {
-      resthcloseedgefac = 1;
-      resthcloseedgeenable = 1;
-	  resthminedgelen = 0.001;
-	  resthminedgelenenable = 1;
-   }
-
-
-
-
-   void OCCParameters :: Print(ostream & ost) const
-   {
-      ost << "OCC Parameters:" << endl
-         << "close edges: " << resthcloseedgeenable
-         << ", fac = " << resthcloseedgefac << endl
-		 << "minimum edge length: " << resthminedgelenenable
-		 << ", min len = " << resthminedgelen << endl;
-   }
-
-
-
-
-   OCCParameters occparam;
-
-}
-
-
-#endif
+
+#ifdef OCCGEOMETRY
+
+#include <mystdlib.h>
+#include <occgeom.hpp>
+#include "ShapeAnalysis_ShapeTolerance.hxx"
+#include "ShapeAnalysis_ShapeContents.hxx"
+#include "ShapeAnalysis_CheckSmallFace.hxx"
+#include "ShapeAnalysis_DataMapOfShapeListOfReal.hxx"
+#include "ShapeAnalysis_Surface.hxx"
+#include <BRepTopAdaptor_FClass2d.hxx> // -- to optimize Project() and FastProject()
+#include <TopAbs_State.hxx>
+#include "BRepAlgoAPI_Fuse.hxx"
+#include "BRepCheck_Analyzer.hxx"
+#include "BRepLib.hxx"
+#include "ShapeBuild_ReShape.hxx"
+#include "ShapeFix.hxx"
+#include "ShapeFix_FixSmallFace.hxx"
+#include "Partition_Spliter.hxx"
+
+namespace netgen
+{
+  // free data used to optimize Project() and FastProject()
+  OCCGeometry::~OCCGeometry()
+  {
+    NCollection_DataMap<int,BRepTopAdaptor_FClass2d*>::Iterator it(fclsmap);
+    for (; it.More(); it.Next())
+      delete it.Value();
+  }
+
+   void OCCGeometry :: PrintNrShapes ()
+   {
+      TopExp_Explorer e;
+      int count = 0;
+      for (e.Init(shape, TopAbs_COMPSOLID); e.More(); e.Next()) count++;
+      std::cout << "CompSolids: " << count << std::endl;
+
+      std::cout << "Solids    : " << somap.Extent() << std::endl;
+      std::cout << "Shells    : " << shmap.Extent() << std::endl;
+      std::cout << "Faces     : " << fmap.Extent() << std::endl;
+      std::cout << "Edges     : " << emap.Extent() << std::endl;
+      std::cout << "Vertices  : " << vmap.Extent() << std::endl;
+   }
+
+
+
+
+   void PrintContents (OCCGeometry * geom)
+   {
+      ShapeAnalysis_ShapeContents cont;
+      cont.Clear();
+      cont.Perform(geom->shape);
+
+      (*testout) << "OCC CONTENTS" << std::endl;
+      (*testout) << "============" << std::endl;
+      (*testout) << "SOLIDS   : " << cont.NbSolids() << std::endl;
+      (*testout) << "SHELLS   : " << cont.NbShells() << std::endl;
+      (*testout) << "FACES    : " << cont.NbFaces() << std::endl;
+      (*testout) << "WIRES    : " << cont.NbWires() << std::endl;
+      (*testout) << "EDGES    : " << cont.NbEdges() << std::endl;
+      (*testout) << "VERTICES : " << cont.NbVertices() << std::endl;
+
+      TopExp_Explorer e;
+      int count = 0;
+      for (e.Init(geom->shape, TopAbs_COMPOUND); e.More(); e.Next())
+         count++;
+      (*testout) << "Compounds: " << count << std::endl;
+
+      count = 0;
+      for (e.Init(geom->shape, TopAbs_COMPSOLID); e.More(); e.Next())
+         count++;
+      (*testout) << "CompSolids: " << count << std::endl;
+
+      (*testout) << std::endl;
+
+      std::cout << "Highest entry in topology hierarchy: " << std::endl;
+      if (count)
+         std::cout << count << " composite solid(s)" << std::endl;
+      else
+         if (geom->somap.Extent())
+            std::cout << geom->somap.Extent() << " solid(s)" << std::endl;
+         else
+            if (geom->shmap.Extent())
+               std::cout << geom->shmap.Extent() << " shells(s)" << std::endl;
+            else
+               if (geom->fmap.Extent())
+                  std::cout << geom->fmap.Extent() << " face(s)" << std::endl;
+               else
+                  if (geom->wmap.Extent())
+                     std::cout << geom->wmap.Extent() << " wire(s)" << std::endl;
+                  else
+                     if (geom->emap.Extent())
+                        std::cout << geom->emap.Extent() << " edge(s)" << std::endl;
+                     else
+                        if (geom->vmap.Extent())
+                           std::cout << geom->vmap.Extent() << " vertices(s)" << std::endl;
+                        else
+                           std::cout << "no entities" << std::endl;
+
+   }
+
+
+
+   void OCCGeometry :: HealGeometry ()
+   {
+      int nrc = 0, nrcs = 0,
+         nrso = somap.Extent(),
+         nrsh = shmap.Extent(),
+         nrf = fmap.Extent(),
+         nrw = wmap.Extent(),
+         nre = emap.Extent(),
+         nrv = vmap.Extent();
+
+      TopExp_Explorer exp0;
+      TopExp_Explorer exp1;
+
+
+      for (exp0.Init(shape, TopAbs_COMPOUND); exp0.More(); exp0.Next()) nrc++;
+      for (exp0.Init(shape, TopAbs_COMPSOLID); exp0.More(); exp0.Next()) nrcs++;
+
+      double surfacecont = 0;
+
+      {
+         Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+         rebuild->Apply(shape);
+         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+         {
+            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+            if ( BRep_Tool::Degenerated(edge) )
+               rebuild->Remove(edge);
+         }
+         shape = rebuild->Apply(shape);
+      }
+
+      BuildFMap();
+
+
+      for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
+      {
+         TopoDS_Face face = TopoDS::Face(exp0.Current());
+
+         GProp_GProps system;
+         BRepGProp::SurfaceProperties(face, system);
+         surfacecont += system.Mass();
+      }
+
+
+      std::cout << "Starting geometry healing procedure (tolerance: " << tolerance << ")" << std::endl
+         << "-----------------------------------" << std::endl;
+
+      {
+         std::cout << std::endl << "- repairing faces" << std::endl;
+
+         Handle(ShapeFix_Face) sff;
+         Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+         rebuild->Apply(shape);
+
+
+         for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
+         {
+            // Variable to hold the colour (if there exists one) of 
+            // the current face being processed
+            Quantity_Color face_colour;
+
+            TopoDS_Face face = TopoDS::Face (exp0.Current());
+
+            if(face_colours.IsNull()
+               || (!(face_colours->GetColor(face,XCAFDoc_ColorSurf,face_colour))))
+            {
+               // Set the default face colour to green (Netgen Standard)
+               // if no colour has been defined for the face
+               face_colour = Quantity_Color(0.0,1.0,0.0,Quantity_TOC_RGB);
+            }
+
+            sff = new ShapeFix_Face (face);
+            sff->FixAddNaturalBoundMode() = Standard_True;
+            sff->FixSmallAreaWireMode() = Standard_True;
+            sff->Perform();
+
+            if(sff->Status(ShapeExtend_DONE1) ||
+               sff->Status(ShapeExtend_DONE2) ||
+               sff->Status(ShapeExtend_DONE3) ||
+               sff->Status(ShapeExtend_DONE4) ||
+               sff->Status(ShapeExtend_DONE5))
+            {
+               std::cout << "repaired face " << fmap.FindIndex(face) << " ";
+               if(sff->Status(ShapeExtend_DONE1))
+                  std::cout << "(some wires are fixed)" <<std::endl;
+               else if(sff->Status(ShapeExtend_DONE2))
+                  std::cout << "(orientation of wires fixed)" <<std::endl;
+               else if(sff->Status(ShapeExtend_DONE3))
+                  std::cout << "(missing seam added)" <<std::endl;
+               else if(sff->Status(ShapeExtend_DONE4))
+                  std::cout << "(small area wire removed)" <<std::endl;
+               else if(sff->Status(ShapeExtend_DONE5))
+                  std::cout << "(natural bounds added)" <<std::endl;
+               TopoDS_Face newface = sff->Face();
+
+               rebuild->Replace(face, newface);
+            }
+
+            // Set the original colour of the face to the newly created 
+            // face (after the healing process)
+            face = TopoDS::Face (exp0.Current());
+            face_colours->SetColor(face,face_colour,XCAFDoc_ColorSurf);
+         }
+         shape = rebuild->Apply(shape);
+      }
+
+
+      {
+         Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+         rebuild->Apply(shape);
+         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+         {
+            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+            if ( BRep_Tool::Degenerated(edge) )
+               rebuild->Remove(edge);
+         }
+         shape = rebuild->Apply(shape);
+      }
+
+
+      if (fixsmalledges)
+      {
+         std::cout << std::endl << "- fixing small edges" << std::endl;
+
+         Handle(ShapeFix_Wire) sfw;
+         Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+         rebuild->Apply(shape);
+
+
+         for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
+         {
+            TopoDS_Face face = TopoDS::Face(exp0.Current());
+
+            for (exp1.Init (face, TopAbs_WIRE); exp1.More(); exp1.Next())
+            {
+               TopoDS_Wire oldwire = TopoDS::Wire(exp1.Current());
+               sfw = new ShapeFix_Wire (oldwire, face ,tolerance);
+               sfw->ModifyTopologyMode() = Standard_True;
+
+               sfw->ClosedWireMode() = Standard_True;
+
+               bool replace = false;
+
+               replace = sfw->FixReorder() || replace;
+
+               replace = sfw->FixConnected() || replace;
+
+
+
+               if (sfw->FixSmall (Standard_False, tolerance) && ! (sfw->StatusSmall(ShapeExtend_FAIL1) ||
+                  sfw->StatusSmall(ShapeExtend_FAIL2) ||
+                  sfw->StatusSmall(ShapeExtend_FAIL3)))
+               {
+                  std::cout << "Fixed small edge in wire " << wmap.FindIndex (oldwire) << std::endl;
+                  replace = true;
+
+               }
+               else if (sfw->StatusSmall(ShapeExtend_FAIL1))
+                  cerr << "Failed to fix small edge in wire " << wmap.FindIndex (oldwire)
+                  << ", edge cannot be checked (no 3d curve and no pcurve)" << std::endl;
+               else if (sfw->StatusSmall(ShapeExtend_FAIL2))
+                  cerr << "Failed to fix small edge in wire " << wmap.FindIndex (oldwire)
+                  << ", edge is null-length and has different vertives at begin and end, and lockvtx is True or ModifiyTopologyMode is False" << std::endl;
+               else if (sfw->StatusSmall(ShapeExtend_FAIL3))
+                  cerr << "Failed to fix small edge in wire " << wmap.FindIndex (oldwire)
+                  << ", CdheckConnected has failed" << std::endl;
+
+               replace = sfw->FixEdgeCurves() || replace;
+
+               replace = sfw->FixDegenerated() || replace;
+
+               replace = sfw->FixSelfIntersection() || replace;
+
+               replace = sfw->FixLacking(Standard_True) || replace;
+
+               if(replace)
+               {
+                  TopoDS_Wire newwire = sfw->Wire();
+                  rebuild->Replace(oldwire, newwire);
+               }
+
+               //delete sfw; sfw = NULL;
+
+            }
+         }
+
+         shape = rebuild->Apply(shape);
+
+
+
+         {
+            BuildFMap();
+            Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+            rebuild->Apply(shape);
+
+            for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+            {
+               TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+               if (vmap.FindIndex(TopExp::FirstVertex (edge)) ==
+                  vmap.FindIndex(TopExp::LastVertex (edge)))
+               {
+                  GProp_GProps system;
+                  BRepGProp::LinearProperties(edge, system);
+                  if (system.Mass() < tolerance)
+                  {
+                     std::cout << "removing degenerated edge " << emap.FindIndex(edge)
+                        << " from vertex " << vmap.FindIndex(TopExp::FirstVertex (edge))
+                        << " to vertex " << vmap.FindIndex(TopExp::LastVertex (edge)) << std::endl;
+                     rebuild->Remove(edge);
+                  }
+               }
+            }
+            shape = rebuild->Apply(shape);
+
+            //delete rebuild; rebuild = NULL;
+         }
+
+
+
+         {
+            Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+            rebuild->Apply(shape);
+            for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+            {
+               TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+               if ( BRep_Tool::Degenerated(edge) )
+                  rebuild->Remove(edge);
+            }
+            shape = rebuild->Apply(shape);
+         }
+
+
+
+
+         Handle(ShapeFix_Wireframe) sfwf = new ShapeFix_Wireframe;
+         sfwf->SetPrecision(tolerance);
+         sfwf->Load (shape);
+         sfwf->ModeDropSmallEdges() = Standard_True;
+
+         sfwf->SetPrecision(boundingbox.Diam());
+
+         if (sfwf->FixWireGaps())
+         {
+            std::cout << std::endl << "- fixing wire gaps" << std::endl;
+            if (sfwf->StatusWireGaps(ShapeExtend_OK)) std::cout << "no gaps found" << std::endl;
+            if (sfwf->StatusWireGaps(ShapeExtend_DONE1)) std::cout << "some 2D gaps fixed" << std::endl;
+            if (sfwf->StatusWireGaps(ShapeExtend_DONE2)) std::cout << "some 3D gaps fixed" << std::endl;
+            if (sfwf->StatusWireGaps(ShapeExtend_FAIL1)) std::cout << "failed to fix some 2D gaps" << std::endl;
+            if (sfwf->StatusWireGaps(ShapeExtend_FAIL2)) std::cout << "failed to fix some 3D gaps" << std::endl;
+         }
+
+         sfwf->SetPrecision(tolerance);
+
+
+         {
+            for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+            {
+               TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+               if ( BRep_Tool::Degenerated(edge) )
+                  std::cout << "degenerated edge at position 4" << std::endl;
+            }
+         }
+
+
+
+         if (sfwf->FixSmallEdges())
+         {
+            std::cout << std::endl << "- fixing wire frames" << std::endl;
+            if (sfwf->StatusSmallEdges(ShapeExtend_OK)) std::cout << "no small edges found" << std::endl;
+            if (sfwf->StatusSmallEdges(ShapeExtend_DONE1)) std::cout << "some small edges fixed" << std::endl;
+            if (sfwf->StatusSmallEdges(ShapeExtend_FAIL1)) std::cout << "failed to fix some small edges" << std::endl;
+         }
+
+
+
+         shape = sfwf->Shape();
+
+         //delete sfwf; sfwf = NULL;
+         //delete rebuild; rebuild = NULL;
+
+      }
+
+
+
+
+
+      {
+         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+         {
+            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+            if ( BRep_Tool::Degenerated(edge) )
+               std::cout << "degenerated edge at position 5" << std::endl;
+         }
+      }
+
+
+
+
+      if (fixspotstripfaces)
+      {
+
+         std::cout << std::endl << "- fixing spot and strip faces" << std::endl;
+         Handle(ShapeFix_FixSmallFace) sffsm = new ShapeFix_FixSmallFace();
+         sffsm -> Init (shape);
+         sffsm -> SetPrecision (tolerance);
+         sffsm -> Perform();
+
+         shape = sffsm -> FixShape();
+         //delete sffsm; sffsm = NULL;
+      }
+
+
+      {
+         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+         {
+            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+            if ( BRep_Tool::Degenerated(edge) )
+               std::cout << "degenerated edge at position 6" << std::endl;
+         }
+      }
+
+
+
+      if (sewfaces)
+      {
+         std::cout << std::endl << "- sewing faces" << std::endl;
+
+         BRepOffsetAPI_Sewing sewedObj(tolerance);
+
+         for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
+         {
+            TopoDS_Face face = TopoDS::Face (exp0.Current());
+            sewedObj.Add (face);
+         }
+
+         sewedObj.Perform();
+
+         if (!sewedObj.SewedShape().IsNull())
+            shape = sewedObj.SewedShape();
+         else
+            std::cout << " not possible";
+      }
+
+
+
+      {
+         Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+         rebuild->Apply(shape);
+         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+         {
+            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+            if ( BRep_Tool::Degenerated(edge) )
+               rebuild->Remove(edge);
+         }
+         shape = rebuild->Apply(shape);
+      }
+
+
+      if (makesolids)
+      {
+         std::cout << std::endl << "- making solids" << std::endl;
+
+         BRepBuilderAPI_MakeSolid ms;
+         int count = 0;
+         for (exp0.Init(shape, TopAbs_SHELL); exp0.More(); exp0.Next())
+         {
+            count++;
+            ms.Add (TopoDS::Shell(exp0.Current()));
+         }
+
+         if (!count)
+         {
+            std::cout << " not possible (no shells)" << std::endl;
+         }
+         else
+         {
+            BRepCheck_Analyzer ba(ms);
+            if (ba.IsValid ())
+            {
+               Handle(ShapeFix_Shape) sfs = new ShapeFix_Shape;
+               sfs->Init (ms);
+               sfs->SetPrecision(tolerance);
+               sfs->SetMaxTolerance(tolerance);
+               sfs->Perform();
+               shape = sfs->Shape();
+
+               for (exp0.Init(shape, TopAbs_SOLID); exp0.More(); exp0.Next())
+               {
+                  TopoDS_Solid solid = TopoDS::Solid(exp0.Current());
+                  TopoDS_Solid newsolid = solid;
+                  BRepLib::OrientClosedSolid (newsolid);
+                  Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+                  //		  rebuild->Apply(shape);
+                  rebuild->Replace(solid, newsolid);
+                  TopoDS_Shape newshape = rebuild->Apply(shape, TopAbs_COMPSOLID);//, 1);
+                  //		  TopoDS_Shape newshape = rebuild->Apply(shape);
+                  shape = newshape;
+               }
+
+               //delete sfs; sfs = NULL;
+            }
+            else
+               std::cout << " not possible" << std::endl;
+         }
+      }
+
+
+
+      if (splitpartitions)
+      {
+         std::cout << "- running SALOME partition splitter" << std::endl;
+
+         TopExp_Explorer e2;
+         Partition_Spliter ps;
+         int count = 0;
+
+         for (e2.Init (shape, TopAbs_SOLID);
+            e2.More(); e2.Next())
+         {
+            count++;
+            ps.AddShape (e2.Current());
+         }
+
+         ps.Compute();
+         shape = ps.Shape();
+
+         std::cout << " before: " << count << " solids" << std::endl;
+
+         count = 0;
+         for (e2.Init (shape, TopAbs_SOLID);
+            e2.More(); e2.Next()) count++;
+
+            std::cout << " after : " << count << " solids" << std::endl;
+      }
+
+      BuildFMap();
+
+
+
+      {
+         for (exp1.Init (shape, TopAbs_EDGE); exp1.More(); exp1.Next())
+         {
+            TopoDS_Edge edge = TopoDS::Edge(exp1.Current());
+            if ( BRep_Tool::Degenerated(edge) )
+               std::cout << "degenerated edge at position 8" << std::endl;
+         }
+      }
+
+
+      double newsurfacecont = 0;
+
+
+      for (exp0.Init (shape, TopAbs_FACE); exp0.More(); exp0.Next())
+      {
+         TopoDS_Face face = TopoDS::Face(exp0.Current());
+         GProp_GProps system;
+         BRepGProp::SurfaceProperties(face, system);
+         newsurfacecont += system.Mass();
+      }
+
+
+      int nnrc = 0, nnrcs = 0,
+         nnrso = somap.Extent(),
+         nnrsh = shmap.Extent(),
+         nnrf = fmap.Extent(),
+         nnrw = wmap.Extent(),
+         nnre = emap.Extent(),
+         nnrv = vmap.Extent();
+
+      for (exp0.Init(shape, TopAbs_COMPOUND); exp0.More(); exp0.Next()) nnrc++;
+      for (exp0.Init(shape, TopAbs_COMPSOLID); exp0.More(); exp0.Next()) nnrcs++;
+
+      std::cout << "-----------------------------------" << std::endl;
+      std::cout << "Compounds       : " << nnrc << " (" << nrc << ")" << std::endl;
+      std::cout << "Composite solids: " << nnrcs << " (" << nrcs << ")" << std::endl;
+      std::cout << "Solids          : " << nnrso << " (" << nrso << ")" << std::endl;
+      std::cout << "Shells          : " << nnrsh << " (" << nrsh << ")" << std::endl;
+      std::cout << "Wires           : " << nnrw << " (" << nrw << ")" << std::endl;
+      std::cout << "Faces           : " << nnrf << " (" << nrf << ")" << std::endl;
+      std::cout << "Edges           : " << nnre << " (" << nre << ")" << std::endl;
+      std::cout << "Vertices        : " << nnrv << " (" << nrv << ")" << std::endl;
+      std::cout << std::endl;
+      std::cout << "Totol surface area : " << newsurfacecont << " (" << surfacecont << ")" << std::endl;
+      std::cout << std::endl;
+   }
+
+
+
+
+   void OCCGeometry :: BuildFMap()
+   {
+      somap.Clear();
+      shmap.Clear();
+      fmap.Clear();
+      wmap.Clear();
+      emap.Clear();
+      vmap.Clear();
+
+      TopExp_Explorer exp0, exp1, exp2, exp3, exp4, exp5;
+
+      for (exp0.Init(shape, TopAbs_COMPOUND);
+         exp0.More(); exp0.Next())
+      {
+         TopoDS_Compound compound = TopoDS::Compound (exp0.Current());
+         (*testout) << "compound" << std::endl;
+         int i = 0;
+         for (exp1.Init(compound, TopAbs_SHELL);
+            exp1.More(); exp1.Next())
+         {
+            (*testout) << "shell " << ++i << std::endl;
+         }
+      }
+
+      for (exp0.Init(shape, TopAbs_SOLID);
+         exp0.More(); exp0.Next())
+      {
+         TopoDS_Solid solid = TopoDS::Solid (exp0.Current());
+
+         if (somap.FindIndex(solid) < 1)
+         {
+            somap.Add (solid);
+
+            for (exp1.Init(solid, TopAbs_SHELL);
+               exp1.More(); exp1.Next())
+            {
+               TopoDS_Shell shell = TopoDS::Shell (exp1.Current());
+               if (shmap.FindIndex(shell) < 1)
+               {
+                  shmap.Add (shell);
+
+                  for (exp2.Init(shell, TopAbs_FACE);
+                     exp2.More(); exp2.Next())
+                  {
+                     TopoDS_Face face = TopoDS::Face(exp2.Current());
+                     if (fmap.FindIndex(face) < 1)
+                     {
+                        fmap.Add (face);
+                        (*testout) << "face " << fmap.FindIndex(face) << " ";
+                        (*testout) << ((face.Orientation() == TopAbs_REVERSED) ? "-" : "+") << ", ";
+                        (*testout) << ((exp2.Current().Orientation() == TopAbs_REVERSED) ? "-" : "+") << std::endl;
+                        for (exp3.Init(exp2.Current(), TopAbs_WIRE);
+                           exp3.More(); exp3.Next())
+                        {
+                           TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
+                           if (wmap.FindIndex(wire) < 1)
+                           {
+                              wmap.Add (wire);
+
+                              for (exp4.Init(exp3.Current(), TopAbs_EDGE);
+                                 exp4.More(); exp4.Next())
+                              {
+                                 TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
+                                 if (emap.FindIndex(edge) < 1)
+                                 {
+                                    emap.Add (edge);
+                                    for (exp5.Init(exp4.Current(), TopAbs_VERTEX);
+                                       exp5.More(); exp5.Next())
+                                    {
+                                       TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
+                                       if (vmap.FindIndex(vertex) < 1)
+                                          vmap.Add (vertex);
+                                    }
+                                 }
+                              }
+                           }
+                        }
+                     }
+                  }
+               }
+            }
+         }
+      }
+
+      // Free Shells
+      for (exp1.Init(shape, TopAbs_SHELL, TopAbs_SOLID); exp1.More(); exp1.Next())
+      {
+         TopoDS_Shell shell = TopoDS::Shell(exp1.Current());
+         if (shmap.FindIndex(shell) < 1)
+         {
+            shmap.Add (shell);
+
+            (*testout) << "shell " << shmap.FindIndex(shell) << " ";
+            (*testout) << ((shell.Orientation() == TopAbs_REVERSED) ? "-" : "+") << ", ";
+            (*testout) << ((exp1.Current().Orientation() == TopAbs_REVERSED) ? "-" : "+") << std::endl;
+
+            for (exp2.Init(shell, TopAbs_FACE); exp2.More(); exp2.Next())
+            {
+               TopoDS_Face face = TopoDS::Face(exp2.Current());
+               if (fmap.FindIndex(face) < 1)
+               {
+                  fmap.Add (face);
+
+                  for (exp3.Init(face, TopAbs_WIRE); exp3.More(); exp3.Next())
+                  {
+                     TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
+                     if (wmap.FindIndex(wire) < 1)
+                     {
+                        wmap.Add (wire);
+
+                        for (exp4.Init(wire, TopAbs_EDGE); exp4.More(); exp4.Next())
+                        {
+                           TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
+                           if (emap.FindIndex(edge) < 1)
+                           {
+                              emap.Add (edge);
+                              for (exp5.Init(edge, TopAbs_VERTEX); exp5.More(); exp5.Next())
+                              {
+                                 TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
+                                 if (vmap.FindIndex(vertex) < 1)
+                                    vmap.Add (vertex);
+                              }
+                           }
+                        }
+                     }
+                  }
+               }
+            }
+         }
+      }
+
+
+      // Free Faces
+
+      for (exp2.Init(shape, TopAbs_FACE, TopAbs_SHELL); exp2.More(); exp2.Next())
+      {
+         TopoDS_Face face = TopoDS::Face(exp2.Current());
+         if (fmap.FindIndex(face) < 1)
+         {
+            fmap.Add (face);
+
+            for (exp3.Init(exp2.Current(), TopAbs_WIRE); exp3.More(); exp3.Next())
+            {
+               TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
+               if (wmap.FindIndex(wire) < 1)
+               {
+                  wmap.Add (wire);
+
+                  for (exp4.Init(exp3.Current(), TopAbs_EDGE); exp4.More(); exp4.Next())
+                  {
+                     TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
+                     if (emap.FindIndex(edge) < 1)
+                     {
+                        emap.Add (edge);
+                        for (exp5.Init(exp4.Current(), TopAbs_VERTEX); exp5.More(); exp5.Next())
+                        {
+                           TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
+                           if (vmap.FindIndex(vertex) < 1)
+                              vmap.Add (vertex);
+                        }
+                     }
+                  }
+               }
+            }
+         }
+      }
+
+
+      // Free Wires
+
+      for (exp3.Init(shape, TopAbs_WIRE, TopAbs_FACE); exp3.More(); exp3.Next())
+      {
+         TopoDS_Wire wire = TopoDS::Wire (exp3.Current());
+         if (wmap.FindIndex(wire) < 1)
+         {
+            wmap.Add (wire);
+
+            for (exp4.Init(exp3.Current(), TopAbs_EDGE); exp4.More(); exp4.Next())
+            {
+               TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
+               if (emap.FindIndex(edge) < 1)
+               {
+                  emap.Add (edge);
+                  for (exp5.Init(exp4.Current(), TopAbs_VERTEX); exp5.More(); exp5.Next())
+                  {
+                     TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
+                     if (vmap.FindIndex(vertex) < 1)
+                        vmap.Add (vertex);
+                  }
+               }
+            }
+         }
+      }
+
+
+      // Free Edges
+
+      for (exp4.Init(shape, TopAbs_EDGE, TopAbs_WIRE); exp4.More(); exp4.Next())
+      {
+         TopoDS_Edge edge = TopoDS::Edge(exp4.Current());
+         if (emap.FindIndex(edge) < 1)
+         {
+            emap.Add (edge);
+            for (exp5.Init(exp4.Current(), TopAbs_VERTEX); exp5.More(); exp5.Next())
+            {
+               TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
+               if (vmap.FindIndex(vertex) < 1)
+                  vmap.Add (vertex);
+            }
+         }
+      }
+
+
+      // Free Vertices
+
+      for (exp5.Init(shape, TopAbs_VERTEX, TopAbs_EDGE); exp5.More(); exp5.Next())
+      {
+         TopoDS_Vertex vertex = TopoDS::Vertex(exp5.Current());
+         if (vmap.FindIndex(vertex) < 1)
+            vmap.Add (vertex);
+      }
+
+
+
+
+      facemeshstatus.DeleteAll();
+      facemeshstatus.SetSize (fmap.Extent());
+      facemeshstatus = 0;
+
+      // Philippose - 15/01/2009
+      face_maxh.DeleteAll();
+      face_maxh.SetSize (fmap.Extent());
+      face_maxh = mparam.maxh;
+
+      // Philippose - 15/01/2010      
+      face_maxh_modified.DeleteAll();      
+      face_maxh_modified.SetSize(fmap.Extent());      
+      face_maxh_modified = 0;
+      
+
+      // Philippose - 17/01/2009
+      face_sel_status.DeleteAll();
+      face_sel_status.SetSize (fmap.Extent());
+      face_sel_status = 0;
+
+      fvispar.SetSize (fmap.Extent());
+      evispar.SetSize (emap.Extent());
+      vvispar.SetSize (vmap.Extent());
+
+      fsingular.SetSize (fmap.Extent());
+      esingular.SetSize (emap.Extent());
+      vsingular.SetSize (vmap.Extent());
+
+      fsingular = esingular = vsingular = false;
+   }
+
+
+
+   void OCCGeometry :: SewFaces ()
+   {
+      (*testout) << "Trying to sew faces ..." << std::endl;
+      std::cout << "Trying to sew faces ..." << flush;
+
+      BRepOffsetAPI_Sewing sewedObj(1);
+ 
+      for (int i = 1; i <= fmap.Extent(); i++)
+      {
+         TopoDS_Face face = TopoDS::Face (fmap(i));
+         sewedObj.Add (face);
+      }
+
+      sewedObj.Perform();
+
+      if (!sewedObj.SewedShape().IsNull())
+      {
+         shape = sewedObj.SewedShape();
+         std::cout << " done" << std::endl;
+      }
+      else
+         std::cout << " not possible";
+   }
+
+
+
+
+
+   void OCCGeometry :: MakeSolid ()
+   {
+      TopExp_Explorer exp0;
+
+      (*testout) << "Trying to build solids ..." << std::endl;
+      std::cout << "Trying to build solids ..." << flush;
+
+      BRepBuilderAPI_MakeSolid ms;
+      int count = 0;
+      for (exp0.Init(shape, TopAbs_SHELL); exp0.More(); exp0.Next())
+      {
+         count++;
+         ms.Add (TopoDS::Shell(exp0.Current()));
+      }
+
+      if (!count)
+      {
+         std::cout << " not possible (no shells)" << std::endl;
+         return;
+      }
+
+      BRepCheck_Analyzer ba(ms);
+      if (ba.IsValid ())
+      {
+         Handle(ShapeFix_Shape) sfs = new ShapeFix_Shape;
+         sfs->Init (ms);
+
+         sfs->SetPrecision(1e-5);
+         sfs->SetMaxTolerance(1e-5);
+
+         sfs->Perform();
+
+         shape = sfs->Shape();
+
+         for (exp0.Init(shape, TopAbs_SOLID); exp0.More(); exp0.Next())
+         {
+            TopoDS_Solid solid = TopoDS::Solid(exp0.Current());
+            TopoDS_Solid newsolid = solid;
+            BRepLib::OrientClosedSolid (newsolid);
+            Handle(ShapeBuild_ReShape) rebuild = new ShapeBuild_ReShape;
+            rebuild->Replace(solid, newsolid);
+
+            TopoDS_Shape newshape = rebuild->Apply(shape, TopAbs_SHAPE, 1);
+            shape = newshape;
+         }
+
+         std::cout << " done" << std::endl;
+      }
+      else
+         std::cout << " not possible" << std::endl;
+   }
+
+
+
+
+   void OCCGeometry :: BuildVisualizationMesh (double deflection)
+   {
+      std::cout << "Preparing visualization (deflection = " << deflection << ") ... " << flush;
+
+      BRepTools::Clean (shape);
+      // BRepMesh_IncrementalMesh::
+      BRepMesh_IncrementalMesh (shape, deflection, true);
+      std::cout << "done" << std::endl;
+   }
+
+
+
+
+   void OCCGeometry :: CalcBoundingBox ()
+   {
+      Bnd_Box bb;
+      BRepBndLib::Add (shape, bb);
+
+      double x1,y1,z1,x2,y2,z2;
+      bb.Get (x1,y1,z1,x2,y2,z2);
+      Point<3> p1 = Point<3> (x1,y1,z1);
+      Point<3> p2 = Point<3> (x2,y2,z2);
+
+      (*testout) << "Bounding Box = [" << p1 << " - " << p2 << "]" << std::endl;
+      boundingbox = Box<3> (p1,p2);
+      SetCenter();
+   }
+
+
+   // returns a projector and a classifier for the given surface
+   void OCCGeometry::GetFaceTools(int surfi, Handle(ShapeAnalysis_Surface)& proj,
+                                  BRepTopAdaptor_FClass2d*& cls) const
+   {
+     //MSV: organize caching projector in the map
+     if (fprjmap.IsBound(surfi))
+     {
+       proj = fprjmap.Find(surfi);
+       cls = fclsmap.Find(surfi);
+     }
+     else
+     {
+       const TopoDS_Face& aFace = TopoDS::Face(fmap(surfi));
+       Handle(Geom_Surface) aSurf = BRep_Tool::Surface(aFace);
+       proj = new ShapeAnalysis_Surface(aSurf);
+       fprjmap.Bind(surfi, proj);
+       cls = new BRepTopAdaptor_FClass2d(aFace,Precision::Confusion());
+       fclsmap.Bind(surfi, cls);
+     }
+   }
+
+   // void OCCGeometry :: Project (int surfi, Point<3> & p) const
+   bool OCCGeometry :: Project (int surfi, Point<3> & p, double& u, double& v) const
+   {
+      static int cnt = 0;
+      if (++cnt % 1000 == 0) std::cout << "Project cnt = " << cnt << std::endl;
+
+      gp_Pnt pnt(p(0), p(1), p(2));
+
+      // -- Optimization: use cached projector and classifier
+      // double u,v;
+      // Handle( Geom_Surface ) thesurf = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
+      // Handle( ShapeAnalysis_Surface ) su = new ShapeAnalysis_Surface( thesurf );
+      // gp_Pnt2d suval = su->ValueOfUV ( pnt, BRep_Tool::Tolerance( TopoDS::Face(fmap(surfi)) ) );
+      // suval.Coord( u, v);
+      // pnt = thesurf->Value( u, v );  
+
+      Handle(ShapeAnalysis_Surface) proj;
+      BRepTopAdaptor_FClass2d *cls;
+      GetFaceTools(surfi, proj, cls);
+
+      gp_Pnt2d p2d = proj->ValueOfUV(pnt, Precision::Confusion());
+      if (cls->Perform(p2d) == TopAbs_OUT)
+      {
+        return false;
+      }
+      pnt = proj->Value(p2d);
+      p2d.Coord(u, v);
+
+      p = Point<3> (pnt.X(), pnt.Y(), pnt.Z());
+
+      return true;
+   }
+
+
+
+
+   bool OCCGeometry :: FastProject (int surfi, Point<3> & ap, double& u, double& v) const
+   {
+      gp_Pnt p(ap(0), ap(1), ap(2));
+
+      // -- Optimization: use cached projector and classifier
+      // Handle(Geom_Surface) surface = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
+      // 
+      // gp_Pnt x = surface->Value (u,v);
+      // 
+      // if (p.SquareDistance(x) <= sqr(PROJECTION_TOLERANCE)) return true;
+      // 
+      // gp_Vec du, dv;
+      // 
+      // surface->D1(u,v,x,du,dv);
+      // 
+      // int count = 0;
+      // 
+      // gp_Pnt xold;
+      // gp_Vec n;
+      // double det, lambda, mu;
+      // 
+      // do {
+      //    count++;
+      // 
+      //    n = du^dv;
+      // 
+      //    det = Det3 (n.X(), du.X(), dv.X(),
+      //       n.Y(), du.Y(), dv.Y(),
+      //       n.Z(), du.Z(), dv.Z());
+      // 
+      //    if (det < 1e-15) return false;
+      // 
+      //    lambda = Det3 (n.X(), p.X()-x.X(), dv.X(),
+      //       n.Y(), p.Y()-x.Y(), dv.Y(),
+      //       n.Z(), p.Z()-x.Z(), dv.Z())/det;
+      // 
+      //    mu     = Det3 (n.X(), du.X(), p.X()-x.X(),
+      //       n.Y(), du.Y(), p.Y()-x.Y(),
+      //       n.Z(), du.Z(), p.Z()-x.Z())/det;
+      // 
+      //    u += lambda;
+      //    v += mu;
+      // 
+      //    xold = x;
+      //    surface->D1(u,v,x,du,dv);
+      // 
+      // } while (xold.SquareDistance(x) > sqr(PROJECTION_TOLERANCE) && count < 50);
+      // 
+      // //    (*testout) << "FastProject count: " << count << std::endl;
+      // 
+      // if (count == 50) return false;
+      // 
+      // ap = Point<3> (x.X(), x.Y(), x.Z());
+      Handle(ShapeAnalysis_Surface) proj;
+      BRepTopAdaptor_FClass2d *cls;
+      GetFaceTools(surfi, proj, cls);
+
+      gp_Pnt2d p2d = proj->NextValueOfUV(gp_Pnt2d(u,v), p, Precision::Confusion());
+      if (cls->Perform(p2d) == TopAbs_OUT)
+      {
+        //std::cout << "Projection fails" << std::endl;
+        return false;
+      }
+
+      p = proj->Value(p2d);
+      p2d.Coord(u, v);
+      ap = Point<3> (p.X(), p.Y(), p.Z());
+
+      return true;
+   }
+
+
+
+
+   void OCCGeometry :: WriteOCC_STL(char * filename)
+   {
+      std::cout << "writing stl..."; std::cout.flush();
+      StlAPI_Writer writer;
+      //writer.RelativeMode() = Standard_False;
+
+      //writer.SetDeflection(0.02);
+      writer.Write(shape,filename);
+
+      std::cout << "done" << std::endl;
+   }
+
+
+
+   // Philippose - 23/02/2009
+   /* Special IGES File load function including the ability
+   to extract individual surface colours via the extended
+   OpenCascade XDE and XCAF Feature set.
+   */
+   OCCGeometry *LoadOCC_IGES(const char *filename)
+   {
+      OCCGeometry *occgeo;
+      occgeo = new OCCGeometry;
+
+      // Initiate a dummy XCAF Application to handle the IGES XCAF Document
+      static Handle(XCAFApp_Application) dummy_app = XCAFApp_Application::GetApplication();
+
+      // Create an XCAF Document to contain the IGES file itself
+      Handle(TDocStd_Document) iges_doc;
+
+      // Check if a IGES File is already open under this handle, if so, close it to prevent
+      // Segmentation Faults when trying to create a new document
+      if(dummy_app->NbDocuments() > 0)
+      {
+         dummy_app->GetDocument(1,iges_doc);
+         dummy_app->Close(iges_doc);
+      }
+      dummy_app->NewDocument ("IGES-XCAF",iges_doc);
+
+      IGESCAFControl_Reader reader;
+
+      Standard_Integer stat = reader.ReadFile((char*)filename);
+
+      if(stat != IFSelect_RetDone)
+      {
+         delete occgeo;
+         return NULL;
+      }
+
+      // Enable transfer of colours
+      reader.SetColorMode(Standard_True);
+
+      reader.Transfer(iges_doc);
+
+      // Read in the shape(s) and the colours present in the IGES File
+      Handle(XCAFDoc_ShapeTool) iges_shape_contents = XCAFDoc_DocumentTool::ShapeTool(iges_doc->Main());
+      Handle(XCAFDoc_ColorTool) iges_colour_contents = XCAFDoc_DocumentTool::ColorTool(iges_doc->Main());
+
+      TDF_LabelSequence iges_shapes;
+      iges_shape_contents->GetShapes(iges_shapes);
+
+      // List out the available colours in the IGES File as Colour Names
+      TDF_LabelSequence all_colours;
+      iges_colour_contents->GetColors(all_colours);
+      PrintMessage(1,"Number of colours in IGES File: ",all_colours.Length());
+      for(int i = 1; i <= all_colours.Length(); i++)
+      {
+         Quantity_Color col;
+         stringstream col_rgb;
+         iges_colour_contents->GetColor(all_colours.Value(i),col);
+         col_rgb << " : (" << col.Red() << "," << col.Green() << "," << col.Blue() << ")";
+         PrintMessage(1, "Colour [", i, "] = ",col.StringName(col.Name()),col_rgb.str());
+      }
+
+
+      // For the IGES Reader, all the shapes can be exported as one compund shape 
+      // using the "OneShape" member
+      occgeo->shape = reader.OneShape();
+      occgeo->face_colours = iges_colour_contents;
+      occgeo->changed = 1;
+      occgeo->BuildFMap();
+
+      occgeo->CalcBoundingBox();
+      PrintContents (occgeo);
+
+      return occgeo;
+   }
+
+
+
+
+
+   // Philippose - 29/01/2009
+   /* Special STEP File load function including the ability
+   to extract individual surface colours via the extended
+   OpenCascade XDE and XCAF Feature set.
+   */
+   OCCGeometry * LoadOCC_STEP (const char * filename)
+   {
+      OCCGeometry * occgeo;
+      occgeo = new OCCGeometry;
+
+      // Initiate a dummy XCAF Application to handle the STEP XCAF Document
+      static Handle(XCAFApp_Application) dummy_app = XCAFApp_Application::GetApplication();
+
+      // Create an XCAF Document to contain the STEP file itself
+      Handle(TDocStd_Document) step_doc;
+
+      // Check if a STEP File is already open under this handle, if so, close it to prevent
+      // Segmentation Faults when trying to create a new document
+      if(dummy_app->NbDocuments() > 0)
+      {
+         dummy_app->GetDocument(1,step_doc);
+         dummy_app->Close(step_doc);
+      }
+      dummy_app->NewDocument ("STEP-XCAF",step_doc);
+
+      STEPCAFControl_Reader reader;
+
+      // Enable transfer of colours
+      reader.SetColorMode(Standard_True);
+
+      Standard_Integer stat = reader.ReadFile((char*)filename);
+
+      if(stat != IFSelect_RetDone)
+      {
+         delete occgeo;
+         return NULL;
+      }
+
+      reader.Transfer(step_doc);
+
+      // Read in the shape(s) and the colours present in the STEP File
+      Handle(XCAFDoc_ShapeTool) step_shape_contents = XCAFDoc_DocumentTool::ShapeTool(step_doc->Main());
+      Handle(XCAFDoc_ColorTool) step_colour_contents = XCAFDoc_DocumentTool::ColorTool(step_doc->Main());
+
+      TDF_LabelSequence step_shapes;
+      step_shape_contents->GetShapes(step_shapes);
+
+      // List out the available colours in the STEP File as Colour Names
+      TDF_LabelSequence all_colours;
+      step_colour_contents->GetColors(all_colours);
+      PrintMessage(1,"Number of colours in STEP File: ",all_colours.Length());
+      for(int i = 1; i <= all_colours.Length(); i++)
+      {
+         Quantity_Color col;
+         stringstream col_rgb;
+         step_colour_contents->GetColor(all_colours.Value(i),col);
+         col_rgb << " : (" << col.Red() << "," << col.Green() << "," << col.Blue() << ")";
+         PrintMessage(1, "Colour [", i, "] = ",col.StringName(col.Name()),col_rgb.str());
+      }
+
+
+      // For the STEP File Reader in OCC, the 1st Shape contains the entire 
+      // compound geometry as one shape
+      occgeo->shape = step_shape_contents->GetShape(step_shapes.Value(1));
+      occgeo->face_colours = step_colour_contents;
+      occgeo->changed = 1;
+      occgeo->BuildFMap();
+
+      occgeo->CalcBoundingBox();
+      PrintContents (occgeo);
+
+      return occgeo;
+   }
+
+
+
+
+   OCCGeometry *LoadOCC_BREP (const char *filename)
+   {
+      OCCGeometry * occgeo;
+      occgeo = new OCCGeometry;
+
+      BRep_Builder aBuilder;
+      Standard_Boolean result = BRepTools::Read(occgeo->shape, const_cast<char*> (filename),aBuilder);
+
+      if(!result)
+      {
+         delete occgeo;
+         return NULL;
+      }
+
+      // Philippose - 23/02/2009
+      // Fixed a bug in the OpenCascade XDE Colour handling when 
+      // opening BREP Files, since BREP Files have no colour data.
+      // Hence, the face_colours Handle needs to be created as a NULL handle.
+      occgeo->face_colours = Handle(XCAFDoc_ColorTool)();
+      occgeo->face_colours.Nullify();
+      occgeo->changed = 1;
+      occgeo->BuildFMap();
+
+      occgeo->CalcBoundingBox();
+      PrintContents (occgeo);
+
+      return occgeo;
+   }
+
+
+  void OCCGeometry :: Save (string sfilename) const
+  {
+    const char * filename = sfilename.c_str();
+    if (strlen(filename) < 4) 
+      throw NgException ("illegal filename");
+    
+    if (strcmp (&filename[strlen(filename)-3], "igs") == 0)
+      {
+	IGESControl_Writer writer("millimeters", 1);
+	writer.AddShape (shape);
+	writer.Write (filename);
+      }
+    else if (strcmp (&filename[strlen(filename)-3], "stp") == 0)
+      {
+	STEPControl_Writer writer;
+	writer.Transfer (shape, STEPControl_AsIs);
+	writer.Write (filename);
+      }
+    else if (strcmp (&filename[strlen(filename)-3], "stl") == 0)
+      {
+	StlAPI_Writer writer;
+	writer.ASCIIMode() = Standard_True;
+	writer.Write (shape, filename);
+      }
+    else if (strcmp (&filename[strlen(filename)-4], "stlb") == 0)
+      {
+	StlAPI_Writer writer;
+	writer.ASCIIMode() = Standard_False;
+	writer.Write (shape, filename);
+      }
+  }
+
+
+
+  const char * shapesname[] =
+   {" ", "CompSolids", "Solids", "Shells",
+
+   "Faces", "Wires", "Edges", "Vertices"};
+
+  const char * shapename[] =
+   {" ", "CompSolid", "Solid", "Shell",
+   "Face", "Wire", "Edge", "Vertex"};
+
+  const char * orientationstring[] =
+     {"+", "-"};
+
+
+
+
+   void OCCGeometry :: RecursiveTopologyTree (const TopoDS_Shape & sh,
+      stringstream & str,
+      TopAbs_ShapeEnum l,
+      bool isfree,
+      const char * lname)
+   {
+      if (l > TopAbs_VERTEX) return;
+
+      TopExp_Explorer e;
+      int count = 0;
+      int count2 = 0;
+
+      if (isfree)
+         e.Init(sh, l, TopAbs_ShapeEnum(l-1));
+      else
+         e.Init(sh, l);
+
+      for (; e.More(); e.Next())
+      {
+         count++;
+
+         stringstream lname2;
+         lname2 << lname << "/" << shapename[l] << count;
+         str << lname2.str() << " ";
+
+         switch (e.Current().ShapeType())
+	   {
+	   case TopAbs_SOLID:
+	     count2 = somap.FindIndex(TopoDS::Solid(e.Current())); break;
+	   case TopAbs_SHELL:
+	     count2 = shmap.FindIndex(TopoDS::Shell(e.Current())); break;
+	   case TopAbs_FACE:
+	     count2 = fmap.FindIndex(TopoDS::Face(e.Current())); break;
+	   case TopAbs_WIRE:
+	     count2 = wmap.FindIndex(TopoDS::Wire(e.Current())); break;
+	   case TopAbs_EDGE:
+	     count2 = emap.FindIndex(TopoDS::Edge(e.Current())); break;
+	   case TopAbs_VERTEX:
+	     count2 = vmap.FindIndex(TopoDS::Vertex(e.Current())); break;
+	   default:
+	     std::cout << "RecursiveTopologyTree: Case " << e.Current().ShapeType() << " not handeled" << std::endl;
+         }
+
+         int nrsubshapes = 0;
+
+         if (l <= TopAbs_WIRE)
+         {
+            TopExp_Explorer e2;
+            for (e2.Init (e.Current(), TopAbs_ShapeEnum (l+1));
+               e2.More(); e2.Next())
+               nrsubshapes++;
+         }
+
+         str << "{" << shapename[l] << " " << count2;
+
+         if (l <= TopAbs_EDGE)
+         {
+            str << " (" << orientationstring[e.Current().Orientation()];
+            if (nrsubshapes != 0) str << ", " << nrsubshapes;
+            str << ") } ";
+         }
+         else
+            str << " } ";
+
+         RecursiveTopologyTree (e.Current(), str, TopAbs_ShapeEnum (l+1),
+            false, (char*)lname2.str().c_str());
+
+      }
+   }
+
+
+
+
+   void OCCGeometry :: GetTopologyTree (stringstream & str)
+   {
+      std::cout << "Building topology tree ... " << flush;
+      RecursiveTopologyTree (shape, str, TopAbs_COMPSOLID, false, "CompSolids");
+      RecursiveTopologyTree (shape, str, TopAbs_SOLID, true, "FreeSolids");
+      RecursiveTopologyTree (shape, str, TopAbs_SHELL, true, "FreeShells");
+      RecursiveTopologyTree (shape, str, TopAbs_FACE, true, "FreeFaces");
+      RecursiveTopologyTree (shape, str, TopAbs_WIRE, true, "FreeWires");
+      RecursiveTopologyTree (shape, str, TopAbs_EDGE, true, "FreeEdges");
+      RecursiveTopologyTree (shape, str, TopAbs_VERTEX, true, "FreeVertices");
+      str << flush;
+      //  std::cout << "done" << std::endl;
+   }
+
+
+
+
+   void OCCGeometry :: CheckIrregularEntities(stringstream & str)
+   {
+      ShapeAnalysis_CheckSmallFace csm;
+
+      csm.SetTolerance (1e-6);
+
+      TopTools_DataMapOfShapeListOfShape mapEdges;
+      ShapeAnalysis_DataMapOfShapeListOfReal mapParam;
+      TopoDS_Compound theAllVert;
+
+      int spotfaces = 0;
+      int stripsupportfaces = 0;
+      int singlestripfaces = 0;
+      int stripfaces = 0;
+      int facessplitbyvertices = 0;
+      int stretchedpinfaces = 0;
+      int smoothpinfaces = 0;
+      int twistedfaces = 0;
+      // int edgessamebutnotidentified = 0;
+
+      std::cout << "checking faces ... " << flush;
+
+      int i;
+      for (i = 1; i <= fmap.Extent(); i++)
+      {
+         TopoDS_Face face = TopoDS::Face (fmap(i));
+         TopoDS_Edge e1, e2;
+
+         if (csm.CheckSpotFace (face))
+         {
+            if (!spotfaces++)
+               str << "SpotFace {Spot face} ";
+
+            (*testout) << "Face " << i << " is a spot face" << std::endl;
+            str << "SpotFace/Face" << i << " ";
+            str << "{Face " << i << " } ";
+         }
+
+         if (csm.IsStripSupport (face))
+         {
+            if (!stripsupportfaces++)
+               str << "StripSupportFace {Strip support face} ";
+
+            (*testout) << "Face " << i << " has strip support" << std::endl;
+            str << "StripSupportFace/Face" << i << " ";
+            str << "{Face " << i << " } ";
+         }
+
+         if (csm.CheckSingleStrip(face, e1, e2))
+         {
+            if (!singlestripfaces++)
+               str << "SingleStripFace {Single strip face} ";
+
+            (*testout) << "Face " << i << " is a single strip (edge " << emap.FindIndex(e1)
+               << " and edge " << emap.FindIndex(e2) << " are identical)" << std::endl;
+            str << "SingleStripFace/Face" << i << " ";
+            str << "{Face " << i << " (edge " << emap.FindIndex(e1)
+               << " and edge " << emap.FindIndex(e2) << " are identical)} ";
+         }
+
+         if (csm.CheckStripFace(face, e1, e2))
+         {
+            if (!stripfaces++)
+               str << "StripFace {Strip face} ";
+
+            (*testout) << "Face " << i << " is a strip (edge " << emap.FindIndex(e1)
+               << " and edge " << emap.FindIndex(e2)
+               << " are identical)" << std::endl;
+            str << "StripFace/Face" << i << " ";
+            str << "{Face " << i << " (edge " << emap.FindIndex(e1)
+               << " and edge " << emap.FindIndex(e2) << " are identical)} ";
+         }
+
+         if (int count = csm.CheckSplittingVertices(face, mapEdges, mapParam, theAllVert))
+         {
+            if (!facessplitbyvertices++)
+               str << "FaceSplitByVertices {Face split by vertices} ";
+
+            (*testout) << "Face " << i << " is split by " << count
+               << " vertex/vertices " << std::endl;
+            str << "FaceSplitByVertices/Face" << i << " ";
+            str << "{Face " << i << " (split by " << count << "vertex/vertices)} ";
+         }
+
+         int whatrow, sens;
+         if (int type = csm.CheckPin (face, whatrow, sens))
+         {
+            if (type == 1)
+            {
+               if (!smoothpinfaces++)
+                  str << "SmoothPinFace {Smooth pin face} ";
+
+               (*testout) << "Face " << i << " is a smooth pin" << std::endl;
+               str << "SmoothPinFace/Face" << i << " ";
+               str << "{Face " << i << " } ";
+            }
+            else
+            {
+               if (!stretchedpinfaces++)
+                  str << "StretchedPinFace {Stretched pin face} ";
+
+               (*testout) << "Face " << i << " is a streched pin" << std::endl;
+               str << "StretchedPinFace/Face" << i << " ";
+               str << "{Face " << i << " } ";
+            }
+         }
+
+         double paramu, paramv;
+         if (csm.CheckTwisted (face, paramu, paramv))
+         {
+            if (!twistedfaces++)
+               str << "TwistedFace {Twisted face} ";
+
+            (*testout) << "Face " << i << " is twisted" << std::endl;
+            str << "TwistedFace/Face" << i << " ";
+            str << "{Face " << i << " } ";
+         }
+      }
+
+      std::cout << "done" << std::endl;
+      std::cout << "checking edges ... " << flush;
+
+      // double dmax;
+      // int cnt = 0;
+      Array <double> edgeLengths;
+      Array <int> order;
+      edgeLengths.SetSize (emap.Extent());
+      order.SetSize (emap.Extent());
+
+      for (i = 1; i <= emap.Extent(); i++)
+      {
+         TopoDS_Edge edge1 = TopoDS::Edge (emap(i));
+         GProp_GProps system;
+         BRepGProp::LinearProperties(edge1, system);
+         edgeLengths[i-1] = system.Mass();
+      }
+
+      Sort (edgeLengths, order);
+
+      str << "ShortestEdges {Shortest edges} ";
+      for (i = 1; i <= min(20, emap.Extent()); i++)
+      {
+         str << "ShortestEdges/Edge" << i;
+         str << " {Edge " << order[i-1] << " (L=" << edgeLengths[order[i-1]-1] << ")} ";
+      }
+
+      str << flush;
+
+      std::cout << "done" << std::endl;
+   }
+
+
+
+
+   void OCCGeometry :: GetUnmeshedFaceInfo (stringstream & str)
+   {
+      for (int i = 1; i <= fmap.Extent(); i++)
+      {
+         if (facemeshstatus[i-1] == -1)
+            str << "Face" << i << " {Face " << i << " } ";
+      }
+      str << flush;
+   }
+
+
+
+
+   void OCCGeometry :: GetNotDrawableFaces (stringstream & str)
+   {
+      for (int i = 1; i <= fmap.Extent(); i++)
+      {
+         if (!fvispar[i-1].IsDrawable())
+            str << "Face" << i << " {Face " << i << " } ";
+      }
+      str << flush;
+   }
+
+
+
+
+   bool OCCGeometry :: ErrorInSurfaceMeshing ()
+   {
+      for (int i = 1; i <= fmap.Extent(); i++)
+         if (facemeshstatus[i-1] == -1)
+            return true;
+
+      return false;
+   }
+
+
+
+
+  int OCCGeometry :: GenerateMesh (Mesh*& mesh, MeshingParameters & mparam,
+      int perfstepsstart, int perfstepsend)
+   {
+     return OCCGenerateMesh (*this, mesh, mparam, perfstepsstart, perfstepsend);
+   }
+
+
+
+
+   const Refinement & OCCGeometry :: GetRefinement () const
+   {
+      return * new OCCRefinementSurfaces (*this);
+   }
+
+
+
+
+   OCCParameters :: OCCParameters()
+   {
+      resthcloseedgefac = 1;
+      resthcloseedgeenable = 1;
+	  resthminedgelen = 0.001;
+	  resthminedgelenenable = 1;
+   }
+
+
+
+
+   void OCCParameters :: Print(ostream & ost) const
+   {
+      ost << "OCC Parameters:" << std::endl
+         << "close edges: " << resthcloseedgeenable
+         << ", fac = " << resthcloseedgefac << std::endl
+		 << "minimum edge length: " << resthminedgelenenable
+		 << ", min len = " << resthminedgelen << std::endl;
+   }
+
+
+
+
+   OCCParameters occparam;
+
+}
+
+
+#endif
--- netgen_ref/libsrc/occ/occgeom.hpp
+++ netgen/libsrc/occ/occgeom.hpp
@@ -1,457 +1,478 @@
-#ifndef FILE_OCCGEOM
-#define FILE_OCCGEOM
-
-/* *************************************************************************/
-/* File:   occgeom.hpp                                                     */
-/* Author: Robert Gaisbauer                                                */
-/* Date:   26. May  03                                                     */
-/* *************************************************************************/
-
-#ifdef OCCGEOMETRY
-
-#include <meshing.hpp>
-
-#include "BRep_Tool.hxx"
-#include "Geom_Curve.hxx"
-#include "Geom2d_Curve.hxx"
-#include "Geom_Surface.hxx"
-#include "GeomAPI_ProjectPointOnSurf.hxx"
-#include "GeomAPI_ProjectPointOnCurve.hxx"
-#include "BRepTools.hxx"
-#include "TopExp.hxx"
-#include "BRepBuilderAPI_MakeVertex.hxx"
-#include "BRepBuilderAPI_MakeShell.hxx"
-#include "BRepBuilderAPI_MakeSolid.hxx"
-#include "BRepOffsetAPI_Sewing.hxx"
-#include "BRepLProp_SLProps.hxx"
-#include "BRepAdaptor_Surface.hxx"
-#include "Poly_Triangulation.hxx"
-#include "Poly_Array1OfTriangle.hxx"
-#include "TColgp_Array1OfPnt2d.hxx"
-#include "Poly_Triangle.hxx"
-#include "GProp_GProps.hxx"
-#include "BRepGProp.hxx"
-#include "Geom_Surface.hxx"
-#include "TopExp.hxx"
-#include "gp_Pnt.hxx"
-#include "TopoDS.hxx"
-#include "TopoDS_Solid.hxx"
-#include "TopExp_Explorer.hxx"
-#include "TopTools_ListIteratorOfListOfShape.hxx"
-#include "BRep_Tool.hxx"
-#include "Geom_Curve.hxx"
-#include "Geom2d_Curve.hxx"
-#include "Geom_Surface.hxx"
-#include "GeomAPI_ProjectPointOnSurf.hxx"
-#include "GeomAPI_ProjectPointOnCurve.hxx"
-#include "TopoDS_Wire.hxx"
-#include "BRepTools_WireExplorer.hxx"
-#include "BRepTools.hxx"
-#include "TopTools_IndexedMapOfShape.hxx"
-#include "TopExp.hxx"
-#include "BRepBuilderAPI_MakeVertex.hxx"
-#include "BRepBuilderAPI_MakeShell.hxx"
-#include "BRepBuilderAPI_MakeSolid.hxx"
-#include "BRepOffsetAPI_Sewing.hxx"
-#include "BRepLProp_CLProps.hxx"
-#include "BRepLProp_SLProps.hxx"
-#include "BRepAdaptor_Surface.hxx"
-#include "BRepAdaptor_Curve.hxx"
-#include "Poly_Triangulation.hxx"
-#include "Poly_Array1OfTriangle.hxx"
-#include "TColgp_Array1OfPnt2d.hxx"
-#include "Poly_Triangle.hxx"
-#include "GProp_GProps.hxx"
-#include "BRepGProp.hxx"
-#include "TopoDS_Shape.hxx"
-#include "TopoDS_Face.hxx"
-#include "IGESToBRep_Reader.hxx"
-#include "Interface_Static.hxx"
-#include "GeomAPI_ExtremaCurveCurve.hxx"
-#include "Standard_ErrorHandler.hxx"
-#include "Standard_Failure.hxx"
-#include "ShapeUpgrade_ShellSewing.hxx"
-#include "ShapeFix_Shape.hxx"
-#include "ShapeFix_Wireframe.hxx"
-#include "BRepMesh.hxx"
-#include "BRepMesh_IncrementalMesh.hxx"
-#include "BRepBndLib.hxx"
-#include "Bnd_Box.hxx"
-#include "ShapeAnalysis.hxx"
-#include "ShapeBuild_ReShape.hxx"
-
-
-// Philippose - 29/01/2009
-// OpenCascade XDE Support
-// Include support for OpenCascade XDE Features
-#include "TDocStd_Document.hxx"
-#include "Quantity_Color.hxx"
-#include "XCAFApp_Application.hxx"
-#include "XCAFDoc_ShapeTool.hxx"
-#include "XCAFDoc_Color.hxx"
-#include "XCAFDoc_ColorTool.hxx"
-#include "XCAFDoc_ColorType.hxx"
-#include "XCAFDoc_LayerTool.hxx"
-#include "XCAFDoc_DimTolTool.hxx"
-#include "XCAFDoc_MaterialTool.hxx"
-#include "XCAFDoc_DocumentTool.hxx"
-#include "TDF_Label.hxx"
-#include "TDF_LabelSequence.hxx"
-#include "STEPCAFControl_Reader.hxx"
-#include "STEPCAFControl_Writer.hxx"
-#include "IGESCAFControl_Reader.hxx"
-#include "IGESCAFControl_Writer.hxx"
-
-#include "IGESControl_Reader.hxx"
-#include "STEPControl_Reader.hxx"
-#include "IGESControl_Writer.hxx"
-#include "STEPControl_Writer.hxx"
-
-#include "StlAPI_Writer.hxx"
-#include "STEPControl_StepModelType.hxx"
-
-namespace netgen
-{
-#include "occmeshsurf.hpp"
-
-  extern DLL_HEADER MeshingParameters mparam;
-
-#define PROJECTION_TOLERANCE 1e-10
-
-#define ENTITYISVISIBLE 1
-#define ENTITYISHIGHLIGHTED 2
-#define ENTITYISDRAWABLE 4
-
-#define OCCGEOMETRYVISUALIZATIONNOCHANGE   0
-#define OCCGEOMETRYVISUALIZATIONFULLCHANGE 1  // Compute transformation matrices and redraw
-#define OCCGEOMETRYVISUALIZATIONHALFCHANGE 2  // Redraw
-
-
-
-   class EntityVisualizationCode
-   {
-      int code;
-
-   public:
-
-      EntityVisualizationCode()
-      {  code = ENTITYISVISIBLE + !ENTITYISHIGHLIGHTED + ENTITYISDRAWABLE;}
-
-      int IsVisible ()
-      {  return code & ENTITYISVISIBLE;}
-
-      int IsHighlighted ()
-      {  return code & ENTITYISHIGHLIGHTED;}
-
-      int IsDrawable ()
-      {  return code & ENTITYISDRAWABLE;}
-
-      void Show ()
-      {  code |= ENTITYISVISIBLE;}
-
-      void Hide ()
-      {  code &= ~ENTITYISVISIBLE;}
-
-      void Highlight ()
-      {  code |= ENTITYISHIGHLIGHTED;}
-
-      void Lowlight ()
-      {  code &= ~ENTITYISHIGHLIGHTED;}
-
-      void SetDrawable ()
-      {  code |= ENTITYISDRAWABLE;}
-
-      void SetNotDrawable ()
-      {  code &= ~ENTITYISDRAWABLE;}
-   };
-
-
-
-   class Line
-   {
-   public:
-      Point<3> p0, p1;
-
-      double Dist (Line l);
-
-      double Length ();
-   };
-
-
-
-   inline double Det3 (double a00, double a01, double a02,
-      double a10, double a11, double a12,
-      double a20, double a21, double a22)
-   {
-      return a00*a11*a22 + a01*a12*a20 + a10*a21*a02 - a20*a11*a02 - a10*a01*a22 - a21*a12*a00;
-   }
-
-
-
-
-   class OCCGeometry : public NetgenGeometry
-   {
-      Point<3> center;
-
-   public:
-      TopoDS_Shape shape;
-      TopTools_IndexedMapOfShape fmap, emap, vmap, somap, shmap, wmap;
-      Array<bool> fsingular, esingular, vsingular;
-      Box<3> boundingbox;
-
-      // Philippose - 29/01/2009
-      // OpenCascade XDE Support
-      // XCAF Handle to make the face colours available to the rest of
-      // the system
-      Handle_XCAFDoc_ColorTool face_colours;
-
-     mutable int changed;
-      Array<int> facemeshstatus;
-
-      // Philippose - 15/01/2009
-      // Maximum mesh size for a given face
-      // (Used to explicitly define mesh size limits on individual faces)
-      Array<double> face_maxh;
-      
-      // Philippose - 14/01/2010
-      // Boolean array to detect whether a face has been explicitly modified 
-      // by the user or not
-      Array<bool> face_maxh_modified;
-
-      // Philippose - 15/01/2009
-      // Indicates which faces have been selected by the user in geometry mode
-      // (Currently handles only selection of one face at a time, but an array would
-      //  help to extend this to multiple faces)
-      Array<bool> face_sel_status;
-
-      Array<EntityVisualizationCode> fvispar, evispar, vvispar;
-
-      double tolerance;
-      bool fixsmalledges;
-      bool fixspotstripfaces;
-      bool sewfaces;
-      bool makesolids;
-      bool splitpartitions;
-
-      OCCGeometry()
-      {
-         somap.Clear();
-         shmap.Clear();
-         fmap.Clear();
-         wmap.Clear();
-         emap.Clear();
-         vmap.Clear();
-      }
-
-
-     virtual void Save (string filename) const;
-
-
-      void BuildFMap();
-
-      Box<3> GetBoundingBox()
-      {  return boundingbox;}
-
-      int NrSolids()
-      {  return somap.Extent();}
-
-      // Philippose - 17/01/2009
-      // Total number of faces in the geometry
-      int NrFaces()
-      {  return fmap.Extent();}
-
-      void SetCenter()
-      {  center = boundingbox.Center();}
-
-      Point<3> Center()
-      {  return center;}
-
-      void Project (int surfi, Point<3> & p) const;
-      bool FastProject (int surfi, Point<3> & ap, double& u, double& v) const;
-
-      OCCSurface GetSurface (int surfi)
-      {
-         cout << "OCCGeometry::GetSurface using PLANESPACE" << endl;
-         return OCCSurface (TopoDS::Face(fmap(surfi)), PLANESPACE);
-      }
-
-      void CalcBoundingBox ();
-      void BuildVisualizationMesh (double deflection);
-
-      void RecursiveTopologyTree (const TopoDS_Shape & sh,
-         stringstream & str,
-         TopAbs_ShapeEnum l,
-         bool free,
-         const char * lname);
-
-      void GetTopologyTree (stringstream & str);
-
-      void PrintNrShapes ();
-
-      void CheckIrregularEntities (stringstream & str);
-
-      void SewFaces();
-
-      void MakeSolid();
-
-      void HealGeometry();
-
-      // Philippose - 15/01/2009
-      // Sets the maximum mesh size for a given face
-      // (Note: Local mesh size limited by the global max mesh size)
-      void SetFaceMaxH(int facenr, double faceh)
-      {
-         if((facenr> 0) && (facenr <= fmap.Extent()))
-         {
-	   face_maxh[facenr-1] = min(mparam.maxh,faceh);
-            
-            // Philippose - 14/01/2010
-            // If the face maxh is greater than or equal to the 
-            // current global maximum, then identify the face as 
-            // not explicitly controlled by the user any more
-            if(faceh >= mparam.maxh)
-            {
-               face_maxh_modified[facenr-1] = 0;
-            }
-            else
-            {
-               face_maxh_modified[facenr-1] = 1;
-            }
-         }
-      }
-
-      // Philippose - 15/01/2009
-      // Returns the local mesh size of a given face
-      double GetFaceMaxH(int facenr)
-      {
-         if((facenr> 0) && (facenr <= fmap.Extent()))
-         {
-            return face_maxh[facenr-1];
-         }
-         else
-         {
-            return 0.0;
-         }
-      }
-      
-      // Philippose - 14/01/2010
-      // Returns the flag whether the given face 
-      // has a mesh size controlled by the user or not
-      bool GetFaceMaxhModified(int facenr)
-      {
-         return face_maxh_modified[facenr-1];
-      }
-      
-      // Philippose - 17/01/2009
-      // Returns the index of the currently selected face
-      int SelectedFace()
-      {
-         int i;
-
-         for(i = 1; i <= fmap.Extent(); i++)
-         {
-            if(face_sel_status[i-1])
-            {
-               return i;
-            }
-         }
-
-         return 0;
-      }
-
-      // Philippose - 17/01/2009
-      // Sets the currently selected face
-      void SetSelectedFace(int facenr)
-      {
-         face_sel_status = 0;
-
-         if((facenr >= 1) && (facenr <= fmap.Extent()))
-         {
-            face_sel_status[facenr-1] = 1;
-         }
-      }
-
-      void LowLightAll()
-      {
-         for (int i = 1; i <= fmap.Extent(); i++)
-            fvispar[i-1].Lowlight();
-         for (int i = 1; i <= emap.Extent(); i++)
-            evispar[i-1].Lowlight();
-         for (int i = 1; i <= vmap.Extent(); i++)
-            vvispar[i-1].Lowlight();
-      }
-
-      void GetUnmeshedFaceInfo (stringstream & str);
-      void GetNotDrawableFaces (stringstream & str);
-      bool ErrorInSurfaceMeshing ();
-
-     void WriteOCC_STL(char * filename);
-
-     virtual int GenerateMesh (Mesh*& mesh, MeshingParameters & mparam, 
-         int perfstepsstart, int perfstepsend);
-
-      virtual const Refinement & GetRefinement () const;
-   };
-
-
-
-   class OCCParameters
-   {
-   public:
-
-      /// Factor for meshing close edges 
-      double resthcloseedgefac;
-
-
-      /// Enable / Disable detection of close edges
-      int resthcloseedgeenable;
-
-
-	  /// Minimum edge length to be used for dividing edges to mesh points
-	  double resthminedgelen;
-
-
-	  /// Enable / Disable use of the minimum edge length (by default use 1e-4)
-	  int resthminedgelenenable;
-
-      /*!
-         Default Constructor for the OpenCascade
-         Mesh generation parameter set
-      */
-      OCCParameters();
-
-
-      /*!
-         Dump all the OpenCascade specific meshing parameters 
-         to console
-      */
-      void Print (ostream & ost) const;
-   };
-   
-
-   void PrintContents (OCCGeometry * geom);
-
-   OCCGeometry * LoadOCC_IGES (const char * filename);
-   OCCGeometry * LoadOCC_STEP (const char * filename);
-   OCCGeometry * LoadOCC_BREP (const char * filename);
-
-   extern OCCParameters occparam;
-
-
-   // Philippose - 31.09.2009
-   // External access to the mesh generation functions within the OCC
-   // subsystem (Not sure if this is the best way to implement this....!!)
-   extern int OCCGenerateMesh (OCCGeometry & occgeometry, Mesh*& mesh,
-			       MeshingParameters & mparam,
-			       int perfstepsstart, int perfstepsend);
-
-  extern void OCCSetLocalMeshSize(OCCGeometry & geom, Mesh & mesh);
-
-   extern void OCCMeshSurface (OCCGeometry & geom, Mesh & mesh, int perfstepsend);
-
-   extern void OCCFindEdges (OCCGeometry & geom, Mesh & mesh);
-}
-
-#endif
-
-#endif
+#ifndef FILE_OCCGEOM
+#define FILE_OCCGEOM
+
+/* *************************************************************************/
+/* File:   occgeom.hpp                                                     */
+/* Author: Robert Gaisbauer                                                */
+/* Date:   26. May  03                                                     */
+/* *************************************************************************/
+
+#ifdef OCCGEOMETRY
+
+#include <myadt.hpp>
+#include <iostream>
+
+#include <meshing.hpp>
+
+#include "BRep_Tool.hxx"
+#include "Geom_Curve.hxx"
+#include "Geom2d_Curve.hxx"
+#include "Geom_Surface.hxx"
+// #include "GeomAPI_ProjectPointOnSurf.hxx"
+// #include "GeomAPI_ProjectPointOnCurve.hxx"
+#include "BRepTools.hxx"
+#include "TopExp.hxx"
+#include "BRepBuilderAPI_MakeVertex.hxx"
+#include "BRepBuilderAPI_MakeShell.hxx"
+#include "BRepBuilderAPI_MakeSolid.hxx"
+#include "BRepOffsetAPI_Sewing.hxx"
+#include "BRepLProp_SLProps.hxx"
+#include "BRepAdaptor_Surface.hxx"
+#include "Poly_Triangulation.hxx"
+#include "Poly_Array1OfTriangle.hxx"
+#include "TColgp_Array1OfPnt2d.hxx"
+#include "Poly_Triangle.hxx"
+#include "GProp_GProps.hxx"
+#include "BRepGProp.hxx"
+#include "Geom_Surface.hxx"
+#include "TopExp.hxx"
+#include "gp_Pnt.hxx"
+#include "TopoDS.hxx"
+#include "TopoDS_Solid.hxx"
+#include "TopExp_Explorer.hxx"
+#include "TopTools_ListIteratorOfListOfShape.hxx"
+#include "BRep_Tool.hxx"
+#include "Geom_Curve.hxx"
+#include "Geom2d_Curve.hxx"
+#include "Geom_Surface.hxx"
+// #include "GeomAPI_ProjectPointOnSurf.hxx"
+// #include "GeomAPI_ProjectPointOnCurve.hxx"
+#include "TopoDS_Wire.hxx"
+#include "BRepTools_WireExplorer.hxx"
+#include "BRepTools.hxx"
+#include "TopTools_IndexedMapOfShape.hxx"
+#include "TopExp.hxx"
+#include "BRepBuilderAPI_MakeVertex.hxx"
+#include "BRepBuilderAPI_MakeShell.hxx"
+#include "BRepBuilderAPI_MakeSolid.hxx"
+#include "BRepOffsetAPI_Sewing.hxx"
+#include "BRepLProp_CLProps.hxx"
+#include "BRepLProp_SLProps.hxx"
+#include "BRepAdaptor_Surface.hxx"
+#include "BRepAdaptor_Curve.hxx"
+#include "Poly_Triangulation.hxx"
+#include "Poly_Array1OfTriangle.hxx"
+#include "TColgp_Array1OfPnt2d.hxx"
+#include "Poly_Triangle.hxx"
+#include "GProp_GProps.hxx"
+#include "BRepGProp.hxx"
+#include "TopoDS_Shape.hxx"
+#include "TopoDS_Face.hxx"
+#include "IGESToBRep_Reader.hxx"
+#include "Interface_Static.hxx"
+#include "GeomAPI_ExtremaCurveCurve.hxx"
+//#include "Standard_ErrorHandler.hxx"
+#include "Standard_Failure.hxx"
+#include "ShapeUpgrade_ShellSewing.hxx"
+#include "ShapeFix_Shape.hxx"
+#include "ShapeFix_Wireframe.hxx"
+#include <Standard_Version.hxx>
+#if (OCC_VERSION_MAJOR << 16 | OCC_VERSION_MINOR << 8 | OCC_VERSION_MAINTENANCE) <= 0x060702
+// porting to OCCT6.7.3
+#include "BRepMesh.hxx"
+#endif
+#include "BRepMesh_IncrementalMesh.hxx"
+#include "BRepBndLib.hxx"
+#include "Bnd_Box.hxx"
+#include "ShapeAnalysis.hxx"
+#include "ShapeBuild_ReShape.hxx"
+
+// -- Optimization: to use cached projector and classifier
+#include <NCollection_DataMap.hxx>
+class ShapeAnalysis_Surface;
+class BRepTopAdaptor_FClass2d;
+
+// Philippose - 29/01/2009
+// OpenCascade XDE Support
+// Include support for OpenCascade XDE Features
+#include "TDocStd_Document.hxx"
+#include "Quantity_Color.hxx"
+#include "XCAFApp_Application.hxx"
+#include "XCAFDoc_ShapeTool.hxx"
+#include "XCAFDoc_Color.hxx"
+#include "XCAFDoc_ColorTool.hxx"
+#include "XCAFDoc_ColorType.hxx"
+#include "XCAFDoc_LayerTool.hxx"
+#include "XCAFDoc_DimTolTool.hxx"
+#include "XCAFDoc_MaterialTool.hxx"
+#include "XCAFDoc_DocumentTool.hxx"
+#include "TDF_Label.hxx"
+#include "TDF_LabelSequence.hxx"
+#include "STEPCAFControl_Reader.hxx"
+#include "STEPCAFControl_Writer.hxx"
+#include "IGESCAFControl_Reader.hxx"
+#include "IGESCAFControl_Writer.hxx"
+
+#include "IGESControl_Reader.hxx"
+#include "STEPControl_Reader.hxx"
+#include "IGESControl_Writer.hxx"
+#include "STEPControl_Writer.hxx"
+
+#include "StlAPI_Writer.hxx"
+#include "STEPControl_StepModelType.hxx"
+
+namespace netgen
+{
+#include "occmeshsurf.hpp"
+
+  DLL_HEADER extern MeshingParameters mparam;
+
+#define PROJECTION_TOLERANCE 1e-10
+
+#define ENTITYISVISIBLE 1
+#define ENTITYISHIGHLIGHTED 2
+#define ENTITYISDRAWABLE 4
+
+#define OCCGEOMETRYVISUALIZATIONNOCHANGE   0
+#define OCCGEOMETRYVISUALIZATIONFULLCHANGE 1  // Compute transformation matrices and redraw
+#define OCCGEOMETRYVISUALIZATIONHALFCHANGE 2  // Redraw
+
+
+
+   class EntityVisualizationCode
+   {
+      int code;
+
+   public:
+
+      EntityVisualizationCode()
+      {  code = ENTITYISVISIBLE + !ENTITYISHIGHLIGHTED + ENTITYISDRAWABLE;}
+
+      int IsVisible ()
+      {  return code & ENTITYISVISIBLE;}
+
+      int IsHighlighted ()
+      {  return code & ENTITYISHIGHLIGHTED;}
+
+      int IsDrawable ()
+      {  return code & ENTITYISDRAWABLE;}
+
+      void Show ()
+      {  code |= ENTITYISVISIBLE;}
+
+      void Hide ()
+      {  code &= ~ENTITYISVISIBLE;}
+
+      void Highlight ()
+      {  code |= ENTITYISHIGHLIGHTED;}
+
+      void Lowlight ()
+      {  code &= ~ENTITYISHIGHLIGHTED;}
+
+      void SetDrawable ()
+      {  code |= ENTITYISDRAWABLE;}
+
+      void SetNotDrawable ()
+      {  code &= ~ENTITYISDRAWABLE;}
+   };
+
+
+
+   class Line
+   {
+   public:
+      Point<3> p0, p1;
+
+      double Dist (Line l);
+
+      double Length ();
+   };
+
+
+
+   inline double Det3 (double a00, double a01, double a02,
+      double a10, double a11, double a12,
+      double a20, double a21, double a22)
+   {
+      return a00*a11*a22 + a01*a12*a20 + a10*a21*a02 - a20*a11*a02 - a10*a01*a22 - a21*a12*a00;
+   }
+
+
+
+
+   class DLL_HEADER OCCGeometry : public NetgenGeometry
+   {
+      Point<3> center;
+      // -- Optimization: to use cached projector and classifier
+      mutable NCollection_DataMap<int,Handle(ShapeAnalysis_Surface)> fprjmap;
+      mutable NCollection_DataMap<int,BRepTopAdaptor_FClass2d*> fclsmap;
+
+   public:
+      TopoDS_Shape shape;
+      TopTools_IndexedMapOfShape fmap, emap, vmap, somap, shmap, wmap;
+      Array<bool> fsingular, esingular, vsingular;
+      Box<3> boundingbox;
+
+      // Philippose - 29/01/2009
+      // OpenCascade XDE Support
+      // XCAF Handle to make the face colours available to the rest of
+      // the system
+      Handle(XCAFDoc_ColorTool) face_colours;
+
+     mutable int changed;
+      Array<int> facemeshstatus;
+
+      // Philippose - 15/01/2009
+      // Maximum mesh size for a given face
+      // (Used to explicitly define mesh size limits on individual faces)
+      Array<double> face_maxh;
+      
+      // Philippose - 14/01/2010
+      // Boolean array to detect whether a face has been explicitly modified 
+      // by the user or not
+      Array<bool> face_maxh_modified;
+
+      // Philippose - 15/01/2009
+      // Indicates which faces have been selected by the user in geometry mode
+      // (Currently handles only selection of one face at a time, but an array would
+      //  help to extend this to multiple faces)
+      Array<bool> face_sel_status;
+
+      Array<EntityVisualizationCode> fvispar, evispar, vvispar;
+
+      double tolerance;
+      bool fixsmalledges;
+      bool fixspotstripfaces;
+      bool sewfaces;
+      bool makesolids;
+      bool splitpartitions;
+
+      OCCGeometry()
+      {
+         somap.Clear();
+         shmap.Clear();
+         fmap.Clear();
+         wmap.Clear();
+         emap.Clear();
+         vmap.Clear();
+      }
+
+
+     virtual void Save (string filename) const;
+
+
+      ~OCCGeometry();      // -- to free cached projector and classifier
+
+      void BuildFMap();
+
+      Box<3> GetBoundingBox()
+      {  return boundingbox;}
+
+      int NrSolids()
+      {  return somap.Extent();}
+
+      // Philippose - 17/01/2009
+      // Total number of faces in the geometry
+      int NrFaces()
+      {  return fmap.Extent();}
+
+      void SetCenter()
+      {  center = boundingbox.Center();}
+
+      Point<3> Center()
+      {  return center;}
+
+      // void Project (int surfi, Point<3> & p) const; -- optimization
+      bool Project (int surfi, Point<3> & p, double& u, double& v) const;
+      bool FastProject (int surfi, Point<3> & ap, double& u, double& v) const;
+
+      // -- Optimization: to use cached projector and classifier
+      void GetFaceTools(int surfi, Handle(ShapeAnalysis_Surface)& proj,
+                        BRepTopAdaptor_FClass2d*& cls) const;
+
+      OCCSurface GetSurface (int surfi)
+      {
+         std::cout << "OCCGeometry::GetSurface using PLANESPACE" << std::endl;
+         return OCCSurface (TopoDS::Face(fmap(surfi)), PLANESPACE);
+      }
+
+      void CalcBoundingBox ();
+      void BuildVisualizationMesh (double deflection);
+
+      void RecursiveTopologyTree (const TopoDS_Shape & sh,
+         stringstream & str,
+         TopAbs_ShapeEnum l,
+         bool free,
+         const char * lname);
+
+      void GetTopologyTree (stringstream & str);
+
+      void PrintNrShapes ();
+
+      void CheckIrregularEntities (stringstream & str);
+
+      void SewFaces();
+
+      void MakeSolid();
+
+      void HealGeometry();
+
+      // Philippose - 15/01/2009
+      // Sets the maximum mesh size for a given face
+      // (Note: Local mesh size limited by the global max mesh size)
+      void SetFaceMaxH(int facenr, double faceh)
+      {
+         if((facenr> 0) && (facenr <= fmap.Extent()))
+         {
+	   face_maxh[facenr-1] = min(mparam.maxh,faceh);
+            
+            // Philippose - 14/01/2010
+            // If the face maxh is greater than or equal to the 
+            // current global maximum, then identify the face as 
+            // not explicitly controlled by the user any more
+            if(faceh >= mparam.maxh)
+            {
+               face_maxh_modified[facenr-1] = 0;
+            }
+            else
+            {
+               face_maxh_modified[facenr-1] = 1;
+            }
+         }
+      }
+
+      // Philippose - 15/01/2009
+      // Returns the local mesh size of a given face
+      double GetFaceMaxH(int facenr)
+      {
+         if((facenr> 0) && (facenr <= fmap.Extent()))
+         {
+            return face_maxh[facenr-1];
+         }
+         else
+         {
+            return 0.0;
+         }
+      }
+      
+      // Philippose - 14/01/2010
+      // Returns the flag whether the given face 
+      // has a mesh size controlled by the user or not
+      bool GetFaceMaxhModified(int facenr)
+      {
+         return face_maxh_modified[facenr-1];
+      }
+      
+      // Philippose - 17/01/2009
+      // Returns the index of the currently selected face
+      int SelectedFace()
+      {
+         int i;
+
+         for(i = 1; i <= fmap.Extent(); i++)
+         {
+            if(face_sel_status[i-1])
+            {
+               return i;
+            }
+         }
+
+         return 0;
+      }
+
+      // Philippose - 17/01/2009
+      // Sets the currently selected face
+      void SetSelectedFace(int facenr)
+      {
+         face_sel_status = 0;
+
+         if((facenr >= 1) && (facenr <= fmap.Extent()))
+         {
+            face_sel_status[facenr-1] = 1;
+         }
+      }
+
+      void LowLightAll()
+      {
+         for (int i = 1; i <= fmap.Extent(); i++)
+            fvispar[i-1].Lowlight();
+         for (int i = 1; i <= emap.Extent(); i++)
+            evispar[i-1].Lowlight();
+         for (int i = 1; i <= vmap.Extent(); i++)
+            vvispar[i-1].Lowlight();
+      }
+
+      void GetUnmeshedFaceInfo (stringstream & str);
+      void GetNotDrawableFaces (stringstream & str);
+      bool ErrorInSurfaceMeshing ();
+
+     void WriteOCC_STL(char * filename);
+
+     virtual int GenerateMesh (Mesh*& mesh, MeshingParameters & mparam, 
+         int perfstepsstart, int perfstepsend);
+
+      virtual const Refinement & GetRefinement () const;
+   };
+
+
+
+   class DLL_HEADER OCCParameters
+   {
+   public:
+
+      /// Factor for meshing close edges 
+      double resthcloseedgefac;
+
+
+      /// Enable / Disable detection of close edges
+      int resthcloseedgeenable;
+
+
+	  /// Minimum edge length to be used for dividing edges to mesh points
+	  double resthminedgelen;
+
+
+	  /// Enable / Disable use of the minimum edge length (by default use 1e-4)
+	  int resthminedgelenenable;
+
+      /*!
+         Default Constructor for the OpenCascade
+         Mesh generation parameter set
+      */
+      OCCParameters();
+
+
+      /*!
+         Dump all the OpenCascade specific meshing parameters 
+         to console
+      */
+      void Print (ostream & ost) const;
+   };
+   
+
+   void PrintContents (OCCGeometry * geom);
+
+   OCCGeometry * LoadOCC_IGES (const char * filename);
+   OCCGeometry * LoadOCC_STEP (const char * filename);
+   OCCGeometry * LoadOCC_BREP (const char * filename);
+
+   extern DLL_HEADER OCCParameters occparam;
+
+
+   // Philippose - 31.09.2009
+   // External access to the mesh generation functions within the OCC
+   // subsystem (Not sure if this is the best way to implement this....!!)
+   extern DLL_HEADER int OCCGenerateMesh (OCCGeometry & occgeometry, Mesh*& mesh,
+			       MeshingParameters & mparam,
+			       int perfstepsstart, int perfstepsend);
+
+  extern DLL_HEADER void OCCSetLocalMeshSize(OCCGeometry & geom, Mesh & mesh);
+
+   extern DLL_HEADER void OCCMeshSurface (OCCGeometry & geom, Mesh & mesh, int perfstepsend);
+
+   extern DLL_HEADER void OCCFindEdges (OCCGeometry & geom, Mesh & mesh);
+}
+
+#endif
+
+#endif
--- /dev/null
+++ netgen/libsrc/occ/occgeom.hpp.orig
@@ -0,0 +1,457 @@
+#ifndef FILE_OCCGEOM
+#define FILE_OCCGEOM
+
+/* *************************************************************************/
+/* File:   occgeom.hpp                                                     */
+/* Author: Robert Gaisbauer                                                */
+/* Date:   26. May  03                                                     */
+/* *************************************************************************/
+
+#ifdef OCCGEOMETRY
+
+#include <meshing.hpp>
+
+#include "BRep_Tool.hxx"
+#include "Geom_Curve.hxx"
+#include "Geom2d_Curve.hxx"
+#include "Geom_Surface.hxx"
+#include "GeomAPI_ProjectPointOnSurf.hxx"
+#include "GeomAPI_ProjectPointOnCurve.hxx"
+#include "BRepTools.hxx"
+#include "TopExp.hxx"
+#include "BRepBuilderAPI_MakeVertex.hxx"
+#include "BRepBuilderAPI_MakeShell.hxx"
+#include "BRepBuilderAPI_MakeSolid.hxx"
+#include "BRepOffsetAPI_Sewing.hxx"
+#include "BRepLProp_SLProps.hxx"
+#include "BRepAdaptor_Surface.hxx"
+#include "Poly_Triangulation.hxx"
+#include "Poly_Array1OfTriangle.hxx"
+#include "TColgp_Array1OfPnt2d.hxx"
+#include "Poly_Triangle.hxx"
+#include "GProp_GProps.hxx"
+#include "BRepGProp.hxx"
+#include "Geom_Surface.hxx"
+#include "TopExp.hxx"
+#include "gp_Pnt.hxx"
+#include "TopoDS.hxx"
+#include "TopoDS_Solid.hxx"
+#include "TopExp_Explorer.hxx"
+#include "TopTools_ListIteratorOfListOfShape.hxx"
+#include "BRep_Tool.hxx"
+#include "Geom_Curve.hxx"
+#include "Geom2d_Curve.hxx"
+#include "Geom_Surface.hxx"
+#include "GeomAPI_ProjectPointOnSurf.hxx"
+#include "GeomAPI_ProjectPointOnCurve.hxx"
+#include "TopoDS_Wire.hxx"
+#include "BRepTools_WireExplorer.hxx"
+#include "BRepTools.hxx"
+#include "TopTools_IndexedMapOfShape.hxx"
+#include "TopExp.hxx"
+#include "BRepBuilderAPI_MakeVertex.hxx"
+#include "BRepBuilderAPI_MakeShell.hxx"
+#include "BRepBuilderAPI_MakeSolid.hxx"
+#include "BRepOffsetAPI_Sewing.hxx"
+#include "BRepLProp_CLProps.hxx"
+#include "BRepLProp_SLProps.hxx"
+#include "BRepAdaptor_Surface.hxx"
+#include "BRepAdaptor_Curve.hxx"
+#include "Poly_Triangulation.hxx"
+#include "Poly_Array1OfTriangle.hxx"
+#include "TColgp_Array1OfPnt2d.hxx"
+#include "Poly_Triangle.hxx"
+#include "GProp_GProps.hxx"
+#include "BRepGProp.hxx"
+#include "TopoDS_Shape.hxx"
+#include "TopoDS_Face.hxx"
+#include "IGESToBRep_Reader.hxx"
+#include "Interface_Static.hxx"
+#include "GeomAPI_ExtremaCurveCurve.hxx"
+#include "Standard_ErrorHandler.hxx"
+#include "Standard_Failure.hxx"
+#include "ShapeUpgrade_ShellSewing.hxx"
+#include "ShapeFix_Shape.hxx"
+#include "ShapeFix_Wireframe.hxx"
+#include "BRepMesh.hxx"
+#include "BRepMesh_IncrementalMesh.hxx"
+#include "BRepBndLib.hxx"
+#include "Bnd_Box.hxx"
+#include "ShapeAnalysis.hxx"
+#include "ShapeBuild_ReShape.hxx"
+
+
+// Philippose - 29/01/2009
+// OpenCascade XDE Support
+// Include support for OpenCascade XDE Features
+#include "TDocStd_Document.hxx"
+#include "Quantity_Color.hxx"
+#include "XCAFApp_Application.hxx"
+#include "XCAFDoc_ShapeTool.hxx"
+#include "XCAFDoc_Color.hxx"
+#include "XCAFDoc_ColorTool.hxx"
+#include "XCAFDoc_ColorType.hxx"
+#include "XCAFDoc_LayerTool.hxx"
+#include "XCAFDoc_DimTolTool.hxx"
+#include "XCAFDoc_MaterialTool.hxx"
+#include "XCAFDoc_DocumentTool.hxx"
+#include "TDF_Label.hxx"
+#include "TDF_LabelSequence.hxx"
+#include "STEPCAFControl_Reader.hxx"
+#include "STEPCAFControl_Writer.hxx"
+#include "IGESCAFControl_Reader.hxx"
+#include "IGESCAFControl_Writer.hxx"
+
+#include "IGESControl_Reader.hxx"
+#include "STEPControl_Reader.hxx"
+#include "IGESControl_Writer.hxx"
+#include "STEPControl_Writer.hxx"
+
+#include "StlAPI_Writer.hxx"
+#include "STEPControl_StepModelType.hxx"
+
+namespace netgen
+{
+#include "occmeshsurf.hpp"
+
+  extern DLL_HEADER MeshingParameters mparam;
+
+#define PROJECTION_TOLERANCE 1e-10
+
+#define ENTITYISVISIBLE 1
+#define ENTITYISHIGHLIGHTED 2
+#define ENTITYISDRAWABLE 4
+
+#define OCCGEOMETRYVISUALIZATIONNOCHANGE   0
+#define OCCGEOMETRYVISUALIZATIONFULLCHANGE 1  // Compute transformation matrices and redraw
+#define OCCGEOMETRYVISUALIZATIONHALFCHANGE 2  // Redraw
+
+
+
+   class EntityVisualizationCode
+   {
+      int code;
+
+   public:
+
+      EntityVisualizationCode()
+      {  code = ENTITYISVISIBLE + !ENTITYISHIGHLIGHTED + ENTITYISDRAWABLE;}
+
+      int IsVisible ()
+      {  return code & ENTITYISVISIBLE;}
+
+      int IsHighlighted ()
+      {  return code & ENTITYISHIGHLIGHTED;}
+
+      int IsDrawable ()
+      {  return code & ENTITYISDRAWABLE;}
+
+      void Show ()
+      {  code |= ENTITYISVISIBLE;}
+
+      void Hide ()
+      {  code &= ~ENTITYISVISIBLE;}
+
+      void Highlight ()
+      {  code |= ENTITYISHIGHLIGHTED;}
+
+      void Lowlight ()
+      {  code &= ~ENTITYISHIGHLIGHTED;}
+
+      void SetDrawable ()
+      {  code |= ENTITYISDRAWABLE;}
+
+      void SetNotDrawable ()
+      {  code &= ~ENTITYISDRAWABLE;}
+   };
+
+
+
+   class Line
+   {
+   public:
+      Point<3> p0, p1;
+
+      double Dist (Line l);
+
+      double Length ();
+   };
+
+
+
+   inline double Det3 (double a00, double a01, double a02,
+      double a10, double a11, double a12,
+      double a20, double a21, double a22)
+   {
+      return a00*a11*a22 + a01*a12*a20 + a10*a21*a02 - a20*a11*a02 - a10*a01*a22 - a21*a12*a00;
+   }
+
+
+
+
+   class OCCGeometry : public NetgenGeometry
+   {
+      Point<3> center;
+
+   public:
+      TopoDS_Shape shape;
+      TopTools_IndexedMapOfShape fmap, emap, vmap, somap, shmap, wmap;
+      Array<bool> fsingular, esingular, vsingular;
+      Box<3> boundingbox;
+
+      // Philippose - 29/01/2009
+      // OpenCascade XDE Support
+      // XCAF Handle to make the face colours available to the rest of
+      // the system
+      Handle_XCAFDoc_ColorTool face_colours;
+
+     mutable int changed;
+      Array<int> facemeshstatus;
+
+      // Philippose - 15/01/2009
+      // Maximum mesh size for a given face
+      // (Used to explicitly define mesh size limits on individual faces)
+      Array<double> face_maxh;
+      
+      // Philippose - 14/01/2010
+      // Boolean array to detect whether a face has been explicitly modified 
+      // by the user or not
+      Array<bool> face_maxh_modified;
+
+      // Philippose - 15/01/2009
+      // Indicates which faces have been selected by the user in geometry mode
+      // (Currently handles only selection of one face at a time, but an array would
+      //  help to extend this to multiple faces)
+      Array<bool> face_sel_status;
+
+      Array<EntityVisualizationCode> fvispar, evispar, vvispar;
+
+      double tolerance;
+      bool fixsmalledges;
+      bool fixspotstripfaces;
+      bool sewfaces;
+      bool makesolids;
+      bool splitpartitions;
+
+      OCCGeometry()
+      {
+         somap.Clear();
+         shmap.Clear();
+         fmap.Clear();
+         wmap.Clear();
+         emap.Clear();
+         vmap.Clear();
+      }
+
+
+     virtual void Save (string filename) const;
+
+
+      void BuildFMap();
+
+      Box<3> GetBoundingBox()
+      {  return boundingbox;}
+
+      int NrSolids()
+      {  return somap.Extent();}
+
+      // Philippose - 17/01/2009
+      // Total number of faces in the geometry
+      int NrFaces()
+      {  return fmap.Extent();}
+
+      void SetCenter()
+      {  center = boundingbox.Center();}
+
+      Point<3> Center()
+      {  return center;}
+
+      void Project (int surfi, Point<3> & p) const;
+      bool FastProject (int surfi, Point<3> & ap, double& u, double& v) const;
+
+      OCCSurface GetSurface (int surfi)
+      {
+         cout << "OCCGeometry::GetSurface using PLANESPACE" << endl;
+         return OCCSurface (TopoDS::Face(fmap(surfi)), PLANESPACE);
+      }
+
+      void CalcBoundingBox ();
+      void BuildVisualizationMesh (double deflection);
+
+      void RecursiveTopologyTree (const TopoDS_Shape & sh,
+         stringstream & str,
+         TopAbs_ShapeEnum l,
+         bool free,
+         const char * lname);
+
+      void GetTopologyTree (stringstream & str);
+
+      void PrintNrShapes ();
+
+      void CheckIrregularEntities (stringstream & str);
+
+      void SewFaces();
+
+      void MakeSolid();
+
+      void HealGeometry();
+
+      // Philippose - 15/01/2009
+      // Sets the maximum mesh size for a given face
+      // (Note: Local mesh size limited by the global max mesh size)
+      void SetFaceMaxH(int facenr, double faceh)
+      {
+         if((facenr> 0) && (facenr <= fmap.Extent()))
+         {
+	   face_maxh[facenr-1] = min(mparam.maxh,faceh);
+            
+            // Philippose - 14/01/2010
+            // If the face maxh is greater than or equal to the 
+            // current global maximum, then identify the face as 
+            // not explicitly controlled by the user any more
+            if(faceh >= mparam.maxh)
+            {
+               face_maxh_modified[facenr-1] = 0;
+            }
+            else
+            {
+               face_maxh_modified[facenr-1] = 1;
+            }
+         }
+      }
+
+      // Philippose - 15/01/2009
+      // Returns the local mesh size of a given face
+      double GetFaceMaxH(int facenr)
+      {
+         if((facenr> 0) && (facenr <= fmap.Extent()))
+         {
+            return face_maxh[facenr-1];
+         }
+         else
+         {
+            return 0.0;
+         }
+      }
+      
+      // Philippose - 14/01/2010
+      // Returns the flag whether the given face 
+      // has a mesh size controlled by the user or not
+      bool GetFaceMaxhModified(int facenr)
+      {
+         return face_maxh_modified[facenr-1];
+      }
+      
+      // Philippose - 17/01/2009
+      // Returns the index of the currently selected face
+      int SelectedFace()
+      {
+         int i;
+
+         for(i = 1; i <= fmap.Extent(); i++)
+         {
+            if(face_sel_status[i-1])
+            {
+               return i;
+            }
+         }
+
+         return 0;
+      }
+
+      // Philippose - 17/01/2009
+      // Sets the currently selected face
+      void SetSelectedFace(int facenr)
+      {
+         face_sel_status = 0;
+
+         if((facenr >= 1) && (facenr <= fmap.Extent()))
+         {
+            face_sel_status[facenr-1] = 1;
+         }
+      }
+
+      void LowLightAll()
+      {
+         for (int i = 1; i <= fmap.Extent(); i++)
+            fvispar[i-1].Lowlight();
+         for (int i = 1; i <= emap.Extent(); i++)
+            evispar[i-1].Lowlight();
+         for (int i = 1; i <= vmap.Extent(); i++)
+            vvispar[i-1].Lowlight();
+      }
+
+      void GetUnmeshedFaceInfo (stringstream & str);
+      void GetNotDrawableFaces (stringstream & str);
+      bool ErrorInSurfaceMeshing ();
+
+     void WriteOCC_STL(char * filename);
+
+     virtual int GenerateMesh (Mesh*& mesh, MeshingParameters & mparam, 
+         int perfstepsstart, int perfstepsend);
+
+      virtual const Refinement & GetRefinement () const;
+   };
+
+
+
+   class OCCParameters
+   {
+   public:
+
+      /// Factor for meshing close edges 
+      double resthcloseedgefac;
+
+
+      /// Enable / Disable detection of close edges
+      int resthcloseedgeenable;
+
+
+	  /// Minimum edge length to be used for dividing edges to mesh points
+	  double resthminedgelen;
+
+
+	  /// Enable / Disable use of the minimum edge length (by default use 1e-4)
+	  int resthminedgelenenable;
+
+      /*!
+         Default Constructor for the OpenCascade
+         Mesh generation parameter set
+      */
+      OCCParameters();
+
+
+      /*!
+         Dump all the OpenCascade specific meshing parameters 
+         to console
+      */
+      void Print (ostream & ost) const;
+   };
+   
+
+   void PrintContents (OCCGeometry * geom);
+
+   OCCGeometry * LoadOCC_IGES (const char * filename);
+   OCCGeometry * LoadOCC_STEP (const char * filename);
+   OCCGeometry * LoadOCC_BREP (const char * filename);
+
+   extern OCCParameters occparam;
+
+
+   // Philippose - 31.09.2009
+   // External access to the mesh generation functions within the OCC
+   // subsystem (Not sure if this is the best way to implement this....!!)
+   extern int OCCGenerateMesh (OCCGeometry & occgeometry, Mesh*& mesh,
+			       MeshingParameters & mparam,
+			       int perfstepsstart, int perfstepsend);
+
+  extern void OCCSetLocalMeshSize(OCCGeometry & geom, Mesh & mesh);
+
+   extern void OCCMeshSurface (OCCGeometry & geom, Mesh & mesh, int perfstepsend);
+
+   extern void OCCFindEdges (OCCGeometry & geom, Mesh & mesh);
+}
+
+#endif
+
+#endif
--- netgen_ref/libsrc/occ/occmeshsurf.cpp
+++ netgen/libsrc/occ/occmeshsurf.cpp
@@ -6,6 +6,7 @@
 #include <meshing.hpp>
 #include <GeomLProp_SLProps.hxx>
 #include <ShapeAnalysis_Surface.hxx>
+#include <GeomAPI_ProjectPointOnCurve.hxx> // -- moved here from occgeom.hpp
 
 
 namespace netgen
@@ -96,24 +97,27 @@
 
 	n.Normalize();
       }
-    else
+    else if ( lprop.IsNormalDefined() )
       {
 	n(0)=lprop.Normal().X();
 	n(1)=lprop.Normal().Y();
 	n(2)=lprop.Normal().Z();
       }
-
+    else
+      {
+        n = 0;
+      }
     if(glob_testout)
       {
 	(*testout) << "u " << geominfo.u << " v " << geominfo.v 
 		   << " du " << lprop.D1U().X() << " "<< lprop.D1U().Y() << " "<< lprop.D1U().Z()
-		   << " dv " << lprop.D1V().X() << " "<< lprop.D1V().Y() << " "<< lprop.D1V().Z() << endl;
+		   << " dv " << lprop.D1V().X() << " "<< lprop.D1V().Y() << " "<< lprop.D1V().Z() << std::endl;
       }
 
 
 
     if (orient == TopAbs_REVERSED) n = -1*n;
-    //  (*testout) << "GetNormalVector" << endl;
+    //  (*testout) << "GetNormalVector" << std::endl;
   }
 
 
@@ -126,8 +130,8 @@
       {
 	p1 = ap1; p2 = ap2;
 
-	//cout << "p1 = " << p1 << endl;
-	//cout << "p2 = " << p2 << endl;
+	//std::cout << "p1 = " << p1 << std::endl;
+	//std::cout << "p2 = " << p2 << std::endl;
       
 	GetNormalVector (p1, geominfo1, ez);
       
@@ -148,7 +152,7 @@
 	ez.Normalize();
 	ey = Cross (ez, ex);
 	nmid = ez;
-	//cout << "ex " << ex << " ey " << ey << " ez " << ez << endl;
+	//std::cout << "ex " << ex << " ey " << ey << " ez " << ez << std::endl;
       }
     else
       {
@@ -178,9 +182,9 @@
 	D1(0,1) = dv.X(); D1(1,1) = dv.Y(); D1(2,1) = dv.Z();
 
 	/*
-	  (*testout) << "DefineTangentialPlane" << endl
-	  << "---------------------" << endl;
-	  (*testout) << "D1 = " << endl << D1 << endl;
+	  (*testout) << "DefineTangentialPlane" << std::endl
+	  << "---------------------" << std::endl;
+	  (*testout) << "D1 = " << std::endl << D1 << std::endl;
 	*/
 
 	Transpose (D1, D1T);
@@ -270,7 +274,7 @@
 	/*
 	  if(zone == -1)
 	  {
-	  (*testout) << "zone = -1 for " << p3d << " 2D: " << pplane << " n " << n << " nmid " << nmid << endl;
+	  (*testout) << "zone = -1 for " << p3d << " 2D: " << pplane << " n " << n << " nmid " << nmid << std::endl;
 	  glob_testout = true;
 	  GetNormalVector (p3d, geominfo, n);
 	  glob_testout = false;
@@ -280,7 +284,7 @@
     else
       {
 	pplane = Point<2>(geominfo.u, geominfo.v);
-	//      (*testout) << "(u,v) = " << geominfo.u << ", " << geominfo.v << endl;
+	//      (*testout) << "(u,v) = " << geominfo.u << ", " << geominfo.v << std::endl;
 	pplane = Point<2> (1/h * (Amatinv * (pplane-psp1)));
 	//      pplane = Point<2> (h * (Amatinv * (pplane-psp1)));
 	//      pplane = Point<2> (1/h * ((pplane-psp1)));
@@ -297,11 +301,11 @@
   { 
     if (projecttype == PLANESPACE)
       {
-	//      cout << "2d   : " << pplane << endl;
+	//      std::cout << "2d   : " << pplane << std::endl;
 	p3d = p1 + (h * pplane(0)) * ex + (h * pplane(1)) * ey;
-	//      cout << "3d   : " << p3d << endl;
+	//      std::cout << "3d   : " << p3d << std::endl;
 	Project (p3d, gi);  
-	//      cout << "proj : " << p3d << endl;
+	//      std::cout << "proj : " << p3d << std::endl;
       }
     else
       {
@@ -321,11 +325,11 @@
   void OCCSurface :: Project (Point<3> & p, PointGeomInfo & gi)
   {
     //   static int cnt = 0;
-    //  if (cnt++ % 1000 == 0) cout << "********************************************** OCCSurfce :: Project, cnt = " << cnt << endl;
+    //  if (cnt++ % 1000 == 0) std::cout << "********************************************** OCCSurfce :: Project, cnt = " << cnt << std::endl;
   
     gp_Pnt pnt(p(0), p(1), p(2));
 
-    //(*testout) << "pnt = " << pnt.X() << ", " << pnt.Y() << ", " << pnt.Z() << endl;
+    //(*testout) << "pnt = " << pnt.X() << ", " << pnt.Y() << ", " << pnt.Z() << std::endl;
 
 
     /*
@@ -333,7 +337,7 @@
 
     if (!proj.NbPoints())
       {
-	cout << "Project Point on Surface FAIL" << endl;
+	std::cout << "Project Point on Surface FAIL" << std::endl;
 	throw UVBoundsException();
       }
     */
@@ -343,13 +347,13 @@
 
 
     /*
-      cout << "NP = " << proj.NbPoints() << endl;
+      std::cout << "NP = " << proj.NbPoints() << std::endl;
 
       for (int i = 1; i <= proj.NbPoints(); i++)
       {
       gp_Pnt pnt2 = proj.Point(i);
       Point<3> p2 = Point<3> (pnt2.X(), pnt2.Y(), pnt2.Z());
-      cout << i << ". p = " << p2 << ", dist = " << (p2-p).Length() << endl;
+      std::cout << i << ". p = " << p2 << ", dist = " << (p2-p).Length() << std::endl;
       }
     */
 
@@ -364,7 +368,7 @@
     suval.Coord( u, v);
     pnt = occface->Value( u, v );
     
-    //(*testout) << "pnt(proj) = " << pnt.X() << ", " << pnt.Y() << ", " << pnt.Z() << endl;
+    //(*testout) << "pnt(proj) = " << pnt.X() << ", " << pnt.Y() << ", " << pnt.Z() << std::endl;
     gi.u = u;
     gi.v = v;
     
@@ -434,23 +438,33 @@
 
   void MeshOptimize2dOCCSurfaces :: ProjectPoint (INDEX surfind, Point<3> & p) const
   {
-    geometry.Project (surfind, p);
+    // geometry.Project (surfind, p); -- signature of Project() changed for optimization
+    double u, v;
+    geometry.Project (surfind, p, u, v);
   }
 
 
   int MeshOptimize2dOCCSurfaces :: ProjectPointGI (INDEX surfind, Point<3> & p, PointGeomInfo & gi) const
   {
-    double u = gi.u;
-    double v = gi.v;
+    //double u = gi.u;
+    //double v = gi.v;
 
     Point<3> hp = p;
-    if (geometry.FastProject (surfind, hp, u, v))
-      {
+    // -- u and v are computed by FastProject() and Project(), no need to call CalcPointGeomInfo()
+    // if (geometry.FastProject (surfind, hp, u, v))
+    //   {
+    //    p = hp;
+    //    return 1;
+    //   }
+    // ProjectPoint (surfind, p); 
+    // return CalcPointGeomInfo (surfind, gi, p); 
+    bool ok;
+    if (gi.trignum > 0)
+      ok = geometry.FastProject (surfind, hp, gi.u, gi.v);
+    else
+      ok = geometry.Project (surfind, hp, gi.u, gi.v);
 	p = hp;
-	return 1;
-      }
-    ProjectPoint (surfind, p); 
-    return CalcPointGeomInfo (surfind, gi, p); 
+    return ok;
   }
 
 
@@ -506,7 +520,7 @@
   GetNormalVector(INDEX surfind, const Point<3> & p, Vec<3> & n) const
   {
     //  static int cnt = 0;
-    //  if (cnt++ % 1000 == 0) cout << "GetNV cnt = " << cnt << endl;
+    //  if (cnt++ % 1000 == 0) std::cout << "GetNV cnt = " << cnt << std::endl;
     Standard_Real u,v;
 
     gp_Pnt pnt(p(0), p(1), p(2));
@@ -519,9 +533,9 @@
 
     if (proj.NbPoints() < 1)
       {
-	cout << "ERROR: OCCSurface :: GetNormalVector: GeomAPI_ProjectPointOnSurf failed!"
-	     << endl;
-	cout << p << endl;
+	std::cout << "ERROR: OCCSurface :: GetNormalVector: GeomAPI_ProjectPointOnSurf failed!"
+	     << std::endl;
+	std::cout << p << std::endl;
 	return;
       }
  
@@ -540,7 +554,7 @@
 
     /*
       if (!occface->IsCNu (1) || !occface->IsCNv (1))
-      (*testout) << "SurfOpt: Differentiation FAIL" << endl;
+      (*testout) << "SurfOpt: Differentiation FAIL" << std::endl;
     */
 
     n = Cross (Vec3d(du.X(), du.Y(), du.Z()),
@@ -566,9 +580,9 @@
 
     if (proj.NbPoints() < 1)
       {
-	cout << "ERROR: OCCSurface :: GetNormalVector: GeomAPI_ProjectPointOnSurf failed!"
-	     << endl;
-	cout << p << endl;
+	std::cout << "ERROR: OCCSurface :: GetNormalVector: GeomAPI_ProjectPointOnSurf failed!"
+	     << std::endl;
+	std::cout << p << std::endl;
 	return 0;
       }
  
@@ -679,8 +693,9 @@
  
 	if (!geometry.FastProject (surfi, hnewp, u, v))
 	  {
-	  //  cout << "Fast projection to surface fails! Using OCC projection" << endl;
-	    geometry.Project (surfi, hnewp);
+	  //  std::cout << "Fast projection to surface fails! Using OCC projection" << std::endl;
+	    // geometry.Project (surfi, hnewp); -- Project() changed for optimization
+	    geometry.Project (surfi, hnewp, u, v);
 	  }
 
 	newgi.trignum = 1;
@@ -689,7 +704,7 @@
       }
   
     newp = hnewp;
-  }
+  }//; -- to compile with -Wall -pedantic
 
 
   void OCCRefinementSurfaces :: 
@@ -708,24 +723,29 @@
     hnewp = Point<3> (pnt.X(), pnt.Y(), pnt.Z());
     newp = hnewp;
     newgi = ap1;
-  };
+  }//; -- to compile with -Wall -pedantic
 
 
   void OCCRefinementSurfaces :: ProjectToSurface (Point<3> & p, int surfi) const
   {
     if (surfi > 0)
-      geometry.Project (surfi, p);
-  };
+      //geometry.Project (surfi, p);
+    {
+      double u, v;
+      geometry.Project (surfi, p, u, v);
+    }
+  }//; -- to compile with -Wall -pedantic
 
   void OCCRefinementSurfaces :: ProjectToSurface (Point<3> & p, int surfi, PointGeomInfo & gi) const
   {
     if (surfi > 0)
       if (!geometry.FastProject (surfi, p, gi.u, gi.v))
 	{
-	  cout << "Fast projection to surface fails! Using OCC projection" << endl;
-	  geometry.Project (surfi, p);
+	  std::cout << "Fast projection to surface fails! Using OCC projection" << std::endl;
+          double u, v;
+	  geometry.Project (surfi, p, u, v);
 	}
-  };
+	}
 
 
 
--- netgen_ref/libsrc/occ/occmeshsurf.hpp
+++ netgen/libsrc/occ/occmeshsurf.hpp
@@ -169,7 +169,7 @@
 class OCCGeometry;
 
 
-class OCCRefinementSurfaces : public Refinement
+class DLL_HEADER OCCRefinementSurfaces : public Refinement
 {
   const OCCGeometry & geometry;
 
--- netgen_ref/libsrc/occ/occpkg.cpp
+++ netgen/libsrc/occ/occpkg.cpp
@@ -1,1024 +1,1024 @@
-#ifdef OCCGEOMETRY
-
-#include <mystdlib.h>
-#include <myadt.hpp>
-#include <linalg.hpp>
-#include <csg.hpp>
-#include <occgeom.hpp>
-
-
-#include <incvis.hpp>
-#include <visual.hpp>
-
-#include "../meshing/bcfunctions.hpp"
-
-#include "vsocc.hpp"
-
-
-extern "C" int Ng_occ_Init (Tcl_Interp * interp);
-
-
-
-namespace netgen
-{
-  extern AutoPtr<NetgenGeometry> ng_geometry;
-  extern AutoPtr<Mesh> mesh;
- 
-  char * err_needsoccgeometry = (char*) "This operation needs an OCC geometry";
-  extern char * err_needsmesh;
-  extern char * err_jobrunning;
-
-
-
-                          
-  class OCCGeometryRegister : public GeometryRegister
-  {
-  public:
-    virtual NetgenGeometry * Load (string filename) const;
-    virtual VisualScene * GetVisualScene (const NetgenGeometry * geom) const;
-
-    virtual void SetParameters (Tcl_Interp * interp) 
-    {
-      occparam.resthcloseedgefac =
-	atof (Tcl_GetVar (interp, "::stloptions.resthcloseedgefac", 0));
-      occparam.resthcloseedgeenable =
-	atoi (Tcl_GetVar (interp, "::stloptions.resthcloseedgeenable", 0));
-	  occparam.resthminedgelen = 
-	atof (Tcl_GetVar (interp, "::stloptions.resthminedgelen", 0));
-	  occparam.resthminedgelenenable = 
-	atoi (Tcl_GetVar (interp, "::stloptions.resthminedgelenenable", 0));
-    }
-  };
-
-
-
-
-  int Ng_SetOCCVisParameters  (ClientData clientData,
-			       Tcl_Interp * interp,
-			       int argc, tcl_const char *argv[])
-  {
-#ifdef OCCGEOMETRY
-    int showvolume;
-	OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
-
-    showvolume = atoi (Tcl_GetVar (interp, "::occoptions.showvolumenr", 0));
-
-    if (occgeometry)
-      if (showvolume != vispar.occshowvolumenr)
-	{
-	  if (showvolume < 0 || showvolume > occgeometry->NrSolids())
-	    {
-	      char buf[20];
-	      sprintf (buf, "%5i", vispar.occshowvolumenr);
-	      Tcl_SetVar (interp, "::occoptions.showvolumenr", buf, 0);
-	    }
-	  else
-	    {
-	      vispar.occshowvolumenr = showvolume;
-	      if (occgeometry)
-		occgeometry -> changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-	    }
-	}
-    
-    int temp;
-
-    temp = atoi (Tcl_GetVar (interp, "::occoptions.visproblemfaces", 0));
-
-    if ((bool) temp != vispar.occvisproblemfaces)
-      {
-	vispar.occvisproblemfaces = temp;
-	if (occgeometry)
-	  occgeometry -> changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-      }
-
-    vispar.occshowsurfaces = atoi (Tcl_GetVar (interp, "::occoptions.showsurfaces", 0));
-    vispar.occshowedges = atoi (Tcl_GetVar (interp, "::occoptions.showedges", 0));
-    vispar.occzoomtohighlightedentity = atoi (Tcl_GetVar (interp, "::occoptions.zoomtohighlightedentity", 0));
-    vispar.occdeflection = pow(10.0,-1-atof (Tcl_GetVar (interp, "::occoptions.deflection", 0)));
-
-#endif
-
-
-
-
-
-#ifdef ACIS
-    vispar.ACISshowfaces = atoi (Tcl_GetVar (interp, "::occoptions.showsurfaces", 0));
-    vispar.ACISshowedges = atoi (Tcl_GetVar (interp, "::occoptions.showedges", 0));
-    vispar.ACISshowsolidnr = atoi (Tcl_GetVar (interp, "::occoptions.showsolidnr", 0));
-    vispar.ACISshowsolidnr2 = atoi (Tcl_GetVar (interp, "::occoptions.showsolidnr2", 0));
-
-#endif
-
-
-
-    return TCL_OK;
-  }  
-
-
-
-
-  int Ng_GetOCCData (ClientData clientData,
-		     Tcl_Interp * interp,
-		     int argc, tcl_const char *argv[])
-  {
-#ifdef OCCGEOMETRY
-    OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
-
-    static char buf[1000];
-    buf[0] = 0;
-    stringstream str;
-
-    if (argc >= 2)
-      {
-	if (strcmp (argv[1], "getentities") == 0)
-	  {
-	    if (occgeometry)
-	      {
-		occgeometry->GetTopologyTree(str);
-	      }
-	  }
-      }
-
-    Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
-
-#endif
-    return TCL_OK;
-  }
-
-  
-
-  int Ng_OCCCommand (ClientData clientData,
-		     Tcl_Interp * interp,
-		     int argc, tcl_const char *argv[])
-  {
-#ifdef OCCGEOMETRY
-    OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
-
-    stringstream str;
-    if (argc >= 2)
-      {
-	if (strcmp (argv[1], "isoccgeometryloaded") == 0)
-	  {
-	    if (occgeometry)
-	      str << "1 " << flush;
-	    else str << "0 " << flush;
-
-	    Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
-	  }
-	if (occgeometry)
-	  {
-	    if (strcmp (argv[1], "buildvisualizationmesh") == 0)
-	      {
-		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
-		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-	      }
-	    if (strcmp (argv[1], "mesherror") == 0)
-	      {
-		if (occgeometry->ErrorInSurfaceMeshing())
-		  str << 1;
-		else
-		  str << 0;
-	      }
-	    if (strcmp (argv[1], "sewfaces") == 0)
-	      {
-		cout << "Before operation:" << endl;
-		occgeometry->PrintNrShapes();
-		occgeometry->SewFaces();
-		occgeometry->BuildFMap();
-		cout << endl << "After operation:" << endl;
-		occgeometry->PrintNrShapes();
-		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
-		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-	      }
-	    if (strcmp (argv[1], "makesolid") == 0)
-	      {
-		cout << "Before operation:" << endl;
-		occgeometry->PrintNrShapes();
-		occgeometry->MakeSolid();
-		occgeometry->BuildFMap();
-		cout << endl << "After operation:" << endl;
-		occgeometry->PrintNrShapes();
-		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
-		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-	      }
-	    if (strcmp (argv[1], "upgradetopology") == 0)
-	      {
-		cout << "Before operation:" << endl;
-		occgeometry->PrintNrShapes();
-		occgeometry->SewFaces();
-		occgeometry->MakeSolid();
-		occgeometry->BuildFMap();
-		cout << endl << "After operation:" << endl;
-		occgeometry->PrintNrShapes();
-		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
-		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-	      }
-	    if (strcmp (argv[1], "shapehealing") == 0)
-	      {
-		occgeometry->tolerance =
-		  atof (Tcl_GetVar (interp, "::occoptions.tolerance", 0));
-		occgeometry->fixsmalledges =
-		  atoi (Tcl_GetVar (interp, "::occoptions.fixsmalledges", 0));
-		occgeometry->fixspotstripfaces =
-		  atoi (Tcl_GetVar (interp, "::occoptions.fixspotstripfaces", 0));
-		occgeometry->sewfaces =
-		  atoi (Tcl_GetVar (interp, "::occoptions.sewfaces", 0));
-		occgeometry->makesolids =
-		  atoi (Tcl_GetVar (interp, "::occoptions.makesolids", 0));
-		occgeometry->splitpartitions =
-		  atoi (Tcl_GetVar (interp, "::occoptions.splitpartitions", 0));
-
-		//	      cout << "Before operation:" << endl;
-		//	      occgeometry->PrintNrShapes();
-		occgeometry->HealGeometry();
-		occgeometry->BuildFMap();
-		//	      cout << endl << "After operation:" << endl;
-		//	      occgeometry->PrintNrShapes();
-		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
-		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-	      }
-
-
-	    if (strcmp (argv[1], "highlightentity") == 0)
-	      {
-		if (strcmp (argv[2], "Face") == 0)
-		  {
-		    int nr = atoi (argv[3]);
-		    occgeometry->LowLightAll();
-
-		    occgeometry->fvispar[nr-1].Highlight();
-		    if (vispar.occzoomtohighlightedentity)
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
-		    else
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		  }
-		if (strcmp (argv[2], "Shell") == 0)
-		  {
-		    int nr = atoi (argv[3]);
-		    occgeometry->LowLightAll();
-
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->shmap(nr), TopAbs_FACE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
-			occgeometry->fvispar[i-1].Highlight();
-		      }
-		    if (vispar.occzoomtohighlightedentity)
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
-		    else
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		  }
-		if (strcmp (argv[2], "Solid") == 0)
-		  {
-		    int nr = atoi (argv[3]);
-		    occgeometry->LowLightAll();
-
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->somap(nr), TopAbs_FACE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
-			occgeometry->fvispar[i-1].Highlight();
-		      }
-		    if (vispar.occzoomtohighlightedentity)
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
-		    else
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		  }
-		/*
-		  if (strcmp (argv[2], "CompSolid") == 0)
-		  {
-		  int nr = atoi (argv[3]);
-		  occgeometry->LowLightAll();
-
-		  TopExp_Explorer exp;
-		  for (exp.Init (occgeometry->cmap(nr), TopAbs_FACE);
-		  exp.More(); exp.Next())
-		  {
-		  int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
-		  occgeometry->fvispar[i-1].Highlight();
-		  }
-		  occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		  }
-		*/
-
-		if (strcmp (argv[2], "Edge") == 0)
-		  {
-		    int nr = atoi (argv[3]);
-		    occgeometry->LowLightAll();
-
-		    occgeometry->evispar[nr-1].Highlight();
-		    if (vispar.occzoomtohighlightedentity)
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
-		    else
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		  }
-		if (strcmp (argv[2], "Wire") == 0)
-		  {
-		    int nr = atoi (argv[3]);
-		    occgeometry->LowLightAll();
-
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->wmap(nr), TopAbs_EDGE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->emap.FindIndex (TopoDS::Edge(exp.Current()));
-			occgeometry->evispar[i-1].Highlight();
-		      }
-		    if (vispar.occzoomtohighlightedentity)
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
-		    else
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		  }
-
-		if (strcmp (argv[2], "Vertex") == 0)
-		  {
-		    int nr = atoi (argv[3]);
-		    occgeometry->LowLightAll();
-
-		    occgeometry->vvispar[nr-1].Highlight();
-		    if (vispar.occzoomtohighlightedentity)
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
-		    else
-		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		  }
-
-	      }
-
-
-
-	    if (strcmp (argv[1], "show") == 0)
-	      {
-		int nr = atoi (argv[3]);
-		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-
-		if (strcmp (argv[2], "Face") == 0)
-		  {
-		    occgeometry->fvispar[nr-1].Show();
-		  }
-		if (strcmp (argv[2], "Shell") == 0)
-		  {
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->shmap(nr), TopAbs_FACE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
-			occgeometry->fvispar[i-1].Show();
-		      }
-		  }
-		if (strcmp (argv[2], "Solid") == 0)
-		  {
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->somap(nr), TopAbs_FACE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
-			occgeometry->fvispar[i-1].Show();
-		      }
-		  }
-		if (strcmp (argv[2], "Edge") == 0)
-		  {
-		    occgeometry->evispar[nr-1].Show();
-		  }
-		if (strcmp (argv[2], "Wire") == 0)
-		  {
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->wmap(nr), TopAbs_EDGE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->emap.FindIndex (TopoDS::Edge(exp.Current()));
-			occgeometry->evispar[i-1].Show();
-		      }
-		  }
-	      }
-
-
-	    if (strcmp (argv[1], "hide") == 0)
-	      {
-		int nr = atoi (argv[3]);
-		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-
-		if (strcmp (argv[2], "Face") == 0)
-		  {
-		    occgeometry->fvispar[nr-1].Hide();
-		  }
-		if (strcmp (argv[2], "Shell") == 0)
-		  {
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->shmap(nr), TopAbs_FACE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
-			occgeometry->fvispar[i-1].Hide();
-		      }
-		  }
-		if (strcmp (argv[2], "Solid") == 0)
-		  {
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->somap(nr), TopAbs_FACE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
-			occgeometry->fvispar[i-1].Hide();
-		      }
-		  }
-		if (strcmp (argv[2], "Edge") == 0)
-		  {
-		    occgeometry->evispar[nr-1].Hide();
-		  }
-		if (strcmp (argv[2], "Wire") == 0)
-		  {
-		    TopExp_Explorer exp;
-		    for (exp.Init (occgeometry->wmap(nr), TopAbs_EDGE);
-			 exp.More(); exp.Next())
-		      {
-			int i = occgeometry->emap.FindIndex (TopoDS::Edge(exp.Current()));
-			occgeometry->evispar[i-1].Hide();
-		      }
-		  }
-	      }
-
-
-
-	    if (strcmp (argv[1], "findsmallentities") == 0)
-	      {
-		stringstream str("");
-		occgeometry->CheckIrregularEntities(str);
-		Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
-	      }
-	    if (strcmp (argv[1], "getunmeshedfaceinfo") == 0)
-	      {
-		occgeometry->GetUnmeshedFaceInfo(str);
-		Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
-	      }
-	    if (strcmp (argv[1], "getnotdrawablefaces") == 0)
-	      {
-		occgeometry->GetNotDrawableFaces(str);
-		Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
-	      }
-	    if (strcmp (argv[1], "redrawstatus") == 0)
-	      {
-		int i = atoi (argv[2]);
-		occgeometry->changed = i;
-	      }
-	    if (strcmp (argv[1], "swaporientation") == 0)
-	      {
-		IGESControl_Writer writer("millimeters", 1);
-		writer.AddShape (occgeometry->shape);
-		writer.Write ("1.igs");
-		/*
-		  int nr = atoi (argv[3]);
-
-		  //	      const_cast<TopoDS_Shape&> (occgeometry->fmap(nr)).Reverse();
-
-		  Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
-		  rebuild->Apply(occgeometry->shape);
-
-		  TopoDS_Shape sh;
-
-		  //	      if (strcmp (argv[2], "CompSolid") == 0) sh = occgeometry->cmap(nr);
-		  if (strcmp (argv[2], "Solid") == 0) sh = occgeometry->somap(nr);
-		  if (strcmp (argv[2], "Shell") == 0) sh = occgeometry->shmap(nr);
-		  if (strcmp (argv[2], "Face") == 0) sh = occgeometry->fmap(nr);
-		  if (strcmp (argv[2], "Wire") == 0) sh = occgeometry->wmap(nr);
-		  if (strcmp (argv[2], "Edge") == 0) sh = occgeometry->emap(nr);
-
-		  rebuild->Replace(sh, sh.Reversed(), Standard_False);
-
-		  TopoDS_Shape newshape = rebuild->Apply(occgeometry->shape, TopAbs_SHELL, 1);
-		  occgeometry->shape = newshape;
-
-		  occgeometry->BuildFMap();
-		  occgeometry->BuildVisualizationMesh();
-		  occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-		*/
-	      }
-	    if (strcmp (argv[1], "marksingular") == 0)
-	      {
-		int nr = atoi (argv[3]);
-		cout << "marking " << argv[2] << " " << nr << endl;
-		char buf[2]; buf[0] = '0'; buf[1] = 0;
-		bool sing = false;
-		if (strcmp (argv[2], "Face") == 0)
-		  sing = occgeometry->fsingular[nr-1] = !occgeometry->fsingular[nr-1];
-		if (strcmp (argv[2], "Edge") == 0)
-		  sing = occgeometry->esingular[nr-1] = !occgeometry->esingular[nr-1];
-		if (strcmp (argv[2], "Vertex") == 0)
-		  sing = occgeometry->vsingular[nr-1] = !occgeometry->vsingular[nr-1];
-
-		if (sing) buf[0] = '1';
-
-                Tcl_SetVar (interp, "::ismarkedsingular", buf, 0);
-
-		stringstream str;
-		occgeometry->GetTopologyTree (str);
-
-		char* cstr = (char*)str.str().c_str();
-
-		(*testout) << cstr << endl;
-
-		char helpstr[1000];
-
-		while (strchr (cstr, '}'))
-		  {
-		    strncpy (helpstr, cstr+2, strlen(strchr(cstr+2, '}')));
-		    (*testout) << "***" << cstr << "***" << endl;
-		    cstr = strchr (cstr, '}');
-		  } 
-	      }
-	  }
-      }
-
-#endif
-    return TCL_OK;
-  }
-
-
-
-#ifdef OCCGEOMETRY
-  /*
-  void OCCConstructGeometry (OCCGeometry & geom);
-
-  int Ng_OCCConstruction (ClientData clientData,
-			  Tcl_Interp * interp,
-			  int argc, tcl_const char *argv[])
-  {
-    if (occgeometry)
-      OCCConstructGeometry (*occgeometry);
-    return TCL_OK;
-  }
-  */
-#endif
-
-
-
-
-  // Philippose - 30/01/2009
-  // TCL interface function for the Local Face Mesh size
-  // definition functionality
-  int Ng_SurfaceMeshSize (ClientData clientData,
-		                    Tcl_Interp * interp,
-		                    int argc, tcl_const char *argv[])
-  {
-#ifdef OCCGEOMETRY
-
-    static char buf[100];
-
-    if (argc < 2)
-    {
-	   Tcl_SetResult (interp, (char *)"Ng_SurfaceMeshSize needs arguments", TCL_STATIC);
-	   return TCL_ERROR;
-    }
-
-    OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
-    if (!occgeometry)
-    {
-      Tcl_SetResult (interp, (char *)"Ng_SurfaceMeshSize currently supports only OCC (STEP/IGES) Files", TCL_STATIC);
-	   return TCL_ERROR;
-    }
-
-    // Update the face mesh sizes to reflect the global maximum mesh size
-    for(int i = 1; i <= occgeometry->NrFaces(); i++)
-    {
-           if(!occgeometry->GetFaceMaxhModified(i))
-           {
-              occgeometry->SetFaceMaxH(i, mparam.maxh);
-           }   
-    }
-
-    if (strcmp (argv[1], "setsurfms") == 0)
-    {
-	   int facenr = atoi (argv[2]);
-	   double surfms = atof (argv[3]);
-	   if (occgeometry && facenr >= 1 && facenr <= occgeometry->NrFaces())
-	     occgeometry->SetFaceMaxH(facenr, surfms);
-
-    }
-
-    if (strcmp (argv[1], "setall") == 0)
-    {
-	   double surfms = atof (argv[2]);
-	   if (occgeometry)
-	   {
-	     int nrFaces = occgeometry->NrFaces();
-	     for (int i = 1; i <= nrFaces; i++)
-	      occgeometry->SetFaceMaxH(i, surfms);
-	   }
-    }
-
-    if (strcmp (argv[1], "getsurfms") == 0)
-    {
-	   int facenr = atoi (argv[2]);
-	   if (occgeometry && facenr >= 1 && facenr <= occgeometry->NrFaces())
-	   {
-	     sprintf (buf, "%5.2f", occgeometry->GetFaceMaxH(facenr));
-	   }
-	   else
-	   {
-	     sprintf (buf, "%5.2f", mparam.maxh);
-	   }
-	   Tcl_SetResult (interp, buf, TCL_STATIC);
-    }
-
-    if (strcmp (argv[1], "getactive") == 0)
-    {
-	   sprintf (buf, "%d", occgeometry->SelectedFace());
-	   Tcl_SetResult (interp, buf, TCL_STATIC);
-    }
-
-    if (strcmp (argv[1], "setactive") == 0)
-    {
-	   int facenr = atoi (argv[2]);
-	   if (occgeometry && facenr >= 1 && facenr <= occgeometry->NrFaces())
-	   {
-	     occgeometry->SetSelectedFace (facenr);
-
-        occgeometry->LowLightAll();
-        occgeometry->fvispar[facenr-1].Highlight();
-        occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
-	   }
-    }
-
-    if (strcmp (argv[1], "getnfd") == 0)
-    {
-	   if (occgeometry)
-	     sprintf (buf, "%d", occgeometry->NrFaces());
-	   else
-	     sprintf (buf, "0");
-	   Tcl_SetResult (interp, buf, TCL_STATIC);
-    }
-    return TCL_OK;
-#else // No OCCGEOMETRY 
-
-    Tcl_SetResult (interp, (char *)"Ng_SurfaceMeshSize currently supports only OCC (STEP/IGES) Files", TCL_STATIC);
-    return TCL_ERROR;
-    
-#endif // OCCGEOMETRY
-  }
-
-
-
-  // Philippose - 25/07/2010
-  // TCL interface function for extracting and eventually 
-  // setting or editing the current colours present in the mesh
-  int Ng_CurrentFaceColours (ClientData clientData,
-                             Tcl_Interp * interp,
-                             int argc, tcl_const char *argv[])
-  {
-     if(argc < 1)
-     {
-        Tcl_SetResult (interp, (char *)"Ng_GetCurrentFaceColours needs arguments", TCL_STATIC);
-        return TCL_ERROR;
-     }
-
-     if(!mesh.Ptr())
-     {
-        Tcl_SetResult (interp, (char *)"Ng_GetCurrentFaceColours: Valid netgen mesh required...please mesh the Geometry first", TCL_STATIC);
-	     return TCL_ERROR;
-     }
-
-     if(strcmp(argv[1], "getcolours") == 0)
-     {
-        stringstream outVar;
-        Array<Vec3d> face_colours;
-        GetFaceColours(*mesh, face_colours);
-
-        for(int i = 0; i < face_colours.Size();i++)
-        {
-           outVar << "{ " << face_colours[i].X(1)
-                  << " "  << face_colours[i].X(2)
-                  << " "  << face_colours[i].X(3)
-                  << " } ";
-        }
-
-        tcl_const char * valuevar = argv[2];
-        Tcl_SetVar  (interp, valuevar, (char*)outVar.str().c_str(), 0);
-     }
-
-     if(strcmp(argv[1], "showalso") == 0)
-     {
-        Array<Vec3d> face_colours;
-        GetFaceColours(*mesh,face_colours);
-
-        int colourind = atoi (argv[2]);
-
-        for(int i = 1; i <= mesh->GetNFD(); i++)
-        {
-           Array<SurfaceElementIndex> surfElems;
-           mesh->GetSurfaceElementsOfFace(i,surfElems);
-
-           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
-           {
-              for(int j = 0; j < surfElems.Size(); j++)
-              {
-                 mesh->SurfaceElement(surfElems[j]).Visible(1);
-              }
-           }
-        }
-
-        mesh->SetNextTimeStamp();
-     }
-
-     if(strcmp(argv[1], "hidealso") == 0)
-     {
-        Array<Vec3d> face_colours;
-        GetFaceColours(*mesh,face_colours);
-
-        int colourind = atoi (argv[2]);
-
-        for(int i = 1; i <= mesh->GetNFD(); i++)
-        {
-           Array<SurfaceElementIndex> surfElems;
-           mesh->GetSurfaceElementsOfFace(i,surfElems);
-
-           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
-           {
-              for(int j = 0; j < surfElems.Size(); j++)
-              {
-                 mesh->SurfaceElement(surfElems[j]).Visible(0);
-              }
-           }
-        }
-
-        mesh->SetNextTimeStamp();
-     }
-
-     if(strcmp(argv[1], "showonly") == 0)
-     {
-        Array<Vec3d> face_colours;
-        GetFaceColours(*mesh,face_colours);
-
-        int colourind = atoi (argv[2]);
-
-        for(int i = 1; i <= mesh->GetNFD(); i++)
-        {
-           Array<SurfaceElementIndex> surfElems;
-           mesh->GetSurfaceElementsOfFace(i,surfElems);
-
-           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
-           {
-              for(int j = 0; j < surfElems.Size(); j++)
-              {
-                 mesh->SurfaceElement(surfElems[j]).Visible(1);
-              }
-           }
-           else
-           {
-              for(int j = 0; j < surfElems.Size(); j++)
-              {
-                 mesh->SurfaceElement(surfElems[j]).Visible(0);
-              }
-           }
-        }
-
-        mesh->SetNextTimeStamp();
-     }
-
-     if(strcmp(argv[1], "hideonly") == 0)
-     {
-        Array<Vec3d> face_colours;
-        GetFaceColours(*mesh,face_colours);
-
-        int colourind = atoi (argv[2]);
-
-        for(int i = 1; i <= mesh->GetNFD(); i++)
-        {
-           Array<SurfaceElementIndex> surfElems;
-           mesh->GetSurfaceElementsOfFace(i,surfElems);
-
-           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
-           {
-              for(int j = 0; j < surfElems.Size(); j++)
-              {
-                 mesh->SurfaceElement(surfElems[j]).Visible(0);
-              }
-           }
-           else
-           {
-              for(int j = 0; j < surfElems.Size(); j++)
-              {
-                 mesh->SurfaceElement(surfElems[j]).Visible(1);
-              }
-           }
-        }
-
-        mesh->SetNextTimeStamp();
-     }
-
-     if(strcmp(argv[1], "showall") == 0)
-     {
-        for(int i = 1; i <= mesh->GetNSE(); i++)
-        {
-           mesh->SurfaceElement(i).Visible(1);
-        }
-
-        mesh->SetNextTimeStamp();
-     }
-
-     if(strcmp(argv[1], "hideall") == 0)
-     {
-        for(int i = 1; i <= mesh->GetNSE(); i++)
-        {
-           mesh->SurfaceElement(i).Visible(0);
-        }
-
-        mesh->SetNextTimeStamp();
-     }
-
-     return TCL_OK;
-  }
-
-
-
-
-  // Philippose - 10/03/2009
-  // TCL interface function for the Automatic Colour-based
-  // definition of boundary conditions for OCC Geometry
-  int Ng_AutoColourBcProps (ClientData clientData,
-		                      Tcl_Interp * interp,
-		                      int argc, tcl_const char *argv[])
-  {
-     if(argc < 1)
-     {
-        Tcl_SetResult (interp, (char *)"Ng_AutoColourBcProps needs arguments", TCL_STATIC);
-        return TCL_ERROR;
-     }
-
-     if(!mesh.Ptr())
-     {
-        Tcl_SetResult (interp, (char *)"Ng_AutoColourBcProps: Valid netgen mesh required...please mesh the Geometry first", TCL_STATIC);
-	     return TCL_ERROR;
-     }
-
-     if(strcmp(argv[1], "auto") == 0)
-     {
-        AutoColourBcProps(*mesh, 0);
-     }
-
-     if(strcmp(argv[1], "profile") == 0)
-     {
-        AutoColourBcProps(*mesh, argv[2]);
-     }
-
-     return TCL_OK;
-  }
-
-
-  int Ng_SetOCCParameters  (ClientData clientData,
-			    Tcl_Interp * interp,
-			    int argc, tcl_const char *argv[])
-  {
-    OCCGeometryRegister reg;
-    reg.SetParameters (interp);
-    /*
-    occparam.resthcloseedgefac =
-      atof (Tcl_GetVar (interp, "::stloptions.resthcloseedgefac", 0));
-
-    occparam.resthcloseedgeenable =
-      atoi (Tcl_GetVar (interp, "::stloptions.resthcloseedgeenable", 0));
-    */
-    return TCL_OK;
-  }
-
-
-
-
-  NetgenGeometry *  OCCGeometryRegister :: Load (string filename) const
-  {
-    const char * lgfilename = filename.c_str();
-
-
-    /*
-    if (strcmp (&cfilename[strlen(cfilename)-3], "geo") == 0)
-      {
-	PrintMessage (1, "Load OCCG geometry file ", cfilename);
-	
-	extern OCCGeometry * ParseOCCG (istream & istr);
-
-	ifstream infile(cfilename);
-
-	OCCGeometry * hgeom = ParseOCCG (infile);
-	if (!hgeom)
-	  throw NgException ("geo-file should start with 'algebraic3d'");
-
-	hgeom -> FindIdenticSurfaces(1e-8 * hgeom->MaxSize()); 
-	return hgeom;
-      }
-    */
-
-
-    if ((strcmp (&lgfilename[strlen(lgfilename)-4], "iges") == 0) ||
-	(strcmp (&lgfilename[strlen(lgfilename)-3], "igs") == 0) ||
-	(strcmp (&lgfilename[strlen(lgfilename)-3], "IGS") == 0) ||
-	(strcmp (&lgfilename[strlen(lgfilename)-4], "IGES") == 0))
-      {
-	PrintMessage (1, "Load IGES geometry file ", lgfilename);
-	OCCGeometry * occgeometry = LoadOCC_IGES (lgfilename);
-	return occgeometry;
-      }
-
-    else if ((strcmp (&lgfilename[strlen(lgfilename)-4], "step") == 0) ||
-		     (strcmp (&lgfilename[strlen(lgfilename)-3], "stp") == 0) ||
-		     (strcmp (&lgfilename[strlen(lgfilename)-3], "STP") == 0) ||
-		     (strcmp (&lgfilename[strlen(lgfilename)-4], "STEP") == 0))
-      {
-	PrintMessage (1, "Load STEP geometry file ", lgfilename);
-	OCCGeometry * occgeometry = LoadOCC_STEP (lgfilename);
-	return occgeometry;    
-      }
-    else if ((strcmp (&lgfilename[strlen(lgfilename)-4], "brep") == 0) ||
-	     (strcmp (&lgfilename[strlen(lgfilename)-4], "Brep") == 0) ||
-	     (strcmp (&lgfilename[strlen(lgfilename)-4], "BREP") == 0))
-      {
-	PrintMessage (1, "Load BREP geometry file ", lgfilename);
-	OCCGeometry * occgeometry = LoadOCC_BREP (lgfilename);
-	return occgeometry;
-      }
-    
-    return NULL;
-  }
-
-
-  static VisualSceneOCCGeometry vsoccgeom;
-
-  VisualScene * OCCGeometryRegister :: GetVisualScene (const NetgenGeometry * geom) const
-  {
-    OCCGeometry * geometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
-    if (geometry)
-      {
-	vsoccgeom.SetGeometry (geometry);
-	return &vsoccgeom;
-      }
-    return NULL;
-  }
-
-
-
-}
-
-
-
-using namespace netgen;
-
-int Ng_occ_Init (Tcl_Interp * interp)
-{
-  geometryregister.Append (new OCCGeometryRegister);
-
-
-    Tcl_CreateCommand (interp, "Ng_SetOCCVisParameters",
-		       Ng_SetOCCVisParameters,
-		       (ClientData)NULL,
-		       (Tcl_CmdDeleteProc*) NULL);
-
-    Tcl_CreateCommand (interp, "Ng_GetOCCData",
-		       Ng_GetOCCData,
-		       (ClientData)NULL,
-		       (Tcl_CmdDeleteProc*) NULL);
-
-    /*
-#ifdef OCCGEOMETRY
-    Tcl_CreateCommand (interp, "Ng_OCCConstruction",
-		       Ng_OCCConstruction,
-		       (ClientData)NULL,
-		       (Tcl_CmdDeleteProc*) NULL);
-#endif
-    */
-
-    Tcl_CreateCommand (interp, "Ng_OCCCommand",
-		       Ng_OCCCommand,
-		       (ClientData)NULL,
-		       (Tcl_CmdDeleteProc*) NULL);
-
-
-    Tcl_CreateCommand (interp, "Ng_SetOCCParameters", Ng_SetOCCParameters,
-		       (ClientData)NULL,
-		       (Tcl_CmdDeleteProc*) NULL);
-
-
-
-    // Philippose - 30/01/2009
-    // Register the TCL Interface Command for local face mesh size
-    // definition
-    Tcl_CreateCommand (interp, "Ng_SurfaceMeshSize", Ng_SurfaceMeshSize,
-		       (ClientData)NULL,
-		       (Tcl_CmdDeleteProc*) NULL);
-
-    Tcl_CreateCommand (interp, "Ng_AutoColourBcProps", Ng_AutoColourBcProps,
-		       (ClientData)NULL,
-		       (Tcl_CmdDeleteProc*) NULL);
-
-    // Philippose - 25/07/2010
-    // Register the TCL Interface Command for handling the face colours 
-    // present in the mesh
-    Tcl_CreateCommand(interp, "Ng_CurrentFaceColours", Ng_CurrentFaceColours,
-                      (ClientData)NULL,
-                      (Tcl_CmdDeleteProc*) NULL);
-
-
-  return TCL_OK;
-}
-
-#endif
-
+#ifdef OCCGEOMETRY
+
+#include <mystdlib.h>
+#include <myadt.hpp>
+#include <linalg.hpp>
+#include <csg.hpp>
+#include <occgeom.hpp>
+
+
+#include <incvis.hpp>
+#include <visual.hpp>
+
+#include "../meshing/bcfunctions.hpp"
+
+#include "vsocc.hpp"
+
+
+extern "C" int Ng_occ_Init (Tcl_Interp * interp);
+
+
+
+namespace netgen
+{
+  extern AutoPtr<NetgenGeometry> ng_geometry;
+  extern AutoPtr<Mesh> mesh;
+ 
+  char * err_needsoccgeometry = (char*) "This operation needs an OCC geometry";
+  extern char * err_needsmesh;
+  extern char * err_jobrunning;
+
+
+
+                          
+  class OCCGeometryRegister : public GeometryRegister
+  {
+  public:
+    virtual NetgenGeometry * Load (string filename) const;
+    virtual VisualScene * GetVisualScene (const NetgenGeometry * geom) const;
+
+    virtual void SetParameters (Tcl_Interp * interp) 
+    {
+      occparam.resthcloseedgefac =
+	atof (Tcl_GetVar (interp, "::stloptions.resthcloseedgefac", 0));
+      occparam.resthcloseedgeenable =
+	atoi (Tcl_GetVar (interp, "::stloptions.resthcloseedgeenable", 0));
+	  occparam.resthminedgelen = 
+	atof (Tcl_GetVar (interp, "::stloptions.resthminedgelen", 0));
+	  occparam.resthminedgelenenable = 
+	atoi (Tcl_GetVar (interp, "::stloptions.resthminedgelenenable", 0));
+    }
+  };
+
+
+
+
+  int Ng_SetOCCVisParameters  (ClientData clientData,
+			       Tcl_Interp * interp,
+			       int argc, tcl_const char *argv[])
+  {
+#ifdef OCCGEOMETRY
+    int showvolume;
+	OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
+
+    showvolume = atoi (Tcl_GetVar (interp, "::occoptions.showvolumenr", 0));
+
+    if (occgeometry)
+      if (showvolume != vispar.occshowvolumenr)
+	{
+	  if (showvolume < 0 || showvolume > occgeometry->NrSolids())
+	    {
+	      char buf[20];
+	      sprintf (buf, "%5i", vispar.occshowvolumenr);
+	      Tcl_SetVar (interp, "::occoptions.showvolumenr", buf, 0);
+	    }
+	  else
+	    {
+	      vispar.occshowvolumenr = showvolume;
+	      if (occgeometry)
+		occgeometry -> changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+	    }
+	}
+    
+    int temp;
+
+    temp = atoi (Tcl_GetVar (interp, "::occoptions.visproblemfaces", 0));
+
+    if ((bool) temp != vispar.occvisproblemfaces)
+      {
+	vispar.occvisproblemfaces = temp;
+	if (occgeometry)
+	  occgeometry -> changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+      }
+
+    vispar.occshowsurfaces = atoi (Tcl_GetVar (interp, "::occoptions.showsurfaces", 0));
+    vispar.occshowedges = atoi (Tcl_GetVar (interp, "::occoptions.showedges", 0));
+    vispar.occzoomtohighlightedentity = atoi (Tcl_GetVar (interp, "::occoptions.zoomtohighlightedentity", 0));
+    vispar.occdeflection = pow(10.0,-1-atof (Tcl_GetVar (interp, "::occoptions.deflection", 0)));
+
+#endif
+
+
+
+
+
+#ifdef ACIS
+    vispar.ACISshowfaces = atoi (Tcl_GetVar (interp, "::occoptions.showsurfaces", 0));
+    vispar.ACISshowedges = atoi (Tcl_GetVar (interp, "::occoptions.showedges", 0));
+    vispar.ACISshowsolidnr = atoi (Tcl_GetVar (interp, "::occoptions.showsolidnr", 0));
+    vispar.ACISshowsolidnr2 = atoi (Tcl_GetVar (interp, "::occoptions.showsolidnr2", 0));
+
+#endif
+
+
+
+    return TCL_OK;
+  }  
+
+
+
+
+  int Ng_GetOCCData (ClientData clientData,
+		     Tcl_Interp * interp,
+		     int argc, tcl_const char *argv[])
+  {
+#ifdef OCCGEOMETRY
+    OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
+
+    static char buf[1000];
+    buf[0] = 0;
+    stringstream str;
+
+    if (argc >= 2)
+      {
+	if (strcmp (argv[1], "getentities") == 0)
+	  {
+	    if (occgeometry)
+	      {
+		occgeometry->GetTopologyTree(str);
+	      }
+	  }
+      }
+
+    Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
+
+#endif
+    return TCL_OK;
+  }
+
+  
+
+  int Ng_OCCCommand (ClientData clientData,
+		     Tcl_Interp * interp,
+		     int argc, tcl_const char *argv[])
+  {
+#ifdef OCCGEOMETRY
+    OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
+
+    stringstream str;
+    if (argc >= 2)
+      {
+	if (strcmp (argv[1], "isoccgeometryloaded") == 0)
+	  {
+	    if (occgeometry)
+	      str << "1 " << flush;
+	    else str << "0 " << flush;
+
+	    Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
+	  }
+	if (occgeometry)
+	  {
+	    if (strcmp (argv[1], "buildvisualizationmesh") == 0)
+	      {
+		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
+		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+	      }
+	    if (strcmp (argv[1], "mesherror") == 0)
+	      {
+		if (occgeometry->ErrorInSurfaceMeshing())
+		  str << 1;
+		else
+		  str << 0;
+	      }
+	    if (strcmp (argv[1], "sewfaces") == 0)
+	      {
+		cout << "Before operation:" << endl;
+		occgeometry->PrintNrShapes();
+		occgeometry->SewFaces();
+		occgeometry->BuildFMap();
+		cout << endl << "After operation:" << endl;
+		occgeometry->PrintNrShapes();
+		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
+		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+	      }
+	    if (strcmp (argv[1], "makesolid") == 0)
+	      {
+		cout << "Before operation:" << endl;
+		occgeometry->PrintNrShapes();
+		occgeometry->MakeSolid();
+		occgeometry->BuildFMap();
+		cout << endl << "After operation:" << endl;
+		occgeometry->PrintNrShapes();
+		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
+		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+	      }
+	    if (strcmp (argv[1], "upgradetopology") == 0)
+	      {
+		cout << "Before operation:" << endl;
+		occgeometry->PrintNrShapes();
+		occgeometry->SewFaces();
+		occgeometry->MakeSolid();
+		occgeometry->BuildFMap();
+		cout << endl << "After operation:" << endl;
+		occgeometry->PrintNrShapes();
+		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
+		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+	      }
+	    if (strcmp (argv[1], "shapehealing") == 0)
+	      {
+		occgeometry->tolerance =
+		  atof (Tcl_GetVar (interp, "::occoptions.tolerance", 0));
+		occgeometry->fixsmalledges =
+		  atoi (Tcl_GetVar (interp, "::occoptions.fixsmalledges", 0));
+		occgeometry->fixspotstripfaces =
+		  atoi (Tcl_GetVar (interp, "::occoptions.fixspotstripfaces", 0));
+		occgeometry->sewfaces =
+		  atoi (Tcl_GetVar (interp, "::occoptions.sewfaces", 0));
+		occgeometry->makesolids =
+		  atoi (Tcl_GetVar (interp, "::occoptions.makesolids", 0));
+		occgeometry->splitpartitions =
+		  atoi (Tcl_GetVar (interp, "::occoptions.splitpartitions", 0));
+
+		//	      cout << "Before operation:" << endl;
+		//	      occgeometry->PrintNrShapes();
+		occgeometry->HealGeometry();
+		occgeometry->BuildFMap();
+		//	      cout << endl << "After operation:" << endl;
+		//	      occgeometry->PrintNrShapes();
+		occgeometry->BuildVisualizationMesh(vispar.occdeflection);
+		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+	      }
+
+
+	    if (strcmp (argv[1], "highlightentity") == 0)
+	      {
+		if (strcmp (argv[2], "Face") == 0)
+		  {
+		    int nr = atoi (argv[3]);
+		    occgeometry->LowLightAll();
+
+		    occgeometry->fvispar[nr-1].Highlight();
+		    if (vispar.occzoomtohighlightedentity)
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
+		    else
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		  }
+		if (strcmp (argv[2], "Shell") == 0)
+		  {
+		    int nr = atoi (argv[3]);
+		    occgeometry->LowLightAll();
+
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->shmap(nr), TopAbs_FACE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
+			occgeometry->fvispar[i-1].Highlight();
+		      }
+		    if (vispar.occzoomtohighlightedentity)
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
+		    else
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		  }
+		if (strcmp (argv[2], "Solid") == 0)
+		  {
+		    int nr = atoi (argv[3]);
+		    occgeometry->LowLightAll();
+
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->somap(nr), TopAbs_FACE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
+			occgeometry->fvispar[i-1].Highlight();
+		      }
+		    if (vispar.occzoomtohighlightedentity)
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
+		    else
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		  }
+		/*
+		  if (strcmp (argv[2], "CompSolid") == 0)
+		  {
+		  int nr = atoi (argv[3]);
+		  occgeometry->LowLightAll();
+
+		  TopExp_Explorer exp;
+		  for (exp.Init (occgeometry->cmap(nr), TopAbs_FACE);
+		  exp.More(); exp.Next())
+		  {
+		  int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
+		  occgeometry->fvispar[i-1].Highlight();
+		  }
+		  occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		  }
+		*/
+
+		if (strcmp (argv[2], "Edge") == 0)
+		  {
+		    int nr = atoi (argv[3]);
+		    occgeometry->LowLightAll();
+
+		    occgeometry->evispar[nr-1].Highlight();
+		    if (vispar.occzoomtohighlightedentity)
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
+		    else
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		  }
+		if (strcmp (argv[2], "Wire") == 0)
+		  {
+		    int nr = atoi (argv[3]);
+		    occgeometry->LowLightAll();
+
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->wmap(nr), TopAbs_EDGE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->emap.FindIndex (TopoDS::Edge(exp.Current()));
+			occgeometry->evispar[i-1].Highlight();
+		      }
+		    if (vispar.occzoomtohighlightedentity)
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
+		    else
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		  }
+
+		if (strcmp (argv[2], "Vertex") == 0)
+		  {
+		    int nr = atoi (argv[3]);
+		    occgeometry->LowLightAll();
+
+		    occgeometry->vvispar[nr-1].Highlight();
+		    if (vispar.occzoomtohighlightedentity)
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONFULLCHANGE;
+		    else
+		      occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		  }
+
+	      }
+
+
+
+	    if (strcmp (argv[1], "show") == 0)
+	      {
+		int nr = atoi (argv[3]);
+		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+
+		if (strcmp (argv[2], "Face") == 0)
+		  {
+		    occgeometry->fvispar[nr-1].Show();
+		  }
+		if (strcmp (argv[2], "Shell") == 0)
+		  {
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->shmap(nr), TopAbs_FACE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
+			occgeometry->fvispar[i-1].Show();
+		      }
+		  }
+		if (strcmp (argv[2], "Solid") == 0)
+		  {
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->somap(nr), TopAbs_FACE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
+			occgeometry->fvispar[i-1].Show();
+		      }
+		  }
+		if (strcmp (argv[2], "Edge") == 0)
+		  {
+		    occgeometry->evispar[nr-1].Show();
+		  }
+		if (strcmp (argv[2], "Wire") == 0)
+		  {
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->wmap(nr), TopAbs_EDGE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->emap.FindIndex (TopoDS::Edge(exp.Current()));
+			occgeometry->evispar[i-1].Show();
+		      }
+		  }
+	      }
+
+
+	    if (strcmp (argv[1], "hide") == 0)
+	      {
+		int nr = atoi (argv[3]);
+		occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+
+		if (strcmp (argv[2], "Face") == 0)
+		  {
+		    occgeometry->fvispar[nr-1].Hide();
+		  }
+		if (strcmp (argv[2], "Shell") == 0)
+		  {
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->shmap(nr), TopAbs_FACE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
+			occgeometry->fvispar[i-1].Hide();
+		      }
+		  }
+		if (strcmp (argv[2], "Solid") == 0)
+		  {
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->somap(nr), TopAbs_FACE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->fmap.FindIndex (TopoDS::Face(exp.Current()));
+			occgeometry->fvispar[i-1].Hide();
+		      }
+		  }
+		if (strcmp (argv[2], "Edge") == 0)
+		  {
+		    occgeometry->evispar[nr-1].Hide();
+		  }
+		if (strcmp (argv[2], "Wire") == 0)
+		  {
+		    TopExp_Explorer exp;
+		    for (exp.Init (occgeometry->wmap(nr), TopAbs_EDGE);
+			 exp.More(); exp.Next())
+		      {
+			int i = occgeometry->emap.FindIndex (TopoDS::Edge(exp.Current()));
+			occgeometry->evispar[i-1].Hide();
+		      }
+		  }
+	      }
+
+
+
+	    if (strcmp (argv[1], "findsmallentities") == 0)
+	      {
+		stringstream str("");
+		occgeometry->CheckIrregularEntities(str);
+		Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
+	      }
+	    if (strcmp (argv[1], "getunmeshedfaceinfo") == 0)
+	      {
+		occgeometry->GetUnmeshedFaceInfo(str);
+		Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
+	      }
+	    if (strcmp (argv[1], "getnotdrawablefaces") == 0)
+	      {
+		occgeometry->GetNotDrawableFaces(str);
+		Tcl_SetResult (interp, (char*)str.str().c_str(), TCL_VOLATILE);
+	      }
+	    if (strcmp (argv[1], "redrawstatus") == 0)
+	      {
+		int i = atoi (argv[2]);
+		occgeometry->changed = i;
+	      }
+	    if (strcmp (argv[1], "swaporientation") == 0)
+	      {
+		IGESControl_Writer writer("millimeters", 1);
+		writer.AddShape (occgeometry->shape);
+		writer.Write ("1.igs");
+		/*
+		  int nr = atoi (argv[3]);
+
+		  //	      const_cast<TopoDS_Shape&> (occgeometry->fmap(nr)).Reverse();
+
+		  Handle_ShapeBuild_ReShape rebuild = new ShapeBuild_ReShape;
+		  rebuild->Apply(occgeometry->shape);
+
+		  TopoDS_Shape sh;
+
+		  //	      if (strcmp (argv[2], "CompSolid") == 0) sh = occgeometry->cmap(nr);
+		  if (strcmp (argv[2], "Solid") == 0) sh = occgeometry->somap(nr);
+		  if (strcmp (argv[2], "Shell") == 0) sh = occgeometry->shmap(nr);
+		  if (strcmp (argv[2], "Face") == 0) sh = occgeometry->fmap(nr);
+		  if (strcmp (argv[2], "Wire") == 0) sh = occgeometry->wmap(nr);
+		  if (strcmp (argv[2], "Edge") == 0) sh = occgeometry->emap(nr);
+
+		  rebuild->Replace(sh, sh.Reversed());
+
+		  TopoDS_Shape newshape = rebuild->Apply(occgeometry->shape, TopAbs_SHELL, 1);
+		  occgeometry->shape = newshape;
+
+		  occgeometry->BuildFMap();
+		  occgeometry->BuildVisualizationMesh();
+		  occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+		*/
+	      }
+	    if (strcmp (argv[1], "marksingular") == 0)
+	      {
+		int nr = atoi (argv[3]);
+		cout << "marking " << argv[2] << " " << nr << endl;
+		char buf[2]; buf[0] = '0'; buf[1] = 0;
+		bool sing = false;
+		if (strcmp (argv[2], "Face") == 0)
+		  sing = occgeometry->fsingular[nr-1] = !occgeometry->fsingular[nr-1];
+		if (strcmp (argv[2], "Edge") == 0)
+		  sing = occgeometry->esingular[nr-1] = !occgeometry->esingular[nr-1];
+		if (strcmp (argv[2], "Vertex") == 0)
+		  sing = occgeometry->vsingular[nr-1] = !occgeometry->vsingular[nr-1];
+
+		if (sing) buf[0] = '1';
+
+                Tcl_SetVar (interp, "::ismarkedsingular", buf, 0);
+
+		stringstream str;
+		occgeometry->GetTopologyTree (str);
+
+		char* cstr = (char*)str.str().c_str();
+
+		(*testout) << cstr << endl;
+
+		char helpstr[1000];
+
+		while (strchr (cstr, '}'))
+		  {
+		    strncpy (helpstr, cstr+2, strlen(strchr(cstr+2, '}')));
+		    (*testout) << "***" << cstr << "***" << endl;
+		    cstr = strchr (cstr, '}');
+		  } 
+	      }
+	  }
+      }
+
+#endif
+    return TCL_OK;
+  }
+
+
+
+#ifdef OCCGEOMETRY
+  /*
+  void OCCConstructGeometry (OCCGeometry & geom);
+
+  int Ng_OCCConstruction (ClientData clientData,
+			  Tcl_Interp * interp,
+			  int argc, tcl_const char *argv[])
+  {
+    if (occgeometry)
+      OCCConstructGeometry (*occgeometry);
+    return TCL_OK;
+  }
+  */
+#endif
+
+
+
+
+  // Philippose - 30/01/2009
+  // TCL interface function for the Local Face Mesh size
+  // definition functionality
+  int Ng_SurfaceMeshSize (ClientData clientData,
+		                    Tcl_Interp * interp,
+		                    int argc, tcl_const char *argv[])
+  {
+#ifdef OCCGEOMETRY
+
+    static char buf[100];
+
+    if (argc < 2)
+    {
+	   Tcl_SetResult (interp, (char *)"Ng_SurfaceMeshSize needs arguments", TCL_STATIC);
+	   return TCL_ERROR;
+    }
+
+    OCCGeometry * occgeometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
+    if (!occgeometry)
+    {
+      Tcl_SetResult (interp, (char *)"Ng_SurfaceMeshSize currently supports only OCC (STEP/IGES) Files", TCL_STATIC);
+	   return TCL_ERROR;
+    }
+
+    // Update the face mesh sizes to reflect the global maximum mesh size
+    for(int i = 1; i <= occgeometry->NrFaces(); i++)
+    {
+           if(!occgeometry->GetFaceMaxhModified(i))
+           {
+              occgeometry->SetFaceMaxH(i, mparam.maxh);
+           }   
+    }
+
+    if (strcmp (argv[1], "setsurfms") == 0)
+    {
+	   int facenr = atoi (argv[2]);
+	   double surfms = atof (argv[3]);
+	   if (occgeometry && facenr >= 1 && facenr <= occgeometry->NrFaces())
+	     occgeometry->SetFaceMaxH(facenr, surfms);
+
+    }
+
+    if (strcmp (argv[1], "setall") == 0)
+    {
+	   double surfms = atof (argv[2]);
+	   if (occgeometry)
+	   {
+	     int nrFaces = occgeometry->NrFaces();
+	     for (int i = 1; i <= nrFaces; i++)
+	      occgeometry->SetFaceMaxH(i, surfms);
+	   }
+    }
+
+    if (strcmp (argv[1], "getsurfms") == 0)
+    {
+	   int facenr = atoi (argv[2]);
+	   if (occgeometry && facenr >= 1 && facenr <= occgeometry->NrFaces())
+	   {
+	     sprintf (buf, "%5.2f", occgeometry->GetFaceMaxH(facenr));
+	   }
+	   else
+	   {
+	     sprintf (buf, "%5.2f", mparam.maxh);
+	   }
+	   Tcl_SetResult (interp, buf, TCL_STATIC);
+    }
+
+    if (strcmp (argv[1], "getactive") == 0)
+    {
+	   sprintf (buf, "%d", occgeometry->SelectedFace());
+	   Tcl_SetResult (interp, buf, TCL_STATIC);
+    }
+
+    if (strcmp (argv[1], "setactive") == 0)
+    {
+	   int facenr = atoi (argv[2]);
+	   if (occgeometry && facenr >= 1 && facenr <= occgeometry->NrFaces())
+	   {
+	     occgeometry->SetSelectedFace (facenr);
+
+        occgeometry->LowLightAll();
+        occgeometry->fvispar[facenr-1].Highlight();
+        occgeometry->changed = OCCGEOMETRYVISUALIZATIONHALFCHANGE;
+	   }
+    }
+
+    if (strcmp (argv[1], "getnfd") == 0)
+    {
+	   if (occgeometry)
+	     sprintf (buf, "%d", occgeometry->NrFaces());
+	   else
+	     sprintf (buf, "0");
+	   Tcl_SetResult (interp, buf, TCL_STATIC);
+    }
+    return TCL_OK;
+#else // No OCCGEOMETRY 
+
+    Tcl_SetResult (interp, (char *)"Ng_SurfaceMeshSize currently supports only OCC (STEP/IGES) Files", TCL_STATIC);
+    return TCL_ERROR;
+    
+#endif // OCCGEOMETRY
+  }
+
+
+
+  // Philippose - 25/07/2010
+  // TCL interface function for extracting and eventually 
+  // setting or editing the current colours present in the mesh
+  int Ng_CurrentFaceColours (ClientData clientData,
+                             Tcl_Interp * interp,
+                             int argc, tcl_const char *argv[])
+  {
+     if(argc < 1)
+     {
+        Tcl_SetResult (interp, (char *)"Ng_GetCurrentFaceColours needs arguments", TCL_STATIC);
+        return TCL_ERROR;
+     }
+
+     if(!mesh.Ptr())
+     {
+        Tcl_SetResult (interp, (char *)"Ng_GetCurrentFaceColours: Valid netgen mesh required...please mesh the Geometry first", TCL_STATIC);
+	     return TCL_ERROR;
+     }
+
+     if(strcmp(argv[1], "getcolours") == 0)
+     {
+        stringstream outVar;
+        Array<Vec3d> face_colours;
+        GetFaceColours(*mesh, face_colours);
+
+        for(int i = 0; i < face_colours.Size();i++)
+        {
+           outVar << "{ " << face_colours[i].X(1)
+                  << " "  << face_colours[i].X(2)
+                  << " "  << face_colours[i].X(3)
+                  << " } ";
+        }
+
+        tcl_const char * valuevar = argv[2];
+        Tcl_SetVar  (interp, valuevar, (char*)outVar.str().c_str(), 0);
+     }
+
+     if(strcmp(argv[1], "showalso") == 0)
+     {
+        Array<Vec3d> face_colours;
+        GetFaceColours(*mesh,face_colours);
+
+        int colourind = atoi (argv[2]);
+
+        for(int i = 1; i <= mesh->GetNFD(); i++)
+        {
+           Array<SurfaceElementIndex> surfElems;
+           mesh->GetSurfaceElementsOfFace(i,surfElems);
+
+           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
+           {
+              for(int j = 0; j < surfElems.Size(); j++)
+              {
+                 mesh->SurfaceElement(surfElems[j]).Visible(1);
+              }
+           }
+        }
+
+        mesh->SetNextTimeStamp();
+     }
+
+     if(strcmp(argv[1], "hidealso") == 0)
+     {
+        Array<Vec3d> face_colours;
+        GetFaceColours(*mesh,face_colours);
+
+        int colourind = atoi (argv[2]);
+
+        for(int i = 1; i <= mesh->GetNFD(); i++)
+        {
+           Array<SurfaceElementIndex> surfElems;
+           mesh->GetSurfaceElementsOfFace(i,surfElems);
+
+           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
+           {
+              for(int j = 0; j < surfElems.Size(); j++)
+              {
+                 mesh->SurfaceElement(surfElems[j]).Visible(0);
+              }
+           }
+        }
+
+        mesh->SetNextTimeStamp();
+     }
+
+     if(strcmp(argv[1], "showonly") == 0)
+     {
+        Array<Vec3d> face_colours;
+        GetFaceColours(*mesh,face_colours);
+
+        int colourind = atoi (argv[2]);
+
+        for(int i = 1; i <= mesh->GetNFD(); i++)
+        {
+           Array<SurfaceElementIndex> surfElems;
+           mesh->GetSurfaceElementsOfFace(i,surfElems);
+
+           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
+           {
+              for(int j = 0; j < surfElems.Size(); j++)
+              {
+                 mesh->SurfaceElement(surfElems[j]).Visible(1);
+              }
+           }
+           else
+           {
+              for(int j = 0; j < surfElems.Size(); j++)
+              {
+                 mesh->SurfaceElement(surfElems[j]).Visible(0);
+              }
+           }
+        }
+
+        mesh->SetNextTimeStamp();
+     }
+
+     if(strcmp(argv[1], "hideonly") == 0)
+     {
+        Array<Vec3d> face_colours;
+        GetFaceColours(*mesh,face_colours);
+
+        int colourind = atoi (argv[2]);
+
+        for(int i = 1; i <= mesh->GetNFD(); i++)
+        {
+           Array<SurfaceElementIndex> surfElems;
+           mesh->GetSurfaceElementsOfFace(i,surfElems);
+
+           if(ColourMatch(face_colours[colourind],mesh->GetFaceDescriptor(i).SurfColour()))
+           {
+              for(int j = 0; j < surfElems.Size(); j++)
+              {
+                 mesh->SurfaceElement(surfElems[j]).Visible(0);
+              }
+           }
+           else
+           {
+              for(int j = 0; j < surfElems.Size(); j++)
+              {
+                 mesh->SurfaceElement(surfElems[j]).Visible(1);
+              }
+           }
+        }
+
+        mesh->SetNextTimeStamp();
+     }
+
+     if(strcmp(argv[1], "showall") == 0)
+     {
+        for(int i = 1; i <= mesh->GetNSE(); i++)
+        {
+           mesh->SurfaceElement(i).Visible(1);
+        }
+
+        mesh->SetNextTimeStamp();
+     }
+
+     if(strcmp(argv[1], "hideall") == 0)
+     {
+        for(int i = 1; i <= mesh->GetNSE(); i++)
+        {
+           mesh->SurfaceElement(i).Visible(0);
+        }
+
+        mesh->SetNextTimeStamp();
+     }
+
+     return TCL_OK;
+  }
+
+
+
+
+  // Philippose - 10/03/2009
+  // TCL interface function for the Automatic Colour-based
+  // definition of boundary conditions for OCC Geometry
+  int Ng_AutoColourBcProps (ClientData clientData,
+		                      Tcl_Interp * interp,
+		                      int argc, tcl_const char *argv[])
+  {
+     if(argc < 1)
+     {
+        Tcl_SetResult (interp, (char *)"Ng_AutoColourBcProps needs arguments", TCL_STATIC);
+        return TCL_ERROR;
+     }
+
+     if(!mesh.Ptr())
+     {
+        Tcl_SetResult (interp, (char *)"Ng_AutoColourBcProps: Valid netgen mesh required...please mesh the Geometry first", TCL_STATIC);
+	     return TCL_ERROR;
+     }
+
+     if(strcmp(argv[1], "auto") == 0)
+     {
+        AutoColourBcProps(*mesh, 0);
+     }
+
+     if(strcmp(argv[1], "profile") == 0)
+     {
+        AutoColourBcProps(*mesh, argv[2]);
+     }
+
+     return TCL_OK;
+  }
+
+
+  int Ng_SetOCCParameters  (ClientData clientData,
+			    Tcl_Interp * interp,
+			    int argc, tcl_const char *argv[])
+  {
+    OCCGeometryRegister reg;
+    reg.SetParameters (interp);
+    /*
+    occparam.resthcloseedgefac =
+      atof (Tcl_GetVar (interp, "::stloptions.resthcloseedgefac", 0));
+
+    occparam.resthcloseedgeenable =
+      atoi (Tcl_GetVar (interp, "::stloptions.resthcloseedgeenable", 0));
+    */
+    return TCL_OK;
+  }
+
+
+
+
+  NetgenGeometry *  OCCGeometryRegister :: Load (string filename) const
+  {
+    const char * lgfilename = filename.c_str();
+
+
+    /*
+    if (strcmp (&cfilename[strlen(cfilename)-3], "geo") == 0)
+      {
+	PrintMessage (1, "Load OCCG geometry file ", cfilename);
+	
+	extern OCCGeometry * ParseOCCG (istream & istr);
+
+	ifstream infile(cfilename);
+
+	OCCGeometry * hgeom = ParseOCCG (infile);
+	if (!hgeom)
+	  throw NgException ("geo-file should start with 'algebraic3d'");
+
+	hgeom -> FindIdenticSurfaces(1e-8 * hgeom->MaxSize()); 
+	return hgeom;
+      }
+    */
+
+
+    if ((strcmp (&lgfilename[strlen(lgfilename)-4], "iges") == 0) ||
+	(strcmp (&lgfilename[strlen(lgfilename)-3], "igs") == 0) ||
+	(strcmp (&lgfilename[strlen(lgfilename)-3], "IGS") == 0) ||
+	(strcmp (&lgfilename[strlen(lgfilename)-4], "IGES") == 0))
+      {
+	PrintMessage (1, "Load IGES geometry file ", lgfilename);
+	OCCGeometry * occgeometry = LoadOCC_IGES (lgfilename);
+	return occgeometry;
+      }
+
+    else if ((strcmp (&lgfilename[strlen(lgfilename)-4], "step") == 0) ||
+		     (strcmp (&lgfilename[strlen(lgfilename)-3], "stp") == 0) ||
+		     (strcmp (&lgfilename[strlen(lgfilename)-3], "STP") == 0) ||
+		     (strcmp (&lgfilename[strlen(lgfilename)-4], "STEP") == 0))
+      {
+	PrintMessage (1, "Load STEP geometry file ", lgfilename);
+	OCCGeometry * occgeometry = LoadOCC_STEP (lgfilename);
+	return occgeometry;    
+      }
+    else if ((strcmp (&lgfilename[strlen(lgfilename)-4], "brep") == 0) ||
+	     (strcmp (&lgfilename[strlen(lgfilename)-4], "Brep") == 0) ||
+	     (strcmp (&lgfilename[strlen(lgfilename)-4], "BREP") == 0))
+      {
+	PrintMessage (1, "Load BREP geometry file ", lgfilename);
+	OCCGeometry * occgeometry = LoadOCC_BREP (lgfilename);
+	return occgeometry;
+      }
+    
+    return NULL;
+  }
+
+
+  static VisualSceneOCCGeometry vsoccgeom;
+
+  VisualScene * OCCGeometryRegister :: GetVisualScene (const NetgenGeometry * geom) const
+  {
+    OCCGeometry * geometry = dynamic_cast<OCCGeometry*> (ng_geometry.Ptr());
+    if (geometry)
+      {
+	vsoccgeom.SetGeometry (geometry);
+	return &vsoccgeom;
+      }
+    return NULL;
+  }
+
+
+
+}
+
+
+
+using namespace netgen;
+
+int Ng_occ_Init (Tcl_Interp * interp)
+{
+  geometryregister.Append (new OCCGeometryRegister);
+
+
+    Tcl_CreateCommand (interp, "Ng_SetOCCVisParameters",
+		       Ng_SetOCCVisParameters,
+		       (ClientData)NULL,
+		       (Tcl_CmdDeleteProc*) NULL);
+
+    Tcl_CreateCommand (interp, "Ng_GetOCCData",
+		       Ng_GetOCCData,
+		       (ClientData)NULL,
+		       (Tcl_CmdDeleteProc*) NULL);
+
+    /*
+#ifdef OCCGEOMETRY
+    Tcl_CreateCommand (interp, "Ng_OCCConstruction",
+		       Ng_OCCConstruction,
+		       (ClientData)NULL,
+		       (Tcl_CmdDeleteProc*) NULL);
+#endif
+    */
+
+    Tcl_CreateCommand (interp, "Ng_OCCCommand",
+		       Ng_OCCCommand,
+		       (ClientData)NULL,
+		       (Tcl_CmdDeleteProc*) NULL);
+
+
+    Tcl_CreateCommand (interp, "Ng_SetOCCParameters", Ng_SetOCCParameters,
+		       (ClientData)NULL,
+		       (Tcl_CmdDeleteProc*) NULL);
+
+
+
+    // Philippose - 30/01/2009
+    // Register the TCL Interface Command for local face mesh size
+    // definition
+    Tcl_CreateCommand (interp, "Ng_SurfaceMeshSize", Ng_SurfaceMeshSize,
+		       (ClientData)NULL,
+		       (Tcl_CmdDeleteProc*) NULL);
+
+    Tcl_CreateCommand (interp, "Ng_AutoColourBcProps", Ng_AutoColourBcProps,
+		       (ClientData)NULL,
+		       (Tcl_CmdDeleteProc*) NULL);
+
+    // Philippose - 25/07/2010
+    // Register the TCL Interface Command for handling the face colours 
+    // present in the mesh
+    Tcl_CreateCommand(interp, "Ng_CurrentFaceColours", Ng_CurrentFaceColours,
+                      (ClientData)NULL,
+                      (Tcl_CmdDeleteProc*) NULL);
+
+
+  return TCL_OK;
+}
+
+#endif
+
--- netgen_ref/libsrc/occ/utilities.h
+++ netgen/libsrc/occ/utilities.h
@@ -33,6 +33,7 @@
 
 #include <string>
 #include <iostream>
+#include <iomanip>
 #include <cstdlib>
 // #include "SALOME_Log.hxx"
 
--- netgen_ref/libsrc/stlgeom/Makefile.am
+++ netgen/libsrc/stlgeom/Makefile.am
@@ -4,10 +4,10 @@
 AM_CPPFLAGS = -I$(top_srcdir)/libsrc/include $(TCL_INCLUDES)
 METASOURCES = AUTO
 
-lib_LTLIBRARIES = libstl.la 
+noinst_LTLIBRARIES = libstl.la 
 
 if NGGUI
-lib_LTLIBRARIES += libstlvis.la 
+lib_LTLIBRARIES = libstlvis.la 
 endif
 
 libstl_la_SOURCES = meshstlsurface.cpp stlgeom.cpp stlgeomchart.cpp \
@@ -16,6 +16,5 @@
 
 libstlvis_la_SOURCES = stlpkg.cpp vsstl.cpp
 libstlvis_la_LIBADD = libstl.la
-libstl_la_LIBADD =  $(top_builddir)/libsrc/meshing/libmesh.la
 # libstlvis_la_LIBADD = libstl.la $(top_builddir)/libsrc/linalg/libla.la 
 
--- netgen_ref/libsrc/stlgeom/stlgeom.cpp
+++ netgen/libsrc/stlgeom/stlgeom.cpp
@@ -250,7 +250,7 @@
 
 	  if (!nbt)
 	    {
-	      cerr << "ERROR: stlgeom::Smoothnormals, nbt = 0" << endl;
+	      std::cerr << "ERROR: stlgeom::Smoothnormals, nbt = 0" << std::endl;
 	    }
 
 	  // smoothed normal
--- netgen_ref/libsrc/stlgeom/stlgeom.hpp
+++ netgen/libsrc/stlgeom/stlgeom.hpp
@@ -38,7 +38,7 @@
     return true;
   }
   
-  extern DLL_HEADER MeshingParameters mparam;
+  DLL_HEADER extern MeshingParameters mparam;
   
 
 
--- /dev/null
+++ netgen/nglib/CMakeLists.txt
@@ -0,0 +1,252 @@
+# Copyright (C) 2016 OPEN CASCADE
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+#
+# See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
+#
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${PROJECT_SOURCE_DIR}/libsrc/include
+    ${ZLIB_INCLUDE_DIRS}
+    ${CAS_INCLUDE_DIRS}
+)
+
+
+# CGS
+SET(CGS_SOURCES 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/algprim.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/brick.cpp
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/bspline2d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/csgeom.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/csgparser.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/curve2d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/edgeflw.cpp	
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/explicitcurve2d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/extrusion.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/gencyl.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/genmesh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/identify.cpp  
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/manifold.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/meshsurf.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/polyhedra.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/revolution.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/singularref.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/solid.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/specpoin.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/spline3d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/surface.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/csg/triapprox.cpp)
+
+# GENERAL
+SET(GENERAL_SOURCES 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/array.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/bitarray.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/dynamicmem.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/flags.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/hashtabl.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/mystring.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/ngexception.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/optmem.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/parthreads.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/profiler.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/seti.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/sort.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/spbita2d.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/symbolta.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/table.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/mpi_interface.cpp 
+   ${PROJECT_SOURCE_DIR}/libsrc/general/gzstream.cpp)
+
+FILE(GLOB GENERAL_INCLUDES "${PROJECT_SOURCE_DIR}/libsrc/general/*.hpp")
+LIST(APPEND GENERAL_INCLUDES ${PROJECT_SOURCE_DIR}/libsrc/general/gzstream.h)
+
+# GEOM2D
+SET (GEOM2D_SOURCES 
+     ${PROJECT_SOURCE_DIR}/libsrc/geom2d/genmesh2d.cpp 
+     ${PROJECT_SOURCE_DIR}/libsrc/geom2d/geom2dmesh.cpp 
+     ${PROJECT_SOURCE_DIR}/libsrc/geom2d/geometry2d.cpp)
+
+# GPRIM
+SET(GPRIM_SOURCES 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/adtree.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/geom2d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/geom3d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/geomfuncs.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/geomtest3d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/transform3d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/spline.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/gprim/splinegeometry.cpp)
+
+FILE(GLOB GPRIM_INCLUDES "${PROJECT_SOURCE_DIR}/libsrc/gprim/*.hpp")
+
+# INCLUDE
+SET(INCLUDE_INCLUDES 
+    ${PROJECT_SOURCE_DIR}/libsrc/include/nginterface.h
+    ${PROJECT_SOURCE_DIR}/libsrc/include/nginterface_v2.hpp
+    ${PROJECT_SOURCE_DIR}/libsrc/include/mystdlib.h
+    ${PROJECT_SOURCE_DIR}/libsrc/include/mydefs.hpp)
+
+# INTERFACE
+SET(INTERFACE_SOURCES 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/nginterface.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/nginterface_v2.cpp
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/read_fnf_mesh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/readtetmesh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/readuser.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writeabaqus.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writediffpack.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writedolfin.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writeelmer.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writefeap.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writefluent.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writegmsh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writejcm.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writepermas.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writetecplot.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writetet.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writetochnog.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writeuser.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/wuchemnitz.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writegmsh2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/interface/writeOpenFOAM15x.cpp)
+
+# LINALG
+SET (LINALG_SOURCES 
+     ${PROJECT_SOURCE_DIR}/libsrc/linalg/densemat.cpp 
+     ${PROJECT_SOURCE_DIR}/libsrc/linalg/polynomial.cpp 
+     ${PROJECT_SOURCE_DIR}/libsrc/linalg/bfgs.cpp 
+     ${PROJECT_SOURCE_DIR}/libsrc/linalg/linopt.cpp 
+     ${PROJECT_SOURCE_DIR}/libsrc/linalg/linsearch.cpp)
+
+FILE(GLOB LINALG_INCLUDES "${PROJECT_SOURCE_DIR}/libsrc/linalg/*.hpp")
+
+# MESHING
+SET(MESHING_SOURCES 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/adfront2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/adfront3.cpp
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/bisect.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/boundarylayer.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/clusters.cpp      
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/curvedelems.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/delaunay.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/delaunay2d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/geomsearch.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/global.cpp     
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/hprefinement.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/improve2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/improve2gen.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/improve3.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/localh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/meshclass.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/meshfunc.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/meshfunc2d.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/meshing2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/meshing3.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/meshtool.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/meshtype.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/msghandler.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/netrule2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/netrule3.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/parser2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/parser3.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/prism2rls.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/pyramid2rls.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/pyramidrls.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/quadrls.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/refine.cpp	
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/ruler2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/ruler3.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/secondorder.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/smoothing2.5.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/smoothing2.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/smoothing3.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/specials.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/tetrarls.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/topology.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/triarls.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/validate.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/zrefine.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/bcfunctions.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/parallelmesh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/paralleltop.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/paralleltop.hpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/meshing/basegeom.cpp)
+
+FILE(GLOB MESHING_INCLUDES "${PROJECT_SOURCE_DIR}/libsrc/meshing/*.hpp")
+
+# OCC
+SET(OCC_SOURCES 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/Partition_Inter2d.cxx 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/Partition_Inter3d.cxx 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/Partition_Loop.cxx 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/Partition_Loop2d.cxx 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/Partition_Loop3d.cxx 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/Partition_Spliter.cxx 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/occconstruction.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/occgenmesh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/occgeom.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/occ/occmeshsurf.cpp)
+
+SET(OCC_INCLUDES ${PROJECT_SOURCE_DIR}/libsrc/occ/occgeom.hpp ${PROJECT_SOURCE_DIR}/libsrc/occ/occmeshsurf.hpp)
+
+# STLGEOM
+SET(STLGEOM_SOURCES 
+    ${PROJECT_SOURCE_DIR}/libsrc/stlgeom/meshstlsurface.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/stlgeom/stlgeom.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/stlgeom/stlgeomchart.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/stlgeom/stlgeommesh.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/stlgeom/stlline.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/stlgeom/stltool.cpp 
+    ${PROJECT_SOURCE_DIR}/libsrc/stlgeom/stltopology.cpp)
+
+# NGLIB
+SET(NGLIB_SOURCES nglib.cpp)
+ADD_LIBRARY(nglib SHARED 
+            ${NGLIB_SOURCES}
+            ${CGS_SOURCES} 
+            ${GENERAL_SOURCES}
+            ${GPRIM_SOURCES}
+            ${GEOM2D_SOURCES}
+            ${INTERFACE_SOURCES} 
+            ${LINALG_SOURCES} 
+            ${MESHING_SOURCES} 
+            ${OCC_SOURCES}
+            ${STLGEOM_SOURCES})
+
+TARGET_LINK_LIBRARIES(nglib ${OCCLIBS} ${PLATFORM_LIBADD} ${ZLIB_LIBRARIES})
+INSTALL(TARGETS nglib DESTINATION ${NETGEN_INSTALL_LIBS}) 
+
+# Install headers
+INSTALL(FILES ${GENERAL_INCLUDES} 
+              ${INCLUDE_INCLUDES}
+              ${GPRIM_INCLUDES} 
+              ${LINALG_INCLUDES} 
+              ${MESHING_INCLUDES} 
+              ${OCC_INCLUDES} 
+              nglib.h 
+              DESTINATION ${NETGEN_INSTALL_HEADERS})
+
+
+# NG_VOL
+SET(NG_VOL_SOURCES ng_vol.cpp)
+ADD_EXECUTABLE(ng_vol ${NG_VOL_SOURCES})
+TARGET_LINK_LIBRARIES(ng_vol nglib)
+INSTALL(TARGETS ng_vol  DESTINATION ${NETGEN_INSTALL_BINS})
+
+# NG_STL
+SET(NG_STL_SOURCES ng_stl.cpp)
+ADD_EXECUTABLE(ng_stl ${NG_STL_SOURCES})
+TARGET_LINK_LIBRARIES(ng_stl nglib)
+INSTALL(TARGETS ng_stl  DESTINATION ${NETGEN_INSTALL_BINS})
--- netgen_ref/nglib/Makefile.am
+++ netgen/nglib/Makefile.am
@@ -14,6 +14,9 @@
 	$(top_builddir)/libsrc/stlgeom/libstl.la \
 	$(top_builddir)/libsrc/occ/libocc.la \
 	$(top_builddir)/libsrc/meshing/libmesh.la \
+	$(top_builddir)/libsrc/general/libgen.la \
+	$(top_builddir)/libsrc/gprim/libgprim.la \
+	$(top_builddir)/libsrc/linalg/libla.la
 	$(OCCLIBS) $(MPI_LIBS)
 
 libnglib_la_LDFLAGS = -avoid-version
--- netgen_ref/nglib/nglib.cpp
+++ netgen/nglib/nglib.cpp
@@ -1,1242 +1,1243 @@
-/**************************************************************************/
-/* File:   nglib.cpp                                                      */
-/* Author: Joachim Schoeberl                                              */
-/* Date:   7. May. 2000                                                   */
-/**************************************************************************/
-
-/*
-  
-  Interface to the netgen meshing kernel
-  
-*/
-#include <mystdlib.h>
-#include <myadt.hpp>
-
-#include <linalg.hpp>
-#include <csg.hpp>
-#include <stlgeom.hpp>
-#include <geometry2d.hpp>
-#include <meshing.hpp>
-#include <../visualization/soldata.hpp>
-
-#ifdef OCCGEOMETRY
-#include <occgeom.hpp>
-#endif
-
-#include <nginterface.h>
-
-
-namespace netgen {
-   extern void MeshFromSpline2D (SplineGeometry2d & geometry,
-                                 Mesh *& mesh, 
-                                 MeshingParameters & mp);
-}
-
-
-
-#ifdef PARALLEL
-#include <mpi.h>
-
-namespace netgen
-{
-  // int id = 0, ntasks = 1;
-  MPI_Comm mesh_comm;
-}
-#endif
-
-
-namespace netgen
-{
-  int id = 0, ntasks = 1;
-}
-
-
-
-/*
-// should not be needed (occ currently requires it)
-namespace netgen {
-#include "../libsrc/visualization/vispar.hpp"
-  VisualizationParameters vispar;
-  VisualizationParameters :: VisualizationParameters() { ; }
-}
-*/
-
-
-namespace nglib {
-#include "nglib.h"
-}
-
-using namespace netgen;
-
-// constants and types:
-
-namespace nglib
-{
-   // initialize, deconstruct Netgen library:
-   DLL_HEADER void Ng_Init ()
-   {
-      mycout = &cout;
-      myerr = &cerr;
-      // netgen::testout->SetOutStream (new ofstream ("test.out"));
-      testout = new ofstream ("test.out");
-   }
-
-
-
-
-   // Clean-up functions before ending usage of nglib
-   DLL_HEADER void Ng_Exit ()
-   {
-      ;
-   }
-
-
-
-
-   // Create a new netgen mesh object
-   DLL_HEADER Ng_Mesh * Ng_NewMesh ()
-   {
-      Mesh * mesh = new Mesh;  
-      mesh->AddFaceDescriptor (FaceDescriptor (1, 1, 0, 1));
-      return (Ng_Mesh*)(void*)mesh;
-   }
-
-
-
-
-   // Delete an existing netgen mesh object
-   DLL_HEADER void Ng_DeleteMesh (Ng_Mesh * mesh)
-   {
-      if(mesh != NULL)
-      {
-         // Delete the Mesh structures
-         ((Mesh*)mesh)->DeleteMesh();
-
-         // Now delete the Mesh class itself
-         delete (Mesh*)mesh;
-
-         // Set the Ng_Mesh pointer to NULL
-         mesh = NULL;
-      }
-   }
-
-
-
-
-   // Save a netgen mesh in the native VOL format 
-   DLL_HEADER void Ng_SaveMesh(Ng_Mesh * mesh, const char* filename)
-   {
-      ((Mesh*)mesh)->Save(filename);
-   }
-
-
-
-
-   // Load a netgen native VOL mesh from a given file
-   DLL_HEADER Ng_Mesh * Ng_LoadMesh(const char* filename)
-   {
-      Mesh * mesh = new Mesh;
-      mesh->Load(filename);
-      return ( (Ng_Mesh*)mesh );
-   }
-
-
-
-
-   // Merge another mesh file into the currently loaded one
-   DLL_HEADER Ng_Result Ng_MergeMesh( Ng_Mesh* mesh, const char* filename)
-   {
-      Ng_Result status = NG_OK;
-
-      ifstream infile(filename);
-      Mesh * m = (Mesh*)mesh;
-
-      if(!infile.good())
-      {
-         status = NG_FILE_NOT_FOUND;
-      }
-
-      if(!m)
-      {
-         status = NG_ERROR;
-      }
-
-      if(status == NG_OK)
-      {
-         const int num_pts = m->GetNP();
-         const int face_offset = m->GetNFD();
-
-         m->Merge(infile, face_offset);
-
-         if(m->GetNP() > num_pts)
-         {
-            status = NG_OK;
-         }
-         else
-         {
-            status = NG_ERROR;
-         }
-      }
-
-      return status;
-   }
-
-
-
-
-   // Merge another mesh file into the currently loaded one
-   DLL_HEADER Ng_Result Ng_MergeMesh( Ng_Mesh* mesh1, Ng_Mesh* mesh2)
-   {
-      return NG_ERROR;
-   }
-
-
-
-
-   // Manually add a point to an existing mesh object
-   DLL_HEADER void Ng_AddPoint (Ng_Mesh * mesh, double * x)
-   {
-      Mesh * m = (Mesh*)mesh;
-      m->AddPoint (Point3d (x[0], x[1], x[2]));
-   }
-
-
-
-
-   // Manually add a surface element of a given type to an existing mesh object
-   DLL_HEADER void Ng_AddSurfaceElement (Ng_Mesh * mesh, Ng_Surface_Element_Type et,
-                                         int * pi)
-   {
-      Mesh * m = (Mesh*)mesh;
-      Element2d el (3);
-      el.SetIndex (1);
-      el.PNum(1) = pi[0];
-      el.PNum(2) = pi[1];
-      el.PNum(3) = pi[2];
-      m->AddSurfaceElement (el);
-   }
-
-
-
-
-   // Manually add a volume element of a given type to an existing mesh object
-   DLL_HEADER void Ng_AddVolumeElement (Ng_Mesh * mesh, Ng_Volume_Element_Type et,
-                                        int * pi)
-   {
-      Mesh * m = (Mesh*)mesh;
-      Element el (4);
-      el.SetIndex (1);
-      el.PNum(1) = pi[0];
-      el.PNum(2) = pi[1];
-      el.PNum(3) = pi[2];
-      el.PNum(4) = pi[3];
-      m->AddVolumeElement (el);
-   }
-
-
-
-
-   // Obtain the number of points in the mesh
-   DLL_HEADER int Ng_GetNP (Ng_Mesh * mesh)
-   {
-      return ((Mesh*)mesh) -> GetNP();
-   }
-
-
-
-
-   // Obtain the number of surface elements in the mesh
-   DLL_HEADER int Ng_GetNSE (Ng_Mesh * mesh)
-   {
-      return ((Mesh*)mesh) -> GetNSE();
-   }
-
-
-
-
-   // Obtain the number of volume elements in the mesh
-   DLL_HEADER int Ng_GetNE (Ng_Mesh * mesh)
-   {
-      return ((Mesh*)mesh) -> GetNE();
-   }
-
-
-
-
-   //  Return point coordinates of a given point index in the mesh
-   DLL_HEADER void Ng_GetPoint (Ng_Mesh * mesh, int num, double * x)
-   {
-      const Point3d & p = ((Mesh*)mesh)->Point(num);
-      x[0] = p.X();
-      x[1] = p.Y();
-      x[2] = p.Z();
-   }
-
-
-
-
-   // Return the surface element at a given index "pi"
-   DLL_HEADER Ng_Surface_Element_Type 
-      Ng_GetSurfaceElement (Ng_Mesh * mesh, int num, int * pi)
-   {
-      const Element2d & el = ((Mesh*)mesh)->SurfaceElement(num);
-      for (int i = 1; i <= el.GetNP(); i++)
-         pi[i-1] = el.PNum(i);
-      Ng_Surface_Element_Type et;
-      switch (el.GetNP())
-      {
-      case 3: et = NG_TRIG; break;
-      case 4: et = NG_QUAD; break;
-      case 6: 
-         switch (el.GetNV())
-         {
-         case 3: et = NG_TRIG6; break;
-         case 4: et = NG_QUAD6; break;
-         default:
-            et = NG_TRIG6; break;
-         }
-         break;
-      case 8: et = NG_QUAD8; break;
-      default:
-         et = NG_TRIG; break; // for the compiler
-      }
-      return et;
-   }
-
-
-
-
-   // Return the volume element at a given index "pi"
-   DLL_HEADER Ng_Volume_Element_Type
-      Ng_GetVolumeElement (Ng_Mesh * mesh, int num, int * pi)
-   {
-      const Element & el = ((Mesh*)mesh)->VolumeElement(num);
-      for (int i = 1; i <= el.GetNP(); i++)
-         pi[i-1] = el.PNum(i);
-      Ng_Volume_Element_Type et;
-      switch (el.GetNP())
-      {
-      case 4: et = NG_TET; break;
-      case 5: et = NG_PYRAMID; break;
-      case 6: et = NG_PRISM; break;
-      case 10: et = NG_TET10; break;
-      default:
-         et = NG_TET; break; // for the compiler
-      }
-      return et;
-   }
-
-
-
-
-   // Set a global limit on the maximum mesh size allowed
-   DLL_HEADER void Ng_RestrictMeshSizeGlobal (Ng_Mesh * mesh, double h)
-   {
-      ((Mesh*)mesh) -> SetGlobalH (h);
-   }
-
-
-
-
-   // Set a local limit on the maximum mesh size allowed around the given point
-   DLL_HEADER void Ng_RestrictMeshSizePoint (Ng_Mesh * mesh, double * p, double h)
-   {
-      ((Mesh*)mesh) -> RestrictLocalH (Point3d (p[0], p[1], p[2]), h);
-   }
-
-
-
-
-   // Set a local limit on the maximum mesh size allowed within a given box region
-   DLL_HEADER void Ng_RestrictMeshSizeBox (Ng_Mesh * mesh, double * pmin, double * pmax, double h)
-   {
-      for (double x = pmin[0]; x < pmax[0]; x += h)
-         for (double y = pmin[1]; y < pmax[1]; y += h)
-            for (double z = pmin[2]; z < pmax[2]; z += h)
-               ((Mesh*)mesh) -> RestrictLocalH (Point3d (x, y, z), h);
-   }
-
-
-
-
-   // Generates volume mesh from an existing surface mesh
-   DLL_HEADER Ng_Result Ng_GenerateVolumeMesh (Ng_Mesh * mesh, Ng_Meshing_Parameters * mp)
-   {
-      Mesh * m = (Mesh*)mesh;
-
-      // Philippose - 30/08/2009
-      // Do not locally re-define "mparam" here... "mparam" is a global 
-      // object 
-      //MeshingParameters mparam;
-      mp->Transfer_Parameters();
-
-      m->CalcLocalH(mparam.grading);
-
-      MeshVolume (mparam, *m);
-      RemoveIllegalElements (*m);
-      OptimizeVolume (mparam, *m);
-
-      return NG_OK;
-   }
-
-
-
-
-   /* ------------------ 2D Meshing Functions ------------------------- */
-   DLL_HEADER void Ng_AddPoint_2D (Ng_Mesh * mesh, double * x)
-   {
-      Mesh * m = (Mesh*)mesh;
-
-      m->AddPoint (Point3d (x[0], x[1], 0));
-   }
-
-
-
-
-   DLL_HEADER void Ng_AddBoundarySeg_2D (Ng_Mesh * mesh, int pi1, int pi2)
-   {
-      Mesh * m = (Mesh*)mesh;
-
-      Segment seg;
-      seg[0] = pi1;
-      seg[1] = pi2;
-      m->AddSegment (seg);
-   }
-
-
-
-
-   DLL_HEADER int Ng_GetNP_2D (Ng_Mesh * mesh)
-   {
-      Mesh * m = (Mesh*)mesh;
-      return m->GetNP();
-   }
-
-
-
-
-   DLL_HEADER int Ng_GetNE_2D (Ng_Mesh * mesh)
-   {
-      Mesh * m = (Mesh*)mesh;
-      return m->GetNSE();
-   }
-
-
-
-
-   DLL_HEADER int Ng_GetNSeg_2D (Ng_Mesh * mesh)
-   {
-      Mesh * m = (Mesh*)mesh;
-      return m->GetNSeg();
-   }
-
-
-
-
-   DLL_HEADER void Ng_GetPoint_2D (Ng_Mesh * mesh, int num, double * x)
-   {
-      Mesh * m = (Mesh*)mesh;
-
-      Point<3> & p = m->Point(num);
-      x[0] = p(0);
-      x[1] = p(1);
-   }
-
-
-
-
-   DLL_HEADER Ng_Surface_Element_Type
-      Ng_GetElement_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum)
-   {
-      const Element2d & el = ((Mesh*)mesh)->SurfaceElement(num);
-      for (int i = 1; i <= el.GetNP(); i++)
-         pi[i-1] = el.PNum(i);
-
-      Ng_Surface_Element_Type et;
-      switch (el.GetNP())
-      {
-      case 3: et = NG_TRIG; break;
-      case 4: et = NG_QUAD; break;
-      case 6: 
-         switch (el.GetNV())
-         {
-         case 3: et = NG_TRIG6; break;
-         case 4: et = NG_QUAD6; break;
-         default:
-            et = NG_TRIG6; break;
-         }
-         break;
-      case 8: et = NG_QUAD8; break;
-      default:
-         et = NG_TRIG; break; // for the compiler
-      }
-
-      if (matnum)
-         *matnum = el.GetIndex();
-
-      return et;
-   }
-
-
-
-
-   DLL_HEADER void Ng_GetSegment_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum)
-   {
-      const Segment & seg = ((Mesh*)mesh)->LineSegment(num);
-      pi[0] = seg[0];
-      pi[1] = seg[1];
-
-      if (matnum)
-         *matnum = seg.edgenr;
-   }
-
-
-
-
-   DLL_HEADER Ng_Geometry_2D * Ng_LoadGeometry_2D (const char * filename)
-   {
-      SplineGeometry2d * geom = new SplineGeometry2d();
-      geom -> Load (filename);
-      return (Ng_Geometry_2D *)geom;
-   }
-
-
-
-
-   DLL_HEADER Ng_Result Ng_GenerateMesh_2D (Ng_Geometry_2D * geom,
-                                            Ng_Mesh ** mesh,
-                                            Ng_Meshing_Parameters * mp)
-   {
-      // use global variable mparam
-      //  MeshingParameters mparam;  
-      mp->Transfer_Parameters();
-
-      Mesh * m;
-      MeshFromSpline2D (*(SplineGeometry2d*)geom, m, mparam);
-
-      cout << m->GetNSE() << " elements, " << m->GetNP() << " points" << endl;
-
-      *mesh = (Ng_Mesh*)m;
-      return NG_OK;
-   }
-
-
-
-
-   DLL_HEADER void Ng_HP_Refinement (Ng_Geometry_2D * geom,
-      Ng_Mesh * mesh,
-      int levels)
-   {
-      Refinement2d ref(*(SplineGeometry2d*)geom);
-      HPRefinement (*(Mesh*)mesh, &ref, levels);
-   }
-
-
-
-
-   DLL_HEADER void Ng_HP_Refinement (Ng_Geometry_2D * geom,
-      Ng_Mesh * mesh,
-      int levels, double parameter)
-   {
-      Refinement2d ref(*(SplineGeometry2d*)geom);
-      HPRefinement (*(Mesh*)mesh, &ref, levels, parameter);
-   }
-
-
-
-
-   Array<STLReadTriangle> readtrias; //only before initstlgeometry
-   Array<Point<3> > readedges; //only before init stlgeometry
-
-   // loads geometry from STL file
-   DLL_HEADER Ng_STL_Geometry * Ng_STL_LoadGeometry (const char * filename, int binary)
-   {
-      int i;
-      STLGeometry geom;
-      STLGeometry* geo;
-      ifstream ist(filename);
-
-      if (binary)
-      {
-         geo = geom.LoadBinary(ist);
-      }
-      else
-      {
-         geo = geom.Load(ist);
-      }
-
-      readtrias.SetSize(0);
-      readedges.SetSize(0);
-
-      Point3d p;
-      Vec3d normal;
-      double p1[3];
-      double p2[3];
-      double p3[3];
-      double n[3];
-
-      Ng_STL_Geometry * geo2 = Ng_STL_NewGeometry();
-
-      for (i = 1; i <= geo->GetNT(); i++)
-      {
-         const STLTriangle& t = geo->GetTriangle(i);
-         p = geo->GetPoint(t.PNum(1));
-         p1[0] = p.X(); p1[1] = p.Y(); p1[2] = p.Z(); 
-         p = geo->GetPoint(t.PNum(2));
-         p2[0] = p.X(); p2[1] = p.Y(); p2[2] = p.Z(); 
-         p = geo->GetPoint(t.PNum(3));
-         p3[0] = p.X(); p3[1] = p.Y(); p3[2] = p.Z();
-         normal = t.Normal();
-         n[0] = normal.X(); n[1] = normal.Y(); n[2] = normal.Z();
-
-         Ng_STL_AddTriangle(geo2, p1, p2, p3, n);
-      }
-
-      return geo2;
-   }
-
-
-
-
-   // generate new STL Geometry
-   DLL_HEADER Ng_STL_Geometry * Ng_STL_NewGeometry ()
-   {
-      return (Ng_STL_Geometry*)(void*)new STLGeometry;
-   } 
-
-
-
-
-   // after adding triangles (and edges) initialize
-   DLL_HEADER Ng_Result Ng_STL_InitSTLGeometry (Ng_STL_Geometry * geom)
-   {
-      STLGeometry* geo = (STLGeometry*)geom;
-      geo->InitSTLGeometry(readtrias);
-      readtrias.SetSize(0);
-
-      if (readedges.Size() != 0)
-      {
-         /*
-         for (int i = 1; i <= readedges.Size(); i+=2)
-         {
-         cout << "e(" << readedges.Get(i) << "," << readedges.Get(i+1) << ")" << endl;
-         }
-         */
-         geo->AddEdges(readedges);
-      }
-
-      if (geo->GetStatus() == STLTopology::STL_GOOD || geo->GetStatus() == STLTopology::STL_WARNING) return NG_OK;
-      return NG_SURFACE_INPUT_ERROR;
-   }
-
-
-
-
-   // automatically generates edges:
-   DLL_HEADER Ng_Result Ng_STL_MakeEdges (Ng_STL_Geometry * geom,
-                                          Ng_Mesh* mesh,
-                                          Ng_Meshing_Parameters * mp)
-   {
-      STLGeometry* stlgeometry = (STLGeometry*)geom;
-      Mesh* me = (Mesh*)mesh;
-
-      // Philippose - 27/07/2009
-      // Do not locally re-define "mparam" here... "mparam" is a global 
-      // object 
-      //MeshingParameters mparam;
-      mp->Transfer_Parameters();
-
-      me -> SetGlobalH (mparam.maxh);
-      me -> SetLocalH (stlgeometry->GetBoundingBox().PMin() - Vec3d(10, 10, 10),
-                       stlgeometry->GetBoundingBox().PMax() + Vec3d(10, 10, 10),
-                       0.3);
-
-      me -> LoadLocalMeshSize (mp->meshsize_filename);
-      /*
-      if (mp->meshsize_filename)
-      {
-      ifstream infile (mp->meshsize_filename);
-      if (!infile.good()) return NG_FILE_NOT_FOUND;
-      me -> LoadLocalMeshSize (infile);
-      }
-      */
-
-      STLMeshing (*stlgeometry, *me);
-
-      stlgeometry->edgesfound = 1;
-      stlgeometry->surfacemeshed = 0;
-      stlgeometry->surfaceoptimized = 0;
-      stlgeometry->volumemeshed = 0;
-
-      return NG_OK;
-   }
-
-
-
-
-   // generates mesh, empty mesh be already created.
-   DLL_HEADER Ng_Result Ng_STL_GenerateSurfaceMesh (Ng_STL_Geometry * geom,
-                                                    Ng_Mesh* mesh,
-                                                    Ng_Meshing_Parameters * mp)
-   {
-      STLGeometry* stlgeometry = (STLGeometry*)geom;
-      Mesh* me = (Mesh*)mesh;
-
-      // Philippose - 27/07/2009
-      // Do not locally re-define "mparam" here... "mparam" is a global 
-      // object
-      //MeshingParameters mparam;
-      mp->Transfer_Parameters();
-
-
-      /*
-      me -> SetGlobalH (mparam.maxh);
-      me -> SetLocalH (stlgeometry->GetBoundingBox().PMin() - Vec3d(10, 10, 10),
-      stlgeometry->GetBoundingBox().PMax() + Vec3d(10, 10, 10),
-      0.3);
-      */
-      /*
-      STLMeshing (*stlgeometry, *me);
-
-      stlgeometry->edgesfound = 1;
-      stlgeometry->surfacemeshed = 0;
-      stlgeometry->surfaceoptimized = 0;
-      stlgeometry->volumemeshed = 0;
-      */  
-      int retval = STLSurfaceMeshing (*stlgeometry, *me);
-      if (retval == MESHING3_OK)
-      {
-         (*mycout) << "Success !!!!" << endl;
-         stlgeometry->surfacemeshed = 1;
-         stlgeometry->surfaceoptimized = 0;
-         stlgeometry->volumemeshed = 0;
-      } 
-      else if (retval == MESHING3_OUTERSTEPSEXCEEDED)
-      {
-         (*mycout) << "ERROR: Give up because of too many trials. Meshing aborted!" << endl;
-      }
-      else if (retval == MESHING3_TERMINATE)
-      {
-         (*mycout) << "Meshing Stopped!" << endl;
-      }
-      else
-      {
-         (*mycout) << "ERROR: Surface meshing not successful. Meshing aborted!" << endl;
-      }
-
-
-      STLSurfaceOptimization (*stlgeometry, *me, mparam);
-
-      return NG_OK;
-   }
-
-
-
-
-   // fills STL Geometry
-   // positive orientation
-   // normal vector may be null-pointer
-   DLL_HEADER void Ng_STL_AddTriangle (Ng_STL_Geometry * geom, 
-                                       double * p1, double * p2, double * p3, 
-                                       double * nv)
-   {
-      Point<3> apts[3];
-      apts[0] = Point<3>(p1[0],p1[1],p1[2]);
-      apts[1] = Point<3>(p2[0],p2[1],p2[2]);
-      apts[2] = Point<3>(p3[0],p3[1],p3[2]);
-
-      Vec<3> n;
-      if (!nv)
-         n = Cross (apts[0]-apts[1], apts[0]-apts[2]);
-      else
-         n = Vec<3>(nv[0],nv[1],nv[2]);
-
-      readtrias.Append(STLReadTriangle(apts,n));
-   }
-
-   // add (optional) edges:
-   DLL_HEADER void Ng_STL_AddEdge (Ng_STL_Geometry * geom, 
-      double * p1, double * p2)
-   {
-      readedges.Append(Point3d(p1[0],p1[1],p1[2]));
-      readedges.Append(Point3d(p2[0],p2[1],p2[2]));
-   }
-
-
-
-
-#ifdef OCCGEOMETRY
-   // --------------------- OCC Geometry / Meshing Utility Functions -------------------
-   // Create new OCC Geometry Object
-   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_NewGeometry ()
-   {
-      return (Ng_OCC_Geometry*)(void*)new OCCGeometry;
-   } 
-
-
-
-
-   // Delete the OCC Geometry Object
-   DLL_HEADER Ng_Result Ng_OCC_DeleteGeometry(Ng_OCC_Geometry * geom)
-   {
-      if (geom != NULL)
-      {
-         delete (OCCGeometry*)geom;
-         geom = NULL;
-         return NG_OK;
-      }
-      
-      return NG_ERROR;
-   }
-
-
-
-   
-   // Loads geometry from STEP File
-   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_STEP (const char * filename)
-   {
-      // Call the STEP File Load function. Note.. the geometry class 
-      // is created and instantiated within the load function
-      OCCGeometry * occgeo = LoadOCC_STEP(filename);
-
-      return ((Ng_OCC_Geometry *)occgeo);
-   }
-
-
-
-   
-   // Loads geometry from IGES File
-   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_IGES (const char * filename)
-   {
-      // Call the IGES File Load function. Note.. the geometry class 
-      // is created and instantiated within the load function
-      OCCGeometry * occgeo = LoadOCC_IGES(filename);
-
-      return ((Ng_OCC_Geometry *)occgeo);
-   }
-
-
-
-   
-   // Loads geometry from BREP File
-   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_BREP (const char * filename)
-   {
-      // Call the BREP File Load function. Note.. the geometry class 
-      // is created and instantiated within the load function
-      OCCGeometry * occgeo = LoadOCC_BREP(filename);
-
-      return ((Ng_OCC_Geometry *)occgeo);
-   }
-
-
-
-
-   // Locally limit the size of the mesh to be generated at various points 
-   // based on the topology of the geometry
-   DLL_HEADER Ng_Result Ng_OCC_SetLocalMeshSize (Ng_OCC_Geometry * geom,
-                                                 Ng_Mesh * mesh,
-                                                 Ng_Meshing_Parameters * mp)
-   {
-      OCCGeometry * occgeom = (OCCGeometry*)geom;
-      Mesh * me = (Mesh*)mesh;
-
-      me->geomtype = Mesh::GEOM_OCC;
-
-      mp->Transfer_Parameters();
-      
-      occparam.resthcloseedgeenable = mp->closeedgeenable;
-      occparam.resthcloseedgefac = mp->closeedgefact;
-
-      // Delete the mesh structures in order to start with a clean 
-      // slate
-      me->DeleteMesh();
-
-      OCCSetLocalMeshSize(*occgeom, *me);
-
-      return(NG_OK);
-   }
-
-
-
-   
-   // Mesh the edges and add Face descriptors to prepare for surface meshing
-   DLL_HEADER Ng_Result Ng_OCC_GenerateEdgeMesh (Ng_OCC_Geometry * geom,
-                                                 Ng_Mesh * mesh,
-                                                 Ng_Meshing_Parameters * mp)
-   {
-      OCCGeometry * occgeom = (OCCGeometry*)geom;
-      Mesh * me = (Mesh*)mesh;
-
-      mp->Transfer_Parameters();
-
-      OCCFindEdges(*occgeom, *me);
-
-      if((me->GetNP()) && (me->GetNFD()))
-      {
-         return NG_OK;
-      }
-      else
-      {
-         return NG_ERROR;
-      }
-   }
-
-
-
-   
-   // Mesh the edges and add Face descriptors to prepare for surface meshing
-   DLL_HEADER Ng_Result Ng_OCC_GenerateSurfaceMesh (Ng_OCC_Geometry * geom,
-                                                    Ng_Mesh * mesh,
-                                                    Ng_Meshing_Parameters * mp)
-   {
-      int numpoints = 0;
-
-      OCCGeometry * occgeom = (OCCGeometry*)geom;
-      Mesh * me = (Mesh*)mesh;
-
-      // Set the internal meshing parameters structure from the nglib meshing 
-      // parameters structure
-      mp->Transfer_Parameters();
-
-
-      // Only go into surface meshing if the face descriptors have already been added
-      if(!me->GetNFD())
-         return NG_ERROR;
-
-      numpoints = me->GetNP();
-
-      // Initially set up only for surface meshing without any optimisation
-      int perfstepsend = MESHCONST_MESHSURFACE;
-
-      // Check and if required, enable surface mesh optimisation step
-      if(mp->optsurfmeshenable)
-      {
-         perfstepsend = MESHCONST_OPTSURFACE;
-      }
-
-      OCCMeshSurface(*occgeom, *me, perfstepsend);
-
-      me->CalcSurfacesOfNode();
-      
-      if(me->GetNP() <= numpoints)
-         return NG_ERROR;
-
-      if(me->GetNSE() <= 0)
-         return NG_ERROR;
-
-      return NG_OK;
-   }
-
-
-
-
-   // Extract the face map from the OCC geometry
-   // The face map basically gives an index to each face in the geometry, 
-   // which can be used to access a specific face
-   DLL_HEADER Ng_Result Ng_OCC_GetFMap(Ng_OCC_Geometry * geom, 
-                                       Ng_OCC_TopTools_IndexedMapOfShape * FMap)
-   {
-      OCCGeometry* occgeom = (OCCGeometry*)geom;
-      TopTools_IndexedMapOfShape *occfmap = (TopTools_IndexedMapOfShape *)FMap;
-
-      // Copy the face map from the geometry to the given variable
-      occfmap->Assign(occgeom->fmap);
-
-      if(occfmap->Extent())
-      {
-         return NG_OK;
-      }
-      else
-      {
-         return NG_ERROR;
-      }
-   }
-
-   // ------------------ End - OCC Geometry / Meshing Utility Functions ----------------
-#endif
-
-
-
-
-   // ------------------ Begin - Meshing Parameters related functions ------------------
-   // Constructor for the local nglib meshing parameters class
-   DLL_HEADER Ng_Meshing_Parameters :: Ng_Meshing_Parameters()
-   {
-      uselocalh = 1;
-
-      maxh = 1000;
-      minh = 0.0;
-
-      fineness = 0.5;
-      grading = 0.3;
-
-      elementsperedge = 2.0;
-      elementspercurve = 2.0;
-
-      closeedgeenable = 0;
-      closeedgefact = 2.0;
-
-	  minedgelenenable = 0;
-	  minedgelen = 1e-4;
-
-      second_order = 0;
-      quad_dominated = 0;
-
-      meshsize_filename = 0;
-
-      optsurfmeshenable = 1;
-      optvolmeshenable = 1;
-
-      optsteps_2d = 3;
-      optsteps_3d = 3;
-
-      invert_tets = 0;
-      invert_trigs = 0;
-
-      check_overlap = 1;
-      check_overlapping_boundary = 1;
-   }
-
-
-
-
-   // Reset the local meshing parameters to the default values
-   DLL_HEADER void Ng_Meshing_Parameters :: Reset_Parameters()
-   {
-      uselocalh = 1;
-
-      maxh = 1000;
-      minh = 0;
-
-      fineness = 0.5;
-      grading = 0.3;
-
-      elementsperedge = 2.0;
-      elementspercurve = 2.0;
-
-      closeedgeenable = 0;
-      closeedgefact = 2.0;
-
-  	  minedgelenenable = 0;
-	  minedgelen = 1e-4;
-
-      second_order = 0;
-      quad_dominated = 0;
-
-      meshsize_filename = 0;
-
-      optsurfmeshenable = 1;
-      optvolmeshenable = 1;
-
-      optsteps_2d = 3;
-      optsteps_3d = 3;
-
-      invert_tets = 0;
-      invert_trigs = 0;
-
-      check_overlap = 1;
-      check_overlapping_boundary = 1;
-   }
-
-
-
-
-   // 
-   DLL_HEADER void Ng_Meshing_Parameters :: Transfer_Parameters()
-   {
-      mparam.uselocalh = uselocalh;
-      
-      mparam.maxh = maxh;
-      mparam.minh = minh;
-
-      mparam.grading = grading;
-      mparam.curvaturesafety = elementspercurve;
-      mparam.segmentsperedge = elementsperedge;
-
-      mparam.secondorder = second_order;
-      mparam.quad = quad_dominated;
-
-      mparam.meshsizefilename = meshsize_filename;
-
-      mparam.optsteps2d = optsteps_2d;
-      mparam.optsteps3d = optsteps_3d;
-
-      mparam.inverttets = invert_tets;
-      mparam.inverttrigs = invert_trigs;
-
-      mparam.checkoverlap = check_overlap;
-      mparam.checkoverlappingboundary = check_overlapping_boundary;
-   }
-   // ------------------ End - Meshing Parameters related functions --------------------
-
-
-
-
-   // ------------------ Begin - Second Order Mesh generation functions ----------------
-   DLL_HEADER void Ng_Generate_SecondOrder(Ng_Mesh * mesh)
-   {
-      Refinement ref;
-      ref.MakeSecondOrder(*(Mesh*) mesh);
-   }
-
-
-
-
-   DLL_HEADER void Ng_2D_Generate_SecondOrder(Ng_Geometry_2D * geom,
-					  Ng_Mesh * mesh)
-   {
-      ( (SplineGeometry2d*)geom ) -> GetRefinement().MakeSecondOrder( * (Mesh*) mesh );
-   }
-
-
-
-
-   DLL_HEADER void Ng_STL_Generate_SecondOrder(Ng_STL_Geometry * geom,
-					   Ng_Mesh * mesh)
-   {
-      ((STLGeometry*)geom)->GetRefinement().MakeSecondOrder(*(Mesh*) mesh);
-   }
-
-
-
-
-   DLL_HEADER void Ng_CSG_Generate_SecondOrder (Ng_CSG_Geometry * geom,
-					   Ng_Mesh * mesh)
-   {
-      ((CSGeometry*)geom)->GetRefinement().MakeSecondOrder(*(Mesh*) mesh);
-   }
-
-
-
-
-#ifdef OCCGEOMETRY
-   DLL_HEADER void Ng_OCC_Generate_SecondOrder (Ng_OCC_Geometry * geom,
-                  Ng_Mesh * mesh)
-   {
-      ((OCCGeometry*)geom )->GetRefinement().MakeSecondOrder(*(Mesh*) mesh);
-   }
-#endif
-   // ------------------ End - Second Order Mesh generation functions ------------------
-
-
-
-
-   // ------------------ Begin - Uniform Mesh Refinement functions ---------------------
-   DLL_HEADER void Ng_Uniform_Refinement (Ng_Mesh * mesh)
-   {
-      Refinement ref;
-      ref.Refine ( * (Mesh*) mesh );
-   }
-
-
-
-
-   DLL_HEADER void Ng_2D_Uniform_Refinement (Ng_Geometry_2D * geom,
-      Ng_Mesh * mesh)
-   {
-      ( (SplineGeometry2d*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
-   }
-
-
-
-
-   DLL_HEADER void Ng_STL_Uniform_Refinement (Ng_STL_Geometry * geom,
-      Ng_Mesh * mesh)
-   {
-      ( (STLGeometry*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
-   }
-
-
-
-
-   DLL_HEADER void Ng_CSG_Uniform_Refinement (Ng_CSG_Geometry * geom,
-      Ng_Mesh * mesh)
-   {
-      ( (CSGeometry*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
-   }
-
-
-
-
-#ifdef OCCGEOMETRY
-   DLL_HEADER void Ng_OCC_Uniform_Refinement (Ng_OCC_Geometry * geom,
-      Ng_Mesh * mesh)
-   {
-      ( (OCCGeometry*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
-   }
-#endif
-   // ------------------ End - Uniform Mesh Refinement functions -----------------------
-} // End of namespace nglib
-
-
-
-
-// compatibility functions:
-namespace netgen 
-{
-   char geomfilename[255];
-
-   DLL_HEADER void MyError (const char * ch)
-   {
-      cerr << ch;
-   }
-
-
-
-
-   //Destination for messages, errors, ...
-   DLL_HEADER void Ng_PrintDest(const char * s)
-   {
-#ifdef PARALLEL
-     int id = 0;
-     MPI_Comm_rank(MPI_COMM_WORLD, &id);
-     if (id != 0) return;
-#endif
-     (*mycout) << s << flush;
-   }
-
-
-
-
-   DLL_HEADER double GetTime ()
-   {
-      return 0;
-   }
-
-
-
-
-   void ResetTime ()
-   {
-      ;
-   }
-
-
-
-
-   void MyBeep (int i)
-   {
-      ;
-   }
-
-
-
-
-   void Render()
-   {
-      ; 
-   }
-} // End of namespace netgen
-
-
-
-
-void Ng_Redraw () { ; }
-void Ng_ClearSolutionData () { ; }
-void Ng_SetSolutionData (Ng_SolutionData * soldata) 
-{ 
-  delete soldata->solclass;
-}
-void Ng_InitSolutionData (Ng_SolutionData * soldata) { ; }
-
-
+/**************************************************************************/
+/* File:   nglib.cpp                                                      */
+/* Author: Joachim Schoeberl                                              */
+/* Date:   7. May. 2000                                                   */
+/**************************************************************************/
+
+/*
+  
+  Interface to the netgen meshing kernel
+  
+*/
+#include <mystdlib.h>
+#include <myadt.hpp>
+
+#include <linalg.hpp>
+#include <csg.hpp>
+#include <stlgeom.hpp>
+#include <geometry2d.hpp>
+#include <meshing.hpp>
+#include <../visualization/soldata.hpp>
+
+#ifdef OCCGEOMETRY
+#include <occgeom.hpp>
+#endif
+
+#include <nginterface.h>
+
+
+namespace netgen {
+   extern void MeshFromSpline2D (SplineGeometry2d & geometry,
+                                 Mesh *& mesh, 
+                                 MeshingParameters & mp);
+}
+
+
+
+#ifdef PARALLEL
+#include <mpi.h>
+
+namespace netgen
+{
+  // int id = 0, ntasks = 1;
+  MPI_Comm mesh_comm;
+}
+#endif
+
+
+namespace netgen
+{
+  int id = 0, ntasks = 1;
+}
+
+
+
+/*
+// should not be needed (occ currently requires it)
+namespace netgen {
+#include "../libsrc/visualization/vispar.hpp"
+  VisualizationParameters vispar;
+  VisualizationParameters :: VisualizationParameters() { ; }
+}
+*/
+
+
+namespace nglib {
+#include "nglib.h"
+}
+
+using namespace netgen;
+using namespace std;
+// constants and types:
+
+namespace nglib
+{
+   // initialize, deconstruct Netgen library:
+   DLL_HEADER void Ng_Init ()
+   {
+      mycout = &std::cout;
+      myerr = &cerr;
+      // netgen::testout->SetOutStream (new ofstream ("test.out"));
+      testout = new ofstream ("test.out");
+   }
+
+
+
+
+   // Clean-up functions before ending usage of nglib
+   DLL_HEADER void Ng_Exit ()
+   {
+       delete testout;
+       testout = 0;
+   }
+
+
+
+
+   // Create a new netgen mesh object
+   DLL_HEADER Ng_Mesh * Ng_NewMesh ()
+   {
+      Mesh * mesh = new Mesh;  
+      mesh->AddFaceDescriptor (FaceDescriptor (1, 1, 0, 1));
+      return (Ng_Mesh*)(void*)mesh;
+   }
+
+
+
+
+   // Delete an existing netgen mesh object
+   DLL_HEADER void Ng_DeleteMesh (Ng_Mesh * mesh)
+   {
+      if(mesh != NULL)
+      {
+         // Delete the Mesh structures
+         ((Mesh*)mesh)->DeleteMesh();
+
+         // Now delete the Mesh class itself
+         delete (Mesh*)mesh;
+
+         // Set the Ng_Mesh pointer to NULL
+         mesh = NULL;
+      }
+   }
+
+
+
+
+   // Save a netgen mesh in the native VOL format 
+   DLL_HEADER void Ng_SaveMesh(Ng_Mesh * mesh, const char* filename)
+   {
+      ((Mesh*)mesh)->Save(filename);
+   }
+
+
+
+
+   // Load a netgen native VOL mesh from a given file
+   DLL_HEADER Ng_Mesh * Ng_LoadMesh(const char* filename)
+   {
+      Mesh * mesh = new Mesh;
+      mesh->Load(filename);
+      return ( (Ng_Mesh*)mesh );
+   }
+
+
+
+
+   // Merge another mesh file into the currently loaded one
+   DLL_HEADER Ng_Result Ng_MergeMesh( Ng_Mesh* mesh, const char* filename)
+   {
+      Ng_Result status = NG_OK;
+
+      ifstream infile(filename);
+      Mesh * m = (Mesh*)mesh;
+
+      if(!infile.good())
+      {
+         status = NG_FILE_NOT_FOUND;
+      }
+
+      if(!m)
+      {
+         status = NG_ERROR;
+      }
+
+      if(status == NG_OK)
+      {
+         const int num_pts = m->GetNP();
+         const int face_offset = m->GetNFD();
+
+         m->Merge(infile, face_offset);
+
+         if(m->GetNP() > num_pts)
+         {
+            status = NG_OK;
+         }
+         else
+         {
+            status = NG_ERROR;
+         }
+      }
+
+      return status;
+   }
+
+
+
+
+   // Merge another mesh file into the currently loaded one
+   DLL_HEADER Ng_Result Ng_MergeMesh( Ng_Mesh* mesh1, Ng_Mesh* mesh2)
+   {
+      return NG_ERROR;
+   }
+
+
+
+
+   // Manually add a point to an existing mesh object
+   DLL_HEADER void Ng_AddPoint (Ng_Mesh * mesh, double * x)
+   {
+      Mesh * m = (Mesh*)mesh;
+      m->AddPoint (Point3d (x[0], x[1], x[2]));
+   }
+
+
+
+
+   // Manually add a surface element of a given type to an existing mesh object
+   DLL_HEADER void Ng_AddSurfaceElement (Ng_Mesh * mesh, Ng_Surface_Element_Type et,
+                                         int * pi)
+   {
+      Mesh * m = (Mesh*)mesh;
+      Element2d el (3);
+      el.SetIndex (1);
+      el.PNum(1) = pi[0];
+      el.PNum(2) = pi[1];
+      el.PNum(3) = pi[2];
+      m->AddSurfaceElement (el);
+   }
+
+
+
+
+   // Manually add a volume element of a given type to an existing mesh object
+   DLL_HEADER void Ng_AddVolumeElement (Ng_Mesh * mesh, Ng_Volume_Element_Type et,
+                                        int * pi)
+   {
+      Mesh * m = (Mesh*)mesh;
+      Element el (4);
+      el.SetIndex (1);
+      el.PNum(1) = pi[0];
+      el.PNum(2) = pi[1];
+      el.PNum(3) = pi[2];
+      el.PNum(4) = pi[3];
+      m->AddVolumeElement (el);
+   }
+
+
+
+
+   // Obtain the number of points in the mesh
+   DLL_HEADER int Ng_GetNP (Ng_Mesh * mesh)
+   {
+      return ((Mesh*)mesh) -> GetNP();
+   }
+
+
+
+
+   // Obtain the number of surface elements in the mesh
+   DLL_HEADER int Ng_GetNSE (Ng_Mesh * mesh)
+   {
+      return ((Mesh*)mesh) -> GetNSE();
+   }
+
+
+
+
+   // Obtain the number of volume elements in the mesh
+   DLL_HEADER int Ng_GetNE (Ng_Mesh * mesh)
+   {
+      return ((Mesh*)mesh) -> GetNE();
+   }
+
+
+
+
+   //  Return point coordinates of a given point index in the mesh
+   DLL_HEADER void Ng_GetPoint (Ng_Mesh * mesh, int num, double * x)
+   {
+      const Point3d & p = ((Mesh*)mesh)->Point(num);
+      x[0] = p.X();
+      x[1] = p.Y();
+      x[2] = p.Z();
+   }
+
+
+
+
+   // Return the surface element at a given index "pi"
+   DLL_HEADER Ng_Surface_Element_Type 
+      Ng_GetSurfaceElement (Ng_Mesh * mesh, int num, int * pi)
+   {
+      const Element2d & el = ((Mesh*)mesh)->SurfaceElement(num);
+      for (int i = 1; i <= el.GetNP(); i++)
+         pi[i-1] = el.PNum(i);
+      Ng_Surface_Element_Type et;
+      switch (el.GetNP())
+      {
+      case 3: et = NG_TRIG; break;
+      case 4: et = NG_QUAD; break;
+      case 6: 
+         switch (el.GetNV())
+         {
+         case 3: et = NG_TRIG6; break;
+         case 4: et = NG_QUAD6; break;
+         default:
+            et = NG_TRIG6; break;
+         }
+         break;
+      case 8: et = NG_QUAD8; break;
+      default:
+         et = NG_TRIG; break; // for the compiler
+      }
+      return et;
+   }
+
+
+
+
+   // Return the volume element at a given index "pi"
+   DLL_HEADER Ng_Volume_Element_Type
+      Ng_GetVolumeElement (Ng_Mesh * mesh, int num, int * pi)
+   {
+      const Element & el = ((Mesh*)mesh)->VolumeElement(num);
+      for (int i = 1; i <= el.GetNP(); i++)
+         pi[i-1] = el.PNum(i);
+      Ng_Volume_Element_Type et;
+      switch (el.GetNP())
+      {
+      case 4: et = NG_TET; break;
+      case 5: et = NG_PYRAMID; break;
+      case 6: et = NG_PRISM; break;
+      case 10: et = NG_TET10; break;
+      default:
+         et = NG_TET; break; // for the compiler
+      }
+      return et;
+   }
+
+
+
+
+   // Set a global limit on the maximum mesh size allowed
+   DLL_HEADER void Ng_RestrictMeshSizeGlobal (Ng_Mesh * mesh, double h)
+   {
+      ((Mesh*)mesh) -> SetGlobalH (h);
+   }
+
+
+
+
+   // Set a local limit on the maximum mesh size allowed around the given point
+   DLL_HEADER void Ng_RestrictMeshSizePoint (Ng_Mesh * mesh, double * p, double h)
+   {
+      ((Mesh*)mesh) -> RestrictLocalH (Point3d (p[0], p[1], p[2]), h);
+   }
+
+
+
+
+   // Set a local limit on the maximum mesh size allowed within a given box region
+   DLL_HEADER void Ng_RestrictMeshSizeBox (Ng_Mesh * mesh, double * pmin, double * pmax, double h)
+   {
+      for (double x = pmin[0]; x < pmax[0]; x += h)
+         for (double y = pmin[1]; y < pmax[1]; y += h)
+            for (double z = pmin[2]; z < pmax[2]; z += h)
+               ((Mesh*)mesh) -> RestrictLocalH (Point3d (x, y, z), h);
+   }
+
+
+
+
+   // Generates volume mesh from an existing surface mesh
+   DLL_HEADER Ng_Result Ng_GenerateVolumeMesh (Ng_Mesh * mesh, Ng_Meshing_Parameters * mp)
+   {
+      Mesh * m = (Mesh*)mesh;
+
+      // Philippose - 30/08/2009
+      // Do not locally re-define "mparam" here... "mparam" is a global 
+      // object 
+      //MeshingParameters mparam;
+      mp->Transfer_Parameters();
+
+      m->CalcLocalH(mparam.grading);
+
+      MeshVolume (mparam, *m);
+      RemoveIllegalElements (*m);
+      OptimizeVolume (mparam, *m);
+
+      return NG_OK;
+   }
+
+
+
+
+   /* ------------------ 2D Meshing Functions ------------------------- */
+   DLL_HEADER void Ng_AddPoint_2D (Ng_Mesh * mesh, double * x)
+   {
+      Mesh * m = (Mesh*)mesh;
+
+      m->AddPoint (Point3d (x[0], x[1], 0));
+   }
+
+
+
+
+   DLL_HEADER void Ng_AddBoundarySeg_2D (Ng_Mesh * mesh, int pi1, int pi2)
+   {
+      Mesh * m = (Mesh*)mesh;
+
+      Segment seg;
+      seg[0] = pi1;
+      seg[1] = pi2;
+      m->AddSegment (seg);
+   }
+
+
+
+
+   DLL_HEADER int Ng_GetNP_2D (Ng_Mesh * mesh)
+   {
+      Mesh * m = (Mesh*)mesh;
+      return m->GetNP();
+   }
+
+
+
+
+   DLL_HEADER int Ng_GetNE_2D (Ng_Mesh * mesh)
+   {
+      Mesh * m = (Mesh*)mesh;
+      return m->GetNSE();
+   }
+
+
+
+
+   DLL_HEADER int Ng_GetNSeg_2D (Ng_Mesh * mesh)
+   {
+      Mesh * m = (Mesh*)mesh;
+      return m->GetNSeg();
+   }
+
+
+
+
+   DLL_HEADER void Ng_GetPoint_2D (Ng_Mesh * mesh, int num, double * x)
+   {
+      Mesh * m = (Mesh*)mesh;
+
+      Point<3> & p = m->Point(num);
+      x[0] = p(0);
+      x[1] = p(1);
+   }
+
+
+
+
+   DLL_HEADER Ng_Surface_Element_Type
+      Ng_GetElement_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum)
+   {
+      const Element2d & el = ((Mesh*)mesh)->SurfaceElement(num);
+      for (int i = 1; i <= el.GetNP(); i++)
+         pi[i-1] = el.PNum(i);
+
+      Ng_Surface_Element_Type et;
+      switch (el.GetNP())
+      {
+      case 3: et = NG_TRIG; break;
+      case 4: et = NG_QUAD; break;
+      case 6: 
+         switch (el.GetNV())
+         {
+         case 3: et = NG_TRIG6; break;
+         case 4: et = NG_QUAD6; break;
+         default:
+            et = NG_TRIG6; break;
+         }
+         break;
+      case 8: et = NG_QUAD8; break;
+      default:
+         et = NG_TRIG; break; // for the compiler
+      }
+
+      if (matnum)
+         *matnum = el.GetIndex();
+
+      return et;
+   }
+
+
+
+
+   DLL_HEADER void Ng_GetSegment_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum)
+   {
+      const Segment & seg = ((Mesh*)mesh)->LineSegment(num);
+      pi[0] = seg[0];
+      pi[1] = seg[1];
+
+      if (matnum)
+         *matnum = seg.edgenr;
+   }
+
+
+
+
+   DLL_HEADER Ng_Geometry_2D * Ng_LoadGeometry_2D (const char * filename)
+   {
+      SplineGeometry2d * geom = new SplineGeometry2d();
+      geom -> Load (filename);
+      return (Ng_Geometry_2D *)geom;
+   }
+
+
+
+
+   DLL_HEADER Ng_Result Ng_GenerateMesh_2D (Ng_Geometry_2D * geom,
+                                            Ng_Mesh ** mesh,
+                                            Ng_Meshing_Parameters * mp)
+   {
+      // use global variable mparam
+      //  MeshingParameters mparam;  
+      mp->Transfer_Parameters();
+
+      Mesh * m;
+      MeshFromSpline2D (*(SplineGeometry2d*)geom, m, mparam);
+
+      std::cout << m->GetNSE() << " elements, " << m->GetNP() << " points" << std::endl;
+
+      *mesh = (Ng_Mesh*)m;
+      return NG_OK;
+   }
+
+
+
+
+   DLL_HEADER void Ng_HP_Refinement (Ng_Geometry_2D * geom,
+      Ng_Mesh * mesh,
+      int levels)
+   {
+      Refinement2d ref(*(SplineGeometry2d*)geom);
+      HPRefinement (*(Mesh*)mesh, &ref, levels);
+   }
+
+
+
+
+   DLL_HEADER void Ng_HP_Refinement (Ng_Geometry_2D * geom,
+      Ng_Mesh * mesh,
+      int levels, double parameter)
+   {
+      Refinement2d ref(*(SplineGeometry2d*)geom);
+      HPRefinement (*(Mesh*)mesh, &ref, levels, parameter);
+   }
+
+
+
+
+   Array<STLReadTriangle> readtrias; //only before initstlgeometry
+   Array<Point<3> > readedges; //only before init stlgeometry
+
+   // loads geometry from STL file
+   DLL_HEADER Ng_STL_Geometry * Ng_STL_LoadGeometry (const char * filename, int binary)
+   {
+      int i;
+      STLGeometry geom;
+      STLGeometry* geo;
+      ifstream ist(filename);
+
+      if (binary)
+      {
+         geo = geom.LoadBinary(ist);
+      }
+      else
+      {
+         geo = geom.Load(ist);
+      }
+
+      readtrias.SetSize(0);
+      readedges.SetSize(0);
+
+      Point3d p;
+      Vec3d normal;
+      double p1[3];
+      double p2[3];
+      double p3[3];
+      double n[3];
+
+      Ng_STL_Geometry * geo2 = Ng_STL_NewGeometry();
+
+      for (i = 1; i <= geo->GetNT(); i++)
+      {
+         const STLTriangle& t = geo->GetTriangle(i);
+         p = geo->GetPoint(t.PNum(1));
+         p1[0] = p.X(); p1[1] = p.Y(); p1[2] = p.Z(); 
+         p = geo->GetPoint(t.PNum(2));
+         p2[0] = p.X(); p2[1] = p.Y(); p2[2] = p.Z(); 
+         p = geo->GetPoint(t.PNum(3));
+         p3[0] = p.X(); p3[1] = p.Y(); p3[2] = p.Z();
+         normal = t.Normal();
+         n[0] = normal.X(); n[1] = normal.Y(); n[2] = normal.Z();
+
+         Ng_STL_AddTriangle(geo2, p1, p2, p3, n);
+      }
+
+      return geo2;
+   }
+
+
+
+
+   // generate new STL Geometry
+   DLL_HEADER Ng_STL_Geometry * Ng_STL_NewGeometry ()
+   {
+      return (Ng_STL_Geometry*)(void*)new STLGeometry;
+   } 
+
+
+
+
+   // after adding triangles (and edges) initialize
+   DLL_HEADER Ng_Result Ng_STL_InitSTLGeometry (Ng_STL_Geometry * geom)
+   {
+      STLGeometry* geo = (STLGeometry*)geom;
+      geo->InitSTLGeometry(readtrias);
+      readtrias.SetSize(0);
+
+      if (readedges.Size() != 0)
+      {
+         /*
+         for (int i = 1; i <= readedges.Size(); i+=2)
+         {
+         cout << "e(" << readedges.Get(i) << "," << readedges.Get(i+1) << ")" << endl;
+         }
+         */
+         geo->AddEdges(readedges);
+      }
+
+      if (geo->GetStatus() == STLTopology::STL_GOOD || geo->GetStatus() == STLTopology::STL_WARNING) return NG_OK;
+      return NG_SURFACE_INPUT_ERROR;
+   }
+
+
+
+
+   // automatically generates edges:
+   DLL_HEADER Ng_Result Ng_STL_MakeEdges (Ng_STL_Geometry * geom,
+                                          Ng_Mesh* mesh,
+                                          Ng_Meshing_Parameters * mp)
+   {
+      STLGeometry* stlgeometry = (STLGeometry*)geom;
+      Mesh* me = (Mesh*)mesh;
+
+      // Philippose - 27/07/2009
+      // Do not locally re-define "mparam" here... "mparam" is a global 
+      // object 
+      //MeshingParameters mparam;
+      mp->Transfer_Parameters();
+
+      me -> SetGlobalH (mparam.maxh);
+      me -> SetLocalH (stlgeometry->GetBoundingBox().PMin() - Vec3d(10, 10, 10),
+                       stlgeometry->GetBoundingBox().PMax() + Vec3d(10, 10, 10),
+                       0.3);
+
+      me -> LoadLocalMeshSize (mp->meshsize_filename);
+      /*
+      if (mp->meshsize_filename)
+      {
+      ifstream infile (mp->meshsize_filename);
+      if (!infile.good()) return NG_FILE_NOT_FOUND;
+      me -> LoadLocalMeshSize (infile);
+      }
+      */
+
+      STLMeshing (*stlgeometry, *me);
+
+      stlgeometry->edgesfound = 1;
+      stlgeometry->surfacemeshed = 0;
+      stlgeometry->surfaceoptimized = 0;
+      stlgeometry->volumemeshed = 0;
+
+      return NG_OK;
+   }
+
+
+
+
+   // generates mesh, empty mesh be already created.
+   DLL_HEADER Ng_Result Ng_STL_GenerateSurfaceMesh (Ng_STL_Geometry * geom,
+                                                    Ng_Mesh* mesh,
+                                                    Ng_Meshing_Parameters * mp)
+   {
+      STLGeometry* stlgeometry = (STLGeometry*)geom;
+      Mesh* me = (Mesh*)mesh;
+
+      // Philippose - 27/07/2009
+      // Do not locally re-define "mparam" here... "mparam" is a global 
+      // object
+      //MeshingParameters mparam;
+      mp->Transfer_Parameters();
+
+
+      /*
+      me -> SetGlobalH (mparam.maxh);
+      me -> SetLocalH (stlgeometry->GetBoundingBox().PMin() - Vec3d(10, 10, 10),
+      stlgeometry->GetBoundingBox().PMax() + Vec3d(10, 10, 10),
+      0.3);
+      */
+      /*
+      STLMeshing (*stlgeometry, *me);
+
+      stlgeometry->edgesfound = 1;
+      stlgeometry->surfacemeshed = 0;
+      stlgeometry->surfaceoptimized = 0;
+      stlgeometry->volumemeshed = 0;
+      */  
+      int retval = STLSurfaceMeshing (*stlgeometry, *me);
+      if (retval == MESHING3_OK)
+      {
+         (*mycout) << "Success !!!!" << std::endl;
+         stlgeometry->surfacemeshed = 1;
+         stlgeometry->surfaceoptimized = 0;
+         stlgeometry->volumemeshed = 0;
+      } 
+      else if (retval == MESHING3_OUTERSTEPSEXCEEDED)
+      {
+         (*mycout) << "ERROR: Give up because of too many trials. Meshing aborted!" << std::endl;
+      }
+      else if (retval == MESHING3_TERMINATE)
+      {
+         (*mycout) << "Meshing Stopped!" << std::endl;
+      }
+      else
+      {
+         (*mycout) << "ERROR: Surface meshing not successful. Meshing aborted!" << std::endl;
+      }
+
+
+      STLSurfaceOptimization (*stlgeometry, *me, mparam);
+
+      return NG_OK;
+   }
+
+
+
+
+   // fills STL Geometry
+   // positive orientation
+   // normal vector may be null-pointer
+   DLL_HEADER void Ng_STL_AddTriangle (Ng_STL_Geometry * geom, 
+                                       double * p1, double * p2, double * p3, 
+                                       double * nv)
+   {
+      Point<3> apts[3];
+      apts[0] = Point<3>(p1[0],p1[1],p1[2]);
+      apts[1] = Point<3>(p2[0],p2[1],p2[2]);
+      apts[2] = Point<3>(p3[0],p3[1],p3[2]);
+
+      Vec<3> n;
+      if (!nv)
+         n = Cross (apts[0]-apts[1], apts[0]-apts[2]);
+      else
+         n = Vec<3>(nv[0],nv[1],nv[2]);
+
+      readtrias.Append(STLReadTriangle(apts,n));
+   }
+
+   // add (optional) edges:
+   DLL_HEADER void Ng_STL_AddEdge (Ng_STL_Geometry * geom, 
+      double * p1, double * p2)
+   {
+      readedges.Append(Point3d(p1[0],p1[1],p1[2]));
+      readedges.Append(Point3d(p2[0],p2[1],p2[2]));
+   }
+
+
+
+
+#ifdef OCCGEOMETRY
+   // --------------------- OCC Geometry / Meshing Utility Functions -------------------
+   // Create new OCC Geometry Object
+   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_NewGeometry ()
+   {
+      return (Ng_OCC_Geometry*)(void*)new OCCGeometry;
+   } 
+
+
+
+
+   // Delete the OCC Geometry Object
+   DLL_HEADER Ng_Result Ng_OCC_DeleteGeometry(Ng_OCC_Geometry * geom)
+   {
+      if (geom != NULL)
+      {
+         delete (OCCGeometry*)geom;
+         geom = NULL;
+         return NG_OK;
+      }
+      
+      return NG_ERROR;
+   }
+
+
+
+   
+   // Loads geometry from STEP File
+   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_STEP (const char * filename)
+   {
+      // Call the STEP File Load function. Note.. the geometry class 
+      // is created and instantiated within the load function
+      OCCGeometry * occgeo = LoadOCC_STEP(filename);
+
+      return ((Ng_OCC_Geometry *)occgeo);
+   }
+
+
+
+   
+   // Loads geometry from IGES File
+   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_IGES (const char * filename)
+   {
+      // Call the IGES File Load function. Note.. the geometry class 
+      // is created and instantiated within the load function
+      OCCGeometry * occgeo = LoadOCC_IGES(filename);
+
+      return ((Ng_OCC_Geometry *)occgeo);
+   }
+
+
+
+   
+   // Loads geometry from BREP File
+   DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_BREP (const char * filename)
+   {
+      // Call the BREP File Load function. Note.. the geometry class 
+      // is created and instantiated within the load function
+      OCCGeometry * occgeo = LoadOCC_BREP(filename);
+
+      return ((Ng_OCC_Geometry *)occgeo);
+   }
+
+
+
+
+   // Locally limit the size of the mesh to be generated at various points 
+   // based on the topology of the geometry
+   DLL_HEADER Ng_Result Ng_OCC_SetLocalMeshSize (Ng_OCC_Geometry * geom,
+                                                 Ng_Mesh * mesh,
+                                                 Ng_Meshing_Parameters * mp)
+   {
+      OCCGeometry * occgeom = (OCCGeometry*)geom;
+      Mesh * me = (Mesh*)mesh;
+
+      me->geomtype = Mesh::GEOM_OCC;
+
+      mp->Transfer_Parameters();
+      
+      occparam.resthcloseedgeenable = mp->closeedgeenable;
+      occparam.resthcloseedgefac = mp->closeedgefact;
+
+      // Delete the mesh structures in order to start with a clean 
+      // slate
+      me->DeleteMesh();
+
+      OCCSetLocalMeshSize(*occgeom, *me);
+
+      return(NG_OK);
+   }
+
+
+
+   
+   // Mesh the edges and add Face descriptors to prepare for surface meshing
+   DLL_HEADER Ng_Result Ng_OCC_GenerateEdgeMesh (Ng_OCC_Geometry * geom,
+                                                 Ng_Mesh * mesh,
+                                                 Ng_Meshing_Parameters * mp)
+   {
+      OCCGeometry * occgeom = (OCCGeometry*)geom;
+      Mesh * me = (Mesh*)mesh;
+
+      mp->Transfer_Parameters();
+
+      OCCFindEdges(*occgeom, *me);
+
+      if((me->GetNP()) && (me->GetNFD()))
+      {
+         return NG_OK;
+      }
+      else
+      {
+         return NG_ERROR;
+      }
+   }
+
+
+
+   
+   // Mesh the edges and add Face descriptors to prepare for surface meshing
+   DLL_HEADER Ng_Result Ng_OCC_GenerateSurfaceMesh (Ng_OCC_Geometry * geom,
+                                                    Ng_Mesh * mesh,
+                                                    Ng_Meshing_Parameters * mp)
+   {
+      int numpoints = 0;
+
+      OCCGeometry * occgeom = (OCCGeometry*)geom;
+      Mesh * me = (Mesh*)mesh;
+
+      // Set the internal meshing parameters structure from the nglib meshing 
+      // parameters structure
+      mp->Transfer_Parameters();
+
+
+      // Only go into surface meshing if the face descriptors have already been added
+      if(!me->GetNFD())
+         return NG_ERROR;
+
+      numpoints = me->GetNP();
+
+      // Initially set up only for surface meshing without any optimisation
+      int perfstepsend = MESHCONST_MESHSURFACE;
+
+      // Check and if required, enable surface mesh optimisation step
+      if(mp->optsurfmeshenable)
+      {
+         perfstepsend = MESHCONST_OPTSURFACE;
+      }
+
+      OCCMeshSurface(*occgeom, *me, perfstepsend);
+
+      me->CalcSurfacesOfNode();
+      
+      if(me->GetNP() <= numpoints)
+         return NG_ERROR;
+
+      if(me->GetNSE() <= 0)
+         return NG_ERROR;
+
+      return NG_OK;
+   }
+
+
+
+
+   // Extract the face map from the OCC geometry
+   // The face map basically gives an index to each face in the geometry, 
+   // which can be used to access a specific face
+   DLL_HEADER Ng_Result Ng_OCC_GetFMap(Ng_OCC_Geometry * geom, 
+                                       Ng_OCC_TopTools_IndexedMapOfShape * FMap)
+   {
+      OCCGeometry* occgeom = (OCCGeometry*)geom;
+      TopTools_IndexedMapOfShape *occfmap = (TopTools_IndexedMapOfShape *)FMap;
+
+      // Copy the face map from the geometry to the given variable
+      occfmap->Assign(occgeom->fmap);
+
+      if(occfmap->Extent())
+      {
+         return NG_OK;
+      }
+      else
+      {
+         return NG_ERROR;
+      }
+   }
+
+   // ------------------ End - OCC Geometry / Meshing Utility Functions ----------------
+#endif
+
+
+
+
+   // ------------------ Begin - Meshing Parameters related functions ------------------
+   // Constructor for the local nglib meshing parameters class
+   DLL_HEADER Ng_Meshing_Parameters :: Ng_Meshing_Parameters()
+   {
+      uselocalh = 1;
+
+      maxh = 1000;
+      minh = 0.0;
+
+      fineness = 0.5;
+      grading = 0.3;
+
+      elementsperedge = 2.0;
+      elementspercurve = 2.0;
+
+      closeedgeenable = 0;
+      closeedgefact = 2.0;
+
+	  minedgelenenable = 0;
+	  minedgelen = 1e-4;
+
+      second_order = 0;
+      quad_dominated = 0;
+
+      meshsize_filename = 0;
+
+      optsurfmeshenable = 1;
+      optvolmeshenable = 1;
+
+      optsteps_2d = 3;
+      optsteps_3d = 3;
+
+      invert_tets = 0;
+      invert_trigs = 0;
+
+      check_overlap = 1;
+      check_overlapping_boundary = 1;
+   }
+
+
+
+
+   // Reset the local meshing parameters to the default values
+   DLL_HEADER void Ng_Meshing_Parameters :: Reset_Parameters()
+   {
+      uselocalh = 1;
+
+      maxh = 1000;
+      minh = 0;
+
+      fineness = 0.5;
+      grading = 0.3;
+
+      elementsperedge = 2.0;
+      elementspercurve = 2.0;
+
+      closeedgeenable = 0;
+      closeedgefact = 2.0;
+
+  	  minedgelenenable = 0;
+	  minedgelen = 1e-4;
+
+      second_order = 0;
+      quad_dominated = 0;
+
+      meshsize_filename = 0;
+
+      optsurfmeshenable = 1;
+      optvolmeshenable = 1;
+
+      optsteps_2d = 3;
+      optsteps_3d = 3;
+
+      invert_tets = 0;
+      invert_trigs = 0;
+
+      check_overlap = 1;
+      check_overlapping_boundary = 1;
+   }
+
+
+
+
+   // 
+   DLL_HEADER void Ng_Meshing_Parameters :: Transfer_Parameters()
+   {
+      mparam.uselocalh = uselocalh;
+      
+      mparam.maxh = maxh;
+      mparam.minh = minh;
+
+      mparam.grading = grading;
+      mparam.curvaturesafety = elementspercurve;
+      mparam.segmentsperedge = elementsperedge;
+
+      mparam.secondorder = second_order;
+      mparam.quad = quad_dominated;
+
+      mparam.meshsizefilename = meshsize_filename;
+
+      mparam.optsteps2d = optsteps_2d;
+      mparam.optsteps3d = optsteps_3d;
+
+      mparam.inverttets = invert_tets;
+      mparam.inverttrigs = invert_trigs;
+
+      mparam.checkoverlap = check_overlap;
+      mparam.checkoverlappingboundary = check_overlapping_boundary;
+   }
+   // ------------------ End - Meshing Parameters related functions --------------------
+
+
+
+
+   // ------------------ Begin - Second Order Mesh generation functions ----------------
+   DLL_HEADER void Ng_Generate_SecondOrder(Ng_Mesh * mesh)
+   {
+      Refinement ref;
+      ref.MakeSecondOrder(*(Mesh*) mesh);
+   }
+
+
+
+
+   DLL_HEADER void Ng_2D_Generate_SecondOrder(Ng_Geometry_2D * geom,
+					  Ng_Mesh * mesh)
+   {
+      ( (SplineGeometry2d*)geom ) -> GetRefinement().MakeSecondOrder( * (Mesh*) mesh );
+   }
+
+
+
+
+   DLL_HEADER void Ng_STL_Generate_SecondOrder(Ng_STL_Geometry * geom,
+					   Ng_Mesh * mesh)
+   {
+      ((STLGeometry*)geom)->GetRefinement().MakeSecondOrder(*(Mesh*) mesh);
+   }
+
+
+
+
+   DLL_HEADER void Ng_CSG_Generate_SecondOrder (Ng_CSG_Geometry * geom,
+					   Ng_Mesh * mesh)
+   {
+      ((CSGeometry*)geom)->GetRefinement().MakeSecondOrder(*(Mesh*) mesh);
+   }
+
+
+
+
+#ifdef OCCGEOMETRY
+   DLL_HEADER void Ng_OCC_Generate_SecondOrder (Ng_OCC_Geometry * geom,
+                  Ng_Mesh * mesh)
+   {
+      ((OCCGeometry*)geom )->GetRefinement().MakeSecondOrder(*(Mesh*) mesh);
+   }
+#endif
+   // ------------------ End - Second Order Mesh generation functions ------------------
+
+
+
+
+   // ------------------ Begin - Uniform Mesh Refinement functions ---------------------
+   DLL_HEADER void Ng_Uniform_Refinement (Ng_Mesh * mesh)
+   {
+      Refinement ref;
+      ref.Refine ( * (Mesh*) mesh );
+   }
+
+
+
+
+   DLL_HEADER void Ng_2D_Uniform_Refinement (Ng_Geometry_2D * geom,
+      Ng_Mesh * mesh)
+   {
+      ( (SplineGeometry2d*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
+   }
+
+
+
+
+   DLL_HEADER void Ng_STL_Uniform_Refinement (Ng_STL_Geometry * geom,
+      Ng_Mesh * mesh)
+   {
+      ( (STLGeometry*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
+   }
+
+
+
+
+   DLL_HEADER void Ng_CSG_Uniform_Refinement (Ng_CSG_Geometry * geom,
+      Ng_Mesh * mesh)
+   {
+      ( (CSGeometry*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
+   }
+
+
+
+
+#ifdef OCCGEOMETRY
+   DLL_HEADER void Ng_OCC_Uniform_Refinement (Ng_OCC_Geometry * geom,
+      Ng_Mesh * mesh)
+   {
+      ( (OCCGeometry*)geom ) -> GetRefinement().Refine ( * (Mesh*) mesh );
+   }
+#endif
+   // ------------------ End - Uniform Mesh Refinement functions -----------------------
+} // End of namespace nglib
+
+
+
+
+// compatibility functions:
+namespace netgen 
+{
+   char geomfilename[255];
+
+   DLL_HEADER void MyError (const char * ch)
+   {
+      cerr << ch;
+   }
+
+
+
+
+   //Destination for messages, errors, ...
+   DLL_HEADER void Ng_PrintDest(const char * s)
+   {
+#ifdef PARALLEL
+     int id = 0;
+     MPI_Comm_rank(MPI_COMM_WORLD, &id);
+     if (id != 0) return;
+#endif
+     (*mycout) << s << std::flush;
+   }
+
+
+
+
+   DLL_HEADER double GetTime ()
+   {
+      return 0;
+   }
+
+
+
+
+   void ResetTime ()
+   {
+      ;
+   }
+
+
+
+
+   void MyBeep (int i)
+   {
+      ;
+   }
+
+
+
+
+   void Render()
+   {
+      ; 
+   }
+} // End of namespace netgen
+
+
+
+
+void Ng_Redraw () { ; }
+void Ng_ClearSolutionData () { ; }
+void Ng_SetSolutionData (Ng_SolutionData * soldata) 
+{ 
+  delete soldata->solclass;
+}
+void Ng_InitSolutionData (Ng_SolutionData * soldata) { ; }
+
+
--- netgen_ref/nglib/nglib.h
+++ netgen/nglib/nglib.h
@@ -1,747 +1,747 @@
-#ifndef NGLIB
-#define NGLIB
-
-/**************************************************************************/
-/* File:   nglib.h                                                        */
-/* Author: Joachim Schoeberl                                              */
-/* Date:   7. May. 2000                                                   */
-/**************************************************************************/
-
-/*!
-   \file nglib.h
-   \brief Library interface to the netgen meshing kernel
-   \author Joachim Schoeberl
-   \date 7. May 2000
-
-   This header file provides access to the core functionality of the Netgen 
-   Mesher via a library interface, without an interactive User Interface.
-
-   The intention of providing these set of functions is to allow system 
-   developers to integrate Netgen into top-level code, to act as the low 
-   level mesh generation / optimisation kernel.  
-*/
-
-// Philippose - 14.02.2009
-// Modifications for creating a DLL in Windows
-#ifdef WIN32
-   #ifdef NGLIB_EXPORTS || nglib_EXPORTS
-      #define DLL_HEADER   __declspec(dllexport)
-   #else
-      #define DLL_HEADER   __declspec(dllimport)
-   #endif
-#else
-   #define DLL_HEADER 
-#endif
-
-
-
-// ** Constants used within Netgen *********************
-/// Maximum allowed number of nodes per volume element
-#define NG_VOLUME_ELEMENT_MAXPOINTS 10
-
-/// Maximum allowed number of nodes per surface element
-#define NG_SURFACE_ELEMENT_MAXPOINTS 8
-
-
-
-// *** Data-types for accessing Netgen functionality ***
-/// Data type for NETGEN mesh
-typedef void * Ng_Mesh;
-
-/// Data type for NETGEN CSG geometry
-typedef void * Ng_CSG_Geometry;
-
-/// Data type for NETGEN 2D geometry
-typedef void * Ng_Geometry_2D;
-
-/// Data type for NETGEN STL geometry
-typedef void * Ng_STL_Geometry;
-
-#ifdef OCCGEOMETRY
-/// Data type for NETGEN OpenCascade geometry
-typedef void * Ng_OCC_Geometry;
-typedef void * Ng_OCC_TopTools_IndexedMapOfShape;
-#endif
-
-
-// *** Special Enum types used within Netgen ***********
-/// Currently implemented surface element types
-enum Ng_Surface_Element_Type 
-   { NG_TRIG = 1, NG_QUAD = 2, NG_TRIG6 = 3, NG_QUAD6 = 4, NG_QUAD8 = 5 };
-
-/// Currently implemented volume element types
-enum Ng_Volume_Element_Type 
-   { NG_TET = 1, NG_PYRAMID = 2, NG_PRISM = 3, NG_TET10 = 4 };
-
-/// Values returned by Netgen functions
-enum Ng_Result 
-   { 
-     NG_ERROR               = -1,   
-     NG_OK                  = 0, 
-     NG_SURFACE_INPUT_ERROR = 1,
-     NG_VOLUME_FAILURE      = 2, 
-     NG_STL_INPUT_ERROR     = 3,
-     NG_SURFACE_FAILURE     = 4,
-     NG_FILE_NOT_FOUND      = 5 
-   };
-
-
-
-// *** Classes required for use within Netgen **********
-/// Netgen Meshing Parameters class
-class Ng_Meshing_Parameters 
-{
-public:
-   int uselocalh;                      //!< Switch to enable / disable usage of local mesh size modifiers
-
-   double maxh;                        //!< Maximum global mesh size allowed
-   double minh;                        //!< Minimum global mesh size allowed
-
-   double fineness;                    //!< Mesh density: 0...1 (0 => coarse; 1 => fine)
-   double grading;                     //!< Mesh grading: 0...1 (0 => uniform mesh; 1 => aggressive local grading)
-
-   double elementsperedge;             //!< Number of elements to generate per edge of the geometry
-   double elementspercurve;            //!< Elements to generate per curvature radius
-
-   int closeedgeenable;                //!< Enable / Disable mesh refinement at close edges
-   double closeedgefact;               //!< Factor to use for refinement at close edges (larger => finer)
-
-   int minedgelenenable;			   //!< Enable / Disable user defined minimum edge length for edge subdivision
-   double minedgelen;                  //!< Minimum edge length to use while subdividing the edges (default = 1e-4)
-
-   int second_order;                   //!< Generate second-order surface and volume elements
-   int quad_dominated;                 //!< Creates a Quad-dominated mesh 
-
-   char * meshsize_filename;           //!< Optional external mesh size file 
-
-   int optsurfmeshenable;              //!< Enable / Disable automatic surface mesh optimization
-   int optvolmeshenable;               //!< Enable / Disable automatic volume mesh optimization
-
-   int optsteps_3d;                     //!< Number of optimize steps to use for 3-D mesh optimization
-   int optsteps_2d;                     //!< Number of optimize steps to use for 2-D mesh optimization
-
-   // Philippose - 13/09/2010
-   // Added a couple more parameters into the meshing parameters list 
-   // from Netgen into Nglib
-   int invert_tets;                    //!< Invert all the volume elements
-   int invert_trigs;                   //!< Invert all the surface triangle elements
-
-   int check_overlap;                  //!< Check for overlapping surfaces during Surface meshing
-   int check_overlapping_boundary;     //!< Check for overlapping surface elements before volume meshing
-
-
-   /*!
-      Default constructor for the Mesh Parameters class
-
-      Note: This constructor initialises the variables in the 
-      class with the following default values
-      - #uselocalh: 1
-      - #maxh: 1000.0
-      - #fineness: 0.5
-      - #grading: 0.3
-      - #elementsperedge: 2.0
-      - #elementspercurve: 2.0
-      - #closeedgeenable: 0
-      - #closeedgefact: 2.0
-      - #secondorder: 0
-      - #meshsize_filename: null
-      - #quad_dominated: 0
-      - #optsurfmeshenable: 1
-      - #optvolmeshenable: 1
-      - #optsteps_2d: 3
-      - #optsteps_3d: 3
-      - #invert_tets: 0
-      - #invert_trigs:0 
-      - #check_overlap: 1
-      - #check_overlapping_boundary: 1
-   */
-   DLL_HEADER Ng_Meshing_Parameters();
-
-
-
-   /*!
-       Reset the meshing parameters to their defaults
-
-       This member function resets all the meshing parameters 
-       of the object to the default values
-   */
-   DLL_HEADER void Reset_Parameters();
-
-
-
-   /*!
-       Transfer local meshing parameters to internal meshing parameters
-
-       This member function transfers all the meshing parameters 
-       defined in the local meshing parameters structure of nglib into 
-       the internal meshing parameters structure used by the Netgen core
-   */
-   DLL_HEADER void Transfer_Parameters();
-};
-
-
-
-
-// *** Functions Exported by this Library *************
-
-// ------------------------------------------------------------------
-// Netgen library initialisation / destruction functions
-
-/*! \brief Initialise the Netgen library and prepare for use
-
-    This function needs to be called by the third-party 
-    program before beginning to use the other Netgen 
-    specific functions.
-*/
-DLL_HEADER void Ng_Init ();
-
-
-/*! \brief Exit the Netgen meshing kernel in a clean manner
-
-    Use this function to exit the meshing sub-system in 
-    a clean and orderly manner.
-*/
-DLL_HEADER void Ng_Exit ();
-  
-
-/*! \brief Create a new (and empty) Netgen Mesh Structure
-
-    This function creates a new Netgen Mesh, initialises 
-    it, and returns a pointer to the created mesh structure. 
-
-    Use the returned pointer for subsequent operations 
-    which involve mesh operations.
-
-    \return Ng_Mesh Pointer to a Netgen Mesh type #Ng_Mesh
-*/
-DLL_HEADER  Ng_Mesh * Ng_NewMesh ();
-
-
-/*! \brief Delete an existing Netgen Mesh Structure
-
-    Use this function to delete an existing Netgen mesh 
-    structure and release the used memory. 
-
-    \param mesh Pointer to an existing Netgen Mesh structure 
-                of type #Ng_Mesh
-*/
-DLL_HEADER void Ng_DeleteMesh (Ng_Mesh * mesh);
-
-
-/*! \brief Save a Netgen Mesh to disk
-
-    This function allows a generated mesh structure to be saved 
-    to disk.
-
-    A Mesh saved using this function, will be written to disk 
-    in the Netgen VOL file format.
-
-    \param mesh    Pointer to an existing Netgen Mesh structure 
-                   of type #Ng_Mesh
-    \param filename Pointer to a character array containing the 
-                    name of the file to which the mesh should 
-                    be saved
-*/
-DLL_HEADER void Ng_SaveMesh(Ng_Mesh * mesh, const char* filename);
-
-
-/*! \brief Load a Netgen VOL Mesh from disk into memory
-
-    A Netgen mesh saved in the internal VOL format can be loaded 
-    into a Netgen Mesh structure using this function. 
-
-    \param filename Pointer to a character array containing the 
-                    name of the file to load
-    \return Ng_Mesh Pointer to a Netgen Mesh type #Ng_Mesh containing 
-                    the mesh loaded from disk
-*/
-DLL_HEADER Ng_Mesh * Ng_LoadMesh(const char* filename);
-
-
-/*! \brief Merge a Netgen VOL Mesh from disk into an existing mesh in memory
-
-    A Netgen mesh saved in the internal VOL format can be merged 
-    into an existing Netgen Mesh structure using this function. 
-
-    \param mesh       Name of the Mesh structure already existent in memory
-    \param filename   Pointer to a character array containing the 
-                      name of the file to load
-    \return Ng_Result Status of the merge operation
-*/
-DLL_HEADER Ng_Result Ng_MergeMesh(Ng_Mesh * mesh, const char* filename);
-
-
-/*! \brief Merge one Netgen Mesh into another Netgen Mesh in the case 
-    when both are already in memory
-
-    (NOTE: FUNCTION STILL WORK IN PROGRESS!!!)
-
-    This function can be used to merge two Netgen meshes already present 
-    in memory.
-
-    \param mesh1      Parent Mesh structure into which the second mesh 
-                      will be merged
-    \param mesh2      Child mesh structure which will get merged into 
-                      the parent mesh
-    \return Ng_Result Status of the merge operation
-*/
-DLL_HEADER Ng_Result Ng_MergeMesh(Ng_Mesh * mesh1, Ng_Mesh * mesh2);
-// ------------------------------------------------------------------
-
-
-
-// ------------------------------------------------------------------
-// Basic Meshing functions for manually adding points, surface elements 
-// and volume elements to a Netgen Mesh structure
-
-/*! \brief Add a point to a given Netgen Mesh Structure
-
-    This function allows points to be directly added to a Netgen 
-    mesh structure by providing the co-ordinates.
-
-    Each call to the function allows only one point to be added.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \param x    Pointer to an array of type double containing the co-ordinates 
-                of the point to be added in the form: \n
-                - x[0] = X co-ordinate
-                - x[1] = Y co-ordinate
-                - x[2] = Z co-ordinate
-*/
-DLL_HEADER void Ng_AddPoint (Ng_Mesh * mesh, double * x);
-
-
-/*! \brief Add a surface element to a given Netgen Mesh Structure
-
-    This function allows the top-level code to directly add individual 
-    Surface Elements to a Netgen Mesh Structure by providing the type of 
-    element to be added and the indices of the points which constitute the 
-    element.
-
-    <i>Note:</i> 
-    - The points referred to by the surface elements must have been
-      added prior to calling this function. 
-    - Currently only triangular elements are supported, and the Surface Element 
-      Type argument is not used.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \param et   Surface Element type provided via the enumerated type 
-                #Ng_Surface_Element_Type 
-    \param pi   Pointer to an array of integers containing the indices of the 
-                points which constitute the surface element being added
-*/
-DLL_HEADER void Ng_AddSurfaceElement (Ng_Mesh * mesh, Ng_Surface_Element_Type et, int * pi);
-
-
-/*! \brief Add a volume element to a given Netgen Mesh Structure
-
-    This function allows the top-level code to directly add individual 
-    Volume Elements to a Netgen Mesh Structure by providing the type of 
-    element to be added and the indices of the points which constitute the 
-    element.
-
-    <i>Note:</i> 
-    - The points referred to by the volume elements must have been
-      added prior to calling this function. 
-    - Currently only tetrahedral elements are supported, and the Volume Element 
-      Type argument is not used.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \param et   Volume Element type provided via the enumerated type 
-                #Ng_Volume_Element_Type 
-    \param pi   Pointer to an array of integers containing the indices of the 
-                points which constitute the volume element being added
-
-*/
-DLL_HEADER void Ng_AddVolumeElement (Ng_Mesh * mesh, Ng_Volume_Element_Type et, int * pi);
-  
-// ------------------------------------------------------------------
-
-
-
-// ------------------------------------------------------------------
-// Local Mesh Size restriction / limiting utilities
-
-/*! \brief Apply a global restriction on mesh element size
-
-    This utility allows the user to apply a global mesh element 
-    size limitation. 
-
-    During mesh creation, in the absence of an explicit local 
-    size restriction around the neighbourhood of a point within 
-    the meshing domain, this global size restriction will be 
-    utilised.
-
-    <b>Note</b>: This function only limits the <b>Maximum</b> 
-    size of an element within the mesh.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \param h    Variable of type <i>double</i>, specifying the maximum
-                allowable mesh size
-*/
-DLL_HEADER void Ng_RestrictMeshSizeGlobal (Ng_Mesh * mesh, double h);
-
-
-/*! \brief Locally restrict the mesh element size at the given point
-
-    Unlike the function #Ng_RestrictMeshSizeGlobal, this function 
-    allows the user to locally restrict the maximum allowable mesh 
-    size at a given point.
-
-    The point is specified via its three cartesian co-ordinates.
-
-    <b>Note</b>: This function only limits the <b>Maximum</b> size 
-    of the elements around the specified point.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \param p    Pointer to an Array of type <i>double</i>, containing 
-                the three co-ordinates of the point in the form: \n
-                - p[0] = X co-ordinate
-                - p[1] = Y co-ordinate
-                - p[2] = Z co-ordinate
-    \param h    Variable of type <i>double</i>, specifying the maximum
-                allowable mesh size at that point
-*/
-DLL_HEADER void Ng_RestrictMeshSizePoint (Ng_Mesh * mesh, double * p, double h);
-
-
-/*! \brief Locally restrict the mesh element size within a specified box
-
-    Similar to the function #Ng_RestrictMeshSizePoint, this function 
-    allows the size of elements within a mesh to be locally limited.
-
-    However, rather than limit the mesh size at a single point, this 
-    utility restricts the local mesh size within a 3D Box region, specified 
-    via the co-ordinates of the two diagonally opposite points of a cuboid.
-
-    <b>Note</b>: This function only limits the <b>Maximum</b> size 
-    of the elements within the specified region.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \param pmin Pointer to an Array of type <i>double</i>, containing 
-                the three co-ordinates of the first point of the cuboid: \n
-                - pmin[0] = X co-ordinate
-                - pmin[1] = Y co-ordinate
-                - pmin[2] = Z co-ordinate
-    \param pmax Pointer to an Array of type <i>double</i>, containing 
-                the three co-ordinates of the opposite point of the 
-                cuboid: \n
-                - pmax[0] = X co-ordinate
-                - pmax[1] = Y co-ordinate
-                - pmax[2] = Z co-ordinate
-    \param h    Variable of type <i>double</i>, specifying the maximum
-                allowable mesh size at that point
-*/
-DLL_HEADER void Ng_RestrictMeshSizeBox (Ng_Mesh * mesh, double * pmin, double * pmax, double h);
-
-// ------------------------------------------------------------------
-
-
-
-// ------------------------------------------------------------------
-// 3D Mesh Generation functions
-
-/*! \brief Create a 3D Volume Mesh given a Surface Mesh
-
-    After creating a surface mesh, this function can be utilised 
-    to automatically generate the corresponding 3D Volume Mesh.
-
-    Mesh generation parameters (such as grading, maximum element size, 
-    etc.) are specified via the meshing parameters class which also 
-    needs to be passed to this function.
-
-    <b>Note</b>: Currently, Netgen generates pure tetrahedral volume 
-    meshes.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \param mp   Pointer to a copy of the Meshing Parameters class
-                (#Ng_Meshing_Parameters), filled up with the 
-                required values
-
-    \return Ng_Result Status of the Mesh Generation routine. More 
-                      details regarding the return value can be 
-                      found in the description of #Ng_Result
-*/
-DLL_HEADER Ng_Result Ng_GenerateVolumeMesh (Ng_Mesh * mesh, Ng_Meshing_Parameters * mp);
-
-// ------------------------------------------------------------------
-
-
-
-// ------------------------------------------------------------------
-// Basic Mesh information functions
-
-/*! \brief Returns the Number of Points present in the specified Mesh
-
-    Given an already existent Netgen Mesh Structure, this function 
-    returns the number of points currently present within the Mesh.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \return 
-                Integer Data-type with the number of points in the Mesh
-*/
-DLL_HEADER int Ng_GetNP (Ng_Mesh * mesh);
-
-
-/*! \brief Returns the Number of Surface Elements present in the specified Mesh
-
-    Given an already existent Netgen Mesh Structure, this function 
-    returns the number of surface elements currently present within 
-    the Mesh.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \return 
-                Integer Data-type with the number of surface elements in the Mesh
-*/
-DLL_HEADER int Ng_GetNSE (Ng_Mesh * mesh);
-
-
-/*! \brief Returns the Number of Volume Elements present in the specified Mesh
-
-    Given an already existent Netgen Mesh Structure, this function 
-    returns the number of volume elements currently present within 
-    the Mesh.
-
-    \param mesh Pointer to an existing Netgen Mesh structure of 
-                type #Ng_Mesh
-    \return 
-                Integer Data-type with the number of volume elements in the Mesh
-*/
-DLL_HEADER int Ng_GetNE (Ng_Mesh * mesh);
-
-// ------------------------------------------------------------------
-
-
-
-// ------------------------------------------------------------------
-// Mesh Topology functions
-// Use these functions to extract points, surface / volume elements, 
-// perform topological searches, etc..etc...
-  
-//  Return the Point Coordinates of a specified Point
-// The x, y and z co-ordinates are returned in the array pointer as 
-// x[0] = x ; x[1] = y ; x[2] = z
-DLL_HEADER void Ng_GetPoint (Ng_Mesh * mesh, int num, double * x);
-
-
-
-// return surface and volume element in pi
-DLL_HEADER Ng_Surface_Element_Type 
-Ng_GetSurfaceElement (Ng_Mesh * mesh, int num, int * pi);
-
-DLL_HEADER Ng_Volume_Element_Type
-Ng_GetVolumeElement (Ng_Mesh * mesh, int num, int * pi);
-
-// ------------------------------------------------------------------
-
-
-
-
-// **********************************************************
-// **   2D Meshing                                         **
-// **********************************************************
-
-
-// feeds points and boundary to mesh
-
-DLL_HEADER void Ng_AddPoint_2D (Ng_Mesh * mesh, double * x);
-DLL_HEADER void Ng_AddBoundarySeg_2D (Ng_Mesh * mesh, int pi1, int pi2);
-  
-// ask for number of points, elements and boundary segments
-DLL_HEADER int Ng_GetNP_2D (Ng_Mesh * mesh);
-DLL_HEADER int Ng_GetNE_2D (Ng_Mesh * mesh);
-DLL_HEADER int Ng_GetNSeg_2D (Ng_Mesh * mesh);
-  
-//  return point coordinates
-DLL_HEADER void Ng_GetPoint_2D (Ng_Mesh * mesh, int num, double * x);
-
-// return 2d elements
-DLL_HEADER Ng_Surface_Element_Type 
-Ng_GetElement_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum = NULL);
-
-// return 2d boundary segment
-DLL_HEADER void Ng_GetSegment_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum = NULL);
-
-
-// load 2d netgen spline geometry
-DLL_HEADER Ng_Geometry_2D * Ng_LoadGeometry_2D (const char * filename);
-
-// generate 2d mesh, mesh is allocated by function
-DLL_HEADER Ng_Result Ng_GenerateMesh_2D (Ng_Geometry_2D * geom,
-                                         Ng_Mesh ** mesh,
-                                         Ng_Meshing_Parameters * mp);
-  
-DLL_HEADER void Ng_HP_Refinement (Ng_Geometry_2D * geom,
-                                  Ng_Mesh * mesh,
-                                  int levels);
-  
-
-
-
-
-// **********************************************************
-// **   STL Meshing                                        **
-// **********************************************************
-
-
-// loads geometry from STL file
-DLL_HEADER Ng_STL_Geometry * Ng_STL_LoadGeometry (const char * filename, int binary = 0);
-
-
-// generate new STL Geometry
-DLL_HEADER Ng_STL_Geometry * Ng_STL_NewGeometry ();
-  
-
-// fills STL Geometry
-// positive orientation
-// normal vector may be null-pointer
-DLL_HEADER void Ng_STL_AddTriangle (Ng_STL_Geometry * geom, 
-                         double * p1, double * p2, double * p3, 
-                         double * nv = NULL);
-
-// add (optional) edges :
-DLL_HEADER void Ng_STL_AddEdge (Ng_STL_Geometry * geom, 
-                     double * p1, double * p2);
-
-// after adding triangles (and edges) initialize
-DLL_HEADER Ng_Result Ng_STL_InitSTLGeometry (Ng_STL_Geometry * geom);
-
-// automatically generates edges:
-DLL_HEADER Ng_Result Ng_STL_MakeEdges (Ng_STL_Geometry * geom,
-                            Ng_Mesh* mesh,
-                            Ng_Meshing_Parameters * mp);
-
-
-// generates mesh, empty mesh must be already created.
-DLL_HEADER Ng_Result Ng_STL_GenerateSurfaceMesh (Ng_STL_Geometry * geom,
-                                                 Ng_Mesh * mesh,
-                                                 Ng_Meshing_Parameters * mp);
-
-
-#ifdef ACIS
-
-// **********************************************************
-// **   ACIS Meshing                                       **
-// **********************************************************
-
-/// Data type for NETGEN STL geomty
-typedef void * Ng_ACIS_Geometry;
-
-// loads geometry from STL file
-DLL_HEADER Ng_ACIS_Geometry * Ng_ACIS_LoadGeometry (const char * filename);
-  
-// generates mesh, empty mesh must be already created.
-DLL_HEADER Ng_Result Ng_ACIS_GenerateSurfaceMesh (Ng_ACIS_Geometry * geom,
-                                                  Ng_Mesh * mesh,
-                                                  Ng_Meshing_Parameters * mp);
-
-
-#endif
-
-
-
-#ifdef OCCGEOMETRY
-
-// **********************************************************
-// **   OpenCascade Geometry / Meshing Utilities           **
-// **********************************************************
-
-// Create new OCC Geometry Object
-DLL_HEADER Ng_OCC_Geometry * Ng_OCC_NewGeometry ();
-
-// Delete an OCC Geometry Object
-DLL_HEADER Ng_Result Ng_OCC_DeleteGeometry (Ng_OCC_Geometry * geom);
-
-// Loads geometry from STEP file
-DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_STEP (const char * filename);
-
-// Loads geometry from IGES file
-DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_IGES (const char * filename);
-
-// Loads geometry from BREP file
-DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_BREP (const char * filename);
-
-// Set the local mesh size based on geometry / topology
-DLL_HEADER Ng_Result Ng_OCC_SetLocalMeshSize (Ng_OCC_Geometry * geom,
-                                              Ng_Mesh * mesh,
-                                              Ng_Meshing_Parameters * mp);
-
-// Mesh the edges and add Face descriptors to prepare for surface meshing
-DLL_HEADER Ng_Result Ng_OCC_GenerateEdgeMesh (Ng_OCC_Geometry * geom,
-                                              Ng_Mesh * mesh,
-                                              Ng_Meshing_Parameters * mp);
-
-// Mesh the surfaces of an OCC geometry
-DLL_HEADER Ng_Result Ng_OCC_GenerateSurfaceMesh (Ng_OCC_Geometry * geom,
-                                                 Ng_Mesh * mesh,
-                                                 Ng_Meshing_Parameters * mp); 
-
-// Get the face map of an already loaded OCC geometry
-DLL_HEADER Ng_Result Ng_OCC_GetFMap(Ng_OCC_Geometry * geom, 
-                                    Ng_OCC_TopTools_IndexedMapOfShape * FMap);
-
-#endif // OCCGEOMETRY
-
-
-
-// **********************************************************
-// **   Mesh refinement algorithms                         **
-// **********************************************************
-
-// uniform mesh refinement
-DLL_HEADER void Ng_Uniform_Refinement (Ng_Mesh * mesh);
-
-
-// uniform mesh refinement with geometry adaption:
-
-DLL_HEADER void Ng_2D_Uniform_Refinement (Ng_Geometry_2D * geom,
-					  Ng_Mesh * mesh);
-
-DLL_HEADER void Ng_STL_Uniform_Refinement (Ng_STL_Geometry * geom,
-					   Ng_Mesh * mesh);
-
-DLL_HEADER void Ng_CSG_Uniform_Refinement (Ng_CSG_Geometry * geom,
-					   Ng_Mesh * mesh);
-
-#ifdef OCCGEOMETRY
-DLL_HEADER void Ng_OCC_Uniform_Refinement (Ng_OCC_Geometry * geom,
-					   Ng_Mesh * mesh);
-#endif
-
-
-
-// **********************************************************
-// **   Second Order mesh algorithms                       **
-// **********************************************************
-
-// convert mesh to second order
-DLL_HEADER void Ng_Generate_SecondOrder (Ng_Mesh * mesh);
-
-
-// convert mesh to second order with geometry adaption:
-
-DLL_HEADER void Ng_2D_Generate_SecondOrder (Ng_Geometry_2D * geom,
-					  Ng_Mesh * mesh);
-
-DLL_HEADER void Ng_STL_Generate_SecondOrder (Ng_STL_Geometry * geom,
-					   Ng_Mesh * mesh);
-
-DLL_HEADER void Ng_CSG_Generate_SecondOrder (Ng_CSG_Geometry * geom,
-					   Ng_Mesh * mesh);
-
-#ifdef OCCGEOMETRY
-DLL_HEADER void Ng_OCC_Generate_SecondOrder (Ng_OCC_Geometry * geom,
-					   Ng_Mesh * mesh);
-#endif
-
-
-#endif // NGLIB
+#ifndef NGLIB
+#define NGLIB
+
+/**************************************************************************/
+/* File:   nglib.h                                                        */
+/* Author: Joachim Schoeberl                                              */
+/* Date:   7. May. 2000                                                   */
+/**************************************************************************/
+
+/*!
+   \file nglib.h
+   \brief Library interface to the netgen meshing kernel
+   \author Joachim Schoeberl
+   \date 7. May 2000
+
+   This header file provides access to the core functionality of the Netgen 
+   Mesher via a library interface, without an interactive User Interface.
+
+   The intention of providing these set of functions is to allow system 
+   developers to integrate Netgen into top-level code, to act as the low 
+   level mesh generation / optimisation kernel.  
+*/
+
+// Philippose - 14.02.2009
+// Modifications for creating a DLL in Windows
+#ifdef WIN32
+   #if defined NGLIB_EXPORTS || defined nglib_EXPORTS
+      #define DLL_HEADER   __declspec(dllexport)
+   #else
+      #define DLL_HEADER   __declspec(dllimport)
+   #endif
+#else
+   #define DLL_HEADER 
+#endif
+
+
+
+// ** Constants used within Netgen *********************
+/// Maximum allowed number of nodes per volume element
+#define NG_VOLUME_ELEMENT_MAXPOINTS 10
+
+/// Maximum allowed number of nodes per surface element
+#define NG_SURFACE_ELEMENT_MAXPOINTS 8
+
+
+
+// *** Data-types for accessing Netgen functionality ***
+/// Data type for NETGEN mesh
+typedef void * Ng_Mesh;
+
+/// Data type for NETGEN CSG geometry
+typedef void * Ng_CSG_Geometry;
+
+/// Data type for NETGEN 2D geometry
+typedef void * Ng_Geometry_2D;
+
+/// Data type for NETGEN STL geometry
+typedef void * Ng_STL_Geometry;
+
+#ifdef OCCGEOMETRY
+/// Data type for NETGEN OpenCascade geometry
+typedef void * Ng_OCC_Geometry;
+typedef void * Ng_OCC_TopTools_IndexedMapOfShape;
+#endif
+
+
+// *** Special Enum types used within Netgen ***********
+/// Currently implemented surface element types
+enum Ng_Surface_Element_Type 
+   { NG_TRIG = 1, NG_QUAD = 2, NG_TRIG6 = 3, NG_QUAD6 = 4, NG_QUAD8 = 5 };
+
+/// Currently implemented volume element types
+enum Ng_Volume_Element_Type 
+   { NG_TET = 1, NG_PYRAMID = 2, NG_PRISM = 3, NG_TET10 = 4 };
+
+/// Values returned by Netgen functions
+enum Ng_Result 
+   { 
+     NG_ERROR               = -1,   
+     NG_OK                  = 0, 
+     NG_SURFACE_INPUT_ERROR = 1,
+     NG_VOLUME_FAILURE      = 2, 
+     NG_STL_INPUT_ERROR     = 3,
+     NG_SURFACE_FAILURE     = 4,
+     NG_FILE_NOT_FOUND      = 5 
+   };
+
+
+
+// *** Classes required for use within Netgen **********
+/// Netgen Meshing Parameters class
+class Ng_Meshing_Parameters 
+{
+public:
+   int uselocalh;                      //!< Switch to enable / disable usage of local mesh size modifiers
+
+   double maxh;                        //!< Maximum global mesh size allowed
+   double minh;                        //!< Minimum global mesh size allowed
+
+   double fineness;                    //!< Mesh density: 0...1 (0 => coarse; 1 => fine)
+   double grading;                     //!< Mesh grading: 0...1 (0 => uniform mesh; 1 => aggressive local grading)
+
+   double elementsperedge;             //!< Number of elements to generate per edge of the geometry
+   double elementspercurve;            //!< Elements to generate per curvature radius
+
+   int closeedgeenable;                //!< Enable / Disable mesh refinement at close edges
+   double closeedgefact;               //!< Factor to use for refinement at close edges (larger => finer)
+
+   int minedgelenenable;			   //!< Enable / Disable user defined minimum edge length for edge subdivision
+   double minedgelen;                  //!< Minimum edge length to use while subdividing the edges (default = 1e-4)
+
+   int second_order;                   //!< Generate second-order surface and volume elements
+   int quad_dominated;                 //!< Creates a Quad-dominated mesh 
+
+   char * meshsize_filename;           //!< Optional external mesh size file 
+
+   int optsurfmeshenable;              //!< Enable / Disable automatic surface mesh optimization
+   int optvolmeshenable;               //!< Enable / Disable automatic volume mesh optimization
+
+   int optsteps_3d;                     //!< Number of optimize steps to use for 3-D mesh optimization
+   int optsteps_2d;                     //!< Number of optimize steps to use for 2-D mesh optimization
+
+   // Philippose - 13/09/2010
+   // Added a couple more parameters into the meshing parameters list 
+   // from Netgen into Nglib
+   int invert_tets;                    //!< Invert all the volume elements
+   int invert_trigs;                   //!< Invert all the surface triangle elements
+
+   int check_overlap;                  //!< Check for overlapping surfaces during Surface meshing
+   int check_overlapping_boundary;     //!< Check for overlapping surface elements before volume meshing
+
+
+   /*!
+      Default constructor for the Mesh Parameters class
+
+      Note: This constructor initialises the variables in the 
+      class with the following default values
+      - #uselocalh: 1
+      - #maxh: 1000.0
+      - #fineness: 0.5
+      - #grading: 0.3
+      - #elementsperedge: 2.0
+      - #elementspercurve: 2.0
+      - #closeedgeenable: 0
+      - #closeedgefact: 2.0
+      - #secondorder: 0
+      - #meshsize_filename: null
+      - #quad_dominated: 0
+      - #optsurfmeshenable: 1
+      - #optvolmeshenable: 1
+      - #optsteps_2d: 3
+      - #optsteps_3d: 3
+      - #invert_tets: 0
+      - #invert_trigs:0 
+      - #check_overlap: 1
+      - #check_overlapping_boundary: 1
+   */
+   DLL_HEADER Ng_Meshing_Parameters();
+
+
+
+   /*!
+       Reset the meshing parameters to their defaults
+
+       This member function resets all the meshing parameters 
+       of the object to the default values
+   */
+   DLL_HEADER void Reset_Parameters();
+
+
+
+   /*!
+       Transfer local meshing parameters to internal meshing parameters
+
+       This member function transfers all the meshing parameters 
+       defined in the local meshing parameters structure of nglib into 
+       the internal meshing parameters structure used by the Netgen core
+   */
+   DLL_HEADER void Transfer_Parameters();
+};
+
+
+
+
+// *** Functions Exported by this Library *************
+
+// ------------------------------------------------------------------
+// Netgen library initialisation / destruction functions
+
+/*! \brief Initialise the Netgen library and prepare for use
+
+    This function needs to be called by the third-party 
+    program before beginning to use the other Netgen 
+    specific functions.
+*/
+DLL_HEADER void Ng_Init ();
+
+
+/*! \brief Exit the Netgen meshing kernel in a clean manner
+
+    Use this function to exit the meshing sub-system in 
+    a clean and orderly manner.
+*/
+DLL_HEADER void Ng_Exit ();
+  
+
+/*! \brief Create a new (and empty) Netgen Mesh Structure
+
+    This function creates a new Netgen Mesh, initialises 
+    it, and returns a pointer to the created mesh structure. 
+
+    Use the returned pointer for subsequent operations 
+    which involve mesh operations.
+
+    \return Ng_Mesh Pointer to a Netgen Mesh type #Ng_Mesh
+*/
+DLL_HEADER  Ng_Mesh * Ng_NewMesh ();
+
+
+/*! \brief Delete an existing Netgen Mesh Structure
+
+    Use this function to delete an existing Netgen mesh 
+    structure and release the used memory. 
+
+    \param mesh Pointer to an existing Netgen Mesh structure 
+                of type #Ng_Mesh
+*/
+DLL_HEADER void Ng_DeleteMesh (Ng_Mesh * mesh);
+
+
+/*! \brief Save a Netgen Mesh to disk
+
+    This function allows a generated mesh structure to be saved 
+    to disk.
+
+    A Mesh saved using this function, will be written to disk 
+    in the Netgen VOL file format.
+
+    \param mesh    Pointer to an existing Netgen Mesh structure 
+                   of type #Ng_Mesh
+    \param filename Pointer to a character array containing the 
+                    name of the file to which the mesh should 
+                    be saved
+*/
+DLL_HEADER void Ng_SaveMesh(Ng_Mesh * mesh, const char* filename);
+
+
+/*! \brief Load a Netgen VOL Mesh from disk into memory
+
+    A Netgen mesh saved in the internal VOL format can be loaded 
+    into a Netgen Mesh structure using this function. 
+
+    \param filename Pointer to a character array containing the 
+                    name of the file to load
+    \return Ng_Mesh Pointer to a Netgen Mesh type #Ng_Mesh containing 
+                    the mesh loaded from disk
+*/
+DLL_HEADER Ng_Mesh * Ng_LoadMesh(const char* filename);
+
+
+/*! \brief Merge a Netgen VOL Mesh from disk into an existing mesh in memory
+
+    A Netgen mesh saved in the internal VOL format can be merged 
+    into an existing Netgen Mesh structure using this function. 
+
+    \param mesh       Name of the Mesh structure already existent in memory
+    \param filename   Pointer to a character array containing the 
+                      name of the file to load
+    \return Ng_Result Status of the merge operation
+*/
+DLL_HEADER Ng_Result Ng_MergeMesh(Ng_Mesh * mesh, const char* filename);
+
+
+/*! \brief Merge one Netgen Mesh into another Netgen Mesh in the case 
+    when both are already in memory
+
+    (NOTE: FUNCTION STILL WORK IN PROGRESS!!!)
+
+    This function can be used to merge two Netgen meshes already present 
+    in memory.
+
+    \param mesh1      Parent Mesh structure into which the second mesh 
+                      will be merged
+    \param mesh2      Child mesh structure which will get merged into 
+                      the parent mesh
+    \return Ng_Result Status of the merge operation
+*/
+DLL_HEADER Ng_Result Ng_MergeMesh(Ng_Mesh * mesh1, Ng_Mesh * mesh2);
+// ------------------------------------------------------------------
+
+
+
+// ------------------------------------------------------------------
+// Basic Meshing functions for manually adding points, surface elements 
+// and volume elements to a Netgen Mesh structure
+
+/*! \brief Add a point to a given Netgen Mesh Structure
+
+    This function allows points to be directly added to a Netgen 
+    mesh structure by providing the co-ordinates.
+
+    Each call to the function allows only one point to be added.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \param x    Pointer to an array of type double containing the co-ordinates 
+                of the point to be added in the form: \n
+                - x[0] = X co-ordinate
+                - x[1] = Y co-ordinate
+                - x[2] = Z co-ordinate
+*/
+DLL_HEADER void Ng_AddPoint (Ng_Mesh * mesh, double * x);
+
+
+/*! \brief Add a surface element to a given Netgen Mesh Structure
+
+    This function allows the top-level code to directly add individual 
+    Surface Elements to a Netgen Mesh Structure by providing the type of 
+    element to be added and the indices of the points which constitute the 
+    element.
+
+    <i>Note:</i> 
+    - The points referred to by the surface elements must have been
+      added prior to calling this function. 
+    - Currently only triangular elements are supported, and the Surface Element 
+      Type argument is not used.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \param et   Surface Element type provided via the enumerated type 
+                #Ng_Surface_Element_Type 
+    \param pi   Pointer to an array of integers containing the indices of the 
+                points which constitute the surface element being added
+*/
+DLL_HEADER void Ng_AddSurfaceElement (Ng_Mesh * mesh, Ng_Surface_Element_Type et, int * pi);
+
+
+/*! \brief Add a volume element to a given Netgen Mesh Structure
+
+    This function allows the top-level code to directly add individual 
+    Volume Elements to a Netgen Mesh Structure by providing the type of 
+    element to be added and the indices of the points which constitute the 
+    element.
+
+    <i>Note:</i> 
+    - The points referred to by the volume elements must have been
+      added prior to calling this function. 
+    - Currently only tetrahedral elements are supported, and the Volume Element 
+      Type argument is not used.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \param et   Volume Element type provided via the enumerated type 
+                #Ng_Volume_Element_Type 
+    \param pi   Pointer to an array of integers containing the indices of the 
+                points which constitute the volume element being added
+
+*/
+DLL_HEADER void Ng_AddVolumeElement (Ng_Mesh * mesh, Ng_Volume_Element_Type et, int * pi);
+  
+// ------------------------------------------------------------------
+
+
+
+// ------------------------------------------------------------------
+// Local Mesh Size restriction / limiting utilities
+
+/*! \brief Apply a global restriction on mesh element size
+
+    This utility allows the user to apply a global mesh element 
+    size limitation. 
+
+    During mesh creation, in the absence of an explicit local 
+    size restriction around the neighbourhood of a point within 
+    the meshing domain, this global size restriction will be 
+    utilised.
+
+    <b>Note</b>: This function only limits the <b>Maximum</b> 
+    size of an element within the mesh.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \param h    Variable of type <i>double</i>, specifying the maximum
+                allowable mesh size
+*/
+DLL_HEADER void Ng_RestrictMeshSizeGlobal (Ng_Mesh * mesh, double h);
+
+
+/*! \brief Locally restrict the mesh element size at the given point
+
+    Unlike the function #Ng_RestrictMeshSizeGlobal, this function 
+    allows the user to locally restrict the maximum allowable mesh 
+    size at a given point.
+
+    The point is specified via its three cartesian co-ordinates.
+
+    <b>Note</b>: This function only limits the <b>Maximum</b> size 
+    of the elements around the specified point.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \param p    Pointer to an Array of type <i>double</i>, containing 
+                the three co-ordinates of the point in the form: \n
+                - p[0] = X co-ordinate
+                - p[1] = Y co-ordinate
+                - p[2] = Z co-ordinate
+    \param h    Variable of type <i>double</i>, specifying the maximum
+                allowable mesh size at that point
+*/
+DLL_HEADER void Ng_RestrictMeshSizePoint (Ng_Mesh * mesh, double * p, double h);
+
+
+/*! \brief Locally restrict the mesh element size within a specified box
+
+    Similar to the function #Ng_RestrictMeshSizePoint, this function 
+    allows the size of elements within a mesh to be locally limited.
+
+    However, rather than limit the mesh size at a single point, this 
+    utility restricts the local mesh size within a 3D Box region, specified 
+    via the co-ordinates of the two diagonally opposite points of a cuboid.
+
+    <b>Note</b>: This function only limits the <b>Maximum</b> size 
+    of the elements within the specified region.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \param pmin Pointer to an Array of type <i>double</i>, containing 
+                the three co-ordinates of the first point of the cuboid: \n
+                - pmin[0] = X co-ordinate
+                - pmin[1] = Y co-ordinate
+                - pmin[2] = Z co-ordinate
+    \param pmax Pointer to an Array of type <i>double</i>, containing 
+                the three co-ordinates of the opposite point of the 
+                cuboid: \n
+                - pmax[0] = X co-ordinate
+                - pmax[1] = Y co-ordinate
+                - pmax[2] = Z co-ordinate
+    \param h    Variable of type <i>double</i>, specifying the maximum
+                allowable mesh size at that point
+*/
+DLL_HEADER void Ng_RestrictMeshSizeBox (Ng_Mesh * mesh, double * pmin, double * pmax, double h);
+
+// ------------------------------------------------------------------
+
+
+
+// ------------------------------------------------------------------
+// 3D Mesh Generation functions
+
+/*! \brief Create a 3D Volume Mesh given a Surface Mesh
+
+    After creating a surface mesh, this function can be utilised 
+    to automatically generate the corresponding 3D Volume Mesh.
+
+    Mesh generation parameters (such as grading, maximum element size, 
+    etc.) are specified via the meshing parameters class which also 
+    needs to be passed to this function.
+
+    <b>Note</b>: Currently, Netgen generates pure tetrahedral volume 
+    meshes.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \param mp   Pointer to a copy of the Meshing Parameters class
+                (#Ng_Meshing_Parameters), filled up with the 
+                required values
+
+    \return Ng_Result Status of the Mesh Generation routine. More 
+                      details regarding the return value can be 
+                      found in the description of #Ng_Result
+*/
+DLL_HEADER Ng_Result Ng_GenerateVolumeMesh (Ng_Mesh * mesh, Ng_Meshing_Parameters * mp);
+
+// ------------------------------------------------------------------
+
+
+
+// ------------------------------------------------------------------
+// Basic Mesh information functions
+
+/*! \brief Returns the Number of Points present in the specified Mesh
+
+    Given an already existent Netgen Mesh Structure, this function 
+    returns the number of points currently present within the Mesh.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \return 
+                Integer Data-type with the number of points in the Mesh
+*/
+DLL_HEADER int Ng_GetNP (Ng_Mesh * mesh);
+
+
+/*! \brief Returns the Number of Surface Elements present in the specified Mesh
+
+    Given an already existent Netgen Mesh Structure, this function 
+    returns the number of surface elements currently present within 
+    the Mesh.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \return 
+                Integer Data-type with the number of surface elements in the Mesh
+*/
+DLL_HEADER int Ng_GetNSE (Ng_Mesh * mesh);
+
+
+/*! \brief Returns the Number of Volume Elements present in the specified Mesh
+
+    Given an already existent Netgen Mesh Structure, this function 
+    returns the number of volume elements currently present within 
+    the Mesh.
+
+    \param mesh Pointer to an existing Netgen Mesh structure of 
+                type #Ng_Mesh
+    \return 
+                Integer Data-type with the number of volume elements in the Mesh
+*/
+DLL_HEADER int Ng_GetNE (Ng_Mesh * mesh);
+
+// ------------------------------------------------------------------
+
+
+
+// ------------------------------------------------------------------
+// Mesh Topology functions
+// Use these functions to extract points, surface / volume elements, 
+// perform topological searches, etc..etc...
+  
+//  Return the Point Coordinates of a specified Point
+// The x, y and z co-ordinates are returned in the array pointer as 
+// x[0] = x ; x[1] = y ; x[2] = z
+DLL_HEADER void Ng_GetPoint (Ng_Mesh * mesh, int num, double * x);
+
+
+
+// return surface and volume element in pi
+DLL_HEADER Ng_Surface_Element_Type 
+Ng_GetSurfaceElement (Ng_Mesh * mesh, int num, int * pi);
+
+DLL_HEADER Ng_Volume_Element_Type
+Ng_GetVolumeElement (Ng_Mesh * mesh, int num, int * pi);
+
+// ------------------------------------------------------------------
+
+
+
+
+// **********************************************************
+// **   2D Meshing                                         **
+// **********************************************************
+
+
+// feeds points and boundary to mesh
+
+DLL_HEADER void Ng_AddPoint_2D (Ng_Mesh * mesh, double * x);
+DLL_HEADER void Ng_AddBoundarySeg_2D (Ng_Mesh * mesh, int pi1, int pi2);
+  
+// ask for number of points, elements and boundary segments
+DLL_HEADER int Ng_GetNP_2D (Ng_Mesh * mesh);
+DLL_HEADER int Ng_GetNE_2D (Ng_Mesh * mesh);
+DLL_HEADER int Ng_GetNSeg_2D (Ng_Mesh * mesh);
+  
+//  return point coordinates
+DLL_HEADER void Ng_GetPoint_2D (Ng_Mesh * mesh, int num, double * x);
+
+// return 2d elements
+DLL_HEADER Ng_Surface_Element_Type 
+Ng_GetElement_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum = NULL);
+
+// return 2d boundary segment
+DLL_HEADER void Ng_GetSegment_2D (Ng_Mesh * mesh, int num, int * pi, int * matnum = NULL);
+
+
+// load 2d netgen spline geometry
+DLL_HEADER Ng_Geometry_2D * Ng_LoadGeometry_2D (const char * filename);
+
+// generate 2d mesh, mesh is allocated by function
+DLL_HEADER Ng_Result Ng_GenerateMesh_2D (Ng_Geometry_2D * geom,
+                                         Ng_Mesh ** mesh,
+                                         Ng_Meshing_Parameters * mp);
+  
+DLL_HEADER void Ng_HP_Refinement (Ng_Geometry_2D * geom,
+                                  Ng_Mesh * mesh,
+                                  int levels);
+  
+
+
+
+
+// **********************************************************
+// **   STL Meshing                                        **
+// **********************************************************
+
+
+// loads geometry from STL file
+DLL_HEADER Ng_STL_Geometry * Ng_STL_LoadGeometry (const char * filename, int binary = 0);
+
+
+// generate new STL Geometry
+DLL_HEADER Ng_STL_Geometry * Ng_STL_NewGeometry ();
+  
+
+// fills STL Geometry
+// positive orientation
+// normal vector may be null-pointer
+DLL_HEADER void Ng_STL_AddTriangle (Ng_STL_Geometry * geom, 
+                         double * p1, double * p2, double * p3, 
+                         double * nv = NULL);
+
+// add (optional) edges :
+DLL_HEADER void Ng_STL_AddEdge (Ng_STL_Geometry * geom, 
+                     double * p1, double * p2);
+
+// after adding triangles (and edges) initialize
+DLL_HEADER Ng_Result Ng_STL_InitSTLGeometry (Ng_STL_Geometry * geom);
+
+// automatically generates edges:
+DLL_HEADER Ng_Result Ng_STL_MakeEdges (Ng_STL_Geometry * geom,
+                            Ng_Mesh* mesh,
+                            Ng_Meshing_Parameters * mp);
+
+
+// generates mesh, empty mesh must be already created.
+DLL_HEADER Ng_Result Ng_STL_GenerateSurfaceMesh (Ng_STL_Geometry * geom,
+                                                 Ng_Mesh * mesh,
+                                                 Ng_Meshing_Parameters * mp);
+
+
+#ifdef ACIS
+
+// **********************************************************
+// **   ACIS Meshing                                       **
+// **********************************************************
+
+/// Data type for NETGEN STL geomty
+typedef void * Ng_ACIS_Geometry;
+
+// loads geometry from STL file
+DLL_HEADER Ng_ACIS_Geometry * Ng_ACIS_LoadGeometry (const char * filename);
+  
+// generates mesh, empty mesh must be already created.
+DLL_HEADER Ng_Result Ng_ACIS_GenerateSurfaceMesh (Ng_ACIS_Geometry * geom,
+                                                  Ng_Mesh * mesh,
+                                                  Ng_Meshing_Parameters * mp);
+
+
+#endif
+
+
+
+#ifdef OCCGEOMETRY
+
+// **********************************************************
+// **   OpenCascade Geometry / Meshing Utilities           **
+// **********************************************************
+
+// Create new OCC Geometry Object
+DLL_HEADER Ng_OCC_Geometry * Ng_OCC_NewGeometry ();
+
+// Delete an OCC Geometry Object
+DLL_HEADER Ng_Result Ng_OCC_DeleteGeometry (Ng_OCC_Geometry * geom);
+
+// Loads geometry from STEP file
+DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_STEP (const char * filename);
+
+// Loads geometry from IGES file
+DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_IGES (const char * filename);
+
+// Loads geometry from BREP file
+DLL_HEADER Ng_OCC_Geometry * Ng_OCC_Load_BREP (const char * filename);
+
+// Set the local mesh size based on geometry / topology
+DLL_HEADER Ng_Result Ng_OCC_SetLocalMeshSize (Ng_OCC_Geometry * geom,
+                                              Ng_Mesh * mesh,
+                                              Ng_Meshing_Parameters * mp);
+
+// Mesh the edges and add Face descriptors to prepare for surface meshing
+DLL_HEADER Ng_Result Ng_OCC_GenerateEdgeMesh (Ng_OCC_Geometry * geom,
+                                              Ng_Mesh * mesh,
+                                              Ng_Meshing_Parameters * mp);
+
+// Mesh the surfaces of an OCC geometry
+DLL_HEADER Ng_Result Ng_OCC_GenerateSurfaceMesh (Ng_OCC_Geometry * geom,
+                                                 Ng_Mesh * mesh,
+                                                 Ng_Meshing_Parameters * mp); 
+
+// Get the face map of an already loaded OCC geometry
+DLL_HEADER Ng_Result Ng_OCC_GetFMap(Ng_OCC_Geometry * geom, 
+                                    Ng_OCC_TopTools_IndexedMapOfShape * FMap);
+
+#endif // OCCGEOMETRY
+
+
+
+// **********************************************************
+// **   Mesh refinement algorithms                         **
+// **********************************************************
+
+// uniform mesh refinement
+DLL_HEADER void Ng_Uniform_Refinement (Ng_Mesh * mesh);
+
+
+// uniform mesh refinement with geometry adaption:
+
+DLL_HEADER void Ng_2D_Uniform_Refinement (Ng_Geometry_2D * geom,
+					  Ng_Mesh * mesh);
+
+DLL_HEADER void Ng_STL_Uniform_Refinement (Ng_STL_Geometry * geom,
+					   Ng_Mesh * mesh);
+
+DLL_HEADER void Ng_CSG_Uniform_Refinement (Ng_CSG_Geometry * geom,
+					   Ng_Mesh * mesh);
+
+#ifdef OCCGEOMETRY
+DLL_HEADER void Ng_OCC_Uniform_Refinement (Ng_OCC_Geometry * geom,
+					   Ng_Mesh * mesh);
+#endif
+
+
+
+// **********************************************************
+// **   Second Order mesh algorithms                       **
+// **********************************************************
+
+// convert mesh to second order
+DLL_HEADER void Ng_Generate_SecondOrder (Ng_Mesh * mesh);
+
+
+// convert mesh to second order with geometry adaption:
+
+DLL_HEADER void Ng_2D_Generate_SecondOrder (Ng_Geometry_2D * geom,
+					  Ng_Mesh * mesh);
+
+DLL_HEADER void Ng_STL_Generate_SecondOrder (Ng_STL_Geometry * geom,
+					   Ng_Mesh * mesh);
+
+DLL_HEADER void Ng_CSG_Generate_SecondOrder (Ng_CSG_Geometry * geom,
+					   Ng_Mesh * mesh);
+
+#ifdef OCCGEOMETRY
+DLL_HEADER void Ng_OCC_Generate_SecondOrder (Ng_OCC_Geometry * geom,
+					   Ng_Mesh * mesh);
+#endif
+
+
+#endif // NGLIB
